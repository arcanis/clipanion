#!/usr/bin/env node
/* eslint-disable */
module.exports =
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(372);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _tools_getPluginConfiguration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(248);




(0,_main__WEBPACK_IMPORTED_MODULE_1__.main)({
  binaryVersion: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.YarnVersion || `<unknown>`,
  pluginConfiguration: (0,_tools_getPluginConfiguration__WEBPACK_IMPORTED_MODULE_2__.getPluginConfiguration)()
});

/***/ }),
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var fromentries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var fromentries__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fromentries__WEBPACK_IMPORTED_MODULE_0__);
// @ts-expect-error: missing declaration
 // Remove when dropping Node 10 (~April 2021)

if (!Object.fromEntries) Object.fromEntries = (fromentries__WEBPACK_IMPORTED_MODULE_0___default());

/***/ }),
/* 2 */
/***/ ((module) => {

module.exports = function fromEntries (iterable) {
  return [...iterable].reduce((obj, [key, val]) => {
    obj[key] = val
    return obj
  }, {})
}


/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "main": () => /* binding */ main
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(231);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(238);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(155);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ci_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var ci_info__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ci_info__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _pluginCommands__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9);
/* harmony import */ var _tools_WelcomeCommand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10);









function runBinary(path) {
  const physicalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.fromPortablePath(path);
  process.on(`SIGINT`, () => {// We don't want SIGINT to kill our process; we want it to kill the
    // innermost process, whose end will cause our own to exit.
  });

  if (physicalPath) {
    (0,child_process__WEBPACK_IMPORTED_MODULE_0__.execFileSync)(process.execPath, [physicalPath, ...process.argv.slice(2)], {
      stdio: `inherit`,
      env: { ...process.env,
        YARN_IGNORE_PATH: `1`,
        YARN_IGNORE_CWD: `1`
      }
    });
  } else {
    (0,child_process__WEBPACK_IMPORTED_MODULE_0__.execFileSync)(physicalPath, process.argv.slice(2), {
      stdio: `inherit`,
      env: { ...process.env,
        YARN_IGNORE_PATH: `1`,
        YARN_IGNORE_CWD: `1`
      }
    });
  }
}

async function main({
  binaryVersion,
  pluginConfiguration
}) {
  async function run() {
    const cli = new clipanion__WEBPACK_IMPORTED_MODULE_2__.Cli({
      binaryLabel: `Yarn Package Manager`,
      binaryName: `yarn`,
      binaryVersion
    });
    cli.register(_tools_WelcomeCommand__WEBPACK_IMPORTED_MODULE_5__.WelcomeCommand);

    try {
      await exec(cli);
    } catch (error) {
      process.stdout.write(cli.error(error));
      process.exitCode = 1;
    }
  }

  async function exec(cli) {
    // Non-exhaustive known requirements:
    // - 10.16+ for Brotli support on `plugin-compat`
    // - 10.17+ to silence `got` warning on `dns.promises`
    // - 14.0 and 14.1 empty http responses - https://github.com/sindresorhus/got/issues/1496
    var _a, _b, _c, _d, _e;

    const version = process.versions.node;
    const range = `>=10.17 <14 || >14.1`;
    if (process.env.YARN_IGNORE_NODE !== `1` && !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.satisfiesWithPrereleases(version, range)) throw new clipanion__WEBPACK_IMPORTED_MODULE_2__.UsageError(`This tool requires a Node version compatible with ${range} (got ${version}). Upgrade Node, or set \`YARN_IGNORE_NODE=1\` in your environment.`); // Since we only care about a few very specific settings (yarn-path and ignore-path) we tolerate extra configuration key.
    // If we didn't, we wouldn't even be able to run `yarn config` (which is recommended in the invalid config error message)

    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Configuration.find(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(process.cwd()), pluginConfiguration, {
      usePath: true,
      strict: false
    });
    const yarnPath = configuration.get(`yarnPath`);
    const ignorePath = configuration.get(`ignorePath`);
    const ignoreCwd = configuration.get(`ignoreCwd`); // Avoid unnecessary spawn when run directly

    if (!ignorePath && !ignoreCwd && yarnPath === _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.resolve(process.argv[1]))) {
      process.env.YARN_IGNORE_PATH = `1`;
      process.env.YARN_IGNORE_CWD = `1`;
      await exec(cli);
      return;
    } else if (yarnPath !== null && !ignorePath) {
      if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.xfs.existsSync(yarnPath)) {
        process.stdout.write(cli.error(new Error(`The "yarn-path" option has been set (in ${configuration.sources.get(`yarnPath`)}), but the specified location doesn't exist (${yarnPath}).`)));
        process.exitCode = 1;
      } else {
        try {
          runBinary(yarnPath);
        } catch (error) {
          process.exitCode = error.code || 1;
        }
      }
    } else {
      if (ignorePath) delete process.env.YARN_IGNORE_PATH;
      const isTelemetryEnabled = configuration.get(`enableTelemetry`);
      if (isTelemetryEnabled && !ci_info__WEBPACK_IMPORTED_MODULE_1__.isCI && process.stdout.isTTY) _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Configuration.telemetry = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.TelemetryManager(configuration, `puba9cdc10ec5790a2cf4969dd413a47270`);
      (_a = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Configuration.telemetry) === null || _a === void 0 ? void 0 : _a.reportVersion(binaryVersion);

      for (const [name, plugin] of configuration.plugins.entries()) {
        if (_pluginCommands__WEBPACK_IMPORTED_MODULE_4__.pluginCommands.has((_c = (_b = name.match(/^@yarnpkg\/plugin-(.*)$/)) === null || _b === void 0 ? void 0 : _b[1]) !== null && _c !== void 0 ? _c : ``)) (_d = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Configuration.telemetry) === null || _d === void 0 ? void 0 : _d.reportPluginName(name);

        for (const command of plugin.commands || []) {
          cli.register(command);
        }
      }

      const command = cli.process(process.argv.slice(2));
      if (!command.help) (_e = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Configuration.telemetry) === null || _e === void 0 ? void 0 : _e.reportCommandName(command.path.join(` `)); // @ts-expect-error: The cwd is a global option defined by BaseCommand

      const cwd = command.cwd;

      if (typeof cwd !== `undefined` && !ignoreCwd) {
        const iAmHere = (0,fs__WEBPACK_IMPORTED_MODULE_3__.realpathSync)(process.cwd());
        const iShouldBeHere = (0,fs__WEBPACK_IMPORTED_MODULE_3__.realpathSync)(cwd);

        if (iAmHere !== iShouldBeHere) {
          process.chdir(cwd);
          await run();
          return;
        }
      }

      await cli.runExit(command, {
        cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(process.cwd()),
        plugins: pluginConfiguration,
        quiet: false,
        stdin: process.stdin,
        stdout: process.stdout,
        stderr: process.stderr
      });
    }
  }

  return run().catch(error => {
    process.stdout.write(error.stack || error.message);
    process.exitCode = 1;
  }).finally(() => _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.xfs.rmtempPromise());
}

/***/ }),
/* 4 */
/***/ ((module) => {

"use strict";
module.exports = require("child_process");;

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var vendors = __webpack_require__(6)

var env = process.env

// Used for testing only
Object.defineProperty(exports, "_vendors", ({
  value: vendors.map(function (v) { return v.constant })
}))

exports.name = null
exports.isPR = null

vendors.forEach(function (vendor) {
  var envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env]
  var isCI = envs.every(function (obj) {
    return checkEnv(obj)
  })

  exports[vendor.constant] = isCI

  if (isCI) {
    exports.name = vendor.name

    switch (typeof vendor.pr) {
      case 'string':
        // "pr": "CIRRUS_PR"
        exports.isPR = !!env[vendor.pr]
        break
      case 'object':
        if ('env' in vendor.pr) {
          // "pr": { "env": "BUILDKITE_PULL_REQUEST", "ne": "false" }
          exports.isPR = vendor.pr.env in env && env[vendor.pr.env] !== vendor.pr.ne
        } else if ('any' in vendor.pr) {
          // "pr": { "any": ["ghprbPullId", "CHANGE_ID"] }
          exports.isPR = vendor.pr.any.some(function (key) {
            return !!env[key]
          })
        } else {
          // "pr": { "DRONE_BUILD_EVENT": "pull_request" }
          exports.isPR = checkEnv(vendor.pr)
        }
        break
      default:
        // PR detection not supported for this vendor
        exports.isPR = null
    }
  }
})

exports.isCI = !!(
  env.CI || // Travis CI, CircleCI, Cirrus CI, Gitlab CI, Appveyor, CodeShip, dsari
  env.CONTINUOUS_INTEGRATION || // Travis CI, Cirrus CI
  env.BUILD_NUMBER || // Jenkins, TeamCity
  env.RUN_ID || // TaskCluster, dsari
  exports.name ||
  false
)

function checkEnv (obj) {
  if (typeof obj === 'string') return !!env[obj]
  return Object.keys(obj).every(function (k) {
    return env[k] === obj[k]
  })
}


/***/ }),
/* 6 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("[{\"name\":\"AppVeyor\",\"constant\":\"APPVEYOR\",\"env\":\"APPVEYOR\",\"pr\":\"APPVEYOR_PULL_REQUEST_NUMBER\"},{\"name\":\"Azure Pipelines\",\"constant\":\"AZURE_PIPELINES\",\"env\":\"SYSTEM_TEAMFOUNDATIONCOLLECTIONURI\",\"pr\":\"SYSTEM_PULLREQUEST_PULLREQUESTID\"},{\"name\":\"Bamboo\",\"constant\":\"BAMBOO\",\"env\":\"bamboo_planKey\"},{\"name\":\"Bitbucket Pipelines\",\"constant\":\"BITBUCKET\",\"env\":\"BITBUCKET_COMMIT\",\"pr\":\"BITBUCKET_PR_ID\"},{\"name\":\"Bitrise\",\"constant\":\"BITRISE\",\"env\":\"BITRISE_IO\",\"pr\":\"BITRISE_PULL_REQUEST\"},{\"name\":\"Buddy\",\"constant\":\"BUDDY\",\"env\":\"BUDDY_WORKSPACE_ID\",\"pr\":\"BUDDY_EXECUTION_PULL_REQUEST_ID\"},{\"name\":\"Buildkite\",\"constant\":\"BUILDKITE\",\"env\":\"BUILDKITE\",\"pr\":{\"env\":\"BUILDKITE_PULL_REQUEST\",\"ne\":\"false\"}},{\"name\":\"CircleCI\",\"constant\":\"CIRCLE\",\"env\":\"CIRCLECI\",\"pr\":\"CIRCLE_PULL_REQUEST\"},{\"name\":\"Cirrus CI\",\"constant\":\"CIRRUS\",\"env\":\"CIRRUS_CI\",\"pr\":\"CIRRUS_PR\"},{\"name\":\"AWS CodeBuild\",\"constant\":\"CODEBUILD\",\"env\":\"CODEBUILD_BUILD_ARN\"},{\"name\":\"Codeship\",\"constant\":\"CODESHIP\",\"env\":{\"CI_NAME\":\"codeship\"}},{\"name\":\"Drone\",\"constant\":\"DRONE\",\"env\":\"DRONE\",\"pr\":{\"DRONE_BUILD_EVENT\":\"pull_request\"}},{\"name\":\"dsari\",\"constant\":\"DSARI\",\"env\":\"DSARI\"},{\"name\":\"GitLab CI\",\"constant\":\"GITLAB\",\"env\":\"GITLAB_CI\"},{\"name\":\"GoCD\",\"constant\":\"GOCD\",\"env\":\"GO_PIPELINE_LABEL\"},{\"name\":\"Hudson\",\"constant\":\"HUDSON\",\"env\":\"HUDSON_URL\"},{\"name\":\"Jenkins\",\"constant\":\"JENKINS\",\"env\":[\"JENKINS_URL\",\"BUILD_ID\"],\"pr\":{\"any\":[\"ghprbPullId\",\"CHANGE_ID\"]}},{\"name\":\"Magnum CI\",\"constant\":\"MAGNUM\",\"env\":\"MAGNUM\"},{\"name\":\"Netlify CI\",\"constant\":\"NETLIFY\",\"env\":\"NETLIFY_BUILD_BASE\",\"pr\":{\"env\":\"PULL_REQUEST\",\"ne\":\"false\"}},{\"name\":\"Sail CI\",\"constant\":\"SAIL\",\"env\":\"SAILCI\",\"pr\":\"SAIL_PULL_REQUEST_NUMBER\"},{\"name\":\"Semaphore\",\"constant\":\"SEMAPHORE\",\"env\":\"SEMAPHORE\",\"pr\":\"PULL_REQUEST_NUMBER\"},{\"name\":\"Shippable\",\"constant\":\"SHIPPABLE\",\"env\":\"SHIPPABLE\",\"pr\":{\"IS_PULL_REQUEST\":\"true\"}},{\"name\":\"Solano CI\",\"constant\":\"SOLANO\",\"env\":\"TDDIUM\",\"pr\":\"TDDIUM_PR_ID\"},{\"name\":\"Strider CD\",\"constant\":\"STRIDER\",\"env\":\"STRIDER\"},{\"name\":\"TaskCluster\",\"constant\":\"TASKCLUSTER\",\"env\":[\"TASK_ID\",\"RUN_ID\"]},{\"name\":\"TeamCity\",\"constant\":\"TEAMCITY\",\"env\":\"TEAMCITY_VERSION\"},{\"name\":\"Travis CI\",\"constant\":\"TRAVIS\",\"env\":\"TRAVIS\",\"pr\":{\"env\":\"TRAVIS_PULL_REQUEST\",\"ne\":\"false\"}}]");

/***/ }),
/* 7 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cli": () => /* binding */ Cli,
/* harmony export */   "Command": () => /* binding */ Command,
/* harmony export */   "UsageError": () => /* binding */ UsageError
/* harmony export */ });
const NODE_INITIAL = 0;
const NODE_SUCCESS = 1;
const NODE_ERRORED = 2;
const START_OF_INPUT = `\u0001`;
const END_OF_INPUT = `\u0000`;
const HELP_COMMAND_INDEX = -1;
const HELP_REGEX = /^(-h|--help)(?:=([0-9]+))?$/;
const OPTION_REGEX = /^(--[a-z]+(?:-[a-z]+)*|-[a-zA-Z]+)$/;
const BATCH_REGEX = /^-[a-zA-Z]{2,}$/;
const BINDING_REGEX = /^([^=]+)=([\s\S]*)$/;
const DEBUG = process.env.DEBUG_CLI === `1`;

/**
 * A generic usage error with the name `UsageError`.
 *
 * It should be used over `Error` only when it's the user's fault.
 */
class UsageError extends Error {
    constructor(message) {
        super(message);
        this.clipanion = { type: `usage` };
        this.name = `UsageError`;
    }
}
class UnknownSyntaxError extends Error {
    constructor(input, candidates) {
        super();
        this.input = input;
        this.candidates = candidates;
        this.clipanion = { type: `none` };
        this.name = `UnknownSyntaxError`;
        if (this.candidates.length === 0) {
            this.message = `Command not found, but we're not sure what's the alternative.`;
        }
        else if (this.candidates.length === 1 && this.candidates[0].reason !== null) {
            const [{ usage, reason }] = this.candidates;
            this.message = `${reason}\n\n$ ${usage}`;
        }
        else if (this.candidates.length === 1) {
            const [{ usage }] = this.candidates;
            this.message = `Command not found; did you mean:\n\n$ ${usage}\n${whileRunning(input)}`;
        }
        else {
            this.message = `Command not found; did you mean one of:\n\n${this.candidates.map(({ usage }, index) => {
                return `${`${index}.`.padStart(4)} ${usage}`;
            }).join(`\n`)}\n\n${whileRunning(input)}`;
        }
    }
}
class AmbiguousSyntaxError extends Error {
    constructor(input, usages) {
        super();
        this.input = input;
        this.usages = usages;
        this.clipanion = { type: `none` };
        this.name = `AmbiguousSyntaxError`;
        this.message = `Cannot find who to pick amongst the following alternatives:\n\n${this.usages.map((usage, index) => {
            return `${`${index}.`.padStart(4)} ${usage}`;
        }).join(`\n`)}\n\n${whileRunning(input)}`;
    }
}
const whileRunning = (input) => `While running ${input.filter(token => {
    return token !== END_OF_INPUT;
}).map(token => {
    const json = JSON.stringify(token);
    if (token.match(/\s/) || token.length === 0 || json !== `"${token}"`) {
        return json;
    }
    else {
        return token;
    }
}).join(` `)}`;

// ------------------------------------------------------------------------
function debug(str) {
    if (DEBUG) {
        console.log(str);
    }
}
const basicHelpState = {
    candidateUsage: null,
    errorMessage: null,
    ignoreOptions: false,
    path: [],
    positionals: [],
    options: [],
    remainder: null,
    selectedIndex: HELP_COMMAND_INDEX
};
function makeStateMachine() {
    return {
        nodes: [makeNode(), makeNode(), makeNode()],
    };
}
function makeAnyOfMachine(inputs) {
    const output = makeStateMachine();
    const heads = [];
    let offset = output.nodes.length;
    for (const input of inputs) {
        heads.push(offset);
        for (let t = 0; t < input.nodes.length; ++t)
            if (!isTerminalNode(t))
                output.nodes.push(cloneNode(input.nodes[t], offset));
        offset += input.nodes.length - 2;
    }
    for (const head of heads)
        registerShortcut(output, NODE_INITIAL, head);
    return output;
}
function injectNode(machine, node) {
    machine.nodes.push(node);
    return machine.nodes.length - 1;
}
function simplifyMachine(input) {
    const visited = new Set();
    const process = (node) => {
        if (visited.has(node))
            return;
        visited.add(node);
        const nodeDef = input.nodes[node];
        for (const transitions of Object.values(nodeDef.statics))
            for (const { to } of transitions)
                process(to);
        for (const [, { to }] of nodeDef.dynamics)
            process(to);
        for (const { to } of nodeDef.shortcuts)
            process(to);
        const shortcuts = new Set(nodeDef.shortcuts.map(({ to }) => to));
        while (nodeDef.shortcuts.length > 0) {
            const { to } = nodeDef.shortcuts.shift();
            const toDef = input.nodes[to];
            for (const [segment, transitions] of Object.entries(toDef.statics)) {
                let store = !Object.prototype.hasOwnProperty.call(nodeDef.statics, segment)
                    ? nodeDef.statics[segment] = []
                    : nodeDef.statics[segment];
                for (const transition of transitions) {
                    if (!store.some(({ to }) => transition.to === to)) {
                        store.push(transition);
                    }
                }
            }
            for (const [test, transition] of toDef.dynamics)
                if (!nodeDef.dynamics.some(([otherTest, { to }]) => test === otherTest && transition.to === to))
                    nodeDef.dynamics.push([test, transition]);
            for (const transition of toDef.shortcuts) {
                if (!shortcuts.has(transition.to)) {
                    nodeDef.shortcuts.push(transition);
                    shortcuts.add(transition.to);
                }
            }
        }
    };
    process(NODE_INITIAL);
}
function debugMachine(machine, { prefix = `` } = {}) {
    debug(`${prefix}Nodes are:`);
    for (let t = 0; t < machine.nodes.length; ++t) {
        debug(`${prefix}  ${t}: ${JSON.stringify(machine.nodes[t])}`);
    }
}
function runMachineInternal(machine, input, partial = false) {
    debug(`Running a vm on ${JSON.stringify(input)}`);
    let branches = [{ node: NODE_INITIAL, state: {
                candidateUsage: null,
                errorMessage: null,
                ignoreOptions: false,
                options: [],
                path: [],
                positionals: [],
                remainder: null,
                selectedIndex: null,
            } }];
    debugMachine(machine, { prefix: `  ` });
    const tokens = [START_OF_INPUT, ...input];
    for (let t = 0; t < tokens.length; ++t) {
        const segment = tokens[t];
        debug(`  Processing ${JSON.stringify(segment)}`);
        const nextBranches = [];
        for (const { node, state } of branches) {
            debug(`    Current node is ${node}`);
            const nodeDef = machine.nodes[node];
            if (node === NODE_ERRORED) {
                nextBranches.push({ node, state });
                continue;
            }
            console.assert(nodeDef.shortcuts.length === 0, `Shortcuts should have been eliminated by now`);
            const hasExactMatch = Object.prototype.hasOwnProperty.call(nodeDef.statics, segment);
            if (!partial || t < tokens.length - 1 || hasExactMatch) {
                if (hasExactMatch) {
                    const transitions = nodeDef.statics[segment];
                    for (const { to, reducer } of transitions) {
                        nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state });
                        debug(`      Static transition to ${to} found`);
                    }
                }
                else {
                    debug(`      No static transition found`);
                }
            }
            else {
                let hasMatches = false;
                for (const candidate of Object.keys(nodeDef.statics)) {
                    if (!candidate.startsWith(segment))
                        continue;
                    if (segment === candidate) {
                        for (const { to, reducer } of nodeDef.statics[candidate]) {
                            nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state });
                            debug(`      Static transition to ${to} found`);
                        }
                    }
                    else {
                        for (const { to, reducer } of nodeDef.statics[candidate]) {
                            nextBranches.push({ node: to, state: Object.assign(Object.assign({}, state), { remainder: candidate.slice(segment.length) }) });
                            debug(`      Static transition to ${to} found (partial match)`);
                        }
                    }
                    hasMatches = true;
                }
                if (!hasMatches) {
                    debug(`      No partial static transition found`);
                }
            }
            if (segment !== END_OF_INPUT) {
                for (const [test, { to, reducer }] of nodeDef.dynamics) {
                    if (execute(tests, test, state, segment)) {
                        nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state });
                        debug(`      Dynamic transition to ${to} found (via ${test})`);
                    }
                }
            }
        }
        if (nextBranches.length === 0 && segment === END_OF_INPUT && input.length === 1) {
            return [{
                    node: NODE_INITIAL,
                    state: basicHelpState,
                }];
        }
        if (nextBranches.length === 0) {
            throw new UnknownSyntaxError(input, branches.filter(({ node }) => {
                return node !== NODE_ERRORED;
            }).map(({ state }) => {
                return { usage: state.candidateUsage, reason: null };
            }));
        }
        if (nextBranches.every(({ node }) => node === NODE_ERRORED)) {
            throw new UnknownSyntaxError(input, nextBranches.map(({ state }) => {
                return { usage: state.candidateUsage, reason: state.errorMessage };
            }));
        }
        branches = trimSmallerBranches(nextBranches);
    }
    if (branches.length > 0) {
        debug(`  Results:`);
        for (const branch of branches) {
            debug(`    - ${branch.node} -> ${JSON.stringify(branch.state)}`);
        }
    }
    else {
        debug(`  No results`);
    }
    return branches;
}
function checkIfNodeIsFinished(node, state) {
    if (state.selectedIndex !== null)
        return true;
    if (Object.prototype.hasOwnProperty.call(node.statics, END_OF_INPUT))
        for (const { to } of node.statics[END_OF_INPUT])
            if (to === NODE_SUCCESS)
                return true;
    return false;
}
function suggestMachine(machine, input, partial) {
    // If we're accepting partial matches, then exact matches need to be
    // prefixed with an extra space.
    const prefix = partial && input.length > 0 ? [``] : [];
    const branches = runMachineInternal(machine, input, partial);
    const suggestions = [];
    const suggestionsJson = new Set();
    const traverseSuggestion = (suggestion, node, skipFirst = true) => {
        let nextNodes = [node];
        while (nextNodes.length > 0) {
            const currentNodes = nextNodes;
            nextNodes = [];
            for (const node of currentNodes) {
                const nodeDef = machine.nodes[node];
                const keys = Object.keys(nodeDef.statics);
                for (const key of Object.keys(nodeDef.statics)) {
                    const segment = keys[0];
                    for (const { to, reducer } of nodeDef.statics[segment]) {
                        if (reducer !== `pushPath`)
                            continue;
                        if (!skipFirst)
                            suggestion.push(segment);
                        nextNodes.push(to);
                    }
                }
            }
            skipFirst = false;
        }
        const json = JSON.stringify(suggestion);
        if (suggestionsJson.has(json))
            return;
        suggestions.push(suggestion);
        suggestionsJson.add(json);
    };
    for (const { node, state } of branches) {
        if (state.remainder !== null) {
            traverseSuggestion([state.remainder], node);
            continue;
        }
        const nodeDef = machine.nodes[node];
        const isFinished = checkIfNodeIsFinished(nodeDef, state);
        for (const [candidate, transitions] of Object.entries(nodeDef.statics))
            if ((isFinished && candidate !== END_OF_INPUT) || (!candidate.startsWith(`-`) && transitions.some(({ reducer }) => reducer === `pushPath`)))
                traverseSuggestion([...prefix, candidate], node);
        if (!isFinished)
            continue;
        for (const [test, { to }] of nodeDef.dynamics) {
            if (to === NODE_ERRORED)
                continue;
            const tokens = suggest(test, state);
            if (tokens === null)
                continue;
            for (const token of tokens) {
                traverseSuggestion([...prefix, token], node);
            }
        }
    }
    return [...suggestions].sort();
}
function runMachine(machine, input) {
    const branches = runMachineInternal(machine, [...input, END_OF_INPUT]);
    return selectBestState(input, branches.map(({ state }) => {
        return state;
    }));
}
function trimSmallerBranches(branches) {
    let maxPathSize = 0;
    for (const { state } of branches)
        if (state.path.length > maxPathSize)
            maxPathSize = state.path.length;
    return branches.filter(({ state }) => {
        return state.path.length === maxPathSize;
    });
}
function selectBestState(input, states) {
    const terminalStates = states.filter(state => {
        return state.selectedIndex !== null;
    });
    if (terminalStates.length === 0)
        throw new Error();
    let maxPathSize = 0;
    for (const state of terminalStates)
        if (state.path.length > maxPathSize)
            maxPathSize = state.path.length;
    const bestPathBranches = terminalStates.filter(state => {
        return state.path.length === maxPathSize;
    });
    const getPositionalCount = (state) => state.positionals.filter(({ extra }) => {
        return !extra;
    }).length + state.options.length;
    const statesWithPositionalCount = bestPathBranches.map(state => {
        return { state, positionalCount: getPositionalCount(state) };
    });
    let maxPositionalCount = 0;
    for (const { positionalCount } of statesWithPositionalCount)
        if (positionalCount > maxPositionalCount)
            maxPositionalCount = positionalCount;
    const bestPositionalStates = statesWithPositionalCount.filter(({ positionalCount }) => {
        return positionalCount === maxPositionalCount;
    }).map(({ state }) => {
        return state;
    });
    const fixedStates = aggregateHelpStates(bestPositionalStates);
    if (fixedStates.length > 1)
        throw new AmbiguousSyntaxError(input, fixedStates.map(state => state.candidateUsage));
    return fixedStates[0];
}
function aggregateHelpStates(states) {
    const notHelps = [];
    const helps = [];
    for (const state of states) {
        if (state.selectedIndex === HELP_COMMAND_INDEX) {
            helps.push(state);
        }
        else {
            notHelps.push(state);
        }
    }
    if (helps.length > 0) {
        notHelps.push(Object.assign(Object.assign({}, basicHelpState), { path: findCommonPrefix(...helps.map(state => state.path)), options: helps.reduce((options, state) => options.concat(state.options), []) }));
    }
    return notHelps;
}
function findCommonPrefix(firstPath, secondPath, ...rest) {
    if (secondPath === undefined)
        return Array.from(firstPath);
    return findCommonPrefix(firstPath.filter((segment, i) => segment === secondPath[i]), ...rest);
}
function makeNode() {
    return {
        dynamics: [],
        shortcuts: [],
        statics: {},
    };
}
function isTerminalNode(node) {
    return node === NODE_SUCCESS || node === NODE_ERRORED;
}
function cloneTransition(input, offset = 0) {
    return {
        to: !isTerminalNode(input.to) ? input.to > 2 ? input.to + offset - 2 : input.to + offset : input.to,
        reducer: input.reducer,
    };
}
function cloneNode(input, offset = 0) {
    const output = makeNode();
    for (const [test, transition] of input.dynamics)
        output.dynamics.push([test, cloneTransition(transition, offset)]);
    for (const transition of input.shortcuts)
        output.shortcuts.push(cloneTransition(transition, offset));
    for (const [segment, transitions] of Object.entries(input.statics))
        output.statics[segment] = transitions.map(transition => cloneTransition(transition, offset));
    return output;
}
function registerDynamic(machine, from, test, to, reducer) {
    machine.nodes[from].dynamics.push([
        test,
        { to, reducer: reducer }
    ]);
}
function registerShortcut(machine, from, to, reducer) {
    machine.nodes[from].shortcuts.push({ to, reducer: reducer });
}
function registerStatic(machine, from, test, to, reducer) {
    let store = !Object.prototype.hasOwnProperty.call(machine.nodes[from].statics, test)
        ? machine.nodes[from].statics[test] = []
        : machine.nodes[from].statics[test];
    store.push({ to, reducer: reducer });
}
function execute(store, callback, state, segment) {
    // TypeScript's control flow can't properly narrow
    // generic conditionals for some mysterious reason
    if (Array.isArray(callback)) {
        const [name, ...args] = callback;
        return store[name](state, segment, ...args);
    }
    else {
        return store[callback](state, segment);
    }
}
function suggest(callback, state) {
    const fn = Array.isArray(callback)
        ? tests[callback[0]]
        : tests[callback];
    // @ts-ignore
    if (typeof fn.suggest === `undefined`)
        return null;
    const args = Array.isArray(callback)
        ? callback.slice(1)
        : [];
    // @ts-ignore
    return fn.suggest(state, ...args);
}
const tests = {
    always: () => {
        return true;
    },
    isOptionLike: (state, segment) => {
        return !state.ignoreOptions && segment.startsWith(`-`);
    },
    isNotOptionLike: (state, segment) => {
        return state.ignoreOptions || !segment.startsWith(`-`);
    },
    isOption: (state, segment, name, hidden) => {
        return !state.ignoreOptions && segment === name;
    },
    isBatchOption: (state, segment, names) => {
        return !state.ignoreOptions && BATCH_REGEX.test(segment) && [...segment.slice(1)].every(name => names.includes(`-${name}`));
    },
    isBoundOption: (state, segment, names, options) => {
        const optionParsing = segment.match(BINDING_REGEX);
        return !state.ignoreOptions && !!optionParsing && OPTION_REGEX.test(optionParsing[1]) && names.includes(optionParsing[1])
            // Disallow bound options with no arguments (i.e. booleans)
            && options.filter(opt => opt.names.includes(optionParsing[1])).every(opt => opt.allowBinding);
    },
    isNegatedOption: (state, segment, name) => {
        return !state.ignoreOptions && segment === `--no-${name.slice(2)}`;
    },
    isHelp: (state, segment) => {
        return !state.ignoreOptions && HELP_REGEX.test(segment);
    },
    isUnsupportedOption: (state, segment, names) => {
        return !state.ignoreOptions && segment.startsWith(`-`) && OPTION_REGEX.test(segment) && !names.includes(segment);
    },
    isInvalidOption: (state, segment) => {
        return !state.ignoreOptions && segment.startsWith(`-`) && !OPTION_REGEX.test(segment);
    },
};
// @ts-ignore
tests.isOption.suggest = (state, name, hidden = true) => {
    return !hidden ? [name] : null;
};
const reducers = {
    setCandidateUsage: (state, segment, usage) => {
        return Object.assign(Object.assign({}, state), { candidateUsage: usage });
    },
    setSelectedIndex: (state, segment, index) => {
        return Object.assign(Object.assign({}, state), { selectedIndex: index });
    },
    pushBatch: (state, segment) => {
        return Object.assign(Object.assign({}, state), { options: state.options.concat([...segment.slice(1)].map(name => ({ name: `-${name}`, value: true }))) });
    },
    pushBound: (state, segment) => {
        const [, name, value] = segment.match(BINDING_REGEX);
        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name, value }) });
    },
    pushPath: (state, segment) => {
        return Object.assign(Object.assign({}, state), { path: state.path.concat(segment) });
    },
    pushPositional: (state, segment) => {
        return Object.assign(Object.assign({}, state), { positionals: state.positionals.concat({ value: segment, extra: false }) });
    },
    pushExtra: (state, segment) => {
        return Object.assign(Object.assign({}, state), { positionals: state.positionals.concat({ value: segment, extra: true }) });
    },
    pushExtraNoLimits: (state, segment) => {
        return Object.assign(Object.assign({}, state), { positionals: state.positionals.concat({ value: segment, extra: NoLimits }) });
    },
    pushTrue: (state, segment, name = segment) => {
        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name: segment, value: true }) });
    },
    pushFalse: (state, segment, name = segment) => {
        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name, value: false }) });
    },
    pushUndefined: (state, segment) => {
        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name: segment, value: undefined }) });
    },
    pushStringValue: (state, segment) => {
        var _a;
        const copy = Object.assign(Object.assign({}, state), { options: [...state.options] });
        const lastOption = state.options[state.options.length - 1];
        lastOption.value = ((_a = lastOption.value) !== null && _a !== void 0 ? _a : []).concat([segment]);
        return copy;
    },
    setStringValue: (state, segment) => {
        const copy = Object.assign(Object.assign({}, state), { options: [...state.options] });
        const lastOption = state.options[state.options.length - 1];
        lastOption.value = segment;
        return copy;
    },
    inhibateOptions: (state) => {
        return Object.assign(Object.assign({}, state), { ignoreOptions: true });
    },
    useHelp: (state, segment, command) => {
        const [, name, index] = segment.match(HELP_REGEX);
        if (typeof index !== `undefined`) {
            return Object.assign(Object.assign({}, state), { options: [{ name: `-c`, value: String(command) }, { name: `-i`, value: index }] });
        }
        else {
            return Object.assign(Object.assign({}, state), { options: [{ name: `-c`, value: String(command) }] });
        }
    },
    setError: (state, segment, errorMessage) => {
        if (segment === END_OF_INPUT) {
            return Object.assign(Object.assign({}, state), { errorMessage: `${errorMessage}.` });
        }
        else {
            return Object.assign(Object.assign({}, state), { errorMessage: `${errorMessage} ("${segment}").` });
        }
    },
    setOptionArityError: (state, segment) => {
        const lastOption = state.options[state.options.length - 1];
        return Object.assign(Object.assign({}, state), { errorMessage: `Not enough arguments to option ${lastOption.name}.` });
    },
};
// ------------------------------------------------------------------------
const NoLimits = Symbol();
class CommandBuilder {
    constructor(cliIndex, cliOpts) {
        this.allOptionNames = [];
        this.arity = { leading: [], trailing: [], extra: [], proxy: false };
        this.options = [];
        this.paths = [];
        this.cliIndex = cliIndex;
        this.cliOpts = cliOpts;
    }
    addPath(path) {
        this.paths.push(path);
    }
    setArity({ leading = this.arity.leading, trailing = this.arity.trailing, extra = this.arity.extra, proxy = this.arity.proxy }) {
        Object.assign(this.arity, { leading, trailing, extra, proxy });
    }
    addPositional({ name = 'arg', required = true } = {}) {
        if (!required && this.arity.extra === NoLimits)
            throw new Error(`Optional parameters cannot be declared when using .rest() or .proxy()`);
        if (!required && this.arity.trailing.length > 0)
            throw new Error(`Optional parameters cannot be declared after the required trailing positional arguments`);
        if (!required && this.arity.extra !== NoLimits) {
            this.arity.extra.push(name);
        }
        else if (this.arity.extra !== NoLimits && this.arity.extra.length === 0) {
            this.arity.leading.push(name);
        }
        else {
            this.arity.trailing.push(name);
        }
    }
    addRest({ name = 'arg', required = 0 } = {}) {
        if (this.arity.extra === NoLimits)
            throw new Error(`Infinite lists cannot be declared multiple times in the same command`);
        if (this.arity.trailing.length > 0)
            throw new Error(`Infinite lists cannot be declared after the required trailing positional arguments`);
        for (let t = 0; t < required; ++t)
            this.addPositional({ name });
        this.arity.extra = NoLimits;
    }
    addProxy({ required = 0 } = {}) {
        this.addRest({ required });
        this.arity.proxy = true;
    }
    addOption({ names, description, arity = 0, hidden = false, allowBinding = true }) {
        if (!allowBinding && arity > 1)
            throw new Error(`The arity cannot be higher than 1 when the option only supports the --arg=value syntax`);
        if (!Number.isInteger(arity))
            throw new Error(`The arity must be an integer, got ${arity}`);
        if (arity < 0)
            throw new Error(`The arity must be positive, got ${arity}`);
        this.allOptionNames.push(...names);
        this.options.push({ names, description, arity, hidden, allowBinding });
    }
    setContext(context) {
        this.context = context;
    }
    usage({ detailed = true, inlineOptions = true } = {}) {
        const segments = [this.cliOpts.binaryName];
        const detailedOptionList = [];
        if (this.paths.length > 0)
            segments.push(...this.paths[0]);
        if (detailed) {
            for (const { names, arity, hidden, description } of this.options) {
                if (hidden)
                    continue;
                const args = [];
                for (let t = 0; t < arity; ++t)
                    args.push(` #${t}`);
                const definition = `${names.join(`,`)}${args.join(``)}`;
                if (!inlineOptions && description) {
                    detailedOptionList.push({ definition, description });
                }
                else {
                    segments.push(`[${definition}]`);
                }
            }
            segments.push(...this.arity.leading.map(name => `<${name}>`));
            if (this.arity.extra === NoLimits)
                segments.push(`...`);
            else
                segments.push(...this.arity.extra.map(name => `[${name}]`));
            segments.push(...this.arity.trailing.map(name => `<${name}>`));
        }
        let usage = segments.join(` `);
        return { usage, options: detailedOptionList };
    }
    compile() {
        if (typeof this.context === `undefined`)
            throw new Error(`Assertion failed: No context attached`);
        const machine = makeStateMachine();
        let firstNode = NODE_INITIAL;
        firstNode = injectNode(machine, makeNode());
        registerStatic(machine, NODE_INITIAL, START_OF_INPUT, firstNode, [`setCandidateUsage`, this.usage().usage]);
        const positionalArgument = this.arity.proxy
            ? `always`
            : `isNotOptionLike`;
        const paths = this.paths.length > 0
            ? this.paths
            : [[]];
        for (const path of paths) {
            let lastPathNode = firstNode;
            // We allow options to be specified before the path. Note that we
            // only do this when there is a path, otherwise there would be
            // some redundancy with the options attached later.
            if (path.length > 0) {
                const optionPathNode = injectNode(machine, makeNode());
                registerShortcut(machine, lastPathNode, optionPathNode);
                this.registerOptions(machine, optionPathNode);
                lastPathNode = optionPathNode;
            }
            for (let t = 0; t < path.length; ++t) {
                const nextPathNode = injectNode(machine, makeNode());
                registerStatic(machine, lastPathNode, path[t], nextPathNode, `pushPath`);
                lastPathNode = nextPathNode;
            }
            if (this.arity.leading.length > 0 || !this.arity.proxy) {
                const helpNode = injectNode(machine, makeNode());
                registerDynamic(machine, lastPathNode, `isHelp`, helpNode, [`useHelp`, this.cliIndex]);
                registerStatic(machine, helpNode, END_OF_INPUT, NODE_SUCCESS, [`setSelectedIndex`, HELP_COMMAND_INDEX]);
                this.registerOptions(machine, lastPathNode);
            }
            if (this.arity.leading.length > 0)
                registerStatic(machine, lastPathNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
            let lastLeadingNode = lastPathNode;
            for (let t = 0; t < this.arity.leading.length; ++t) {
                const nextLeadingNode = injectNode(machine, makeNode());
                if (!this.arity.proxy)
                    this.registerOptions(machine, nextLeadingNode);
                if (this.arity.trailing.length > 0 || t + 1 !== this.arity.leading.length)
                    registerStatic(machine, nextLeadingNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
                registerDynamic(machine, lastLeadingNode, `isNotOptionLike`, nextLeadingNode, `pushPositional`);
                lastLeadingNode = nextLeadingNode;
            }
            let lastExtraNode = lastLeadingNode;
            if (this.arity.extra === NoLimits || this.arity.extra.length > 0) {
                const extraShortcutNode = injectNode(machine, makeNode());
                registerShortcut(machine, lastLeadingNode, extraShortcutNode);
                if (this.arity.extra === NoLimits) {
                    const extraNode = injectNode(machine, makeNode());
                    if (!this.arity.proxy)
                        this.registerOptions(machine, extraNode);
                    registerDynamic(machine, lastLeadingNode, positionalArgument, extraNode, `pushExtraNoLimits`);
                    registerDynamic(machine, extraNode, positionalArgument, extraNode, `pushExtraNoLimits`);
                    registerShortcut(machine, extraNode, extraShortcutNode);
                }
                else {
                    for (let t = 0; t < this.arity.extra.length; ++t) {
                        const nextExtraNode = injectNode(machine, makeNode());
                        if (!this.arity.proxy)
                            this.registerOptions(machine, nextExtraNode);
                        registerDynamic(machine, lastExtraNode, positionalArgument, nextExtraNode, `pushExtra`);
                        registerShortcut(machine, nextExtraNode, extraShortcutNode);
                        lastExtraNode = nextExtraNode;
                    }
                }
                lastExtraNode = extraShortcutNode;
            }
            if (this.arity.trailing.length > 0)
                registerStatic(machine, lastExtraNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
            let lastTrailingNode = lastExtraNode;
            for (let t = 0; t < this.arity.trailing.length; ++t) {
                const nextTrailingNode = injectNode(machine, makeNode());
                if (!this.arity.proxy)
                    this.registerOptions(machine, nextTrailingNode);
                if (t + 1 < this.arity.trailing.length)
                    registerStatic(machine, nextTrailingNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
                registerDynamic(machine, lastTrailingNode, `isNotOptionLike`, nextTrailingNode, `pushPositional`);
                lastTrailingNode = nextTrailingNode;
            }
            registerDynamic(machine, lastTrailingNode, positionalArgument, NODE_ERRORED, [`setError`, `Extraneous positional argument`]);
            registerStatic(machine, lastTrailingNode, END_OF_INPUT, NODE_SUCCESS, [`setSelectedIndex`, this.cliIndex]);
        }
        return {
            machine,
            context: this.context,
        };
    }
    registerOptions(machine, node) {
        registerDynamic(machine, node, [`isOption`, `--`], node, `inhibateOptions`);
        registerDynamic(machine, node, [`isBatchOption`, this.allOptionNames], node, `pushBatch`);
        registerDynamic(machine, node, [`isBoundOption`, this.allOptionNames, this.options], node, `pushBound`);
        registerDynamic(machine, node, [`isUnsupportedOption`, this.allOptionNames], NODE_ERRORED, [`setError`, `Unsupported option name`]);
        registerDynamic(machine, node, [`isInvalidOption`], NODE_ERRORED, [`setError`, `Invalid option name`]);
        for (const option of this.options) {
            const longestName = option.names.reduce((longestName, name) => {
                return name.length > longestName.length ? name : longestName;
            }, ``);
            if (option.arity === 0) {
                for (const name of option.names) {
                    registerDynamic(machine, node, [`isOption`, name, option.hidden || name !== longestName], node, `pushTrue`);
                    if (name.startsWith(`--`) && !name.startsWith(`--no-`)) {
                        registerDynamic(machine, node, [`isNegatedOption`, name], node, [`pushFalse`, name]);
                    }
                }
            }
            else {
                // We inject a new node at the end of the state machine
                let lastNode = injectNode(machine, makeNode());
                // We register transitions from the starting node to this new node
                for (const name of option.names) {
                    registerDynamic(machine, node, [`isOption`, name, option.hidden || name !== longestName], lastNode, `pushUndefined`);
                }
                // For each argument, we inject a new node at the end and we
                // register a transition from the current node to this new node
                for (let t = 0; t < option.arity; ++t) {
                    const nextNode = injectNode(machine, makeNode());
                    // We can provide better errors when another option or END_OF_INPUT is encountered
                    registerStatic(machine, lastNode, END_OF_INPUT, NODE_ERRORED, `setOptionArityError`);
                    registerDynamic(machine, lastNode, `isOptionLike`, NODE_ERRORED, `setOptionArityError`);
                    // If the option has a single argument, no need to store it in an array
                    const action = option.arity === 1
                        ? `setStringValue`
                        : `pushStringValue`;
                    registerDynamic(machine, lastNode, `isNotOptionLike`, nextNode, action);
                    lastNode = nextNode;
                }
                // In the end, we register a shortcut from
                // the last node back to the starting node
                registerShortcut(machine, lastNode, node);
            }
        }
    }
}
class CliBuilder {
    constructor({ binaryName = `...` } = {}) {
        this.builders = [];
        this.opts = { binaryName };
    }
    static build(cbs, opts = {}) {
        return new CliBuilder(opts).commands(cbs).compile();
    }
    getBuilderByIndex(n) {
        if (!(n >= 0 && n < this.builders.length))
            throw new Error(`Assertion failed: Out-of-bound command index (${n})`);
        return this.builders[n];
    }
    commands(cbs) {
        for (const cb of cbs)
            cb(this.command());
        return this;
    }
    command() {
        const builder = new CommandBuilder(this.builders.length, this.opts);
        this.builders.push(builder);
        return builder;
    }
    compile() {
        const machines = [];
        const contexts = [];
        for (const builder of this.builders) {
            const { machine, context } = builder.compile();
            machines.push(machine);
            contexts.push(context);
        }
        const machine = makeAnyOfMachine(machines);
        simplifyMachine(machine);
        return {
            machine,
            contexts,
            process: (input) => {
                return runMachine(machine, input);
            },
            suggest: (input, partial) => {
                return suggestMachine(machine, input, partial);
            },
        };
    }
}

class Command {
    constructor() {
        /**
         * Predefined that will be set to true if `-h,--help` has been used, in which case `Command#execute` shouldn't be called.
         */
        this.help = false;
    }
    static getMeta(prototype) {
        const base = prototype.constructor;
        return base.meta = Object.prototype.hasOwnProperty.call(base, `meta`) ? base.meta : {
            definitions: [],
            transformers: [
                (state, command) => {
                    for (const { name, value } of state.options) {
                        if (name === `-h` || name === `--help`) {
                            // @ts-ignore: The property is meant to have been defined by the child class
                            command.help = value;
                        }
                    }
                },
            ],
        };
    }
    static resolveMeta(prototype) {
        const definitions = [];
        const transformers = [];
        for (let proto = prototype; proto instanceof Command; proto = proto.__proto__) {
            const meta = this.getMeta(proto);
            for (const definition of meta.definitions)
                definitions.push(definition);
            for (const transformer of meta.transformers) {
                transformers.push(transformer);
            }
        }
        return {
            definitions,
            transformers,
        };
    }
    static registerDefinition(prototype, definition) {
        this.getMeta(prototype).definitions.push(definition);
    }
    static registerTransformer(prototype, transformer) {
        this.getMeta(prototype).transformers.push(transformer);
    }
    static addPath(...path) {
        this.Path(...path)(this.prototype, `execute`);
    }
    static addOption(name, builder) {
        builder(this.prototype, name);
    }
    /**
     * Wrap the specified command to be attached to the given path on the command line.
     * The first path thus attached will be considered the "main" one, and all others will be aliases.
     * @param path The command path.
     */
    static Path(...path) {
        return (prototype, propertyName) => {
            this.registerDefinition(prototype, command => {
                command.addPath(path);
            });
        };
    }
    /**
     * Register a boolean listener for the given option names. When Clipanion detects that this argument is present, the value will be set to false. The value won't be set unless the option is found, so you must remember to set it to an appropriate default value.
     * @param descriptor the option names.
     */
    static Boolean(descriptor, { hidden = false, description } = {}) {
        return (prototype, propertyName) => {
            const optNames = descriptor.split(`,`);
            this.registerDefinition(prototype, command => {
                command.addOption({ names: optNames, arity: 0, hidden, allowBinding: false, description });
            });
            this.registerTransformer(prototype, (state, command) => {
                for (const { name, value } of state.options) {
                    if (optNames.includes(name)) {
                        // @ts-ignore: The property is meant to have been defined by the child class
                        command[propertyName] = value;
                    }
                }
            });
        };
    }
    /**
     * Register a boolean listener for the given option names. Each time Clipanion detects that this argument is present, the counter will be incremented. Each time the argument is negated, the counter will be reset to `0`. The counter won't be set unless the option is found, so you must remember to set it to an appropriate default value.

     * @param descriptor A comma-separated list of option names.
     */
    static Counter(descriptor, { hidden = false, description } = {}) {
        return (prototype, propertyName) => {
            const optNames = descriptor.split(`,`);
            this.registerDefinition(prototype, command => {
                command.addOption({ names: optNames, arity: 0, hidden, allowBinding: false, description });
            });
            this.registerTransformer(prototype, (state, command) => {
                var _a;
                for (const { name, value } of state.options) {
                    if (optNames.includes(name)) {
                        // @ts-ignore: The property is meant to have been defined by the child class
                        (_a = command[propertyName]) !== null && _a !== void 0 ? _a : (command[propertyName] = 0);
                        // Negated options reset the counter
                        if (!value) {
                            // @ts-ignore: The property is meant to have been defined by the child class
                            command[propertyName] = 0;
                        }
                        else {
                            // @ts-ignore: The property is meant to have been defined by the child class
                            command[propertyName]++;
                        }
                    }
                }
            });
        };
    }
    static String(descriptor = {}, { arity = 1, tolerateBoolean = false, hidden = false, description } = {}) {
        return (prototype, propertyName) => {
            if (typeof descriptor === `string`) {
                const optNames = descriptor.split(`,`);
                this.registerDefinition(prototype, command => {
                    // If tolerateBoolean is specified, the command will only accept a string value
                    // using the bind syntax and will otherwise act like a boolean option
                    command.addOption({ names: optNames, arity: tolerateBoolean ? 0 : arity, hidden, description });
                });
                this.registerTransformer(prototype, (state, command) => {
                    for (const { name, value } of state.options) {
                        if (optNames.includes(name)) {
                            // @ts-ignore: The property is meant to have been defined by the child class
                            command[propertyName] = value;
                        }
                    }
                });
            }
            else {
                const { name = propertyName, required = true } = descriptor;
                this.registerDefinition(prototype, command => {
                    command.addPositional({ name, required });
                });
                this.registerTransformer(prototype, (state, command) => {
                    for (let i = 0; i < state.positionals.length; ++i) {
                        // We skip NoLimits extras. We only care about
                        // required and optional finite positionals.
                        if (state.positionals[i].extra === NoLimits)
                            continue;
                        // We skip optional positionals when we only
                        // care about required positionals.
                        if (required && state.positionals[i].extra === true)
                            continue;
                        // We skip required positionals when we only
                        // care about optional positionals.
                        if (!required && state.positionals[i].extra === false)
                            continue;
                        // We remove the positional from the list
                        const [positional] = state.positionals.splice(i, 1);
                        // We assign its value to the property.
                        // @ts-ignore: The property is meant to have been defined by the child class
                        command[propertyName] = positional.value;
                        // We stop after the first successful iteration.
                        break;
                    }
                });
            }
        };
    }
    /**
     * Register a listener that looks for an option and its followup argument. When Clipanion detects that this argument is present, the value will be pushed into the array represented in the property.
     */
    static Array(descriptor, { arity = 1, hidden = false, description } = {}) {
        return (prototype, propertyName) => {
            if (arity === 0)
                throw new Error(`Array options are expected to have at least an arity of 1`);
            const optNames = descriptor.split(`,`);
            this.registerDefinition(prototype, command => {
                command.addOption({ names: optNames, arity, hidden, description });
            });
            this.registerTransformer(prototype, (state, command) => {
                for (const { name, value } of state.options) {
                    if (optNames.includes(name)) {
                        // @ts-ignore: The property is meant to have been defined by the child class
                        command[propertyName] = command[propertyName] || [];
                        // @ts-ignore: The property is meant to have been defined by the child class
                        command[propertyName].push(value);
                    }
                }
            });
        };
    }
    static Rest({ required = 0 } = {}) {
        return (prototype, propertyName) => {
            this.registerDefinition(prototype, command => {
                command.addRest({ name: propertyName, required });
            });
            this.registerTransformer(prototype, (state, command, builder) => {
                // The builder's arity.extra will always be NoLimits,
                // because it is set when we call registerDefinition
                const isRestPositional = (index) => {
                    const positional = state.positionals[index];
                    // A NoLimits extra (i.e. an optional rest argument)
                    if (positional.extra === NoLimits)
                        return true;
                    // A leading positional (i.e. a required rest argument)
                    if (positional.extra === false && index < builder.arity.leading.length)
                        return true;
                    return false;
                };
                let count = 0;
                while (count < state.positionals.length && isRestPositional(count))
                    count += 1;
                // @ts-ignore: The property is meant to have been defined by the child class
                command[propertyName] = state.positionals
                    .splice(0, count)
                    .map(({ value }) => value);
            });
        };
    }
    /**
     * Register a listener that takes all the arguments remaining (including options and such) and store them into the selected property.
     * Note that all methods affecting positional arguments are evaluated in the definition order; don't mess with it (for example sorting your properties in ascendent order might have adverse results).
     */
    static Proxy({ required = 0 } = {}) {
        return (prototype, propertyName) => {
            this.registerDefinition(prototype, command => {
                command.addProxy({ required });
            });
            this.registerTransformer(prototype, (state, command) => {
                // No need to filter / splice any positionals for Command.Proxy.
                // Once inside a proxy, we've already reached the point of no return.
                // @ts-ignore: The property is meant to have been defined by the child class
                command[propertyName] = state.positionals.map(({ value }) => value);
            });
        };
    }
    /**
     * Defines the usage information for the given command.
     * @param usage
     */
    static Usage(usage) {
        return usage;
    }
    /**
     * Defines the schema for the given command.
     * @param schema
     */
    static Schema(schema) {
        return schema;
    }
    /**
     * Standard error handler which will simply rethrow the error. Can be used to add custom logic to handle errors
     * from the command or simply return the parent class error handling.
     * @param error
     */
    async catch(error) {
        throw error;
    }
    async validateAndExecute() {
        const commandClass = this.constructor;
        const schema = commandClass.schema;
        if (typeof schema !== `undefined`) {
            try {
                await schema.validate(this);
            }
            catch (error) {
                if (error.name === `ValidationError`)
                    error.clipanion = { type: `usage` };
                throw error;
            }
        }
        const exitCode = await this.execute();
        if (typeof exitCode !== `undefined`) {
            return exitCode;
        }
        else {
            return 0;
        }
    }
}
/**
 * A list of useful semi-opinionated command entries that have to be registered manually.
 *
 * They cover the basic needs of most CLIs (e.g. help command, version command).
 *
 * @example
 * cli.register(Command.Entries.Help);
 * cli.register(Command.Entries.Version);
 */
Command.Entries = {};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

class HelpCommand extends Command {
    async execute() {
        this.context.stdout.write(this.cli.usage(null));
    }
}
__decorate([
    Command.Path(`--help`),
    Command.Path(`-h`)
], HelpCommand.prototype, "execute", null);

class VersionCommand extends Command {
    async execute() {
        var _a;
        this.context.stdout.write(`${(_a = this.cli.binaryVersion) !== null && _a !== void 0 ? _a : `<unknown>`}\n`);
    }
}
__decorate([
    Command.Path(`--version`),
    Command.Path(`-v`)
], VersionCommand.prototype, "execute", null);

const richFormat = {
    bold: str => `\x1b[1m${str}\x1b[22m`,
    error: str => `\x1b[31m\x1b[1m${str}\x1b[22m\x1b[39m`,
    code: str => `\x1b[36m${str}\x1b[39m`,
};
const textFormat = {
    bold: str => str,
    error: str => str,
    code: str => str,
};
function formatMarkdownish(text, { format, paragraphs }) {
    // Enforce \n as newline character
    text = text.replace(/\r\n?/g, `\n`);
    // Remove the indentation, since it got messed up with the JS indentation
    text = text.replace(/^[\t ]+|[\t ]+$/gm, ``);
    // Remove surrounding newlines, since they got added for JS formatting
    text = text.replace(/^\n+|\n+$/g, ``);
    // List items always end with at least two newlines (in order to not be collapsed)
    text = text.replace(/^-([^\n]*?)\n+/gm, `-$1\n\n`);
    // Single newlines are removed; larger than that are collapsed into one
    text = text.replace(/\n(\n)?\n*/g, `$1`);
    if (paragraphs) {
        text = text.split(/\n/).map(function (paragraph) {
            // Does the paragraph starts with a list?
            let bulletMatch = paragraph.match(/^[*-][\t ]+(.*)/);
            if (!bulletMatch)
                // No, cut the paragraphs into segments of 80 characters
                return paragraph.match(/(.{1,80})(?: |$)/g).join('\n');
            // Yes, cut the paragraphs into segments of 78 characters (to account for the prefix)
            return bulletMatch[1].match(/(.{1,78})(?: |$)/g).map((line, index) => {
                return (index === 0 ? `- ` : `  `) + line;
            }).join(`\n`);
        }).join(`\n\n`);
    }
    // Highlight the code segments
    text = text.replace(/(`+)((?:.|[\n])*?)\1/g, function ($0, $1, $2) {
        return format.code($1 + $2 + $1);
    });
    return text ? text + `\n` : ``;
}

class HelpCommand$1 extends Command {
    constructor(contexts) {
        super();
        this.contexts = contexts;
        this.commands = [];
    }
    static from(state, contexts) {
        const command = new HelpCommand$1(contexts);
        command.path = state.path;
        for (const opt of state.options) {
            switch (opt.name) {
                case `-c`:
                    {
                        command.commands.push(Number(opt.value));
                    }
                    break;
                case `-i`:
                    {
                        command.index = Number(opt.value);
                    }
                    break;
            }
        }
        return command;
    }
    async execute() {
        let commands = this.commands;
        if (typeof this.index !== `undefined` && this.index >= 0 && this.index < commands.length)
            commands = [commands[this.index]];
        if (commands.length === 0) {
            this.context.stdout.write(this.cli.usage());
        }
        else if (commands.length === 1) {
            this.context.stdout.write(this.cli.usage(this.contexts[commands[0]].commandClass, { detailed: true }));
        }
        else if (commands.length > 1) {
            this.context.stdout.write(`Multiple commands match your selection:\n`);
            this.context.stdout.write(`\n`);
            let index = 0;
            for (const command of this.commands)
                this.context.stdout.write(this.cli.usage(this.contexts[command].commandClass, { prefix: `${index++}. `.padStart(5) }));
            this.context.stdout.write(`\n`);
            this.context.stdout.write(`Run again with -h=<index> to see the longer details of any of those commands.\n`);
        }
    }
}

function getDefaultColorSettings() {
    if (process.env.FORCE_COLOR === `0`)
        return false;
    if (process.env.FORCE_COLOR === `1`)
        return true;
    if (typeof process.stdout !== `undefined` && process.stdout.isTTY)
        return true;
    return false;
}
/**
 * @template Context The context shared by all commands. Contexts are a set of values, defined when calling the `run`/`runExit` functions from the CLI instance, that will be made available to the commands via `this.context`.
 */
class Cli {
    constructor({ binaryLabel, binaryName: binaryNameOpt = `...`, binaryVersion, enableColors = getDefaultColorSettings() } = {}) {
        this.registrations = new Map();
        this.builder = new CliBuilder({ binaryName: binaryNameOpt });
        this.binaryLabel = binaryLabel;
        this.binaryName = binaryNameOpt;
        this.binaryVersion = binaryVersion;
        this.enableColors = enableColors;
    }
    /**
     * Creates a new Cli and registers all commands passed as parameters.
     *
     * @param commandClasses The Commands to register
     * @returns The created `Cli` instance
     */
    static from(commandClasses, options = {}) {
        const cli = new Cli(options);
        for (const commandClass of commandClasses)
            cli.register(commandClass);
        return cli;
    }
    /**
     * Registers a command inside the CLI.
     */
    register(commandClass) {
        const commandBuilder = this.builder.command();
        this.registrations.set(commandClass, commandBuilder.cliIndex);
        const { definitions } = commandClass.resolveMeta(commandClass.prototype);
        for (const definition of definitions)
            definition(commandBuilder);
        commandBuilder.setContext({
            commandClass,
        });
    }
    process(input) {
        const { contexts, process } = this.builder.compile();
        const state = process(input);
        switch (state.selectedIndex) {
            case HELP_COMMAND_INDEX:
                {
                    return HelpCommand$1.from(state, contexts);
                }
            default:
                {
                    const { commandClass } = contexts[state.selectedIndex];
                    const index = this.registrations.get(commandClass);
                    if (typeof index === `undefined`)
                        throw new Error(`Assertion failed: Expected the command class to have been registered.`);
                    const commandBuilder = this.builder.getBuilderByIndex(index);
                    const command = new commandClass();
                    command.path = state.path;
                    const { transformers } = commandClass.resolveMeta(commandClass.prototype);
                    for (const transformer of transformers)
                        transformer(state, command, commandBuilder);
                    return command;
                }
        }
    }
    async run(input, context) {
        let command;
        if (!Array.isArray(input)) {
            command = input;
        }
        else {
            try {
                command = this.process(input);
            }
            catch (error) {
                context.stdout.write(this.error(error));
                return 1;
            }
        }
        if (command.help) {
            context.stdout.write(this.usage(command, { detailed: true }));
            return 0;
        }
        command.context = context;
        command.cli = {
            binaryLabel: this.binaryLabel,
            binaryName: this.binaryName,
            binaryVersion: this.binaryVersion,
            enableColors: this.enableColors,
            definitions: () => this.definitions(),
            error: (error, opts) => this.error(error, opts),
            process: input => this.process(input),
            run: (input, subContext) => this.run(input, Object.assign(Object.assign({}, context), subContext)),
            usage: (command, opts) => this.usage(command, opts),
        };
        let exitCode;
        try {
            exitCode = await command.validateAndExecute().catch(error => command.catch(error).then(() => 0));
        }
        catch (error) {
            context.stdout.write(this.error(error, { command }));
            return 1;
        }
        return exitCode;
    }
    /**
     * Runs a command and exits the current `process` with the exit code returned by the command.
     *
     * @param input An array containing the name of the command and its arguments.
     *
     * @example
     * cli.runExit(process.argv.slice(2), Cli.defaultContext)
     */
    async runExit(input, context) {
        process.exitCode = await this.run(input, context);
    }
    suggest(input, partial) {
        const { contexts, process, suggest } = this.builder.compile();
        return suggest(input, partial);
    }
    definitions({ colored = false } = {}) {
        const data = [];
        for (const [commandClass, number] of this.registrations) {
            if (typeof commandClass.usage === `undefined`)
                continue;
            const { usage: path } = this.getUsageByIndex(number, { detailed: false });
            const { usage, options } = this.getUsageByIndex(number, { detailed: true, inlineOptions: false });
            const category = typeof commandClass.usage.category !== `undefined`
                ? formatMarkdownish(commandClass.usage.category, { format: this.format(colored), paragraphs: false })
                : undefined;
            const description = typeof commandClass.usage.description !== `undefined`
                ? formatMarkdownish(commandClass.usage.description, { format: this.format(colored), paragraphs: false })
                : undefined;
            const details = typeof commandClass.usage.details !== `undefined`
                ? formatMarkdownish(commandClass.usage.details, { format: this.format(colored), paragraphs: true })
                : undefined;
            const examples = typeof commandClass.usage.examples !== `undefined`
                ? commandClass.usage.examples.map(([label, cli]) => [formatMarkdownish(label, { format: this.format(colored), paragraphs: false }), cli.replace(/\$0/g, this.binaryName)])
                : undefined;
            data.push({ path, usage, category, description, details, examples, options });
        }
        return data;
    }
    usage(command = null, { colored, detailed = false, prefix = `$ ` } = {}) {
        // @ts-ignore
        const commandClass = command !== null && typeof command.getMeta === `undefined`
            ? command.constructor
            : command;
        let result = ``;
        if (!commandClass) {
            const commandsByCategories = new Map();
            for (const [commandClass, number] of this.registrations.entries()) {
                if (typeof commandClass.usage === `undefined`)
                    continue;
                const category = typeof commandClass.usage.category !== `undefined`
                    ? formatMarkdownish(commandClass.usage.category, { format: this.format(colored), paragraphs: false })
                    : null;
                let categoryCommands = commandsByCategories.get(category);
                if (typeof categoryCommands === `undefined`)
                    commandsByCategories.set(category, categoryCommands = []);
                const { usage } = this.getUsageByIndex(number);
                categoryCommands.push({ commandClass, usage });
            }
            const categoryNames = Array.from(commandsByCategories.keys()).sort((a, b) => {
                if (a === null)
                    return -1;
                if (b === null)
                    return +1;
                return a.localeCompare(b, `en`, { usage: `sort`, caseFirst: `upper` });
            });
            const hasLabel = typeof this.binaryLabel !== `undefined`;
            const hasVersion = typeof this.binaryVersion !== `undefined`;
            if (hasLabel || hasVersion) {
                if (hasLabel && hasVersion)
                    result += `${this.format(colored).bold(`${this.binaryLabel} - ${this.binaryVersion}`)}\n\n`;
                else if (hasLabel)
                    result += `${this.format(colored).bold(`${this.binaryLabel}`)}\n`;
                else
                    result += `${this.format(colored).bold(`${this.binaryVersion}`)}\n`;
                result += `  ${this.format(colored).bold(prefix)}${this.binaryName} <command>\n`;
            }
            else {
                result += `${this.format(colored).bold(prefix)}${this.binaryName} <command>\n`;
            }
            for (let categoryName of categoryNames) {
                const commands = commandsByCategories.get(categoryName).slice().sort((a, b) => {
                    return a.usage.localeCompare(b.usage, `en`, { usage: `sort`, caseFirst: `upper` });
                });
                const header = categoryName !== null
                    ? categoryName.trim()
                    : `Where <command> is one of`;
                result += `\n`;
                result += `${this.format(colored).bold(`${header}:`)}\n`;
                for (let { commandClass, usage } of commands) {
                    const doc = commandClass.usage.description || `undocumented`;
                    result += `\n`;
                    result += `  ${this.format(colored).bold(usage)}\n`;
                    result += `    ${formatMarkdownish(doc, { format: this.format(colored), paragraphs: false })}`;
                }
            }
            result += `\n`;
            result += formatMarkdownish(`You can also print more details about any of these commands by calling them after adding the \`-h,--help\` flag right after the command name.`, { format: this.format(colored), paragraphs: true });
        }
        else {
            if (!detailed) {
                const { usage } = this.getUsageByRegistration(commandClass);
                result += `${this.format(colored).bold(prefix)}${usage}\n`;
            }
            else {
                const { description = ``, details = ``, examples = [], } = commandClass.usage || {};
                if (description !== ``) {
                    result += formatMarkdownish(description, { format: this.format(colored), paragraphs: false }).replace(/^./, $0 => $0.toUpperCase());
                    result += `\n`;
                }
                if (details !== `` || examples.length > 0) {
                    result += `${this.format(colored).bold(`Usage:`)}\n`;
                    result += `\n`;
                }
                const { usage, options } = this.getUsageByRegistration(commandClass, { inlineOptions: false });
                result += `${this.format(colored).bold(prefix)}${usage}\n`;
                if (options.length > 0) {
                    result += `\n`;
                    result += `${richFormat.bold('Options:')}\n`;
                    const maxDefinitionLength = options.reduce((length, option) => {
                        return Math.max(length, option.definition.length);
                    }, 0);
                    result += `\n`;
                    for (const { definition, description } of options) {
                        result += `  ${definition.padEnd(maxDefinitionLength)}    ${formatMarkdownish(description, { format: this.format(colored), paragraphs: false })}`;
                    }
                }
                if (details !== ``) {
                    result += `\n`;
                    result += `${this.format(colored).bold(`Details:`)}\n`;
                    result += `\n`;
                    result += formatMarkdownish(details, { format: this.format(colored), paragraphs: true });
                }
                if (examples.length > 0) {
                    result += `\n`;
                    result += `${this.format(colored).bold(`Examples:`)}\n`;
                    for (let [description, example] of examples) {
                        result += `\n`;
                        result += formatMarkdownish(description, { format: this.format(colored), paragraphs: false });
                        result += example
                            .replace(/^/m, `  ${this.format(colored).bold(prefix)}`)
                            .replace(/\$0/g, this.binaryName)
                            + `\n`;
                    }
                }
            }
        }
        return result;
    }
    error(error, { colored, command = null } = {}) {
        if (!(error instanceof Error))
            error = new Error(`Execution failed with a non-error rejection (rejected value: ${JSON.stringify(error)})`);
        let result = ``;
        let name = error.name.replace(/([a-z])([A-Z])/g, `$1 $2`);
        if (name === `Error`)
            name = `Internal Error`;
        result += `${this.format(colored).error(name)}: ${error.message}\n`;
        // @ts-ignore
        const meta = error.clipanion;
        if (typeof meta !== `undefined`) {
            if (meta.type === `usage`) {
                result += `\n`;
                result += this.usage(command);
            }
        }
        else {
            if (error.stack) {
                result += `${error.stack.replace(/^.*\n/, ``)}\n`;
            }
        }
        return result;
    }
    getUsageByRegistration(klass, opts) {
        const index = this.registrations.get(klass);
        if (typeof index === `undefined`)
            throw new Error(`Assertion failed: Unregistered command`);
        return this.getUsageByIndex(index, opts);
    }
    getUsageByIndex(n, opts) {
        return this.builder.getBuilderByIndex(n).usage(opts);
    }
    format(colored = this.enableColors) {
        return colored ? richFormat : textFormat;
    }
}
/**
 * The default context of the CLI.
 *
 * Contains the stdio of the current `process`.
 */
Cli.defaultContext = {
    stdin: process.stdin,
    stdout: process.stdout,
    stderr: process.stderr,
};

Command.Entries.Help = HelpCommand;
Command.Entries.Version = VersionCommand;




/***/ }),
/* 8 */
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pluginCommands": () => /* binding */ pluginCommands
/* harmony export */ });
// Don't modify this script directly! Instead, run:
// yarn build:plugin-commands
const pluginCommands = new Map([[`constraints`, [[`constraints`, `query`], [`constraints`, `source`], [`constraints`]]], [`exec`, []], [`interactive-tools`, [[`search`], [`upgrade-interactive`]]], [`stage`, [[`stage`]]], [`typescript`, []], [`version`, [[`version`, `apply`], [`version`, `check`], [`version`]]], [`workspace-tools`, [[`workspaces`, `focus`], [`workspaces`, `foreach`]]]]);

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WelcomeCommand": () => /* binding */ WelcomeCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _BaseCommand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);





const getMessage = configuration => `
${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `Welcome on Yarn 2!`, `bold`)}  Thanks for helping us shape our vision of how projects
should be managed going forward.

Being still in RC, Yarn 2 isn't completely stable yet. Some features might be
missing, and some behaviors may have received major overhaul. In case of doubt,
use the following URLs to get some insight:

  - The changelog:
    ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `https://github.com/yarnpkg/berry/tree/CHANGELOG.md`, `cyan`)}

  - Our issue tracker:
    ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `https://github.com/yarnpkg/berry`, `cyan`)}

  - Our Discord server:
    ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `https://discord.gg/yarnpkg`, `cyan`)}

We're hoping you will enjoy the experience. For now, a good start is to run
the two following commands:

  ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `find . -name node_modules -prune -exec rm -r {} \\;`, `magenta`)}
  ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `yarn install`, `magenta`)}

One last trick! If you need at some point to upgrade Yarn to a nightly build,
the following command will install the CLI straight from master:

  ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `yarn set version from sources`, `magenta`)}

See you later 
`;

class WelcomeCommand extends _BaseCommand__WEBPACK_IMPORTED_MODULE_1__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    this.context.stdout.write(`${getMessage(configuration).trim()}\n`);
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`--welcome`)], WelcomeCommand.prototype, "execute", null);

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseCommand": () => /* binding */ BaseCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);


class BaseCommand extends clipanion__WEBPACK_IMPORTED_MODULE_0__.Command {}

(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.String(`--cwd`, {
  hidden: true
})], BaseCommand.prototype, "cwd", void 0);

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__extends": () => /* binding */ __extends,
/* harmony export */   "__assign": () => /* binding */ __assign,
/* harmony export */   "__rest": () => /* binding */ __rest,
/* harmony export */   "__decorate": () => /* binding */ __decorate,
/* harmony export */   "__param": () => /* binding */ __param,
/* harmony export */   "__metadata": () => /* binding */ __metadata,
/* harmony export */   "__awaiter": () => /* binding */ __awaiter,
/* harmony export */   "__generator": () => /* binding */ __generator,
/* harmony export */   "__createBinding": () => /* binding */ __createBinding,
/* harmony export */   "__exportStar": () => /* binding */ __exportStar,
/* harmony export */   "__values": () => /* binding */ __values,
/* harmony export */   "__read": () => /* binding */ __read,
/* harmony export */   "__spread": () => /* binding */ __spread,
/* harmony export */   "__spreadArrays": () => /* binding */ __spreadArrays,
/* harmony export */   "__await": () => /* binding */ __await,
/* harmony export */   "__asyncGenerator": () => /* binding */ __asyncGenerator,
/* harmony export */   "__asyncDelegator": () => /* binding */ __asyncDelegator,
/* harmony export */   "__asyncValues": () => /* binding */ __asyncValues,
/* harmony export */   "__makeTemplateObject": () => /* binding */ __makeTemplateObject,
/* harmony export */   "__importStar": () => /* binding */ __importStar,
/* harmony export */   "__importDefault": () => /* binding */ __importDefault,
/* harmony export */   "__classPrivateFieldGet": () => /* binding */ __classPrivateFieldGet,
/* harmony export */   "__classPrivateFieldSet": () => /* binding */ __classPrivateFieldSet
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Type": () => /* binding */ Type,
/* harmony export */   "Style": () => /* binding */ Style,
/* harmony export */   "supportsColor": () => /* binding */ supportsColor,
/* harmony export */   "supportsHyperlinks": () => /* binding */ supportsHyperlinks,
/* harmony export */   "tuple": () => /* binding */ tuple,
/* harmony export */   "applyStyle": () => /* binding */ applyStyle,
/* harmony export */   "applyColor": () => /* binding */ applyColor,
/* harmony export */   "pretty": () => /* binding */ pretty,
/* harmony export */   "prettyList": () => /* binding */ prettyList,
/* harmony export */   "json": () => /* binding */ json,
/* harmony export */   "LogLevel": () => /* binding */ LogLevel,
/* harmony export */   "addLogFilterSupport": () => /* binding */ addLogFilterSupport
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(chalk__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(180);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(177);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(179);






var Type;

(function (Type) {
  Type["NO_HINT"] = "NO_HINT";
  Type["NULL"] = "NULL";
  Type["SCOPE"] = "SCOPE";
  Type["NAME"] = "NAME";
  Type["RANGE"] = "RANGE";
  Type["REFERENCE"] = "REFERENCE";
  Type["NUMBER"] = "NUMBER";
  Type["PATH"] = "PATH";
  Type["URL"] = "URL";
  Type["ADDED"] = "ADDED";
  Type["REMOVED"] = "REMOVED";
  Type["CODE"] = "CODE";
  Type["DURATION"] = "DURATION";
  Type["SIZE"] = "SIZE";
  Type["IDENT"] = "IDENT";
  Type["DESCRIPTOR"] = "DESCRIPTOR";
  Type["LOCATOR"] = "LOCATOR";
  Type["RESOLUTION"] = "RESOLUTION";
  Type["DEPENDENT"] = "DEPENDENT";
  Type["PACKAGE_EXTENSION"] = "PACKAGE_EXTENSION";
})(Type || (Type = {}));

var Style;

(function (Style) {
  Style[Style["BOLD"] = 2] = "BOLD";
})(Style || (Style = {}));

const chalkOptions = process.env.GITHUB_ACTIONS ? {
  level: 2
} : (chalk__WEBPACK_IMPORTED_MODULE_0___default().supportsColor) ? {
  level: (chalk__WEBPACK_IMPORTED_MODULE_0___default().supportsColor.level)
} : {
  level: 0
};
const supportsColor = chalkOptions.level !== 0;
const supportsHyperlinks = supportsColor && !process.env.GITHUB_ACTIONS;
const chalkInstance = new (chalk__WEBPACK_IMPORTED_MODULE_0___default().Instance)(chalkOptions);
const colors = new Map([[Type.NO_HINT, null], [Type.NULL, [`#a853b5`, 129]], [Type.SCOPE, [`#d75f00`, 166]], [Type.NAME, [`#d7875f`, 173]], [Type.RANGE, [`#00afaf`, 37]], [Type.REFERENCE, [`#87afff`, 111]], [Type.NUMBER, [`#ffd700`, 220]], [Type.PATH, [`#d75fd7`, 170]], [Type.URL, [`#d75fd7`, 170]], [Type.ADDED, [`#5faf00`, 70]], [Type.REMOVED, [`#d70000`, 160]], [Type.CODE, [`#87afff`, 111]], [Type.SIZE, [`#ffd700`, 220]]]); // Just to make sure that the individual fields of the transform map have
// compatible parameter types, without upcasting the map to a too generic type
//
// We also take the opportunity to downcast the configuration into `any`,
// otherwise TypeScript will detect a circular reference and won't allow us to
// properly type the `format` method from Configuration. Since transforms are
// internal to this file, it should be fine.

const validateTransform = spec => spec;

const transforms = {
  [Type.NUMBER]: validateTransform({
    pretty: (configuration, value) => {
      return `${value}`;
    },
    json: value => {
      return value;
    }
  }),
  [Type.IDENT]: validateTransform({
    pretty: (configuration, ident) => {
      return _structUtils__WEBPACK_IMPORTED_MODULE_1__.prettyIdent(configuration, ident);
    },
    json: ident => {
      return _structUtils__WEBPACK_IMPORTED_MODULE_1__.stringifyIdent(ident);
    }
  }),
  [Type.LOCATOR]: validateTransform({
    pretty: (configuration, locator) => {
      return _structUtils__WEBPACK_IMPORTED_MODULE_1__.prettyLocator(configuration, locator);
    },
    json: locator => {
      return _structUtils__WEBPACK_IMPORTED_MODULE_1__.stringifyLocator(locator);
    }
  }),
  [Type.DESCRIPTOR]: validateTransform({
    pretty: (configuration, descriptor) => {
      return _structUtils__WEBPACK_IMPORTED_MODULE_1__.prettyDescriptor(configuration, descriptor);
    },
    json: descriptor => {
      return _structUtils__WEBPACK_IMPORTED_MODULE_1__.stringifyDescriptor(descriptor);
    }
  }),
  [Type.RESOLUTION]: validateTransform({
    pretty: (configuration, {
      descriptor,
      locator
    }) => {
      return _structUtils__WEBPACK_IMPORTED_MODULE_1__.prettyResolution(configuration, descriptor, locator);
    },
    json: ({
      descriptor,
      locator
    }) => {
      return {
        descriptor: _structUtils__WEBPACK_IMPORTED_MODULE_1__.stringifyDescriptor(descriptor),
        locator: locator !== null ? _structUtils__WEBPACK_IMPORTED_MODULE_1__.stringifyLocator(locator) : null
      };
    }
  }),
  [Type.DEPENDENT]: validateTransform({
    pretty: (configuration, {
      locator,
      descriptor
    }) => {
      return _structUtils__WEBPACK_IMPORTED_MODULE_1__.prettyDependent(configuration, locator, descriptor);
    },
    json: ({
      locator,
      descriptor
    }) => {
      return {
        locator: _structUtils__WEBPACK_IMPORTED_MODULE_1__.stringifyLocator(locator),
        descriptor: _structUtils__WEBPACK_IMPORTED_MODULE_1__.stringifyDescriptor(descriptor)
      };
    }
  }),
  [Type.PACKAGE_EXTENSION]: validateTransform({
    pretty: (configuration, packageExtension) => {
      switch (packageExtension.type) {
        case _types__WEBPACK_IMPORTED_MODULE_2__.PackageExtensionType.Dependency:
          return `${_structUtils__WEBPACK_IMPORTED_MODULE_1__.prettyIdent(configuration, packageExtension.parentDescriptor)}  ${applyColor(configuration, `dependencies`, Type.CODE)}  ${_structUtils__WEBPACK_IMPORTED_MODULE_1__.prettyIdent(configuration, packageExtension.descriptor)}`;

        case _types__WEBPACK_IMPORTED_MODULE_2__.PackageExtensionType.PeerDependency:
          return `${_structUtils__WEBPACK_IMPORTED_MODULE_1__.prettyIdent(configuration, packageExtension.parentDescriptor)}  ${applyColor(configuration, `peerDependencies`, Type.CODE)}  ${_structUtils__WEBPACK_IMPORTED_MODULE_1__.prettyIdent(configuration, packageExtension.descriptor)}`;

        case _types__WEBPACK_IMPORTED_MODULE_2__.PackageExtensionType.PeerDependencyMeta:
          return `${_structUtils__WEBPACK_IMPORTED_MODULE_1__.prettyIdent(configuration, packageExtension.parentDescriptor)}  ${applyColor(configuration, `peerDependenciesMeta`, Type.CODE)}  ${_structUtils__WEBPACK_IMPORTED_MODULE_1__.prettyIdent(configuration, _structUtils__WEBPACK_IMPORTED_MODULE_1__.parseIdent(packageExtension.selector))}  ${applyColor(configuration, packageExtension.key, Type.CODE)}`;

        default:
          throw new Error(`Assertion failed: Unsupported package extension type: ${packageExtension.type}`);
      }
    },
    json: packageExtension => {
      switch (packageExtension.type) {
        case _types__WEBPACK_IMPORTED_MODULE_2__.PackageExtensionType.Dependency:
          return `${_structUtils__WEBPACK_IMPORTED_MODULE_1__.stringifyIdent(packageExtension.parentDescriptor)} > ${_structUtils__WEBPACK_IMPORTED_MODULE_1__.stringifyIdent(packageExtension.descriptor)}`;

        case _types__WEBPACK_IMPORTED_MODULE_2__.PackageExtensionType.PeerDependency:
          return `${_structUtils__WEBPACK_IMPORTED_MODULE_1__.stringifyIdent(packageExtension.parentDescriptor)} >> ${_structUtils__WEBPACK_IMPORTED_MODULE_1__.stringifyIdent(packageExtension.descriptor)}`;

        case _types__WEBPACK_IMPORTED_MODULE_2__.PackageExtensionType.PeerDependencyMeta:
          return `${_structUtils__WEBPACK_IMPORTED_MODULE_1__.stringifyIdent(packageExtension.parentDescriptor)} >> ${packageExtension.selector} / ${packageExtension.key}`;

        default:
          throw new Error(`Assertion failed: Unsupported package extension type: ${packageExtension.type}`);
      }
    }
  }),
  [Type.DURATION]: validateTransform({
    pretty: (configuration, duration) => {
      if (duration > 1000 * 60) {
        const minutes = Math.floor(duration / 1000 / 60);
        const seconds = Math.ceil((duration - minutes * 60 * 1000) / 1000);
        return seconds === 0 ? `${minutes}m` : `${minutes}m ${seconds}s`;
      } else {
        const seconds = Math.floor(duration / 1000);
        const milliseconds = duration - seconds * 1000;
        return milliseconds === 0 ? `${seconds}s` : `${seconds}s ${milliseconds}ms`;
      }
    },
    json: duration => {
      return duration;
    }
  }),
  [Type.SIZE]: validateTransform({
    pretty: (configuration, size) => {
      const thresholds = [`KB`, `MB`, `GB`, `TB`];
      let power = thresholds.length;

      while (power > 1 && size < 1024 ** power) power -= 1;

      const factor = 1024 ** power;
      const value = Math.floor(size * 100 / factor) / 100;
      return applyColor(configuration, `${value} ${thresholds[power - 1]}`, Type.NUMBER);
    },
    json: size => {
      return size;
    }
  }),
  [Type.PATH]: validateTransform({
    pretty: (configuration, filePath) => {
      return applyColor(configuration, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(filePath), Type.PATH);
    },
    json: filePath => {
      return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(filePath);
    }
  })
};
function tuple(formatType, value) {
  return [value, formatType];
}
function applyStyle(configuration, text, flags) {
  if (!configuration.get(`enableColors`)) return text;
  if (flags & Style.BOLD) text = chalk__WEBPACK_IMPORTED_MODULE_0___default().bold(text);
  return text;
}
function applyColor(configuration, value, formatType) {
  if (!configuration.get(`enableColors`)) return value;
  const colorSpec = colors.get(formatType);
  if (colorSpec === null) return value;
  const color = typeof colorSpec === `undefined` ? formatType : chalkOptions.level >= 3 ? colorSpec[0] : colorSpec[1];
  const fn = typeof color === `number` ? chalkInstance.ansi256(color) : color.startsWith(`#`) ? chalkInstance.hex(color) : chalkInstance[color];
  if (typeof fn !== `function`) throw new Error(`Invalid format type ${color}`);
  return fn(value);
}
function pretty(configuration, value, formatType) {
  if (value === null) return applyColor(configuration, `null`, Type.NULL);

  if (Object.prototype.hasOwnProperty.call(transforms, formatType)) {
    const transform = transforms[formatType];
    const typedTransform = transform;
    return typedTransform.pretty(configuration, value);
  }

  if (typeof value !== `string`) throw new Error(`Assertion failed: Expected the value to be a string, got ${typeof value}`);
  return applyColor(configuration, value, formatType);
}
function prettyList(configuration, values, formatType, {
  separator = `, `
} = {}) {
  return [...values].map(value => pretty(configuration, value, formatType)).join(separator);
}
function json(value, formatType) {
  if (value === null) return null;

  if (Object.prototype.hasOwnProperty.call(transforms, formatType)) {
    _miscUtils__WEBPACK_IMPORTED_MODULE_4__.overrideType(formatType);
    return transforms[formatType].json(value);
  }

  if (typeof value !== `string`) throw new Error(`Assertion failed: Expected the value to be a string, got ${typeof value}`);
  return value;
}
var LogLevel;

(function (LogLevel) {
  LogLevel["Error"] = "error";
  LogLevel["Warning"] = "warning";
  LogLevel["Info"] = "info";
  LogLevel["Discard"] = "discard";
})(LogLevel || (LogLevel = {}));
/**
 * Add support support for the `logFilters` setting to the specified Report
 * instance.
 */


function addLogFilterSupport(report, {
  configuration
}) {
  const logFilters = configuration.get(`logFilters`);
  const logFiltersByCode = new Map();
  const logFiltersByText = new Map();

  for (const filter of logFilters) {
    const level = filter.get(`level`);
    if (typeof level === `undefined`) continue;
    const code = filter.get(`code`);
    if (typeof code !== `undefined`) logFiltersByCode.set(code, level);
    const text = filter.get(`text`);

    if (typeof text !== `undefined`) {
      logFiltersByText.set(text, level);
    }
  }

  const findLogLevel = (name, text, defaultLevel) => {
    if (name === null || name === _MessageName__WEBPACK_IMPORTED_MODULE_5__.MessageName.UNNAMED) return defaultLevel;

    if (logFiltersByText.size > 0) {
      const level = logFiltersByText.get(chalk__WEBPACK_IMPORTED_MODULE_0___default().reset(text));

      if (typeof level !== `undefined`) {
        return level !== null && level !== void 0 ? level : defaultLevel;
      }
    }

    if (logFiltersByCode.size > 0) {
      const level = logFiltersByCode.get((0,_MessageName__WEBPACK_IMPORTED_MODULE_5__.stringifyMessageName)(name));

      if (typeof level !== `undefined`) {
        return level !== null && level !== void 0 ? level : defaultLevel;
      }
    }

    return defaultLevel;
  };

  const reportInfo = report.reportInfo;
  const reportWarning = report.reportWarning;
  const reportError = report.reportError;

  const routeMessage = function (report, name, text, level) {
    switch (findLogLevel(name, text, level)) {
      case LogLevel.Info:
        {
          reportInfo.call(report, name, text);
        }
        break;

      case LogLevel.Warning:
        {
          reportWarning.call(report, name !== null && name !== void 0 ? name : _MessageName__WEBPACK_IMPORTED_MODULE_5__.MessageName.UNNAMED, text);
        }
        break;

      case LogLevel.Error:
        {
          reportError.call(report, name !== null && name !== void 0 ? name : _MessageName__WEBPACK_IMPORTED_MODULE_5__.MessageName.UNNAMED, text);
        }
        break;
    }
  };

  report.reportInfo = function (...args) {
    return routeMessage(this, ...args, LogLevel.Info);
  };

  report.reportWarning = function (...args) {
    return routeMessage(this, ...args, LogLevel.Warning);
  };

  report.reportError = function (...args) {
    return routeMessage(this, ...args, LogLevel.Error);
  };
}

/***/ }),
/* 14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ansiStyles = __webpack_require__(15);
const {stdout: stdoutColor, stderr: stderrColor} = __webpack_require__(20);
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = __webpack_require__(24);

// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level > 3 || options.level < 0) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => {
		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// `__proto__` is used because we must return a function, but there is
	// no way to create a function with a different prototype
	builder.__proto__ = proto; // eslint-disable-line no-proto

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!Array.isArray(firstString)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = __webpack_require__(25);
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

// For TypeScript
chalk.Level = {
	None: 0,
	Basic: 1,
	Ansi256: 2,
	TrueColor: 3,
	0: 'None',
	1: 'Basic',
	2: 'Ansi256',
	3: 'TrueColor'
};

module.exports = chalk;


/***/ }),
/* 15 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = __webpack_require__(16);
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});


/***/ }),
/* 16 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(17);
const route = __webpack_require__(19);

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),
/* 17 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* MIT license */
/* eslint-disable no-mixed-operators */
const cssKeywords = __webpack_require__(18);

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

module.exports = convert;

// Hide .channels and .labels properties
for (const model of Object.keys(convert)) {
	if (!('channels' in convert[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert[model].labels.length !== convert[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert[model];
	delete convert[model].channels;
	delete convert[model].labels;
	Object.defineProperty(convert[model], 'channels', {value: channels});
	Object.defineProperty(convert[model], 'labels', {value: labels});
}

convert.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	const xyz = convert.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hsv = convert.gray.hsl;

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),
/* 18 */
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),
/* 19 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(17);

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),
/* 20 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(21);
const tty = __webpack_require__(22);
const hasFlag = __webpack_require__(23);

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if ('GITHUB_ACTIONS' in env) {
		return 1;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),
/* 21 */
/***/ ((module) => {

"use strict";
module.exports = require("os");;

/***/ }),
/* 22 */
/***/ ((module) => {

"use strict";
module.exports = require("tty");;

/***/ }),
/* 23 */
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),
/* 24 */
/***/ ((module) => {

"use strict";


const stringReplaceAll = (string, substring, replacer) => {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

module.exports = {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
};


/***/ }),
/* 25 */
/***/ ((module) => {

"use strict";

const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}

		if (!(styleName in current)) {
			throw new Error(`Unknown Chalk style: ${styleName}`);
		}

		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}

	return current;
}

module.exports = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMsg);
	}

	return chunks.join('');
};


/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeIdent": () => /* binding */ makeIdent,
/* harmony export */   "makeDescriptor": () => /* binding */ makeDescriptor,
/* harmony export */   "makeLocator": () => /* binding */ makeLocator,
/* harmony export */   "convertToIdent": () => /* binding */ convertToIdent,
/* harmony export */   "convertDescriptorToLocator": () => /* binding */ convertDescriptorToLocator,
/* harmony export */   "convertLocatorToDescriptor": () => /* binding */ convertLocatorToDescriptor,
/* harmony export */   "convertPackageToLocator": () => /* binding */ convertPackageToLocator,
/* harmony export */   "renamePackage": () => /* binding */ renamePackage,
/* harmony export */   "copyPackage": () => /* binding */ copyPackage,
/* harmony export */   "virtualizeDescriptor": () => /* binding */ virtualizeDescriptor,
/* harmony export */   "virtualizePackage": () => /* binding */ virtualizePackage,
/* harmony export */   "isVirtualDescriptor": () => /* binding */ isVirtualDescriptor,
/* harmony export */   "isVirtualLocator": () => /* binding */ isVirtualLocator,
/* harmony export */   "devirtualizeDescriptor": () => /* binding */ devirtualizeDescriptor,
/* harmony export */   "devirtualizeLocator": () => /* binding */ devirtualizeLocator,
/* harmony export */   "bindDescriptor": () => /* binding */ bindDescriptor,
/* harmony export */   "bindLocator": () => /* binding */ bindLocator,
/* harmony export */   "areIdentsEqual": () => /* binding */ areIdentsEqual,
/* harmony export */   "areDescriptorsEqual": () => /* binding */ areDescriptorsEqual,
/* harmony export */   "areLocatorsEqual": () => /* binding */ areLocatorsEqual,
/* harmony export */   "areVirtualPackagesEquivalent": () => /* binding */ areVirtualPackagesEquivalent,
/* harmony export */   "parseIdent": () => /* binding */ parseIdent,
/* harmony export */   "tryParseIdent": () => /* binding */ tryParseIdent,
/* harmony export */   "parseDescriptor": () => /* binding */ parseDescriptor,
/* harmony export */   "tryParseDescriptor": () => /* binding */ tryParseDescriptor,
/* harmony export */   "parseLocator": () => /* binding */ parseLocator,
/* harmony export */   "tryParseLocator": () => /* binding */ tryParseLocator,
/* harmony export */   "parseRange": () => /* binding */ parseRange,
/* harmony export */   "parseFileStyleRange": () => /* binding */ parseFileStyleRange,
/* harmony export */   "makeRange": () => /* binding */ makeRange,
/* harmony export */   "convertToManifestRange": () => /* binding */ convertToManifestRange,
/* harmony export */   "requirableIdent": () => /* binding */ requirableIdent,
/* harmony export */   "stringifyIdent": () => /* binding */ stringifyIdent,
/* harmony export */   "stringifyDescriptor": () => /* binding */ stringifyDescriptor,
/* harmony export */   "stringifyLocator": () => /* binding */ stringifyLocator,
/* harmony export */   "slugifyIdent": () => /* binding */ slugifyIdent,
/* harmony export */   "slugifyLocator": () => /* binding */ slugifyLocator,
/* harmony export */   "prettyIdent": () => /* binding */ prettyIdent,
/* harmony export */   "prettyRange": () => /* binding */ prettyRange,
/* harmony export */   "prettyDescriptor": () => /* binding */ prettyDescriptor,
/* harmony export */   "prettyReference": () => /* binding */ prettyReference,
/* harmony export */   "prettyLocator": () => /* binding */ prettyLocator,
/* harmony export */   "prettyLocatorNoColors": () => /* binding */ prettyLocatorNoColors,
/* harmony export */   "sortDescriptors": () => /* binding */ sortDescriptors,
/* harmony export */   "prettyWorkspace": () => /* binding */ prettyWorkspace,
/* harmony export */   "prettyResolution": () => /* binding */ prettyResolution,
/* harmony export */   "prettyDependent": () => /* binding */ prettyDependent,
/* harmony export */   "getIdentVendorPath": () => /* binding */ getIdentVendorPath
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _formatUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13);
/* harmony import */ var _hashUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(177);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);







const VIRTUAL_PROTOCOL = `virtual:`;
const VIRTUAL_ABBREVIATE = 5;
/**
 * Creates a package ident.
 *
 * @param scope The package scope without the `@` prefix (eg. `types`)
 * @param name The name of the package
 */

function makeIdent(scope, name) {
  if (scope === null || scope === void 0 ? void 0 : scope.startsWith(`@`)) throw new Error(`Invalid scope: don't prefix it with '@'`);
  return {
    identHash: _hashUtils__WEBPACK_IMPORTED_MODULE_2__.makeHash(scope, name),
    scope,
    name
  };
}
/**
 * Creates a package descriptor.
 *
 * @param ident The base ident (see `makeIdent`)
 * @param range The range to attach (eg. `^1.0.0`)
 */

function makeDescriptor(ident, range) {
  return {
    identHash: ident.identHash,
    scope: ident.scope,
    name: ident.name,
    descriptorHash: _hashUtils__WEBPACK_IMPORTED_MODULE_2__.makeHash(ident.identHash, range),
    range
  };
}
/**
 * Creates a package locator.
 *
 * @param ident The base ident (see `makeIdent`)
 * @param range The reference to attach (eg. `1.0.0`)
 */

function makeLocator(ident, reference) {
  return {
    identHash: ident.identHash,
    scope: ident.scope,
    name: ident.name,
    locatorHash: _hashUtils__WEBPACK_IMPORTED_MODULE_2__.makeHash(ident.identHash, reference),
    reference
  };
}
/**
 * Turns a compatible source to an ident. You won't really have to use this
 * function since by virtue of structural inheritance all descriptors and
 * locators are already valid idents.
 *
 * This function is only useful if you absolutely need to remove the non-ident
 * fields from a structure before storing it somewhere.
 *
 * @param source The data structure to convert into an ident.
 */

function convertToIdent(source) {
  return {
    identHash: source.identHash,
    scope: source.scope,
    name: source.name
  };
}
/**
 * Turns a descriptor into a locator.
 *
 * Note that this process may be unsafe, as descriptors may reference multiple
 * packages, putting them at odd with locators' expected semantic. Only makes
 * sense when used with single-resolution protocols, for instance `file:`.
 *
 * @param descriptor The descriptor to convert into a locator.
 */

function convertDescriptorToLocator(descriptor) {
  return {
    identHash: descriptor.identHash,
    scope: descriptor.scope,
    name: descriptor.name,
    locatorHash: descriptor.descriptorHash,
    reference: descriptor.range
  };
}
/**
 * Turns a locator into a descriptor.
 *
 * This should be safe to do regardless of the locator, since all locator
 * references are expected to be valid descriptor ranges.
 *
 * @param locator The locator to convert into a descriptor.
 */

function convertLocatorToDescriptor(locator) {
  return {
    identHash: locator.identHash,
    scope: locator.scope,
    name: locator.name,
    descriptorHash: locator.locatorHash,
    range: locator.reference
  };
}
/**
 * Turns a package structure into a simple locator. You won't often need to
 * call this function since packages are already valid locators by virtue of
 * structural inheritance.
 *
 * This function is only useful if you absolutely need to remove the
 * non-locator fields from a structure before storing it somewhere.
 *
 * @param pkg The package to convert into a locator.
 */

function convertPackageToLocator(pkg) {
  return {
    identHash: pkg.identHash,
    scope: pkg.scope,
    name: pkg.name,
    locatorHash: pkg.locatorHash,
    reference: pkg.reference
  };
}
/**
 * Deep copies a package then change its locator to something else.
 *
 * @param pkg The source package
 * @param locator Its new new locator
 */

function renamePackage(pkg, locator) {
  return {
    identHash: locator.identHash,
    scope: locator.scope,
    name: locator.name,
    locatorHash: locator.locatorHash,
    reference: locator.reference,
    version: pkg.version,
    languageName: pkg.languageName,
    linkType: pkg.linkType,
    dependencies: new Map(pkg.dependencies),
    peerDependencies: new Map(pkg.peerDependencies),
    dependenciesMeta: new Map(pkg.dependenciesMeta),
    peerDependenciesMeta: new Map(pkg.peerDependenciesMeta),
    bin: new Map(pkg.bin)
  };
}
/**
 * Deep copies a package. The copy will share the same locator as the original.
 *
 * @param pkg The source package
 */

function copyPackage(pkg) {
  return renamePackage(pkg, pkg);
}
/**
 * Creates a new virtual descriptor from a non virtual one.
 *
 * @param descriptor The descriptor to virtualize
 * @param entropy A hash that provides uniqueness to this virtualized descriptor (normally a locator hash)
 */

function virtualizeDescriptor(descriptor, entropy) {
  if (entropy.includes(`#`)) throw new Error(`Invalid entropy`);
  return makeDescriptor(descriptor, `virtual:${entropy}#${descriptor.range}`);
}
/**
 * Creates a new virtual package from a non virtual one.
 *
 * @param pkg The package to virtualize
 * @param entropy A hash that provides uniqueness to this virtualized package (normally a locator hash)
 */

function virtualizePackage(pkg, entropy) {
  if (entropy.includes(`#`)) throw new Error(`Invalid entropy`);
  return renamePackage(pkg, makeLocator(pkg, `virtual:${entropy}#${pkg.reference}`));
}
/**
 * Returns `true` if the descriptor is virtual.
 */

function isVirtualDescriptor(descriptor) {
  return descriptor.range.startsWith(VIRTUAL_PROTOCOL);
}
/**
 * Returns `true` if the locator is virtual.
 */

function isVirtualLocator(locator) {
  return locator.reference.startsWith(VIRTUAL_PROTOCOL);
}
/**
 * Returns a new devirtualized descriptor based on a virtualized descriptor
 */

function devirtualizeDescriptor(descriptor) {
  if (!isVirtualDescriptor(descriptor)) throw new Error(`Not a virtual descriptor`);
  return makeDescriptor(descriptor, descriptor.range.replace(/^[^#]*#/, ``));
}
/**
 * Returns a new devirtualized locator based on a virtualized locator
 * @param locator the locator
 */

function devirtualizeLocator(locator) {
  if (!isVirtualLocator(locator)) throw new Error(`Not a virtual descriptor`);
  return makeLocator(locator, locator.reference.replace(/^[^#]*#/, ``));
}
/**
 * Some descriptors only make sense when bound with some internal state. For
 * instance that would be the case for the `file:` ranges, which require to
 * be bound to their parent packages in order to resolve relative paths from
 * the right location.
 *
 * This function will apply the specified parameters onto the requested
 * descriptor, but only if it didn't get bound before (important to handle the
 * case where we replace a descriptor by another, since when that happens the
 * replacement has probably been already bound).
 *
 * @param descriptor The original descriptor
 * @param params The parameters to encode in the range
 */

function bindDescriptor(descriptor, params) {
  if (descriptor.range.includes(`::`)) return descriptor;
  return makeDescriptor(descriptor, `${descriptor.range}::${querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify(params)}`);
}
/**
 * Some locators only make sense when bound with some internal state. For
 * instance that would be the case for the `file:` references, which require to
 * be bound to their parent packages in order to resolve relative paths from
 * the right location.
 *
 * This function will apply the specified parameters onto the requested
 * locator, but only if it didn't get bound before (important to handle the
 * case where we replace a locator by another, since when that happens the
 * replacement has probably been already bound).
 *
 * @param locator The original locator
 * @param params The parameters to encode in the reference
 */

function bindLocator(locator, params) {
  if (locator.reference.includes(`::`)) return locator;
  return makeLocator(locator, `${locator.reference}::${querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify(params)}`);
}
/**
 * Returns `true` if the idents are equal
 */

function areIdentsEqual(a, b) {
  return a.identHash === b.identHash;
}
/**
 * Returns `true` if the descriptors are equal
 */

function areDescriptorsEqual(a, b) {
  return a.descriptorHash === b.descriptorHash;
}
/**
 * Returns `true` if the locators are equal
 */

function areLocatorsEqual(a, b) {
  return a.locatorHash === b.locatorHash;
}
/**
 * Virtual packages are considered equivalent when they belong to the same
 * package identity and have the same dependencies. Note that equivalence
 * is not the same as equality, as the references may be different.
 */

function areVirtualPackagesEquivalent(a, b) {
  if (!isVirtualLocator(a)) throw new Error(`Invalid package type`);
  if (!isVirtualLocator(b)) throw new Error(`Invalid package type`);
  if (!areIdentsEqual(a, b)) return false;
  if (a.dependencies.size !== b.dependencies.size) return false;

  for (const dependencyDescriptorA of a.dependencies.values()) {
    const dependencyDescriptorB = b.dependencies.get(dependencyDescriptorA.identHash);
    if (!dependencyDescriptorB) return false;

    if (!areDescriptorsEqual(dependencyDescriptorA, dependencyDescriptorB)) {
      return false;
    }
  }

  return true;
}
/**
 * Parses a string into an ident.
 *
 * Throws an error if the ident cannot be parsed.
 *
 * @param string The ident string (eg. `@types/lodash`)
 */

function parseIdent(string) {
  const ident = tryParseIdent(string);
  if (!ident) throw new Error(`Invalid ident (${string})`);
  return ident;
}
/**
 * Parses a string into an ident.
 *
 * Returns `null` if the ident cannot be parsed.
 *
 * @param string The ident string (eg. `@types/lodash`)
 */

function tryParseIdent(string) {
  const match = string.match(/^(?:@([^/]+?)\/)?([^/]+)$/);
  if (!match) return null;
  const [, scope, name] = match;
  const realScope = typeof scope !== `undefined` ? scope : null;
  return makeIdent(realScope, name);
}
/**
 * Parses a `string` into a descriptor
 *
 * Throws an error if the descriptor cannot be parsed.
 *
 * @param string The descriptor string (eg. `lodash@^1.0.0`)
 * @param strict If `false`, the range is optional (`unknown` will be used as fallback)
 */

function parseDescriptor(string, strict = false) {
  const descriptor = tryParseDescriptor(string, strict);
  if (!descriptor) throw new Error(`Invalid descriptor (${string})`);
  return descriptor;
}
/**
 * Parses a `string` into a descriptor
 *
 * Returns `null` if the descriptor cannot be parsed.
 *
 * @param string The descriptor string (eg. `lodash@^1.0.0`)
 * @param strict If `false`, the range is optional (`unknown` will be used as fallback)
 */

function tryParseDescriptor(string, strict = false) {
  const match = strict ? string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))$/) : string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))?$/);
  if (!match) return null;
  const [, scope, name, range] = match;
  if (range === `unknown`) throw new Error(`Invalid range (${string})`);
  const realScope = typeof scope !== `undefined` ? scope : null;
  const realRange = typeof range !== `undefined` ? range : `unknown`;
  return makeDescriptor(makeIdent(realScope, name), realRange);
}
/**
 * Parses a `string` into a locator
 *
 * Throws an error if the locator cannot be parsed.
 *
 * @param string The locator `string` (eg. `lodash@1.0.0`)
 * @param strict If `false`, the reference is optional (`unknown` will be used as fallback)
 */

function parseLocator(string, strict = false) {
  const locator = tryParseLocator(string, strict);
  if (!locator) throw new Error(`Invalid locator (${string})`);
  return locator;
}
/**
 * Parses a `string` into a locator
 *
 * Returns `null` if the locator cannot be parsed.
 *
 * @param string The locator string (eg. `lodash@1.0.0`)
 * @param strict If `false`, the reference is optional (`unknown` will be used as fallback)
 */

function tryParseLocator(string, strict = false) {
  const match = strict ? string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))$/) : string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))?$/);
  if (!match) return null;
  const [, scope, name, reference] = match;
  if (reference === `unknown`) throw new Error(`Invalid reference (${string})`);
  const realScope = typeof scope !== `undefined` ? scope : null;
  const realReference = typeof reference !== `undefined` ? reference : `unknown`;
  return makeLocator(makeIdent(realScope, name), realReference);
}
/**
 * Parses a range into its constituents. Ranges typically follow these forms,
 * with both `protocol` and `bindings` being optionals:
 *
 * <protocol>:<selector>::<bindings>
 * <protocol>:<source>#<selector>::<bindings>
 *
 * The selector is intended to "refine" the source, and is required. The source
 * itself is optional (for instance we don't need it for npm packages, but we
 * do for git dependencies).
 */

function parseRange(range, opts) {
  const match = range.match(/^([^#:]*:)?((?:(?!::)[^#])*)(?:#((?:(?!::).)*))?(?:::(.*))?$/);
  if (match === null) throw new Error(`Invalid range (${range})`);
  const protocol = typeof match[1] !== `undefined` ? match[1] : null;
  if (typeof (opts === null || opts === void 0 ? void 0 : opts.requireProtocol) === `string` && protocol !== opts.requireProtocol) throw new Error(`Invalid protocol (${protocol})`);else if ((opts === null || opts === void 0 ? void 0 : opts.requireProtocol) && protocol === null) throw new Error(`Missing protocol (${protocol})`);
  const source = typeof match[3] !== `undefined` ? decodeURIComponent(match[2]) : null;
  if ((opts === null || opts === void 0 ? void 0 : opts.requireSource) && source === null) throw new Error(`Missing source (${range})`);
  const rawSelector = typeof match[3] !== `undefined` ? decodeURIComponent(match[3]) : decodeURIComponent(match[2]);
  const selector = (opts === null || opts === void 0 ? void 0 : opts.parseSelector) ? querystring__WEBPACK_IMPORTED_MODULE_0___default().parse(rawSelector) : rawSelector;
  const params = typeof match[4] !== `undefined` ? querystring__WEBPACK_IMPORTED_MODULE_0___default().parse(match[4]) : null;
  return {
    // @ts-expect-error
    protocol,
    // @ts-expect-error
    source,
    // @ts-expect-error
    selector,
    // @ts-expect-error
    params
  };
}
/**
 * File-style ranges are bound to a parent locators that we need in order to
 * resolve relative paths to the location of their parent packages. This
 * function wraps `parseRange` to automatically extract the parent locator
 * from the bindings and return it along with the selector.
 */

function parseFileStyleRange(range, {
  protocol
}) {
  const {
    selector,
    params
  } = parseRange(range, {
    requireProtocol: protocol,
    requireBindings: true
  });
  if (typeof params.locator !== `string`) throw new Error(`Assertion failed: Invalid bindings for ${range}`);
  const parentLocator = parseLocator(params.locator, true);
  const path = selector;
  return {
    parentLocator,
    path
  };
}

function encodeUnsafeCharacters(str) {
  str = str.replace(/%/g, `%25`);
  str = str.replace(/:/g, `%3A`);
  str = str.replace(/#/g, `%23`);
  return str;
}

function hasParams(params) {
  if (params === null) return false;
  return Object.entries(params).length > 0;
}
/**
 * Turn the components returned by `parseRange` back into a string. Check
 * `parseRange` for more details.
 */


function makeRange({
  protocol,
  source,
  selector,
  params
}) {
  let range = ``;
  if (protocol !== null) range += `${protocol}`;
  if (source !== null) range += `${encodeUnsafeCharacters(source)}#`;
  range += encodeUnsafeCharacters(selector);
  if (hasParams(params)) range += `::${querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify(params)}`;
  return range;
}
/**
 * Some bindings are internal-only and not meant to be displayed anywhere (for
 * instance that's the case with the parent locator bound to the `file:` ranges).
 *
 * this function strips them from a range.
 */

function convertToManifestRange(range) {
  const {
    params,
    protocol,
    source,
    selector
  } = parseRange(range);

  for (const name in params) if (name.startsWith(`__`)) delete params[name];

  return makeRange({
    protocol,
    source,
    params,
    selector
  });
}
/**
 * @deprecated Prefer using `stringifyIdent`
 */

function requirableIdent(ident) {
  if (ident.scope) {
    return `@${ident.scope}/${ident.name}`;
  } else {
    return `${ident.name}`;
  }
}
/**
 * Returns a string from an ident (eg. `@types/lodash`).
 */

function stringifyIdent(ident) {
  if (ident.scope) {
    return `@${ident.scope}/${ident.name}`;
  } else {
    return `${ident.name}`;
  }
}
/**
 * Returns a string from a descriptor (eg. `@types/lodash@^1.0.0`).
 */

function stringifyDescriptor(descriptor) {
  if (descriptor.scope) {
    return `@${descriptor.scope}/${descriptor.name}@${descriptor.range}`;
  } else {
    return `${descriptor.name}@${descriptor.range}`;
  }
}
/**
 * Returns a string from a descriptor (eg. `@types/lodash@1.0.0`).
 */

function stringifyLocator(locator) {
  if (locator.scope) {
    return `@${locator.scope}/${locator.name}@${locator.reference}`;
  } else {
    return `${locator.name}@${locator.reference}`;
  }
}
/**
 * Returns a string from an ident, formatted as a slug (eg. `@types-lodash`).
 */

function slugifyIdent(ident) {
  if (ident.scope !== null) {
    return `@${ident.scope}-${ident.name}`;
  } else {
    return ident.name;
  }
}
/**
 * Returns a string from a locator, formatted as a slug (eg. `@types-lodash-npm-1.0.0-abcdef1234`).
 */

function slugifyLocator(locator) {
  const {
    protocol,
    selector
  } = parseRange(locator.reference);
  const humanProtocol = protocol !== null ? protocol.replace(/:$/, ``) : `exotic`;
  const humanVersion = semver__WEBPACK_IMPORTED_MODULE_1___default().valid(selector);
  const humanReference = humanVersion !== null ? `${humanProtocol}-${humanVersion}` : `${humanProtocol}`; // 10 hex characters means that 47 different entries have 10^-9 chances of
  // causing a hash collision. Since this hash is joined with the package name
  // (making it highly unlikely you'll have more than a handful of instances
  // of any single package), this should provide a good enough guard in most
  // cases.
  //
  // Also note that eCryptfs eats some bytes, so the theoretical maximum for a
  // file size is around 140 bytes (but we don't need as much, as explained).

  const hashTruncate = 10;
  const slug = locator.scope ? `${slugifyIdent(locator)}-${humanReference}-${locator.locatorHash.slice(0, hashTruncate)}` : `${slugifyIdent(locator)}-${humanReference}-${locator.locatorHash.slice(0, hashTruncate)}`;
  return (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.toFilename)(slug);
}
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param ident The ident to pretty print
 */

function prettyIdent(configuration, ident) {
  if (ident.scope) {
    return `${_formatUtils__WEBPACK_IMPORTED_MODULE_4__.pretty(configuration, `@${ident.scope}/`, _formatUtils__WEBPACK_IMPORTED_MODULE_4__.Type.SCOPE)}${_formatUtils__WEBPACK_IMPORTED_MODULE_4__.pretty(configuration, ident.name, _formatUtils__WEBPACK_IMPORTED_MODULE_4__.Type.NAME)}`;
  } else {
    return `${_formatUtils__WEBPACK_IMPORTED_MODULE_4__.pretty(configuration, ident.name, _formatUtils__WEBPACK_IMPORTED_MODULE_4__.Type.NAME)}`;
  }
}

function prettyRangeNoColors(range) {
  if (range.startsWith(VIRTUAL_PROTOCOL)) {
    const nested = prettyRangeNoColors(range.substr(range.indexOf(`#`) + 1));
    const abbrev = range.substr(VIRTUAL_PROTOCOL.length, VIRTUAL_ABBREVIATE); // I'm not satisfied of how the virtual packages appear in the output
    // eslint-disable-next-line no-constant-condition

    return  false ? 0 : `${nested} [${abbrev}]`;
  } else {
    return range.replace(/\?.*/, `?[...]`);
  }
}
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param ident The range to pretty print
 */


function prettyRange(configuration, range) {
  return `${_formatUtils__WEBPACK_IMPORTED_MODULE_4__.pretty(configuration, prettyRangeNoColors(range), _formatUtils__WEBPACK_IMPORTED_MODULE_4__.Type.RANGE)}`;
}
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param descriptor The descriptor to pretty print
 */

function prettyDescriptor(configuration, descriptor) {
  return `${prettyIdent(configuration, descriptor)}${_formatUtils__WEBPACK_IMPORTED_MODULE_4__.pretty(configuration, `@`, _formatUtils__WEBPACK_IMPORTED_MODULE_4__.Type.RANGE)}${prettyRange(configuration, descriptor.range)}`;
}
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param reference The reference to pretty print
 */

function prettyReference(configuration, reference) {
  return `${_formatUtils__WEBPACK_IMPORTED_MODULE_4__.pretty(configuration, prettyRangeNoColors(reference), _formatUtils__WEBPACK_IMPORTED_MODULE_4__.Type.REFERENCE)}`;
}
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param locator The locator to pretty print
 */

function prettyLocator(configuration, locator) {
  return `${prettyIdent(configuration, locator)}${_formatUtils__WEBPACK_IMPORTED_MODULE_4__.pretty(configuration, `@`, _formatUtils__WEBPACK_IMPORTED_MODULE_4__.Type.REFERENCE)}${prettyReference(configuration, locator.reference)}`;
}
/**
 * Returns a string that is suitable to be printed to stdout. It will never
 * be colored.
 *
 * @param locator The locator to pretty print
 */

function prettyLocatorNoColors(locator) {
  return `${stringifyIdent(locator)}@${prettyRangeNoColors(locator.reference)}`;
}
/**
 * Sorts a list of descriptors, first by their idents then by their ranges.
 */

function sortDescriptors(descriptors) {
  return _miscUtils__WEBPACK_IMPORTED_MODULE_5__.sortMap(descriptors, [descriptor => stringifyIdent(descriptor), descriptor => descriptor.range]);
}
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param workspace The workspace to pretty print
 */

function prettyWorkspace(configuration, workspace) {
  return prettyIdent(configuration, workspace.locator);
}
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param descriptor The descriptor to pretty print
 * @param locator The locator is resolves to
 */

function prettyResolution(configuration, descriptor, locator) {
  const devirtualizedDescriptor = isVirtualDescriptor(descriptor) ? devirtualizeDescriptor(descriptor) : descriptor;

  if (locator === null) {
    return `${_structUtils__WEBPACK_IMPORTED_MODULE_6__.prettyDescriptor(configuration, devirtualizedDescriptor)}  ${_formatUtils__WEBPACK_IMPORTED_MODULE_4__.pretty(configuration, ``, `red`)}`;
  } else if (devirtualizedDescriptor.identHash === locator.identHash) {
    return `${_structUtils__WEBPACK_IMPORTED_MODULE_6__.prettyDescriptor(configuration, devirtualizedDescriptor)}  ${prettyReference(configuration, locator.reference)}`;
  } else {
    return `${_structUtils__WEBPACK_IMPORTED_MODULE_6__.prettyDescriptor(configuration, devirtualizedDescriptor)}  ${prettyLocator(configuration, locator)}`;
  }
}
/**
 * Returns a string that is suitable to be printed to stdout. Based on the
 * configuration it may include color sequences.
 *
 * @param configuration Reference configuration
 * @param locator The locator to pretty print
 * @param descriptor The descriptor that depends on it
 */

function prettyDependent(configuration, locator, descriptor) {
  if (descriptor === null) {
    return `${prettyLocator(configuration, locator)}`;
  } else {
    return `${prettyLocator(configuration, locator)} (via ${_structUtils__WEBPACK_IMPORTED_MODULE_6__.prettyRange(configuration, descriptor.range)})`;
  }
}
/**
 * The presence of a `node_modules` directory in the path is extremely common
 * in the JavaScript ecosystem to denote whether a path belongs to a vendor
 * or not. I considered using a more generic path for packages that aren't
 * always JS-only (such as when using the Git fetcher), but that unfortunately
 * caused various JS apps to start showing errors when working with git repos.
 *
 * As a result, all packages from all languages will follow this convention. At
 * least it'll be consistent, and linkers will always have the ability to remap
 * them to a different location if that's a critical requirement.
 */

function getIdentVendorPath(ident) {
  return `node_modules/${requirableIdent(ident)}`;
}

/***/ }),
/* 27 */
/***/ ((module) => {

"use strict";
module.exports = require("querystring");;

/***/ }),
/* 28 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(29)
module.exports = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: __webpack_require__(30).SEMVER_SPEC_VERSION,
  SemVer: __webpack_require__(32),
  compareIdentifiers: __webpack_require__(33).compareIdentifiers,
  rcompareIdentifiers: __webpack_require__(33).rcompareIdentifiers,
  parse: __webpack_require__(34),
  valid: __webpack_require__(35),
  clean: __webpack_require__(36),
  inc: __webpack_require__(37),
  diff: __webpack_require__(38),
  major: __webpack_require__(41),
  minor: __webpack_require__(42),
  patch: __webpack_require__(43),
  prerelease: __webpack_require__(44),
  compare: __webpack_require__(40),
  rcompare: __webpack_require__(45),
  compareLoose: __webpack_require__(46),
  compareBuild: __webpack_require__(47),
  sort: __webpack_require__(48),
  rsort: __webpack_require__(49),
  gt: __webpack_require__(50),
  lt: __webpack_require__(51),
  eq: __webpack_require__(39),
  neq: __webpack_require__(52),
  gte: __webpack_require__(53),
  lte: __webpack_require__(54),
  cmp: __webpack_require__(55),
  coerce: __webpack_require__(56),
  Comparator: __webpack_require__(57),
  Range: __webpack_require__(58),
  satisfies: __webpack_require__(59),
  toComparators: __webpack_require__(60),
  maxSatisfying: __webpack_require__(61),
  minSatisfying: __webpack_require__(62),
  minVersion: __webpack_require__(63),
  validRange: __webpack_require__(64),
  outside: __webpack_require__(65),
  gtr: __webpack_require__(66),
  ltr: __webpack_require__(67),
  intersects: __webpack_require__(68),
  simplifyRange: __webpack_require__(69),
  subset: __webpack_require__(70),
}


/***/ }),
/* 29 */
/***/ ((module, exports, __webpack_require__) => {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(30)
const debug = __webpack_require__(31)
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$')


/***/ }),
/* 30 */
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH
}


/***/ }),
/* 31 */
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),
/* 32 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(31)
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(30)
const { re, t } = __webpack_require__(29)

const { compareIdentifiers } = __webpack_require__(33)
class SemVer {
  constructor (version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),
/* 33 */
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers
}


/***/ }),
/* 34 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {MAX_LENGTH} = __webpack_require__(30)
const { re, t } = __webpack_require__(29)
const SemVer = __webpack_require__(32)

const parse = (version, options) => {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),
/* 35 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(34)
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),
/* 36 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(34)
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),
/* 37 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(32)

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),
/* 38 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(34)
const eq = __webpack_require__(39)

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),
/* 39 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(40)
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),
/* 40 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(32)
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),
/* 41 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(32)
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),
/* 42 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(32)
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),
/* 43 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(32)
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),
/* 44 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(34)
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),
/* 45 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(40)
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),
/* 46 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(40)
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),
/* 47 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(32)
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),
/* 48 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(47)
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),
/* 49 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(47)
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),
/* 50 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(40)
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),
/* 51 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(40)
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),
/* 52 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(40)
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),
/* 53 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(40)
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),
/* 54 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(40)
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),
/* 55 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(39)
const neq = __webpack_require__(52)
const gt = __webpack_require__(50)
const gte = __webpack_require__(53)
const lt = __webpack_require__(51)
const lte = __webpack_require__(54)

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),
/* 56 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(32)
const parse = __webpack_require__(34)
const {re, t} = __webpack_require__(29)

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null)
    return null

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),
/* 57 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }
  constructor (comp, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const {re, t} = __webpack_require__(29)
const cmp = __webpack_require__(55)
const debug = __webpack_require__(31)
const SemVer = __webpack_require__(32)
const Range = __webpack_require__(58)


/***/ }),
/* 58 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    const loose = this.options.loose
    range = range.trim()
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[t.COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    return range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      .map(comp => replaceGTE0(comp, this.options))
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new Comparator(comp, this.options))
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const Comparator = __webpack_require__(57)
const debug = __webpack_require__(31)
const SemVer = __webpack_require__(32)
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = __webpack_require__(29)

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<')
        pr = '-0'

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),
/* 59 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(58)
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),
/* 60 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(58)

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),
/* 61 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(32)
const Range = __webpack_require__(58)

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),
/* 62 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(32)
const Range = __webpack_require__(58)
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),
/* 63 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(32)
const Range = __webpack_require__(58)
const gt = __webpack_require__(50)

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),
/* 64 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(58)
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),
/* 65 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(32)
const Comparator = __webpack_require__(57)
const {ANY} = Comparator
const Range = __webpack_require__(58)
const satisfies = __webpack_require__(59)
const gt = __webpack_require__(50)
const lt = __webpack_require__(51)
const lte = __webpack_require__(54)
const gte = __webpack_require__(53)

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),
/* 66 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(65)
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),
/* 67 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(65)
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),
/* 68 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(58)
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),
/* 69 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(59)
const compare = __webpack_require__(40)
module.exports = (versions, range, options) => {
  const set = []
  let min = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!min)
        min = version
    } else {
      if (prev) {
        set.push([min, prev])
      }
      prev = null
      min = null
    }
  }
  if (min)
    set.push([min, null])

  const ranges = []
  for (const [min, max] of set) {
    if (min === max)
      ranges.push(min)
    else if (!max && min === v[0])
      ranges.push('*')
    else if (!max)
      ranges.push(`>=${min}`)
    else if (min === v[0])
      ranges.push(`<=${max}`)
    else
      ranges.push(`${min} - ${max}`)
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),
/* 70 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(58)
const { ANY } = __webpack_require__(57)
const satisfies = __webpack_require__(59)
const compare = __webpack_require__(40)

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else return false
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
// - If LT
//   - If LT.semver is greater than that of any > comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
// - If any C is a = range, and GT or LT are set, return false
// - Else return true

const subset = (sub, dom, options) => {
  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub.length === 1 && sub[0].semver === ANY)
    return dom.length === 1 && dom[0].semver === ANY

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options)
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options)
    else
      eqSet.add(c.semver)
  }

  if (eqSet.size > 1)
    return null

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options))
      return null

    if (lt && !satisfies(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies(eq, String(c), options))
        return false
    }
    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c)
          return false
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c)
          return false
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeHash": () => /* binding */ makeHash,
/* harmony export */   "checksumFile": () => /* binding */ checksumFile,
/* harmony export */   "checksumPattern": () => /* binding */ checksumPattern
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var globby__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73);
/* harmony import */ var globby__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(globby__WEBPACK_IMPORTED_MODULE_1__);



function makeHash(...args) {
  const hash = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHash)(`sha512`);

  for (const arg of args) hash.update(arg ? arg : ``);

  return hash.digest(`hex`);
}
function checksumFile(path) {
  return new Promise((resolve, reject) => {
    const hash = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHash)(`sha512`);
    const stream = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.createReadStream(path);
    stream.on(`data`, chunk => {
      hash.update(chunk);
    });
    stream.on(`error`, error => {
      reject(error);
    });
    stream.on(`end`, () => {
      resolve(hash.digest(`hex`));
    });
  });
}
async function checksumPattern(pattern, {
  cwd
}) {
  // Note: We use a two-pass glob instead of using the expandDirectories option
  // from globby, because the native implementation is broken.
  //
  // Ref: https://github.com/sindresorhus/globby/issues/147
  const dirListing = await globby__WEBPACK_IMPORTED_MODULE_1___default()(pattern, {
    cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(cwd),
    expandDirectories: false,
    onlyDirectories: true,
    unique: true
  });
  const dirPatterns = dirListing.map(entry => {
    return `${entry}/**/*`;
  });
  const listing = await globby__WEBPACK_IMPORTED_MODULE_1___default()([pattern, ...dirPatterns], {
    cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(cwd),
    expandDirectories: false,
    onlyFiles: false,
    unique: true
  });
  listing.sort();
  const hashes = await Promise.all(listing.map(async entry => {
    const parts = [Buffer.from(entry)];
    const p = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.toPortablePath(entry);
    const stat = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.lstatPromise(p);
    if (stat.isSymbolicLink()) parts.push(Buffer.from(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.readlinkPromise(p)));else if (stat.isFile()) parts.push(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.readFilePromise(p));
    return parts.join(`\u0000`);
  }));
  const hash = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHash)(`sha512`);

  for (const sub of hashes) hash.update(sub);

  return hash.digest(`hex`);
}

/***/ }),
/* 72 */
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),
/* 73 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(8);
const arrayUnion = __webpack_require__(74);
const merge2 = __webpack_require__(75);
const fastGlob = __webpack_require__(77);
const dirGlob = __webpack_require__(149);
const gitignore = __webpack_require__(151);
const {FilterStream, UniqueStream} = __webpack_require__(154);

const DEFAULT_FILTER = () => false;

const isNegative = pattern => pattern[0] === '!';

const assertPatternsInput = patterns => {
	if (!patterns.every(pattern => typeof pattern === 'string')) {
		throw new TypeError('Patterns must be a string or an array of strings');
	}
};

const checkCwdOption = (options = {}) => {
	if (!options.cwd) {
		return;
	}

	let stat;
	try {
		stat = fs.statSync(options.cwd);
	} catch (_) {
		return;
	}

	if (!stat.isDirectory()) {
		throw new Error('The `cwd` option must be a path to a directory');
	}
};

const getPathString = p => p.stats instanceof fs.Stats ? p.path : p;

const generateGlobTasks = (patterns, taskOptions) => {
	patterns = arrayUnion([].concat(patterns));
	assertPatternsInput(patterns);
	checkCwdOption(taskOptions);

	const globTasks = [];

	taskOptions = {
		ignore: [],
		expandDirectories: true,
		...taskOptions
	};

	for (const [index, pattern] of patterns.entries()) {
		if (isNegative(pattern)) {
			continue;
		}

		const ignore = patterns
			.slice(index)
			.filter(isNegative)
			.map(pattern => pattern.slice(1));

		const options = {
			...taskOptions,
			ignore: taskOptions.ignore.concat(ignore)
		};

		globTasks.push({pattern, options});
	}

	return globTasks;
};

const globDirs = (task, fn) => {
	let options = {};
	if (task.options.cwd) {
		options.cwd = task.options.cwd;
	}

	if (Array.isArray(task.options.expandDirectories)) {
		options = {
			...options,
			files: task.options.expandDirectories
		};
	} else if (typeof task.options.expandDirectories === 'object') {
		options = {
			...options,
			...task.options.expandDirectories
		};
	}

	return fn(task.pattern, options);
};

const getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];

const getFilterSync = options => {
	return options && options.gitignore ?
		gitignore.sync({cwd: options.cwd, ignore: options.ignore}) :
		DEFAULT_FILTER;
};

const globToTask = task => glob => {
	const {options} = task;
	if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
		options.ignore = dirGlob.sync(options.ignore);
	}

	return {
		pattern: glob,
		options
	};
};

module.exports = async (patterns, options) => {
	const globTasks = generateGlobTasks(patterns, options);

	const getFilter = async () => {
		return options && options.gitignore ?
			gitignore({cwd: options.cwd, ignore: options.ignore}) :
			DEFAULT_FILTER;
	};

	const getTasks = async () => {
		const tasks = await Promise.all(globTasks.map(async task => {
			const globs = await getPattern(task, dirGlob);
			return Promise.all(globs.map(globToTask(task)));
		}));

		return arrayUnion(...tasks);
	};

	const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
	const paths = await Promise.all(tasks.map(task => fastGlob(task.pattern, task.options)));

	return arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));
};

module.exports.sync = (patterns, options) => {
	const globTasks = generateGlobTasks(patterns, options);

	const tasks = globTasks.reduce((tasks, task) => {
		const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
		return tasks.concat(newTask);
	}, []);

	const filter = getFilterSync(options);

	return tasks.reduce(
		(matches, task) => arrayUnion(matches, fastGlob.sync(task.pattern, task.options)),
		[]
	).filter(path_ => !filter(path_));
};

module.exports.stream = (patterns, options) => {
	const globTasks = generateGlobTasks(patterns, options);

	const tasks = globTasks.reduce((tasks, task) => {
		const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
		return tasks.concat(newTask);
	}, []);

	const filter = getFilterSync(options);
	const filterStream = new FilterStream(p => !filter(p));
	const uniqueStream = new UniqueStream();

	return merge2(tasks.map(task => fastGlob.stream(task.pattern, task.options)))
		.pipe(filterStream)
		.pipe(uniqueStream);
};

module.exports.generateGlobTasks = generateGlobTasks;

module.exports.hasMagic = (patterns, options) => []
	.concat(patterns)
	.some(pattern => fastGlob.isDynamicPattern(pattern, options));

module.exports.gitignore = gitignore;


/***/ }),
/* 74 */
/***/ ((module) => {

"use strict";


module.exports = (...arguments_) => {
	return [...new Set([].concat(...arguments_))];
};


/***/ }),
/* 75 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*
 * merge2
 * https://github.com/teambition/merge2
 *
 * Copyright (c) 2014-2016 Teambition
 * Licensed under the MIT license.
 */
const Stream = __webpack_require__(76)
const PassThrough = Stream.PassThrough
const slice = Array.prototype.slice

module.exports = merge2

function merge2 () {
  const streamsQueue = []
  let merging = false
  const args = slice.call(arguments)
  let options = args[args.length - 1]

  if (options && !Array.isArray(options) && options.pipe == null) args.pop()
  else options = {}

  const doEnd = options.end !== false
  if (options.objectMode == null) options.objectMode = true
  if (options.highWaterMark == null) options.highWaterMark = 64 * 1024
  const mergedStream = PassThrough(options)

  function addStream () {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push(pauseStreams(arguments[i], options))
    }
    mergeStream()
    return this
  }

  function mergeStream () {
    if (merging) return
    merging = true

    let streams = streamsQueue.shift()
    if (!streams) {
      process.nextTick(endStream)
      return
    }
    if (!Array.isArray(streams)) streams = [streams]

    let pipesCount = streams.length + 1

    function next () {
      if (--pipesCount > 0) return
      merging = false
      mergeStream()
    }

    function pipe (stream) {
      function onend () {
        stream.removeListener('merge2UnpipeEnd', onend)
        stream.removeListener('end', onend)
        next()
      }
      // skip ended stream
      if (stream._readableState.endEmitted) return next()

      stream.on('merge2UnpipeEnd', onend)
      stream.on('end', onend)
      stream.pipe(mergedStream, { end: false })
      // compatible for old stream
      stream.resume()
    }

    for (let i = 0; i < streams.length; i++) pipe(streams[i])

    next()
  }

  function endStream () {
    merging = false
    // emit 'queueDrain' when all streams merged.
    mergedStream.emit('queueDrain')
    return doEnd && mergedStream.end()
  }

  mergedStream.setMaxListeners(0)
  mergedStream.add = addStream
  mergedStream.on('unpipe', function (stream) {
    stream.emit('merge2UnpipeEnd')
  })

  if (args.length) addStream.apply(null, args)
  return mergedStream
}

// check and pause streams for pipe.
function pauseStreams (streams, options) {
  if (!Array.isArray(streams)) {
    // Backwards-compat with old-style streams
    if (!streams._readableState && streams.pipe) streams = streams.pipe(PassThrough(options))
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error('Only readable stream can be merged.')
    }
    streams.pause()
  } else {
    for (let i = 0, len = streams.length; i < len; i++) streams[i] = pauseStreams(streams[i], options)
  }
  return streams
}


/***/ }),
/* 76 */
/***/ ((module) => {

"use strict";
module.exports = require("stream");;

/***/ }),
/* 77 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const taskManager = __webpack_require__(78);
const async_1 = __webpack_require__(109);
const stream_1 = __webpack_require__(145);
const sync_1 = __webpack_require__(146);
const settings_1 = __webpack_require__(148);
const utils = __webpack_require__(79);
async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils.array.flatten(result);
}
// https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare
(function (FastGlob) {
    function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
    }
    FastGlob.sync = sync;
    function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        /**
         * The stream returned by the provider cannot work with an asynchronous iterator.
         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
         * This affects performance (+25%). I don't see best solution right now.
         */
        return utils.stream.merge(works);
    }
    FastGlob.stream = stream;
    function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
    }
    FastGlob.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
    }
    FastGlob.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
    }
    FastGlob.escapePath = escapePath;
})(FastGlob || (FastGlob = {}));
function getWorks(source, _Provider, options) {
    const patterns = [].concat(source);
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
}
function assertPatternsInput(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
    if (!isValidSource) {
        throw new TypeError('Patterns must be a string (non empty) or an array of strings');
    }
}
module.exports = FastGlob;


/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(79);
function generate(patterns, settings) {
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);
    return staticTasks.concat(dynamicTasks);
}
exports.generate = generate;
function convertPatternsToTasks(positive, negative, dynamic) {
    const positivePatternsGroup = groupPatternsByBaseDirectory(positive);
    // When we have a global group  there is no reason to divide the patterns into independent tasks.
    // In this case, the global task covers the rest.
    if ('.' in positivePatternsGroup) {
        const task = convertPatternGroupToTask('.', positive, negative, dynamic);
        return [task];
    }
    return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);
}
exports.convertPatternsToTasks = convertPatternsToTasks;
function getPositivePatterns(patterns) {
    return utils.pattern.getPositivePatterns(patterns);
}
exports.getPositivePatterns = getPositivePatterns;
function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils.pattern.convertToPositivePattern);
    return positive;
}
exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
            collection[base].push(pattern);
        }
        else {
            collection[base] = [pattern];
        }
        return collection;
    }, group);
}
exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
}
exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
    };
}
exports.convertPatternGroupToTask = convertPatternGroupToTask;


/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const array = __webpack_require__(80);
exports.array = array;
const errno = __webpack_require__(81);
exports.errno = errno;
const fs = __webpack_require__(82);
exports.fs = fs;
const path = __webpack_require__(83);
exports.path = path;
const pattern = __webpack_require__(85);
exports.pattern = pattern;
const stream = __webpack_require__(107);
exports.stream = stream;
const string = __webpack_require__(108);
exports.string = string;


/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function flatten(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
}
exports.flatten = flatten;
function splitWhen(items, predicate) {
    const result = [[]];
    let groupIndex = 0;
    for (const item of items) {
        if (predicate(item)) {
            groupIndex++;
            result[groupIndex] = [];
        }
        else {
            result[groupIndex].push(item);
        }
    }
    return result;
}
exports.splitWhen = splitWhen;


/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isEnoentCodeError(error) {
    return error.code === 'ENOENT';
}
exports.isEnoentCodeError = isEnoentCodeError;


/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;


/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(84);
const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\
const UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
/**
 * Designed to work only with simple paths: `dir\\file`.
 */
function unixify(filepath) {
    return filepath.replace(/\\/g, '/');
}
exports.unixify = unixify;
function makeAbsolute(cwd, filepath) {
    return path.resolve(cwd, filepath);
}
exports.makeAbsolute = makeAbsolute;
function escape(pattern) {
    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
}
exports.escape = escape;
function removeLeadingDotSegment(entry) {
    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
    if (entry.charAt(0) === '.') {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === '/' || secondCharactery === '\\') {
            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
    }
    return entry;
}
exports.removeLeadingDotSegment = removeLeadingDotSegment;


/***/ }),
/* 84 */
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(84);
const globParent = __webpack_require__(86);
const micromatch = __webpack_require__(89);
const picomatch = __webpack_require__(101);
const GLOBSTAR = '**';
const ESCAPE_SYMBOL = '\\';
const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
const BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
}
exports.isStaticPattern = isStaticPattern;
function isDynamicPattern(pattern, options = {}) {
    /**
     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
     * filepath directly (without read directory).
     */
    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    return false;
}
exports.isDynamicPattern = isDynamicPattern;
function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
}
exports.convertToPositivePattern = convertToPositivePattern;
function convertToNegativePattern(pattern) {
    return '!' + pattern;
}
exports.convertToNegativePattern = convertToNegativePattern;
function isNegativePattern(pattern) {
    return pattern.startsWith('!') && pattern[1] !== '(';
}
exports.isNegativePattern = isNegativePattern;
function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
}
exports.isPositivePattern = isPositivePattern;
function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
}
exports.getNegativePatterns = getNegativePatterns;
function getPositivePatterns(patterns) {
    return patterns.filter(isPositivePattern);
}
exports.getPositivePatterns = getPositivePatterns;
function getBaseDirectory(pattern) {
    return globParent(pattern, { flipBackslashes: false });
}
exports.getBaseDirectory = getBaseDirectory;
function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
}
exports.hasGlobStar = hasGlobStar;
function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith('/' + GLOBSTAR);
}
exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
function isAffectDepthOfReadingPattern(pattern) {
    const basename = path.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
}
exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
    }, []);
}
exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
function expandBraceExpansion(pattern) {
    return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
    });
}
exports.expandBraceExpansion = expandBraceExpansion;
function getPatternParts(pattern, options) {
    const info = picomatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
    // See micromatch/picomatch#58 for more details
    if (info.parts.length === 0) {
        return [pattern];
    }
    return info.parts;
}
exports.getPatternParts = getPatternParts;
function makeRe(pattern, options) {
    return micromatch.makeRe(pattern, options);
}
exports.makeRe = makeRe;
function convertPatternsToRe(patterns, options) {
    return patterns.map((pattern) => makeRe(pattern, options));
}
exports.convertPatternsToRe = convertPatternsToRe;
function matchAny(entry, patternsRe) {
    return patternsRe.some((patternRe) => patternRe.test(entry));
}
exports.matchAny = matchAny;


/***/ }),
/* 86 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isGlob = __webpack_require__(87);
var pathPosixDirname = __webpack_require__(84).posix.dirname;
var isWin32 = __webpack_require__(21).platform() === 'win32';

var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\/]*.*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\*\?\|\[\]\(\)\{\}])/g;

/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 */
module.exports = function globParent(str, opts) {
  var options = Object.assign({ flipBackslashes: true }, opts);

  // flip windows path separators
  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }

  // special case for strings ending in enclosure containing path separator
  if (enclosure.test(str)) {
    str += slash;
  }

  // preserves full path in case of trailing path separator
  str += 'a';

  // remove path parts that are globby
  do {
    str = pathPosixDirname(str);
  } while (isGlob(str) || globby.test(str));

  // remove escape chars and return result
  return str.replace(escaped, '$1');
};


/***/ }),
/* 87 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = __webpack_require__(88);
var chars = { '{': '}', '(': ')', '[': ']'};
var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

module.exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var regex = strictRegex;
  var match;

  // optionally relax regex
  if (options && options.strict === false) {
    regex = relaxedRegex;
  }

  while ((match = regex.exec(str))) {
    if (match[2]) return true;
    var idx = match.index + match[0].length;

    // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character
    var open = match[1];
    var close = open ? chars[open] : null;
    if (open && close) {
      var n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }

    str = str.slice(idx);
  }
  return false;
};


/***/ }),
/* 88 */
/***/ ((module) => {

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};


/***/ }),
/* 89 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(90);
const braces = __webpack_require__(91);
const picomatch = __webpack_require__(101);
const utils = __webpack_require__(104);
const isEmptyString = val => typeof val === 'string' && (val === '' || val === './');

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} list List of strings to match.
 * @param {String|Array<string>} patterns One or more glob patterns to use for matching.
 * @param {Object} options See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch = (list, patterns, options) => {
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => {
    items.add(state.output);
    if (options && options.onResult) {
      options.onResult(state);
    }
  };

  for (let i = 0; i < patterns.length; i++) {
    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) {
      let matched = isMatch(item, true);

      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) {
    if (options.failglob === true) {
      throw new Error(`No matches found for "${patterns.join(', ')}"`);
    }

    if (options.nonull === true || options.nullglob === true) {
      return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
    }
  }

  return matches;
};

/**
 * Backwards compatibility
 */

micromatch.match = micromatch;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = (pattern, options) => picomatch(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch.any = micromatch.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = (list, patterns, options = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => {
    if (options.onResult) options.onResult(state);
    items.push(state.output);
  };

  let matches = micromatch(list, patterns, { ...options, onResult });

  for (let item of items) {
    if (!matches.includes(item)) {
      result.add(item);
    }
  }
  return [...result];
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

micromatch.contains = (str, pattern, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  if (Array.isArray(pattern)) {
    return pattern.some(p => micromatch.contains(str, p, options));
  }

  if (typeof pattern === 'string') {
    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }

    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {
      return true;
    }
  }

  return micromatch.isMatch(str, pattern, { ...options, contains: true });
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = (obj, patterns, options) => {
  if (!utils.isObject(obj)) {
    throw new TypeError('Expected the first argument to be an object');
  }
  let keys = micromatch(Object.keys(obj), patterns, options);
  let res = {};
  for (let key of keys) res[key] = obj[key];
  return res;
};

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.some = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (items.some(item => isMatch(item))) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.every = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (!items.every(item => isMatch(item))) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = (str, patterns, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  return [].concat(patterns).every(p => picomatch(p, options)(str));
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = (glob, input, options) => {
  let posix = utils.isWindows(options);
  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);

  if (match) {
    return match.slice(1).map(v => v === void 0 ? '' : v);
  }
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = (...args) => picomatch.makeRe(...args);

/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

micromatch.scan = (...args) => picomatch.scan(...args);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch.parse = (patterns, options) => {
  let res = [];
  for (let pattern of [].concat(patterns || [])) {
    for (let str of braces(String(pattern), options)) {
      res.push(picomatch.parse(str, options));
    }
  }
  return res;
};

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
    return [pattern];
  }
  return braces(pattern, options);
};

/**
 * Expand braces
 */

micromatch.braceExpand = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return micromatch.braces(pattern, { ...options, expand: true });
};

/**
 * Expose micromatch
 */

module.exports = micromatch;


/***/ }),
/* 90 */
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ }),
/* 91 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stringify = __webpack_require__(92);
const compile = __webpack_require__(94);
const expand = __webpack_require__(98);
const parse = __webpack_require__(99);

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (let pattern of input) {
      let result = braces.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = (input, options = {}) => parse(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return stringify(braces.parse(input, options), options);
  }
  return stringify(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }
  return compile(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

 return options.expand !== true
    ? braces.compile(input, options)
    : braces.expand(input, options);
};

/**
 * Expose "braces"
 */

module.exports = braces;


/***/ }),
/* 92 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(93);

module.exports = (ast, options = {}) => {
  let stringify = (node, parent = {}) => {
    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
        return '\\' + node.value;
      }
      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += stringify(child);
      }
    }
    return output;
  };

  return stringify(ast);
};



/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.isInteger = num => {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }
  return false;
};

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
};

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => {
  let node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
    if (node.escaped !== true) {
      node.value = '\\' + node.value;
      node.escaped = true;
    }
  }
};

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => {
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
    node.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
    block.invalid = true;
    return true;
  }
  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }
  return node.open === true || node.close === true;
};

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => {
  const result = [];
  const flat = arr => {
    for (let i = 0; i < arr.length; i++) {
      let ele = arr[i];
      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
    }
    return result;
  };
  flat(args);
  return result;
};


/***/ }),
/* 94 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fill = __webpack_require__(95);
const utils = __webpack_require__(93);

const compile = (ast, options = {}) => {
  let walk = (node, parent = {}) => {
    let invalidBlock = utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }
    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? (prefix + node.value) : '(';
    }

    if (node.type === 'close') {
      return invalid ? (prefix + node.value) : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);
      let range = fill(...args, { ...options, wrap: false, toRegex: true });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += walk(child, node);
      }
    }
    return output;
  };

  return walk(ast);
};

module.exports = compile;


/***/ }),
/* 95 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */



const util = __webpack_require__(90);
const toRegexRange = __webpack_require__(96);

const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1
      ? toSequence(parts, options)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
    return invalidRange(start, end, options);
  }


  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill(start, end, 1, { transform: step });
  }

  if (isObject(step)) {
    return fill(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

module.exports = fill;


/***/ }),
/* 96 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */



const isNumber = __webpack_require__(97);

const toRegexRange = (min, max, options) => {
  if (isNumber(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives, opts);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
    state.result = `(?:${state.result})`;
  }

  toRegexRange.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit, options);

    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let { string } = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0{0,2}' : '00';
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}

/**
 * Cache
 */

toRegexRange.cache = {};
toRegexRange.clearCache = () => (toRegexRange.cache = {});

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;


/***/ }),
/* 97 */
/***/ ((module) => {

"use strict";
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};


/***/ }),
/* 98 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fill = __webpack_require__(95);
const stringify = __webpack_require__(92);
const utils = __webpack_require__(93);

const append = (queue = '', stash = '', enclose = false) => {
  let result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (let item of queue) {
    if (Array.isArray(item)) {
      for (let value of item) {
        result.push(append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
      }
    }
  }
  return utils.flatten(result);
};

const expand = (ast, options = {}) => {
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = {}) => {
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);

      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = fill(...args, options);
      if (range.length === 0) {
        range = stringify(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    let enclose = utils.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils.flatten(walk(ast));
};

module.exports = expand;


/***/ }),
/* 99 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stringify = __webpack_require__(92);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA, /* , */
  CHAR_DOT, /* . */
  CHAR_LEFT_PARENTHESES, /* ( */
  CHAR_RIGHT_PARENTHESES, /* ) */
  CHAR_LEFT_CURLY_BRACE, /* { */
  CHAR_RIGHT_CURLY_BRACE, /* } */
  CHAR_LEFT_SQUARE_BRACKET, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = __webpack_require__(100);

/**
 * parse
 */

const parse = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  let opts = options || {};
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  let ast = { type: 'root', input, nodes: [] };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;
  let memo = {};

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({ type: 'bos' });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) {
      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
      continue;
    }

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
      push({ type: 'text', value: '\\' + value });
      continue;
    }

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;

      let closed = true;
      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES) {
      block = push({ type: 'paren', nodes: [] });
      stack.push(block);
      push({ type: 'text', value });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({ type: 'text', value });
        continue;
      }
      block = stack.pop();
      push({ type: 'text', value });
      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      let open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Left curly brace: '{'
     */

    if (value === CHAR_LEFT_CURLY_BRACE) {
      depth++;

      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      let brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };

      block = push(brace);
      stack.push(block);
      push({ type: 'open', value });
      continue;
    }

    /**
     * Right curly brace: '}'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({ type: 'text', value });
        continue;
      }

      let type = 'close';
      block = stack.pop();
      block.close = true;

      push({ type, value });
      depth--;

      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open = block.nodes.shift();
        block.nodes = [open, { type: 'text', value: stringify(block) }];
      }

      push({ type: 'comma', value });
      block.commas++;
      continue;
    }

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
      let siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({ type: 'text', value });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();

        let before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({ type: 'dot', value });
      continue;
    }

    /**
     * Text
     */

    push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      });

      // get the location of the block on parent.nodes (block's siblings)
      let parent = stack[stack.length - 1];
      let index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

module.exports = parse;


/***/ }),
/* 100 */
/***/ ((module) => {

"use strict";


module.exports = {
  MAX_LENGTH: 1024 * 64,

  // Digits
  CHAR_0: '0', /* 0 */
  CHAR_9: '9', /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A', /* A */
  CHAR_LOWERCASE_A: 'a', /* a */
  CHAR_UPPERCASE_Z: 'Z', /* Z */
  CHAR_LOWERCASE_Z: 'z', /* z */

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_ASTERISK: '*', /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&', /* & */
  CHAR_AT: '@', /* @ */
  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_CARRIAGE_RETURN: '\r', /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
  CHAR_COLON: ':', /* : */
  CHAR_COMMA: ',', /* , */
  CHAR_DOLLAR: '$', /* . */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_EQUAL: '=', /* = */
  CHAR_EXCLAMATION_MARK: '!', /* ! */
  CHAR_FORM_FEED: '\f', /* \f */
  CHAR_FORWARD_SLASH: '/', /* / */
  CHAR_HASH: '#', /* # */
  CHAR_HYPHEN_MINUS: '-', /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_LINE_FEED: '\n', /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_PERCENT: '%', /* % */
  CHAR_PLUS: '+', /* + */
  CHAR_QUESTION_MARK: '?', /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SEMICOLON: ';', /* ; */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_SPACE: ' ', /*   */
  CHAR_TAB: '\t', /* \t */
  CHAR_UNDERSCORE: '_', /* _ */
  CHAR_VERTICAL_LINE: '|', /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};


/***/ }),
/* 101 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(102);


/***/ }),
/* 102 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(84);
const scan = __webpack_require__(103);
const parse = __webpack_require__(106);
const utils = __webpack_require__(104);
const constants = __webpack_require__(105);
const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => picomatch(input, options, returnState));
    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
    return arrayMatcher;
  }

  const isState = isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = utils.isWindows(options);
  const regex = isState
    ? picomatch.compileRe(glob, options)
    : picomatch.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
    const result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  return parse(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return parsed.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${parsed.output})${append}`;
  if (parsed && parsed.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = picomatch.toRegex(source, options);
  if (returnState === true) {
    regex.state = parsed;
  }

  return regex;
};

picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  const opts = options || {};
  let parsed = { negated: false, fastpaths: true };
  let prefix = '';
  let output;

  if (input.startsWith('./')) {
    input = input.slice(2);
    prefix = parsed.prefix = './';
  }

  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    output = parse.fastpaths(input, options);
  }

  if (output === undefined) {
    parsed = parse(input, options);
    parsed.prefix = prefix + (parsed.prefix || '');
  } else {
    parsed.output = output;
  }

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = constants;

/**
 * Expose "picomatch"
 */

module.exports = picomatch;


/***/ }),
/* 103 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(104);
const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
} = __webpack_require__(105);

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = { value: '', depth: 0, isGlob: false };

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value !== '') {
        parts.push(value);
      }
      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

module.exports = scan;


/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(84);
const win32 = process.platform === 'win32';
const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = __webpack_require__(105);

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

exports.supportsLookbehinds = () => {
  const segs = process.version.slice(1).split('.').map(Number);
  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
    return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }
  return output;
};


/***/ }),
/* 105 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(84);
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};


/***/ }),
/* 106 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const constants = __webpack_require__(105);
const utils = __webpack_require__(104);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = (opts) => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index];
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };
  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.prev.type === 'bos' && eos()) {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance() || '';
      } else {
        value += advance() || '';
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = (opts) => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

module.exports = parse;


/***/ }),
/* 107 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const merge2 = __webpack_require__(75);
function merge(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream) => {
        stream.once('error', (error) => mergedStream.emit('error', error));
    });
    mergedStream.once('close', () => propagateCloseEventToSources(streams));
    mergedStream.once('end', () => propagateCloseEventToSources(streams));
    return mergedStream;
}
exports.merge = merge;
function propagateCloseEventToSources(streams) {
    streams.forEach((stream) => stream.emit('close'));
}


/***/ }),
/* 108 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isString(input) {
    return typeof input === 'string';
}
exports.isString = isString;
function isEmpty(input) {
    return input === '';
}
exports.isEmpty = isEmpty;


/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __webpack_require__(110);
const provider_1 = __webpack_require__(138);
class ProviderAsync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
            const stream = this.api(root, task, options);
            stream.once('error', reject);
            stream.on('data', (entry) => entries.push(options.transform(entry)));
            stream.once('end', () => resolve(entries));
        });
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderAsync;


/***/ }),
/* 110 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __webpack_require__(76);
const fsStat = __webpack_require__(111);
const fsWalk = __webpack_require__(116);
const reader_1 = __webpack_require__(137);
class ReaderStream extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
    }
    dynamic(root, options) {
        return this._walkStream(root, options);
    }
    static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
            return this._getEntry(filepaths[index], patterns[index], options)
                .then((entry) => {
                if (entry !== null && options.entryFilter(entry)) {
                    stream.push(entry);
                }
                if (index === filepaths.length - 1) {
                    stream.end();
                }
                done();
            })
                .catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
            stream.write(i);
        }
        return stream;
    }
    _getEntry(filepath, pattern, options) {
        return this._getStat(filepath)
            .then((stats) => this._makeEntry(stats, pattern))
            .catch((error) => {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        });
    }
    _getStat(filepath) {
        return new Promise((resolve, reject) => {
            this._stat(filepath, this._fsStatSettings, (error, stats) => {
                return error === null ? resolve(stats) : reject(error);
            });
        });
    }
}
exports.default = ReaderStream;


/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async = __webpack_require__(112);
const sync = __webpack_require__(113);
const settings_1 = __webpack_require__(114);
exports.Settings = settings_1.default;
function stat(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        return async.read(path, getSettings(), optionsOrSettingsOrCallback);
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.stat = stat;
function statSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.statSync = statSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function read(path, settings, callback) {
    settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
            return callFailureCallback(callback, lstatError);
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
            return callSuccessCallback(callback, lstat);
        }
        settings.fs.stat(path, (statError, stat) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    return callFailureCallback(callback, statError);
                }
                return callSuccessCallback(callback, lstat);
            }
            if (settings.markSymbolicLink) {
                stat.isSymbolicLink = () => true;
            }
            callSuccessCallback(callback, stat);
        });
    });
}
exports.read = read;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}


/***/ }),
/* 113 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function read(path, settings) {
    const lstat = settings.fs.lstatSync(path);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
    }
    try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
        }
        return stat;
    }
    catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
            return lstat;
        }
        throw error;
    }
}
exports.read = read;


/***/ }),
/* 114 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(115);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
}
exports.default = Settings;


/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(8);
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;


/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async_1 = __webpack_require__(117);
const stream_1 = __webpack_require__(133);
const sync_1 = __webpack_require__(134);
const settings_1 = __webpack_require__(136);
exports.Settings = settings_1.default;
function walk(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        return new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
    }
    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
exports.walk = walk;
function walkSync(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1.default(directory, settings);
    return provider.read();
}
exports.walkSync = walkSync;
function walkStream(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1.default(directory, settings);
    return provider.read();
}
exports.walkStream = walkStream;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async_1 = __webpack_require__(118);
class AsyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = new Set();
    }
    read(callback) {
        this._reader.onError((error) => {
            callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
            this._storage.add(entry);
        });
        this._reader.onEnd(() => {
            callSuccessCallback(callback, [...this._storage]);
        });
        this._reader.read();
    }
}
exports.default = AsyncProvider;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, entries) {
    callback(null, entries);
}


/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(119);
const fsScandir = __webpack_require__(120);
const fastq = __webpack_require__(129);
const common = __webpack_require__(131);
const reader_1 = __webpack_require__(132);
class AsyncReader extends reader_1.default {
    constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
            if (!this._isFatalError) {
                this._emitter.emit('end');
            }
        };
    }
    read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
            this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
    }
    destroy() {
        if (this._isDestroyed) {
            throw new Error('The reader is already destroyed');
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
    }
    onEntry(callback) {
        this._emitter.on('entry', callback);
    }
    onError(callback) {
        this._emitter.once('error', callback);
    }
    onEnd(callback) {
        this._emitter.once('end', callback);
    }
    _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
            if (error !== null) {
                this._handleError(error);
            }
        });
    }
    _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
            if (error !== null) {
                return done(error, undefined);
            }
            for (const entry of entries) {
                this._handleEntry(entry, item.base);
            }
            done(null, undefined);
        });
    }
    _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
            return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit('error', error);
    }
    _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
            return;
        }
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, entry.path);
        }
    }
    _emitEntry(entry) {
        this._emitter.emit('entry', entry);
    }
}
exports.default = AsyncReader;


/***/ }),
/* 119 */
/***/ ((module) => {

"use strict";
module.exports = require("events");;

/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async = __webpack_require__(121);
const sync = __webpack_require__(126);
const settings_1 = __webpack_require__(127);
exports.Settings = settings_1.default;
function scandir(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        return async.read(path, getSettings(), optionsOrSettingsOrCallback);
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.scandir = scandir;
function scandirSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.scandirSync = scandirSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),
/* 121 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsStat = __webpack_require__(111);
const rpl = __webpack_require__(122);
const constants_1 = __webpack_require__(123);
const utils = __webpack_require__(124);
function read(directory, settings, callback) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings, callback);
    }
    return readdir(directory, settings, callback);
}
exports.read = read;
function readdirWithFileTypes(directory, settings, callback) {
    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
            return callFailureCallback(callback, readdirError);
        }
        const entries = dirents.map((dirent) => ({
            dirent,
            name: dirent.name,
            path: `${directory}${settings.pathSegmentSeparator}${dirent.name}`
        }));
        if (!settings.followSymbolicLinks) {
            return callSuccessCallback(callback, entries);
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
            if (rplError !== null) {
                return callFailureCallback(callback, rplError);
            }
            callSuccessCallback(callback, rplEntries);
        });
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function makeRplTaskEntry(entry, settings) {
    return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
            return done(null, entry);
        }
        settings.fs.stat(entry.path, (statError, stats) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    return done(statError);
                }
                return done(null, entry);
            }
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            return done(null, entry);
        });
    };
}
function readdir(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
            return callFailureCallback(callback, readdirError);
        }
        const filepaths = names.map((name) => `${directory}${settings.pathSegmentSeparator}${name}`);
        const tasks = filepaths.map((filepath) => {
            return (done) => fsStat.stat(filepath, settings.fsStatSettings, done);
        });
        rpl(tasks, (rplError, results) => {
            if (rplError !== null) {
                return callFailureCallback(callback, rplError);
            }
            const entries = [];
            names.forEach((name, index) => {
                const stats = results[index];
                const entry = {
                    name,
                    path: filepaths[index],
                    dirent: utils.fs.createDirentFromStats(name, stats)
                };
                if (settings.stats) {
                    entry.stats = stats;
                }
                entries.push(entry);
            });
            callSuccessCallback(callback, entries);
        });
    });
}
exports.readdir = readdir;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}


/***/ }),
/* 122 */
/***/ ((module) => {

module.exports = runParallel

function runParallel (tasks, cb) {
  var results, pending, keys
  var isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (--pending === 0 || err) {
      done(err)
    }
  }

  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result) })
    })
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result) })
    })
  }

  isSync = false
}


/***/ }),
/* 123 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');
const MAJOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
const MINOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
const SUPPORTED_MAJOR_VERSION = 10;
const SUPPORTED_MINOR_VERSION = 10;
const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
const IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
/**
 * IS `true` for Node.js 10.10 and greater.
 */
exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;


/***/ }),
/* 124 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(125);
exports.fs = fs;


/***/ }),
/* 125 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;


/***/ }),
/* 126 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsStat = __webpack_require__(111);
const constants_1 = __webpack_require__(123);
const utils = __webpack_require__(124);
function read(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
    }
    return readdir(directory, settings);
}
exports.read = read;
function readdirWithFileTypes(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
    return dirents.map((dirent) => {
        const entry = {
            dirent,
            name: dirent.name,
            path: `${directory}${settings.pathSegmentSeparator}${dirent.name}`
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
            try {
                const stats = settings.fs.statSync(entry.path);
                entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            }
            catch (error) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    throw error;
                }
            }
        }
        return entry;
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function readdir(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name) => {
        const entryPath = `${directory}${settings.pathSegmentSeparator}${name}`;
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
            name,
            path: entryPath,
            dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
            entry.stats = stats;
        }
        return entry;
    });
}
exports.readdir = readdir;


/***/ }),
/* 127 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(84);
const fsStat = __webpack_require__(111);
const fs = __webpack_require__(128);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this.followSymbolicLinks,
            fs: this.fs,
            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
}
exports.default = Settings;


/***/ }),
/* 128 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(8);
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;


/***/ }),
/* 129 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reusify = __webpack_require__(130)

function fastqueue (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker
    worker = context
    context = null
  }

  var cache = reusify(Task)
  var queueHead = null
  var queueTail = null
  var _running = 0

  var self = {
    push: push,
    drain: noop,
    saturated: noop,
    pause: pause,
    paused: false,
    concurrency: concurrency,
    running: running,
    resume: resume,
    idle: idle,
    length: length,
    unshift: unshift,
    empty: noop,
    kill: kill,
    killAndDrain: killAndDrain
  }

  return self

  function running () {
    return _running
  }

  function pause () {
    self.paused = true
  }

  function length () {
    var current = queueHead
    var counter = 0

    while (current) {
      current = current.next
      counter++
    }

    return counter
  }

  function resume () {
    if (!self.paused) return
    self.paused = false
    for (var i = 0; i < self.concurrency; i++) {
      _running++
      release()
    }
  }

  function idle () {
    return _running === 0 && self.length() === 0
  }

  function push (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop

    if (_running === self.concurrency || self.paused) {
      if (queueTail) {
        queueTail.next = current
        queueTail = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function unshift (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop

    if (_running === self.concurrency || self.paused) {
      if (queueHead) {
        current.next = queueHead
        queueHead = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function release (holder) {
    if (holder) {
      cache.release(holder)
    }
    var next = queueHead
    if (next) {
      if (!self.paused) {
        if (queueTail === queueHead) {
          queueTail = null
        }
        queueHead = next.next
        next.next = null
        worker.call(context, next.value, next.worked)
        if (queueTail === null) {
          self.empty()
        }
      } else {
        _running--
      }
    } else if (--_running === 0) {
      self.drain()
    }
  }

  function kill () {
    queueHead = null
    queueTail = null
    self.drain = noop
  }

  function killAndDrain () {
    queueHead = null
    queueTail = null
    self.drain()
    self.drain = noop
  }
}

function noop () {}

function Task () {
  this.value = null
  this.callback = noop
  this.next = null
  this.release = noop
  this.context = null

  var self = this

  this.worked = function worked (err, result) {
    var callback = self.callback
    self.value = null
    self.callback = noop
    callback.call(self.context, err, result)
    self.release(self)
  }
}

module.exports = fastqueue


/***/ }),
/* 130 */
/***/ ((module) => {

"use strict";


function reusify (Constructor) {
  var head = new Constructor()
  var tail = head

  function get () {
    var current = head

    if (current.next) {
      head = current.next
    } else {
      head = new Constructor()
      tail = head
    }

    current.next = null

    return current
  }

  function release (obj) {
    tail.next = obj
    tail = obj
  }

  return {
    get: get,
    release: release
  }
}

module.exports = reusify


/***/ }),
/* 131 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isFatalError(settings, error) {
    if (settings.errorFilter === null) {
        return true;
    }
    return !settings.errorFilter(error);
}
exports.isFatalError = isFatalError;
function isAppliedFilter(filter, value) {
    return filter === null || filter(value);
}
exports.isAppliedFilter = isAppliedFilter;
function replacePathSegmentSeparator(filepath, separator) {
    return filepath.split(/[\\/]/).join(separator);
}
exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
function joinPathSegments(a, b, separator) {
    if (a === '') {
        return b;
    }
    return a + separator + b;
}
exports.joinPathSegments = joinPathSegments;


/***/ }),
/* 132 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const common = __webpack_require__(131);
class Reader {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
}
exports.default = Reader;


/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __webpack_require__(76);
const async_1 = __webpack_require__(118);
class StreamProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
            objectMode: true,
            read: () => { },
            destroy: this._reader.destroy.bind(this._reader)
        });
    }
    read() {
        this._reader.onError((error) => {
            this._stream.emit('error', error);
        });
        this._reader.onEntry((entry) => {
            this._stream.push(entry);
        });
        this._reader.onEnd(() => {
            this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
    }
}
exports.default = StreamProvider;


/***/ }),
/* 134 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sync_1 = __webpack_require__(135);
class SyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
    }
    read() {
        return this._reader.read();
    }
}
exports.default = SyncProvider;


/***/ }),
/* 135 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsScandir = __webpack_require__(120);
const common = __webpack_require__(131);
const reader_1 = __webpack_require__(132);
class SyncReader extends reader_1.default {
    constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = new Set();
        this._queue = new Set();
    }
    read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return [...this._storage];
    }
    _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
    }
    _handleQueue() {
        for (const item of this._queue.values()) {
            this._handleDirectory(item.directory, item.base);
        }
    }
    _handleDirectory(directory, base) {
        try {
            const entries = this._scandir(directory, this._settings.fsScandirSettings);
            for (const entry of entries) {
                this._handleEntry(entry, base);
            }
        }
        catch (error) {
            this._handleError(error);
        }
    }
    _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
            return;
        }
        throw error;
    }
    _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, entry.path);
        }
    }
    _pushToStorage(entry) {
        this._storage.add(entry);
    }
}
exports.default = SyncReader;


/***/ }),
/* 136 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(84);
const fsScandir = __webpack_require__(120);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, undefined);
        this.concurrency = this._getValue(this._options.concurrency, Infinity);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
            followSymbolicLinks: this._options.followSymbolicLinks,
            fs: this._options.fs,
            pathSegmentSeparator: this._options.pathSegmentSeparator,
            stats: this._options.stats,
            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
}
exports.default = Settings;


/***/ }),
/* 137 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(84);
const fsStat = __webpack_require__(111);
const utils = __webpack_require__(79);
class Reader {
    constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
    }
    _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern) {
        const entry = {
            name: pattern,
            path: pattern,
            dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
            entry.stats = stats;
        }
        return entry;
    }
    _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }
}
exports.default = Reader;


/***/ }),
/* 138 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(84);
const deep_1 = __webpack_require__(139);
const entry_1 = __webpack_require__(142);
const error_1 = __webpack_require__(143);
const entry_2 = __webpack_require__(144);
class Provider {
    constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
        const basePath = task.base === '.' ? '' : task.base;
        return {
            basePath,
            pathSegmentSeparator: '/',
            concurrency: this._settings.concurrency,
            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
            errorFilter: this.errorFilter.getFilter(),
            followSymbolicLinks: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            stats: this._settings.stats,
            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
            transform: this.entryTransformer.getTransformer()
        };
    }
    _getMicromatchOptions() {
        return {
            dot: this._settings.dot,
            matchBase: this._settings.baseNameMatch,
            nobrace: !this._settings.braceExpansion,
            nocase: !this._settings.caseSensitiveMatch,
            noext: !this._settings.extglob,
            noglobstar: !this._settings.globstar,
            posix: true,
            strictSlashes: false
        };
    }
}
exports.default = Provider;


/***/ }),
/* 139 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(79);
const partial_1 = __webpack_require__(140);
class DeepFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
    }
    _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath, entry, matcher, negativeRe) {
        const depth = this._getEntryLevel(basePath, entry.path);
        if (this._isSkippedByDeep(depth)) {
            return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
            return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
            return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(entryDepth) {
        return entryDepth >= this._settings.deep;
    }
    _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _getEntryLevel(basePath, entryPath) {
        const basePathDepth = basePath.split('/').length;
        const entryPathDepth = entryPath.split('/').length;
        return entryPathDepth - (basePath === '' ? 0 : basePathDepth);
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, negativeRe) {
        return !utils.pattern.matchAny(entryPath, negativeRe);
    }
}
exports.default = DeepFilter;


/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const matcher_1 = __webpack_require__(141);
class PartialMatcher extends matcher_1.default {
    match(filepath) {
        const parts = filepath.split('/');
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
            const section = pattern.sections[0];
            /**
             * In this case, the pattern has a globstar and we must read all directories unconditionally,
             * but only if the level has reached the end of the first group.
             *
             * fixtures/{a,b}/**
             *  ^ true/false  ^ always true
            */
            if (!pattern.complete && levels > section.length) {
                return true;
            }
            const match = parts.every((part, index) => {
                const segment = pattern.segments[index];
                if (segment.dynamic && segment.patternRe.test(part)) {
                    return true;
                }
                if (!segment.dynamic && segment.pattern === part) {
                    return true;
                }
                return false;
            });
            if (match) {
                return true;
            }
        }
        return false;
    }
}
exports.default = PartialMatcher;


/***/ }),
/* 141 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(79);
class Matcher {
    constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
    }
    _fillStorage() {
        /**
         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).
         * So, before expand patterns with brace expansion into separated patterns.
         */
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
            const segments = this._getPatternSegments(pattern);
            const sections = this._splitSegmentsIntoSections(segments);
            this._storage.push({
                complete: sections.length <= 1,
                pattern,
                segments,
                sections
            });
        }
    }
    _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
            if (!dynamic) {
                return {
                    dynamic: false,
                    pattern: part
                };
            }
            return {
                dynamic: true,
                pattern: part,
                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
            };
        });
    }
    _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
    }
}
exports.default = Matcher;


/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(79);
class EntryFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
    }
    getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
    }
    _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique) {
            if (this._isDuplicateEntry(entry)) {
                return false;
            }
            this._createIndexRecord(entry);
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
            return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry, negativeRe)) {
            return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        return this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
    }
    _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
    }
    _createIndexRecord(entry) {
        this.index.set(entry.path, undefined);
    }
    _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(entry, negativeRe) {
        if (!this._settings.absolute) {
            return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entry.path);
        return this._isMatchToPatterns(fullpath, negativeRe);
    }
    _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        return utils.pattern.matchAny(filepath, patternsRe);
    }
}
exports.default = EntryFilter;


/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(79);
class ErrorFilter {
    constructor(_settings) {
        this._settings = _settings;
    }
    getFilter() {
        return (error) => this._isNonFatalError(error);
    }
    _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }
}
exports.default = ErrorFilter;


/***/ }),
/* 144 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(79);
class EntryTransformer {
    constructor(_settings) {
        this._settings = _settings;
    }
    getTransformer() {
        return (entry) => this._transform(entry);
    }
    _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
            filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
            filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
            filepath += '/';
        }
        if (!this._settings.objectMode) {
            return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
    }
}
exports.default = EntryTransformer;


/***/ }),
/* 145 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __webpack_require__(76);
const stream_2 = __webpack_require__(110);
const provider_1 = __webpack_require__(138);
class ProviderStream extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => { } });
        source
            .once('error', (error) => destination.emit('error', error))
            .on('data', (entry) => destination.emit('data', options.transform(entry)))
            .once('end', () => destination.emit('end'));
        destination
            .once('close', () => source.destroy());
        return destination;
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderStream;


/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sync_1 = __webpack_require__(147);
const provider_1 = __webpack_require__(138);
class ProviderSync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderSync;


/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsStat = __webpack_require__(111);
const fsWalk = __webpack_require__(116);
const reader_1 = __webpack_require__(137);
class ReaderSync extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
        return this._walkSync(root, options);
    }
    static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
            const filepath = this._getFullEntryPath(pattern);
            const entry = this._getEntry(filepath, pattern, options);
            if (entry === null || !options.entryFilter(entry)) {
                continue;
            }
            entries.push(entry);
        }
        return entries;
    }
    _getEntry(filepath, pattern, options) {
        try {
            const stats = this._getStat(filepath);
            return this._makeEntry(stats, pattern);
        }
        catch (error) {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        }
    }
    _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
    }
}
exports.default = ReaderSync;


/***/ }),
/* 148 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(8);
const os = __webpack_require__(21);
const CPU_COUNT = os.cpus().length;
exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    lstatSync: fs.lstatSync,
    stat: fs.stat,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
            this.onlyFiles = false;
        }
        if (this.stats) {
            this.objectMode = true;
        }
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
    _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
}
exports.default = Settings;


/***/ }),
/* 149 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(84);
const pathType = __webpack_require__(150);

const getExtensions = extensions => extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0];

const getPath = (filepath, cwd) => {
	const pth = filepath[0] === '!' ? filepath.slice(1) : filepath;
	return path.isAbsolute(pth) ? pth : path.join(cwd, pth);
};

const addExtensions = (file, extensions) => {
	if (path.extname(file)) {
		return `**/${file}`;
	}

	return `**/${file}.${getExtensions(extensions)}`;
};

const getGlob = (directory, options) => {
	if (options.files && !Array.isArray(options.files)) {
		throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
	}

	if (options.extensions && !Array.isArray(options.extensions)) {
		throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
	}

	if (options.files && options.extensions) {
		return options.files.map(x => path.posix.join(directory, addExtensions(x, options.extensions)));
	}

	if (options.files) {
		return options.files.map(x => path.posix.join(directory, `**/${x}`));
	}

	if (options.extensions) {
		return [path.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
	}

	return [path.posix.join(directory, '**')];
};

module.exports = async (input, options) => {
	options = {
		cwd: process.cwd(),
		...options
	};

	if (typeof options.cwd !== 'string') {
		throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
	}

	const globs = await Promise.all([].concat(input).map(async x => {
		const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
		return isDirectory ? getGlob(x, options) : x;
	}));

	return [].concat.apply([], globs); // eslint-disable-line prefer-spread
};

module.exports.sync = (input, options) => {
	options = {
		cwd: process.cwd(),
		...options
	};

	if (typeof options.cwd !== 'string') {
		throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
	}

	const globs = [].concat(input).map(x => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);

	return [].concat.apply([], globs); // eslint-disable-line prefer-spread
};


/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const {promisify} = __webpack_require__(90);
const fs = __webpack_require__(8);

async function isType(fsStatType, statsMethodName, filePath) {
	if (typeof filePath !== 'string') {
		throw new TypeError(`Expected a string, got ${typeof filePath}`);
	}

	try {
		const stats = await promisify(fs[fsStatType])(filePath);
		return stats[statsMethodName]();
	} catch (error) {
		if (error.code === 'ENOENT') {
			return false;
		}

		throw error;
	}
}

function isTypeSync(fsStatType, statsMethodName, filePath) {
	if (typeof filePath !== 'string') {
		throw new TypeError(`Expected a string, got ${typeof filePath}`);
	}

	try {
		return fs[fsStatType](filePath)[statsMethodName]();
	} catch (error) {
		if (error.code === 'ENOENT') {
			return false;
		}

		throw error;
	}
}

exports.isFile = isType.bind(null, 'stat', 'isFile');
exports.isDirectory = isType.bind(null, 'stat', 'isDirectory');
exports.isSymlink = isType.bind(null, 'lstat', 'isSymbolicLink');
exports.isFileSync = isTypeSync.bind(null, 'statSync', 'isFile');
exports.isDirectorySync = isTypeSync.bind(null, 'statSync', 'isDirectory');
exports.isSymlinkSync = isTypeSync.bind(null, 'lstatSync', 'isSymbolicLink');


/***/ }),
/* 151 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {promisify} = __webpack_require__(90);
const fs = __webpack_require__(8);
const path = __webpack_require__(84);
const fastGlob = __webpack_require__(77);
const gitIgnore = __webpack_require__(152);
const slash = __webpack_require__(153);

const DEFAULT_IGNORE = [
	'**/node_modules/**',
	'**/flow-typed/**',
	'**/coverage/**',
	'**/.git'
];

const readFileP = promisify(fs.readFile);

const mapGitIgnorePatternTo = base => ignore => {
	if (ignore.startsWith('!')) {
		return '!' + path.posix.join(base, ignore.slice(1));
	}

	return path.posix.join(base, ignore);
};

const parseGitIgnore = (content, options) => {
	const base = slash(path.relative(options.cwd, path.dirname(options.fileName)));

	return content
		.split(/\r?\n/)
		.filter(Boolean)
		.filter(line => !line.startsWith('#'))
		.map(mapGitIgnorePatternTo(base));
};

const reduceIgnore = files => {
	return files.reduce((ignores, file) => {
		ignores.add(parseGitIgnore(file.content, {
			cwd: file.cwd,
			fileName: file.filePath
		}));
		return ignores;
	}, gitIgnore());
};

const ensureAbsolutePathForCwd = (cwd, p) => {
	cwd = slash(cwd);
	if (path.isAbsolute(p)) {
		if (p.startsWith(cwd)) {
			return p;
		}

		throw new Error(`Path ${p} is not in cwd ${cwd}`);
	}

	return path.join(cwd, p);
};

const getIsIgnoredPredecate = (ignores, cwd) => {
	return p => ignores.ignores(slash(path.relative(cwd, ensureAbsolutePathForCwd(cwd, p))));
};

const getFile = async (file, cwd) => {
	const filePath = path.join(cwd, file);
	const content = await readFileP(filePath, 'utf8');

	return {
		cwd,
		filePath,
		content
	};
};

const getFileSync = (file, cwd) => {
	const filePath = path.join(cwd, file);
	const content = fs.readFileSync(filePath, 'utf8');

	return {
		cwd,
		filePath,
		content
	};
};

const normalizeOptions = ({
	ignore = [],
	cwd = slash(process.cwd())
} = {}) => {
	return {ignore, cwd};
};

module.exports = async options => {
	options = normalizeOptions(options);

	const paths = await fastGlob('**/.gitignore', {
		ignore: DEFAULT_IGNORE.concat(options.ignore),
		cwd: options.cwd
	});

	const files = await Promise.all(paths.map(file => getFile(file, options.cwd)));
	const ignores = reduceIgnore(files);

	return getIsIgnoredPredecate(ignores, options.cwd);
};

module.exports.sync = options => {
	options = normalizeOptions(options);

	const paths = fastGlob.sync('**/.gitignore', {
		ignore: DEFAULT_IGNORE.concat(options.ignore),
		cwd: options.cwd
	});

	const files = paths.map(file => getFileSync(file, options.cwd));
	const ignores = reduceIgnore(files);

	return getIsIgnoredPredecate(ignores, options.cwd);
};


/***/ }),
/* 152 */
/***/ ((module) => {

// A simple implementation of make-array
function makeArray (subject) {
  return Array.isArray(subject)
    ? subject
    : [subject]
}

const REGEX_TEST_BLANK_LINE = /^\s+$/
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/
const REGEX_SPLITALL_CRLF = /\r?\n/g
// /foo,
// ./foo,
// ../foo,
// .
// ..
const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/

const SLASH = '/'
const KEY_IGNORE = typeof Symbol !== 'undefined'
  ? Symbol.for('node-ignore')
  /* istanbul ignore next */
  : 'node-ignore'

const define = (object, key, value) =>
  Object.defineProperty(object, key, {value})

const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = range => range.replace(
  REGEX_REGEXP_RANGE,
  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)
    ? match
    // Invalid range (out of order) which is ok for gitignore rules but
    //   fatal for JavaScript regular expression, so eliminate it.
    : ''
)

// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// '`foo/`' should not continue with the '`..`'
const REPLACERS = [

  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a \ ) -> (a  )
    /\\?\s+$/,
    match => match.indexOf('\\') === 0
      ? ' '
      : ''
  ],

  // replace (\ ) with ' '
  [
    /\\\s/g,
    () => ' '
  ],

  // Escape metacharacters
  // which is written down by users but means special for regular expressions.

  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\^$.|*+(){]/g,
    match => `\\${match}`
  ],

  [
    // > [abc] matches any character inside the brackets
    // >    (in this case a, b, or c);
    /\[([^\]/]*)($|\])/g,
    (match, p1, p2) => p2 === ']'
      ? `[${sanitizeRange(p1)}]`
      : `\\${match}`
  ],

  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => '[^/]'
  ],

  // leading slash
  [

    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => '^'
  ],

  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => '\\/'
  ],

  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,

    // '**/foo' <-> 'foo'
    () => '^(?:.*\\/)?'
  ],

  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*])$/,

    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38

    // > If there is a separator at the end of the pattern then the pattern
    // > will only match directories, otherwise the pattern can match both
    // > files and directories.

    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    match => /\/$/.test(match)
      // foo/ will not match 'foo'
      ? `${match}$`
      // foo matches 'foo' and 'foo/'
      : `${match}(?=$|\\/$)`
  ],

  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function startingReplacer () {
      // If has a slash `/` at the beginning or middle
      return !/\/(?!$)/.test(this)
        // > Prior to 2.22.1
        // > If the pattern does not contain a slash /,
        // >   Git treats it as a shell glob pattern
        // Actually, if there is only a trailing slash,
        //   git also treats it as a shell glob pattern

        // After 2.22.1 (compatible but clearer)
        // > If there is a separator at the beginning or middle (or both)
        // > of the pattern, then the pattern is relative to the directory
        // > level of the particular .gitignore file itself.
        // > Otherwise the pattern may also match at any level below
        // > the .gitignore level.
        ? '(?:^|\\/)'

        // > Otherwise, Git treats the pattern as a shell glob suitable for
        // >   consumption by fnmatch(3)
        : '^'
    }
  ],

  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,

    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer

    // Check if it is not the last `'/**'`
    (_, index, str) => index + 6 < str.length

      // case: /**/
      // > A slash followed by two consecutive asterisks then a slash matches
      // >   zero or more directories.
      // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
      // '/**/'
      ? '(?:\\/[^\\/]+)*'

      // case: /**
      // > A trailing `"/**"` matches everything inside.

      // #21: everything inside but it should not include the current folder
      : '\\/.+'
  ],

  // intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'

    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule
    /(^|[^\\]+)\\\*(?=.+)/g,

    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (_, p1) => `${p1}[^\\/]*`
  ],

  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (_, p1) => {
      const prefix = p1
        // '\^':
        // '/*' does not match ''
        // '/*' does not match everything

        // '\\\/':
        // 'abc/*' does not match 'abc/'
        ? `${p1}[^/]+`

        // 'a*' matches 'a'
        // 'a*' matches 'aa'
        : '[^/]*'

      return `${prefix}(?=$|\\/$)`
    }
  ],

  [
    // unescape
    /\\\\\\/g,
    () => '\\'
  ]
]

// A simple cache, because an ignore rule only has only one certain meaning
const regexCache = Object.create(null)

// @param {pattern}
const makeRegex = (pattern, negative, ignorecase) => {
  const r = regexCache[pattern]
  if (r) {
    return r
  }

  // const replacers = negative
  //   ? NEGATIVE_REPLACERS
  //   : POSITIVE_REPLACERS

  const source = REPLACERS.reduce(
    (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
    pattern
  )

  return regexCache[pattern] = ignorecase
    ? new RegExp(source, 'i')
    : new RegExp(source)
}

const isString = subject => typeof subject === 'string'

// > A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = pattern => pattern
  && isString(pattern)
  && !REGEX_TEST_BLANK_LINE.test(pattern)

  // > A line starting with # serves as a comment.
  && pattern.indexOf('#') !== 0

const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)

class IgnoreRule {
  constructor (
    origin,
    pattern,
    negative,
    regex
  ) {
    this.origin = origin
    this.pattern = pattern
    this.negative = negative
    this.regex = regex
  }
}

const createRule = (pattern, ignorecase) => {
  const origin = pattern
  let negative = false

  // > An optional prefix "!" which negates the pattern;
  if (pattern.indexOf('!') === 0) {
    negative = true
    pattern = pattern.substr(1)
  }

  pattern = pattern
  // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
  // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')

  const regex = makeRegex(pattern, negative, ignorecase)

  return new IgnoreRule(
    origin,
    pattern,
    negative,
    regex
  )
}

const throwError = (message, Ctor) => {
  throw new Ctor(message)
}

const checkPath = (path, originalPath, doThrow) => {
  if (!isString(path)) {
    return doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    )
  }

  // We don't know if we should ignore '', so throw
  if (!path) {
    return doThrow(`path must not be empty`, TypeError)
  }

  // Check if it is a relative path
  if (checkPath.isNotRelative(path)) {
    const r = '`path.relative()`d'
    return doThrow(
      `path should be a ${r} string, but got "${originalPath}"`,
      RangeError
    )
  }

  return true
}

const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)

checkPath.isNotRelative = isNotRelative
checkPath.convert = p => p

class Ignore {
  constructor ({
    ignorecase = true
  } = {}) {
    this._rules = []
    this._ignorecase = ignorecase
    define(this, KEY_IGNORE, true)
    this._initCache()
  }

  _initCache () {
    this._ignoreCache = Object.create(null)
    this._testCache = Object.create(null)
  }

  _addPattern (pattern) {
    // #32
    if (pattern && pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules)
      this._added = true
      return
    }

    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignorecase)
      this._added = true
      this._rules.push(rule)
    }
  }

  // @param {Array<string> | string | Ignore} pattern
  add (pattern) {
    this._added = false

    makeArray(
      isString(pattern)
        ? splitPattern(pattern)
        : pattern
    ).forEach(this._addPattern, this)

    // Some rules have just added to the ignore,
    // making the behavior changed.
    if (this._added) {
      this._initCache()
    }

    return this
  }

  // legacy
  addPattern (pattern) {
    return this.add(pattern)
  }

  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X

  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen

  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.

  // @returns {TestResult} true if a file is ignored
  _testOne (path, checkUnignored) {
    let ignored = false
    let unignored = false

    this._rules.forEach(rule => {
      const {negative} = rule
      if (
        unignored === negative && ignored !== unignored
        || negative && !ignored && !unignored && !checkUnignored
      ) {
        return
      }

      const matched = rule.regex.test(path)

      if (matched) {
        ignored = !negative
        unignored = negative
      }
    })

    return {
      ignored,
      unignored
    }
  }

  // @returns {TestResult}
  _test (originalPath, cache, checkUnignored, slices) {
    const path = originalPath
      // Supports nullable path
      && checkPath.convert(originalPath)

    checkPath(path, originalPath, throwError)

    return this._t(path, cache, checkUnignored, slices)
  }

  _t (path, cache, checkUnignored, slices) {
    if (path in cache) {
      return cache[path]
    }

    if (!slices) {
      // path/to/a.js
      // ['path', 'to', 'a.js']
      slices = path.split(SLASH)
    }

    slices.pop()

    // If the path has no parent directory, just test it
    if (!slices.length) {
      return cache[path] = this._testOne(path, checkUnignored)
    }

    const parent = this._t(
      slices.join(SLASH) + SLASH,
      cache,
      checkUnignored,
      slices
    )

    // If the path contains a parent directory, check the parent first
    return cache[path] = parent.ignored
      // > It is not possible to re-include a file if a parent directory of
      // >   that file is excluded.
      ? parent
      : this._testOne(path, checkUnignored)
  }

  ignores (path) {
    return this._test(path, this._ignoreCache, false).ignored
  }

  createFilter () {
    return path => !this.ignores(path)
  }

  filter (paths) {
    return makeArray(paths).filter(this.createFilter())
  }

  // @returns {TestResult}
  test (path) {
    return this._test(path, this._testCache, true)
  }
}

const factory = options => new Ignore(options)

const returnFalse = () => false

const isPathValid = path =>
  checkPath(path && checkPath.convert(path), path, returnFalse)

factory.isPathValid = isPathValid

// Fixes typescript
factory.default = factory

module.exports = factory

// Windows
// --------------------------------------------------------------
/* istanbul ignore if  */
if (
  // Detect `process` so that it can run in browsers.
  typeof process !== 'undefined'
  && (
    process.env && process.env.IGNORE_TEST_WIN32
    || process.platform === 'win32'
  )
) {
  /* eslint no-control-regex: "off" */
  const makePosix = str => /^\\\\\?\\/.test(str)
  || /["<>|\u0000-\u001F]+/u.test(str)
    ? str
    : str.replace(/\\/g, '/')

  checkPath.convert = makePosix

  // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
  // 'd:\\foo'
  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i
  checkPath.isNotRelative = path =>
    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)
    || isNotRelative(path)
}


/***/ }),
/* 153 */
/***/ ((module) => {

"use strict";

module.exports = path => {
	const isExtendedLengthPath = /^\\\\\?\\/.test(path);
	const hasNonAscii = /[^\u0000-\u0080]+/.test(path); // eslint-disable-line no-control-regex

	if (isExtendedLengthPath || hasNonAscii) {
		return path;
	}

	return path.replace(/\\/g, '/');
};


/***/ }),
/* 154 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {Transform} = __webpack_require__(76);

class ObjectTransform extends Transform {
	constructor() {
		super({
			objectMode: true
		});
	}
}

class FilterStream extends ObjectTransform {
	constructor(filter) {
		super();
		this._filter = filter;
	}

	_transform(data, encoding, callback) {
		if (this._filter(data)) {
			this.push(data);
		}

		callback();
	}
}

class UniqueStream extends ObjectTransform {
	constructor() {
		super();
		this._pushed = new Set();
	}

	_transform(data, encoding, callback) {
		if (!this._pushed.has(data)) {
			this.push(data);
			this._pushed.add(data);
		}

		callback();
	}
}

module.exports = {
	FilterStream,
	UniqueStream
};


/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "opendir": () => /* reexport safe */ _algorithms_opendir__WEBPACK_IMPORTED_MODULE_2__.opendir,
/* harmony export */   "statUtils": () => /* reexport module object */ _statUtils__WEBPACK_IMPORTED_MODULE_3__,
/* harmony export */   "normalizeLineEndings": () => /* reexport safe */ _FakeFS__WEBPACK_IMPORTED_MODULE_4__.normalizeLineEndings,
/* harmony export */   "DEFAULT_COMPRESSION_LEVEL": () => /* reexport safe */ _ZipFS__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_COMPRESSION_LEVEL,
/* harmony export */   "PortablePath": () => /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_6__.PortablePath,
/* harmony export */   "Filename": () => /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_6__.Filename,
/* harmony export */   "npath": () => /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_6__.npath,
/* harmony export */   "ppath": () => /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_6__.ppath,
/* harmony export */   "toFilename": () => /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_6__.toFilename,
/* harmony export */   "AliasFS": () => /* reexport safe */ _AliasFS__WEBPACK_IMPORTED_MODULE_7__.AliasFS,
/* harmony export */   "FakeFS": () => /* reexport safe */ _FakeFS__WEBPACK_IMPORTED_MODULE_4__.FakeFS,
/* harmony export */   "CwdFS": () => /* reexport safe */ _CwdFS__WEBPACK_IMPORTED_MODULE_8__.CwdFS,
/* harmony export */   "JailFS": () => /* reexport safe */ _JailFS__WEBPACK_IMPORTED_MODULE_9__.JailFS,
/* harmony export */   "LazyFS": () => /* reexport safe */ _LazyFS__WEBPACK_IMPORTED_MODULE_10__.LazyFS,
/* harmony export */   "NoFS": () => /* reexport safe */ _NoFS__WEBPACK_IMPORTED_MODULE_11__.NoFS,
/* harmony export */   "NodeFS": () => /* reexport safe */ _NodeFS__WEBPACK_IMPORTED_MODULE_12__.NodeFS,
/* harmony export */   "PosixFS": () => /* reexport safe */ _PosixFS__WEBPACK_IMPORTED_MODULE_13__.PosixFS,
/* harmony export */   "ProxiedFS": () => /* reexport safe */ _ProxiedFS__WEBPACK_IMPORTED_MODULE_14__.ProxiedFS,
/* harmony export */   "VirtualFS": () => /* reexport safe */ _VirtualFS__WEBPACK_IMPORTED_MODULE_15__.VirtualFS,
/* harmony export */   "ZipFS": () => /* reexport safe */ _ZipFS__WEBPACK_IMPORTED_MODULE_5__.ZipFS,
/* harmony export */   "ZipOpenFS": () => /* reexport safe */ _ZipOpenFS__WEBPACK_IMPORTED_MODULE_16__.ZipOpenFS,
/* harmony export */   "patchFs": () => /* binding */ patchFs,
/* harmony export */   "extendFs": () => /* binding */ extendFs,
/* harmony export */   "xfs": () => /* binding */ xfs
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(90);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _NodeFS__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(165);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(162);
/* harmony import */ var _statUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(158);
/* harmony import */ var _algorithms_opendir__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(156);
/* harmony import */ var _FakeFS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(160);
/* harmony import */ var _ZipFS__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(163);
/* harmony import */ var _AliasFS__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(168);
/* harmony import */ var _CwdFS__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(170);
/* harmony import */ var _JailFS__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(171);
/* harmony import */ var _LazyFS__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(172);
/* harmony import */ var _NoFS__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(173);
/* harmony import */ var _PosixFS__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(174);
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(169);
/* harmony import */ var _VirtualFS__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(175);
/* harmony import */ var _ZipOpenFS__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(176);
























function getTempName(prefix) {
  const tmpdir = _path__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(os__WEBPACK_IMPORTED_MODULE_0___default().tmpdir());
  const hash = Math.ceil(Math.random() * 0x100000000).toString(16).padStart(8, `0`);
  return _path__WEBPACK_IMPORTED_MODULE_6__.ppath.join(tmpdir, `${prefix}${hash}`);
}

function patchFs(patchedFs, fakeFs) {
  const SYNC_IMPLEMENTATIONS = new Set([`accessSync`, `appendFileSync`, `createReadStream`, `chmodSync`, `chownSync`, `closeSync`, `copyFileSync`, `linkSync`, `lstatSync`, `lutimesSync`, `mkdirSync`, `openSync`, `opendirSync`, `readSync`, `readlinkSync`, `readFileSync`, `readdirSync`, `readlinkSync`, `realpathSync`, `renameSync`, `rmdirSync`, `statSync`, `symlinkSync`, `truncateSync`, `unlinkSync`, `unwatchFile`, `utimesSync`, `watch`, `watchFile`, `writeFileSync`, `writeSync`]);
  const ASYNC_IMPLEMENTATIONS = new Set([`accessPromise`, `appendFilePromise`, `chmodPromise`, `chownPromise`, `closePromise`, `copyFilePromise`, `linkPromise`, `lstatPromise`, `lutimesPromise`, `mkdirPromise`, `openPromise`, `opendirPromise`, `readdirPromise`, `realpathPromise`, `readFilePromise`, `readdirPromise`, `readlinkPromise`, `renamePromise`, `rmdirPromise`, `statPromise`, `symlinkPromise`, `truncatePromise`, `unlinkPromise`, `utimesPromise`, `writeFilePromise`, `writeSync`]);
  const FILEHANDLE_IMPLEMENTATIONS = new Set([`appendFilePromise`, `chmodPromise`, `chownPromise`, `closePromise`, `readPromise`, `readFilePromise`, `statPromise`, `truncatePromise`, `utimesPromise`, `writePromise`, `writeFilePromise`]);

  const setupFn = (target, name, replacement) => {
    const orig = target[name];
    target[name] = replacement; // Preserve any util.promisify implementations

    if (typeof (orig === null || orig === void 0 ? void 0 : orig[util__WEBPACK_IMPORTED_MODULE_1__.promisify.custom]) !== `undefined`) {
      replacement[util__WEBPACK_IMPORTED_MODULE_1__.promisify.custom] = orig[util__WEBPACK_IMPORTED_MODULE_1__.promisify.custom];
    }
  };
  /** Callback implementations */


  {
    setupFn(patchedFs, `exists`, (p, ...args) => {
      const hasCallback = typeof args[args.length - 1] === `function`;
      const callback = hasCallback ? args.pop() : () => {};
      process.nextTick(() => {
        fakeFs.existsPromise(p).then(exists => {
          callback(exists);
        }, () => {
          callback(false);
        });
      });
    });
    setupFn(patchedFs, `read`, (p, buffer, ...args) => {
      const hasCallback = typeof args[args.length - 1] === `function`;
      const callback = hasCallback ? args.pop() : () => {};
      process.nextTick(() => {
        fakeFs.readPromise(p, buffer, ...args).then(bytesRead => {
          callback(null, bytesRead, buffer);
        }, error => {
          callback(error);
        });
      });
    });

    for (const fnName of ASYNC_IMPLEMENTATIONS) {
      const origName = fnName.replace(/Promise$/, ``);
      if (typeof patchedFs[origName] === `undefined`) continue;
      const fakeImpl = fakeFs[fnName];
      if (typeof fakeImpl === `undefined`) continue;

      const wrapper = (...args) => {
        const hasCallback = typeof args[args.length - 1] === `function`;
        const callback = hasCallback ? args.pop() : () => {};
        process.nextTick(() => {
          fakeImpl.apply(fakeFs, args).then(result => {
            callback(null, result);
          }, error => {
            callback(error);
          });
        });
      };

      setupFn(patchedFs, origName, wrapper);
    }

    patchedFs.realpath.native = patchedFs.realpath;
  }
  /** Sync implementations */

  {
    setupFn(patchedFs, `existsSync`, p => {
      try {
        return fakeFs.existsSync(p);
      } catch (error) {
        return false;
      }
    });

    for (const fnName of SYNC_IMPLEMENTATIONS) {
      const origName = fnName;
      if (typeof patchedFs[origName] === `undefined`) continue;
      const fakeImpl = fakeFs[fnName];
      if (typeof fakeImpl === `undefined`) continue;
      setupFn(patchedFs, origName, fakeImpl.bind(fakeFs));
    }

    patchedFs.realpathSync.native = patchedFs.realpathSync;
  }
  /** Promise implementations */

  {
    // `fs.promises` is a getter that returns a reference to require(`fs/promises`),
    // so we can just patch `fs.promises` and both will be updated
    const origEmitWarning = process.emitWarning;

    process.emitWarning = () => {};

    let patchedFsPromises;

    try {
      patchedFsPromises = patchedFs.promises;
    } finally {
      process.emitWarning = origEmitWarning;
    }

    if (typeof patchedFsPromises !== `undefined`) {
      // `fs.promises.exists` doesn't exist
      for (const fnName of ASYNC_IMPLEMENTATIONS) {
        const origName = fnName.replace(/Promise$/, ``);
        if (typeof patchedFsPromises[origName] === `undefined`) continue;
        const fakeImpl = fakeFs[fnName];
        if (typeof fakeImpl === `undefined`) continue; // Open is a bit particular with fs.promises: it returns a file handle
        // instance instead of the traditional file descriptor number

        if (fnName === `open`) continue;
        setupFn(patchedFsPromises, origName, fakeImpl.bind(fakeFs));
      }

      class FileHandle {
        constructor(fd) {
          this.fd = fd;
        }

      }

      for (const fnName of FILEHANDLE_IMPLEMENTATIONS) {
        const origName = fnName.replace(/Promise$/, ``);
        const fakeImpl = fakeFs[fnName];
        if (typeof fakeImpl === `undefined`) continue;
        setupFn(FileHandle.prototype, origName, function (...args) {
          return fakeImpl.call(fakeFs, this.fd, ...args);
        });
      }

      setupFn(patchedFsPromises, `open`, async (...args) => {
        // @ts-expect-error
        const fd = await fakeFs.openPromise(...args);
        return new FileHandle(fd);
      }); // `fs.promises.realpath` doesn't have a `native` property
    }
  }
  /** util.promisify implementations */

  {
    // Override the promisified version of `fs.read` to return an object as per
    // https://github.com/nodejs/node/blob/dc79f3f37caf6f25b8efee4623bec31e2c20f595/lib/fs.js#L559-L560
    // and
    // https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L293
    // @ts-expect-error
    patchedFs.read[util__WEBPACK_IMPORTED_MODULE_1__.promisify.custom] = async (p, buffer, ...args) => {
      const res = fakeFs.readPromise(p, buffer, ...args);
      return {
        bytesRead: await res,
        buffer
      };
    };
  }
}
function extendFs(realFs, fakeFs) {
  const patchedFs = Object.create(realFs);
  patchFs(patchedFs, fakeFs);
  return patchedFs;
}
const tmpdirs = new Set();
let cleanExitRegistered = false;

function registerCleanExit() {
  if (cleanExitRegistered) return;
  cleanExitRegistered = true;
  process.once(`exit`, () => {
    xfs.rmtempSync();
  });
}

const xfs = Object.assign(new _NodeFS__WEBPACK_IMPORTED_MODULE_12__.NodeFS(), {
  detachTemp(p) {
    tmpdirs.delete(p);
  },

  mktempSync(cb) {
    registerCleanExit();

    while (true) {
      const p = getTempName(`xfs-`);

      try {
        this.mkdirSync(p);
      } catch (error) {
        if (error.code === `EEXIST`) {
          continue;
        } else {
          throw error;
        }
      }

      const realP = this.realpathSync(p);
      tmpdirs.add(realP);

      if (typeof cb !== `undefined`) {
        try {
          return cb(realP);
        } finally {
          if (tmpdirs.has(realP)) {
            tmpdirs.delete(realP);

            try {
              this.removeSync(realP);
            } catch (_a) {// Too bad if there's an error
            }
          }
        }
      } else {
        return p;
      }
    }
  },

  async mktempPromise(cb) {
    registerCleanExit();

    while (true) {
      const p = getTempName(`xfs-`);

      try {
        await this.mkdirPromise(p);
      } catch (error) {
        if (error.code === `EEXIST`) {
          continue;
        } else {
          throw error;
        }
      }

      const realP = await this.realpathPromise(p);
      tmpdirs.add(realP);

      if (typeof cb !== `undefined`) {
        try {
          return await cb(realP);
        } finally {
          if (tmpdirs.has(realP)) {
            tmpdirs.delete(realP);

            try {
              await this.removePromise(realP);
            } catch (_a) {// Too bad if there's an error
            }
          }
        }
      } else {
        return realP;
      }
    }
  },

  async rmtempPromise() {
    await Promise.all(Array.from(tmpdirs.values()).map(async p => {
      try {
        await xfs.removePromise(p, {
          maxRetries: 0
        });
        tmpdirs.delete(p);
      } catch (_a) {// Too bad if there's an error
      }
    }));
  },

  rmtempSync() {
    for (const p of tmpdirs) {
      try {
        xfs.removeSync(p);
        tmpdirs.delete(p);
      } catch (_a) {// Too bad if there's an error
      }
    }
  }

});

/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomDir": () => /* binding */ CustomDir,
/* harmony export */   "opendir": () => /* binding */ opendir
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(157);

class CustomDir {
  constructor(path, nextDirent, opts = {}) {
    this.path = path;
    this.nextDirent = nextDirent;
    this.opts = opts;
    this.closed = false;
  }

  throwIfClosed() {
    if (this.closed) {
      throw _errors__WEBPACK_IMPORTED_MODULE_0__.ERR_DIR_CLOSED();
    }
  }

  async *[Symbol.asyncIterator]() {
    try {
      let dirent; // eslint-disable-next-line no-cond-assign

      while ((dirent = await this.read()) !== null) {
        yield dirent;
      }
    } finally {
      await this.close();
    }
  }

  read(cb) {
    const dirent = this.readSync();
    if (typeof cb !== `undefined`) return cb(null, dirent);
    return Promise.resolve(dirent);
  }

  readSync() {
    this.throwIfClosed();
    return this.nextDirent();
  }

  close(cb) {
    this.closeSync();
    if (typeof cb !== `undefined`) return cb(null);
    return Promise.resolve();
  }

  closeSync() {
    var _a, _b;

    this.throwIfClosed();
    (_b = (_a = this.opts).onClose) === null || _b === void 0 ? void 0 : _b.call(_a);
    this.closed = true;
  }

}
function opendir(fakeFs, path, entries, opts) {
  const nextDirent = () => {
    const filename = entries.shift();
    if (typeof filename === `undefined`) return null;
    return Object.assign(fakeFs.statSync(fakeFs.pathUtils.join(path, filename)), {
      name: filename
    });
  };

  return new CustomDir(path, nextDirent, opts);
}

/***/ }),
/* 157 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EBUSY": () => /* binding */ EBUSY,
/* harmony export */   "ENOSYS": () => /* binding */ ENOSYS,
/* harmony export */   "EINVAL": () => /* binding */ EINVAL,
/* harmony export */   "EBADF": () => /* binding */ EBADF,
/* harmony export */   "ENOENT": () => /* binding */ ENOENT,
/* harmony export */   "ENOTDIR": () => /* binding */ ENOTDIR,
/* harmony export */   "EISDIR": () => /* binding */ EISDIR,
/* harmony export */   "EEXIST": () => /* binding */ EEXIST,
/* harmony export */   "EROFS": () => /* binding */ EROFS,
/* harmony export */   "ENOTEMPTY": () => /* binding */ ENOTEMPTY,
/* harmony export */   "EOPNOTSUPP": () => /* binding */ EOPNOTSUPP,
/* harmony export */   "ERR_DIR_CLOSED": () => /* binding */ ERR_DIR_CLOSED,
/* harmony export */   "LibzipError": () => /* binding */ LibzipError
/* harmony export */ });
function makeError(code, message) {
  return Object.assign(new Error(`${code}: ${message}`), {
    code
  });
}

function EBUSY(message) {
  return makeError(`EBUSY`, message);
}
function ENOSYS(message, reason) {
  return makeError(`ENOSYS`, `${message}, ${reason}`);
}
function EINVAL(reason) {
  return makeError(`EINVAL`, `invalid argument, ${reason}`);
}
function EBADF(reason) {
  return makeError(`EBADF`, `bad file descriptor, ${reason}`);
}
function ENOENT(reason) {
  return makeError(`ENOENT`, `no such file or directory, ${reason}`);
}
function ENOTDIR(reason) {
  return makeError(`ENOTDIR`, `not a directory, ${reason}`);
}
function EISDIR(reason) {
  return makeError(`EISDIR`, `illegal operation on a directory, ${reason}`);
}
function EEXIST(reason) {
  return makeError(`EEXIST`, `file already exists, ${reason}`);
}
function EROFS(reason) {
  return makeError(`EROFS`, `read-only filesystem, ${reason}`);
}
function ENOTEMPTY(reason) {
  return makeError(`ENOTEMPTY`, `directory not empty, ${reason}`);
}
function EOPNOTSUPP(reason) {
  return makeError(`EOPNOTSUPP`, `operation not supported, ${reason}`);
} // ------------------------------------------------------------------------

function ERR_DIR_CLOSED() {
  return makeError(`ERR_DIR_CLOSED`, `Directory handle was closed`);
} // ------------------------------------------------------------------------

class LibzipError extends Error {
  constructor(message, code) {
    super(message);
    this.name = `Libzip Error`;
    this.code = code;
  }

}

/***/ }),
/* 158 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DirEntry": () => /* binding */ DirEntry,
/* harmony export */   "StatEntry": () => /* binding */ StatEntry,
/* harmony export */   "makeDefaultStats": () => /* binding */ makeDefaultStats,
/* harmony export */   "makeEmptyStats": () => /* binding */ makeEmptyStats,
/* harmony export */   "areStatsEqual": () => /* binding */ areStatsEqual
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(159);

class DirEntry {
  constructor() {
    this.name = ``;
    this.mode = 0;
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isDirectory() {
    return (this.mode & _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFMT) === _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFDIR;
  }

  isFIFO() {
    return false;
  }

  isFile() {
    return (this.mode & _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFMT) === _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFREG;
  }

  isSocket() {
    return false;
  }

  isSymbolicLink() {
    return (this.mode & _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFMT) === _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFLNK;
  }

}
class StatEntry {
  constructor() {
    this.dev = 0;
    this.ino = 0;
    this.mode = 0;
    this.nlink = 1;
    this.rdev = 0;
    this.blocks = 1;
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isDirectory() {
    return (this.mode & _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFMT) === _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFDIR;
  }

  isFIFO() {
    return false;
  }

  isFile() {
    return (this.mode & _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFMT) === _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFREG;
  }

  isSocket() {
    return false;
  }

  isSymbolicLink() {
    return (this.mode & _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFMT) === _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFLNK;
  }

}
function makeDefaultStats() {
  return Object.assign(new StatEntry(), {
    uid: 0,
    gid: 0,
    size: 0,
    blksize: 0,
    atimeMs: 0,
    mtimeMs: 0,
    ctimeMs: 0,
    birthtimeMs: 0,
    atime: new Date(0),
    mtime: new Date(0),
    ctime: new Date(0),
    birthtime: new Date(0),
    mode: _constants__WEBPACK_IMPORTED_MODULE_0__.S_IFREG | 0o644
  });
}
function makeEmptyStats() {
  return Object.assign(makeDefaultStats(), {
    nlink: 0,
    blocks: 0,
    mode: 0
  });
}
function areStatsEqual(a, b) {
  if (a.atimeMs !== b.atimeMs) return false;
  if (a.birthtimeMs !== b.birthtimeMs) return false;
  if (a.blksize !== b.blksize) return false;
  if (a.blocks !== b.blocks) return false;
  if (a.ctimeMs !== b.ctimeMs) return false;
  if (a.dev !== b.dev) return false;
  if (a.gid !== b.gid) return false;
  if (a.ino !== b.ino) return false;
  if (a.isBlockDevice() !== b.isBlockDevice()) return false;
  if (a.isCharacterDevice() !== b.isCharacterDevice()) return false;
  if (a.isDirectory() !== b.isDirectory()) return false;
  if (a.isFIFO() !== b.isFIFO()) return false;
  if (a.isFile() !== b.isFile()) return false;
  if (a.isSocket() !== b.isSocket()) return false;
  if (a.isSymbolicLink() !== b.isSymbolicLink()) return false;
  if (a.mode !== b.mode) return false;
  if (a.mtimeMs !== b.mtimeMs) return false;
  if (a.nlink !== b.nlink) return false;
  if (a.rdev !== b.rdev) return false;
  if (a.size !== b.size) return false;
  if (a.uid !== b.uid) return false;
  return true;
}

/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S_IFMT": () => /* binding */ S_IFMT,
/* harmony export */   "S_IFDIR": () => /* binding */ S_IFDIR,
/* harmony export */   "S_IFREG": () => /* binding */ S_IFREG,
/* harmony export */   "S_IFLNK": () => /* binding */ S_IFLNK
/* harmony export */ });
const S_IFMT = 0o170000;
const S_IFDIR = 0o040000;
const S_IFREG = 0o100000;
const S_IFLNK = 0o120000;

/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FakeFS": () => /* binding */ FakeFS,
/* harmony export */   "BasePortableFakeFS": () => /* binding */ BasePortableFakeFS,
/* harmony export */   "normalizeLineEndings": () => /* binding */ normalizeLineEndings
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _algorithms_copyPromise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(161);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);



class FakeFS {
  constructor(pathUtils) {
    this.pathUtils = pathUtils;
  }

  async *genTraversePromise(init, {
    stableSort = false
  } = {}) {
    const stack = [init];

    while (stack.length > 0) {
      const p = stack.shift();
      const entry = await this.lstatPromise(p);

      if (entry.isDirectory()) {
        const entries = await this.readdirPromise(p);

        if (stableSort) {
          for (const entry of entries.sort()) {
            stack.push(this.pathUtils.join(p, entry));
          }
        } else {
          throw new Error(`Not supported`);
        }
      } else {
        yield p;
      }
    }
  }

  async removePromise(p, {
    recursive = true,
    maxRetries = 5
  } = {}) {
    let stat;

    try {
      stat = await this.lstatPromise(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }

    if (stat.isDirectory()) {
      if (recursive) for (const entry of await this.readdirPromise(p)) await this.removePromise(this.pathUtils.resolve(p, entry)); // 5 gives 1s worth of retries at worst

      let t = 0;

      do {
        try {
          await this.rmdirPromise(p);
          break;
        } catch (error) {
          if (error.code === `EBUSY` || error.code === `ENOTEMPTY`) {
            if (maxRetries === 0) {
              break;
            } else {
              await new Promise(resolve => setTimeout(resolve, t * 100));
              continue;
            }
          } else {
            throw error;
          }
        }
      } while (t++ < maxRetries);
    } else {
      await this.unlinkPromise(p);
    }
  }

  removeSync(p, {
    recursive = true
  } = {}) {
    let stat;

    try {
      stat = this.lstatSync(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }

    if (stat.isDirectory()) {
      if (recursive) for (const entry of this.readdirSync(p)) this.removeSync(this.pathUtils.resolve(p, entry));
      this.rmdirSync(p);
    } else {
      this.unlinkSync(p);
    }
  }

  async mkdirpPromise(p, {
    chmod,
    utimes
  } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p)) return;
    const parts = p.split(this.pathUtils.sep);

    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);

      if (!this.existsSync(subPath)) {
        try {
          await this.mkdirPromise(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }

        if (chmod != null) await this.chmodPromise(subPath, chmod);

        if (utimes != null) {
          await this.utimesPromise(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
          await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
  }

  mkdirpSync(p, {
    chmod,
    utimes
  } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p)) return;
    const parts = p.split(this.pathUtils.sep);

    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);

      if (!this.existsSync(subPath)) {
        try {
          this.mkdirSync(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }

        if (chmod != null) this.chmodSync(subPath, chmod);

        if (utimes != null) {
          this.utimesSync(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = this.statSync(this.pathUtils.dirname(subPath));
          this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
  }

  async copyPromise(destination, source, {
    baseFs = this,
    overwrite = true,
    stableSort = false,
    stableTime = false
  } = {}) {
    return await (0,_algorithms_copyPromise__WEBPACK_IMPORTED_MODULE_1__.copyPromise)(this, destination, baseFs, source, {
      overwrite,
      stableSort,
      stableTime
    });
  }

  copySync(destination, source, {
    baseFs = this,
    overwrite = true
  } = {}) {
    const stat = baseFs.lstatSync(source);
    const exists = this.existsSync(destination);

    if (stat.isDirectory()) {
      this.mkdirpSync(destination);
      const directoryListing = baseFs.readdirSync(source);

      for (const entry of directoryListing) {
        this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), {
          baseFs,
          overwrite
        });
      }
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists) this.removeSync(destination);
        const content = baseFs.readFileSync(source);
        this.writeFileSync(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists) this.removeSync(destination);
        const target = baseFs.readlinkSync(source);
        this.symlinkSync((0,_path__WEBPACK_IMPORTED_MODULE_2__.convertPath)(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }

    const mode = stat.mode & 0o777;
    this.chmodSync(destination, mode);
  }

  async changeFilePromise(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferPromise(p, content);
    } else {
      return this.changeFileTextPromise(p, content, opts);
    }
  }

  async changeFileBufferPromise(p, content) {
    let current = Buffer.alloc(0);

    try {
      current = await this.readFilePromise(p);
    } catch (error) {// ignore errors, no big deal
    }

    if (Buffer.compare(current, content) === 0) return;
    await this.writeFilePromise(p, content);
  }

  async changeFileTextPromise(p, content, {
    automaticNewlines
  } = {}) {
    let current = ``;

    try {
      current = await this.readFilePromise(p, `utf8`);
    } catch (error) {// ignore errors, no big deal
    }

    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent) return;
    await this.writeFilePromise(p, normalizedContent);
  }

  changeFileSync(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferSync(p, content);
    } else {
      return this.changeFileTextSync(p, content, opts);
    }
  }

  changeFileBufferSync(p, content) {
    let current = Buffer.alloc(0);

    try {
      current = this.readFileSync(p);
    } catch (error) {// ignore errors, no big deal
    }

    if (Buffer.compare(current, content) === 0) return;
    this.writeFileSync(p, content);
  }

  changeFileTextSync(p, content, {
    automaticNewlines = false
  } = {}) {
    let current = ``;

    try {
      current = this.readFileSync(p, `utf8`);
    } catch (error) {// ignore errors, no big deal
    }

    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent) return;
    this.writeFileSync(p, normalizedContent);
  }

  async movePromise(fromP, toP) {
    try {
      await this.renamePromise(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        await this.copyPromise(toP, fromP);
        await this.removePromise(fromP);
      } else {
        throw error;
      }
    }
  }

  moveSync(fromP, toP) {
    try {
      this.renameSync(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        this.copySync(toP, fromP);
        this.removeSync(fromP);
      } else {
        throw error;
      }
    }
  }

  async lockPromise(affectedPath, callback) {
    const lockPath = `${affectedPath}.flock`;
    const interval = 1000 / 60;
    const startTime = Date.now();
    let fd = null; // Even when we detect that a lock file exists, we still look inside to see
    // whether the pid that created it is still alive. It's not foolproof
    // (there are false positive), but there are no false negative and that's
    // all that matters in 99% of the cases.

    const isAlive = async () => {
      let pid;

      try {
        [pid] = await this.readJsonPromise(lockPath);
      } catch (error) {
        // If we can't read the file repeatedly, we assume the process was
        // aborted before even writing finishing writing the payload.
        return Date.now() - startTime < 500;
      }

      try {
        // "As a special case, a signal of 0 can be used to test for the
        // existence of a process" - so we check whether it's alive.
        process.kill(pid, 0);
        return true;
      } catch (error) {
        return false;
      }
    };

    while (fd === null) {
      try {
        fd = await this.openPromise(lockPath, `wx`);
      } catch (error) {
        if (error.code === `EEXIST`) {
          if (!(await isAlive())) {
            try {
              await this.unlinkPromise(lockPath);
              continue;
            } catch (error) {// No big deal if we can't remove it. Just fallback to wait for
              // it to be eventually released by its owner.
            }
          }

          if (Date.now() - startTime < 60 * 1000) {
            await new Promise(resolve => setTimeout(resolve, interval));
          } else {
            throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
          }
        } else {
          throw error;
        }
      }
    }

    await this.writePromise(fd, JSON.stringify([process.pid]));

    try {
      return await callback();
    } finally {
      try {
        // closePromise needs to come before unlinkPromise otherwise another process can attempt
        // to get the file handle after the unlink but before close resuling in
        // EPERM: operation not permitted, open
        await this.closePromise(fd);
        await this.unlinkPromise(lockPath);
      } catch (error) {// noop
      }
    }
  }

  async readJsonPromise(p) {
    const content = await this.readFilePromise(p, `utf8`);

    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }

  readJsonSync(p) {
    const content = this.readFileSync(p, `utf8`);

    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }

  async writeJsonPromise(p, data) {
    return await this.writeFilePromise(p, `${JSON.stringify(data, null, 2)}\n`);
  }

  writeJsonSync(p, data) {
    return this.writeFileSync(p, `${JSON.stringify(data, null, 2)}\n`);
  }

  async preserveTimePromise(p, cb) {
    const stat = await this.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`) p = result;

    if (this.lutimesPromise) {
      await this.lutimesPromise(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      await this.utimesPromise(p, stat.atime, stat.mtime);
    }
  }

  async preserveTimeSync(p, cb) {
    const stat = this.lstatSync(p);
    const result = cb();
    if (typeof result !== `undefined`) p = result;

    if (this.lutimesSync) {
      this.lutimesSync(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      this.utimesSync(p, stat.atime, stat.mtime);
    }
  }

}
FakeFS.DEFAULT_TIME = 315532800;
class BasePortableFakeFS extends FakeFS {
  constructor() {
    super(_path__WEBPACK_IMPORTED_MODULE_2__.ppath);
  }

}

function getEndOfLine(content) {
  const matches = content.match(/\r?\n/g);
  if (matches === null) return os__WEBPACK_IMPORTED_MODULE_0__.EOL;
  const crlf = matches.filter(nl => nl === `\r\n`).length;
  const lf = matches.length - crlf;
  return crlf > lf ? `\r\n` : `\n`;
}

function normalizeLineEndings(originalContent, newContent) {
  return newContent.replace(/\r?\n/g, getEndOfLine(originalContent));
}

/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copyPromise": () => /* binding */ copyPromise
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(162);

 // 1980-01-01, like Fedora

const defaultTime = new Date(315532800 * 1000);
async function copyPromise(destinationFs, destination, sourceFs, source, opts) {
  const normalizedDestination = destinationFs.pathUtils.normalize(destination);
  const normalizedSource = sourceFs.pathUtils.normalize(source);
  const prelayout = [];
  const postlayout = [];
  await destinationFs.mkdirPromise(destinationFs.pathUtils.dirname(destination), {
    recursive: true
  });
  const updateTime = typeof destinationFs.lutimesPromise === `function` ? destinationFs.lutimesPromise.bind(destinationFs) : destinationFs.utimesPromise.bind(destinationFs);
  await copyImpl(prelayout, postlayout, updateTime, destinationFs, normalizedDestination, sourceFs, normalizedSource, opts);

  for (const operation of prelayout) await operation();

  await Promise.all(postlayout.map(operation => {
    return operation();
  }));
}

async function copyImpl(prelayout, postlayout, updateTime, destinationFs, destination, sourceFs, source, opts) {
  var _a, _b;

  const destinationStat = await maybeLStat(destinationFs, destination);
  const sourceStat = await sourceFs.lstatPromise(source);
  const referenceTime = opts.stableTime ? {
    mtime: defaultTime,
    atime: defaultTime
  } : sourceStat;
  let updated;

  switch (true) {
    case sourceStat.isDirectory():
      {
        updated = await copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;

    case sourceStat.isFile():
      {
        updated = await copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;

    case sourceStat.isSymbolicLink():
      {
        updated = await copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;

    default:
      {
        throw new Error(`Unsupported file type (${sourceStat.mode})`);
      }
      break;
  }

  if (updated || ((_a = destinationStat === null || destinationStat === void 0 ? void 0 : destinationStat.mtime) === null || _a === void 0 ? void 0 : _a.getTime()) !== referenceTime.mtime.getTime() || ((_b = destinationStat === null || destinationStat === void 0 ? void 0 : destinationStat.atime) === null || _b === void 0 ? void 0 : _b.getTime()) !== referenceTime.atime.getTime()) {
    postlayout.push(() => updateTime(destination, referenceTime.atime, referenceTime.mtime));
    updated = true;
  }

  if (destinationStat === null || (destinationStat.mode & 0o777) !== (sourceStat.mode & 0o777)) {
    postlayout.push(() => destinationFs.chmodPromise(destination, sourceStat.mode & 0o777));
    updated = true;
  }

  return updated;
}

async function maybeLStat(baseFs, p) {
  try {
    return await baseFs.lstatPromise(p);
  } catch (e) {
    return null;
  }
}

async function copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null && !destinationStat.isDirectory()) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }

  let updated = false;

  if (destinationStat === null) {
    prelayout.push(async () => destinationFs.mkdirPromise(destination, {
      mode: sourceStat.mode
    }));
    updated = true;
  }

  const entries = await sourceFs.readdirPromise(source);

  if (opts.stableSort) {
    for (const entry of entries.sort()) {
      if (await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), opts)) {
        updated = true;
      }
    }
  } else {
    const entriesUpdateStatus = await Promise.all(entries.map(async entry => {
      await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), opts);
    }));

    if (entriesUpdateStatus.some(status => status)) {
      updated = true;
    }
  }

  return updated;
}

async function copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }

  const op = destinationFs === sourceFs ? async () => destinationFs.copyFilePromise(source, destination, (fs__WEBPACK_IMPORTED_MODULE_0___default().constants.COPYFILE_FICLONE)) : async () => destinationFs.writeFilePromise(destination, await sourceFs.readFilePromise(source));
  prelayout.push(async () => op());
  return true;
}

async function copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }

  prelayout.push(async () => {
    await destinationFs.symlinkPromise((0,_path__WEBPACK_IMPORTED_MODULE_1__.convertPath)(destinationFs.pathUtils, await sourceFs.readlinkPromise(source)), destination);
  });
  return true;
}

/***/ }),
/* 162 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PortablePath": () => /* binding */ PortablePath,
/* harmony export */   "Filename": () => /* binding */ Filename,
/* harmony export */   "npath": () => /* binding */ npath,
/* harmony export */   "ppath": () => /* binding */ ppath,
/* harmony export */   "convertPath": () => /* binding */ convertPath,
/* harmony export */   "toFilename": () => /* binding */ toFilename
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);

var PathType;

(function (PathType) {
  PathType[PathType["File"] = 0] = "File";
  PathType[PathType["Portable"] = 1] = "Portable";
  PathType[PathType["Native"] = 2] = "Native";
})(PathType || (PathType = {}));

const PortablePath = {
  root: `/`,
  dot: `.`
};
const Filename = {
  nodeModules: `node_modules`,
  manifest: `package.json`,
  lockfile: `yarn.lock`,
  pnpJs: `.pnp.js`,
  rc: `.yarnrc.yml`
};
const npath = Object.create((path__WEBPACK_IMPORTED_MODULE_0___default()));
const ppath = Object.create((path__WEBPACK_IMPORTED_MODULE_0___default().posix));

npath.cwd = () => process.cwd();

ppath.cwd = () => toPortablePath(process.cwd());

ppath.resolve = (...segments) => {
  if (segments.length > 0 && ppath.isAbsolute(segments[0])) {
    return path__WEBPACK_IMPORTED_MODULE_0___default().posix.resolve(...segments);
  } else {
    return path__WEBPACK_IMPORTED_MODULE_0___default().posix.resolve(ppath.cwd(), ...segments);
  }
};

const contains = function (pathUtils, from, to) {
  from = pathUtils.normalize(from);
  to = pathUtils.normalize(to);
  if (from === to) return `.`;
  if (!from.endsWith(pathUtils.sep)) from = from + pathUtils.sep;

  if (to.startsWith(from)) {
    return to.slice(from.length);
  } else {
    return null;
  }
};

npath.fromPortablePath = fromPortablePath;
npath.toPortablePath = toPortablePath;

npath.contains = (from, to) => contains(npath, from, to);

ppath.contains = (from, to) => contains(ppath, from, to);

const WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
const UNC_WINDOWS_PATH_REGEXP = /^\\\\(\.\\)?(.*)$/;
const PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
const UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/; // Path should look like "/N:/berry/scripts/plugin-pack.js"
// And transform to "N:\berry\scripts\plugin-pack.js"

function fromPortablePath(p) {
  if (process.platform !== `win32`) return p;
  if (p.match(PORTABLE_PATH_REGEXP)) p = p.replace(PORTABLE_PATH_REGEXP, `$1`);else if (p.match(UNC_PORTABLE_PATH_REGEXP)) p = p.replace(UNC_PORTABLE_PATH_REGEXP, (match, p1, p2) => `\\\\${p1 ? `.\\` : ``}${p2}`);else return p;
  return p.replace(/\//g, `\\`);
} // Path should look like "N:/berry/scripts/plugin-pack.js"
// And transform to "/N:/berry/scripts/plugin-pack.js"


function toPortablePath(p) {
  if (process.platform !== `win32`) return p;
  if (p.match(WINDOWS_PATH_REGEXP)) p = p.replace(WINDOWS_PATH_REGEXP, `/$1`);else if (p.match(UNC_WINDOWS_PATH_REGEXP)) p = p.replace(UNC_WINDOWS_PATH_REGEXP, (match, p1, p2) => `/unc/${p1 ? `.dot/` : ``}${p2}`);
  return p.replace(/\\/g, `/`);
}

function convertPath(targetPathUtils, sourcePath) {
  return targetPathUtils === npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
}
function toFilename(filename) {
  if (npath.parse(filename).dir !== `` || ppath.parse(filename).dir !== ``) throw new Error(`Invalid filename: "${filename}"`);
  return filename;
}

/***/ }),
/* 163 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_COMPRESSION_LEVEL": () => /* binding */ DEFAULT_COMPRESSION_LEVEL,
/* harmony export */   "ZipFS": () => /* binding */ ZipFS
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(164);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _FakeFS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(160);
/* harmony import */ var _NodeFS__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(165);
/* harmony import */ var _algorithms_opendir__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(156);
/* harmony import */ var _algorithms_watchFile__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(166);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(159);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(157);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(162);
/* harmony import */ var _statUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(158);












const DEFAULT_COMPRESSION_LEVEL = `mixed`;

function toUnixTimestamp(time) {
  if (typeof time === `string` && String(+time) === time) return +time;

  if (Number.isFinite(time)) {
    if (time < 0) {
      return Date.now() / 1000;
    } else {
      return time;
    }
  } // convert to 123.456 UNIX timestamp


  if ((0,util__WEBPACK_IMPORTED_MODULE_2__.isDate)(time)) return time.getTime() / 1000;
  throw new Error(`Invalid time`);
}

class ZipFS extends _FakeFS__WEBPACK_IMPORTED_MODULE_4__.BasePortableFakeFS {
  constructor(source, opts) {
    super();
    this.lzSource = null;
    this.listings = new Map();
    this.entries = new Map();
    /**
     * A cache of indices mapped to file sources.
     * Populated by `setFileSource` calls.
     * Required for supporting read after write.
     */

    this.fileSources = new Map();
    this.fds = new Map();
    this.nextFd = 0;
    this.ready = false;
    this.readOnly = false;
    this.libzip = opts.libzip;
    const pathOptions = opts;
    this.level = typeof pathOptions.level !== `undefined` ? pathOptions.level : DEFAULT_COMPRESSION_LEVEL;

    if (source === null) {
      source = Buffer.from([0x50, 0x4B, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    }

    if (typeof source === `string`) {
      const {
        baseFs = new _NodeFS__WEBPACK_IMPORTED_MODULE_5__.NodeFS()
      } = pathOptions;
      this.baseFs = baseFs;
      this.path = source;
    } else {
      this.path = null;
      this.baseFs = null;
    }

    if (opts.stats) {
      this.stats = opts.stats;
    } else {
      if (typeof source === `string`) {
        try {
          this.stats = this.baseFs.statSync(source);
        } catch (error) {
          if (error.code === `ENOENT` && pathOptions.create) {
            this.stats = _statUtils__WEBPACK_IMPORTED_MODULE_6__.makeDefaultStats();
          } else {
            throw error;
          }
        }
      } else {
        this.stats = _statUtils__WEBPACK_IMPORTED_MODULE_6__.makeDefaultStats();
      }
    }

    const errPtr = this.libzip.malloc(4);

    try {
      let flags = 0;
      if (typeof source === `string` && pathOptions.create) flags |= this.libzip.ZIP_CREATE | this.libzip.ZIP_TRUNCATE;

      if (opts.readOnly) {
        flags |= this.libzip.ZIP_RDONLY;
        this.readOnly = true;
      }

      if (typeof source === `string`) {
        this.zip = this.libzip.open(_path__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(source), flags, errPtr);
      } else {
        const lzSource = this.allocateUnattachedSource(source);

        try {
          this.zip = this.libzip.openFromSource(lzSource, flags, errPtr);
          this.lzSource = lzSource;
        } catch (error) {
          this.libzip.source.free(lzSource);
          throw error;
        }
      }

      if (this.zip === 0) {
        const error = this.libzip.struct.errorS();
        this.libzip.error.initWithCode(error, this.libzip.getValue(errPtr, `i32`));
        throw this.makeLibzipError(error);
      }
    } finally {
      this.libzip.free(errPtr);
    }

    this.listings.set(_path__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, new Set());
    const entryCount = this.libzip.getNumEntries(this.zip, 0);

    for (let t = 0; t < entryCount; ++t) {
      const raw = this.libzip.getName(this.zip, t, 0);
      if (_path__WEBPACK_IMPORTED_MODULE_7__.ppath.isAbsolute(raw)) continue;
      const p = _path__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_path__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, raw);
      this.registerEntry(p, t); // If the raw path is a directory, register it
      // to prevent empty folder being skipped

      if (raw.endsWith(`/`)) {
        this.registerListing(p);
      }
    }

    this.symlinkCount = this.libzip.ext.countSymlinks(this.zip);
    if (this.symlinkCount === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
    this.ready = true;
  }

  makeLibzipError(error) {
    const errorCode = this.libzip.struct.errorCodeZip(error);
    const strerror = this.libzip.error.strerror(error);
    const libzipError = new _errors__WEBPACK_IMPORTED_MODULE_8__.LibzipError(strerror, this.libzip.errors[errorCode]); // This error should never come up because of the file source cache

    if (errorCode === this.libzip.errors.ZIP_ER_CHANGED) throw new Error(`Assertion failed: Unexpected libzip error: ${libzipError.message}`);
    return libzipError;
  }

  getExtractHint(hints) {
    for (const fileName of this.entries.keys()) {
      const ext = this.pathUtils.extname(fileName);

      if (hints.relevantExtensions.has(ext)) {
        return true;
      }
    }

    return false;
  }

  getAllFiles() {
    return Array.from(this.entries.keys());
  }

  getRealPath() {
    if (!this.path) throw new Error(`ZipFS don't have real paths when loaded from a buffer`);
    return this.path;
  }

  getBufferAndClose() {
    this.prepareClose();
    if (!this.lzSource) throw new Error(`ZipFS was not created from a Buffer`);

    try {
      // Prevent close from cleaning up the source
      this.libzip.source.keep(this.lzSource); // Close the zip archive

      if (this.libzip.close(this.zip) === -1) throw this.makeLibzipError(this.libzip.getError(this.zip)); // Open the source for reading

      if (this.libzip.source.open(this.lzSource) === -1) throw this.makeLibzipError(this.libzip.source.error(this.lzSource)); // Move to the end of source

      if (this.libzip.source.seek(this.lzSource, 0, 0, this.libzip.SEEK_END) === -1) throw this.makeLibzipError(this.libzip.source.error(this.lzSource)); // Get the size of source

      const size = this.libzip.source.tell(this.lzSource);
      if (size === -1) throw this.makeLibzipError(this.libzip.source.error(this.lzSource)); // Move to the start of source

      if (this.libzip.source.seek(this.lzSource, 0, 0, this.libzip.SEEK_SET) === -1) throw this.makeLibzipError(this.libzip.source.error(this.lzSource));
      const buffer = this.libzip.malloc(size);
      if (!buffer) throw new Error(`Couldn't allocate enough memory`);

      try {
        const rc = this.libzip.source.read(this.lzSource, buffer, size);
        if (rc === -1) throw this.makeLibzipError(this.libzip.source.error(this.lzSource));else if (rc < size) throw new Error(`Incomplete read`);else if (rc > size) throw new Error(`Overread`);
        const memory = this.libzip.HEAPU8.subarray(buffer, buffer + size);
        return Buffer.from(memory);
      } finally {
        this.libzip.free(buffer);
      }
    } finally {
      this.libzip.source.close(this.lzSource);
      this.libzip.source.free(this.lzSource);
      this.ready = false;
    }
  }

  prepareClose() {
    if (!this.ready) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EBUSY(`archive closed, close`);
    (0,_algorithms_watchFile__WEBPACK_IMPORTED_MODULE_9__.unwatchAllFiles)(this);
  }

  saveAndClose() {
    if (!this.path || !this.baseFs) throw new Error(`ZipFS cannot be saved and must be discarded when loaded from a buffer`);
    this.prepareClose();

    if (this.readOnly) {
      this.discardAndClose();
      return;
    }

    const previousMod = this.baseFs.existsSync(this.path) ? this.baseFs.statSync(this.path).mode & 0o777 : null;
    const rc = this.libzip.close(this.zip);
    if (rc === -1) throw this.makeLibzipError(this.libzip.getError(this.zip)); // this.libzip overrides the chmod when writing the archive, which is a weird
    // behavior I don't totally understand (plus the umask seems bogus in some
    // weird cases - maybe related to emscripten?)
    //
    // See also https://github.com/nih-at/libzip/issues/77

    if (previousMod === null) this.baseFs.chmodSync(this.path, this.stats.mode);else if (previousMod !== (this.baseFs.statSync(this.path).mode & 0o777)) this.baseFs.chmodSync(this.path, previousMod);
    this.ready = false;
  }

  discardAndClose() {
    this.prepareClose();
    this.libzip.discard(this.zip);
    this.ready = false;
  }

  resolve(p) {
    return _path__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_path__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, p);
  }

  async openPromise(p, flags, mode) {
    return this.openSync(p, flags, mode);
  }

  openSync(p, flags, mode) {
    const fd = this.nextFd++;
    this.fds.set(fd, {
      cursor: 0,
      p
    });
    return fd;
  }

  hasOpenFileHandles() {
    return !!this.fds.size;
  }

  async opendirPromise(p, opts) {
    return this.opendirSync(p, opts);
  }

  opendirSync(p, opts = {}) {
    const resolvedP = this.resolveFilename(`opendir '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOENT(`opendir '${p}'`);
    const directoryListing = this.listings.get(resolvedP);
    if (!directoryListing) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOTDIR(`opendir '${p}'`);
    const entries = [...directoryListing];
    const fd = this.openSync(resolvedP, `r`);

    const onClose = () => {
      this.closeSync(fd);
    };

    return (0,_algorithms_opendir__WEBPACK_IMPORTED_MODULE_10__.opendir)(this, resolvedP, entries, {
      onClose
    });
  }

  async readPromise(fd, buffer, offset, length, position) {
    return this.readSync(fd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset = 0, length = 0, position = -1) {
    const entry = this.fds.get(fd);
    if (typeof entry === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EBADF(`read`);
    let realPosition;
    if (position === -1 || position === null) realPosition = entry.cursor;else realPosition = position;
    const source = this.readFileSync(entry.p);
    source.copy(buffer, offset, realPosition, realPosition + length);
    const bytesRead = Math.max(0, Math.min(source.length - realPosition, length));
    if (position === -1 || position === null) entry.cursor += bytesRead;
    return bytesRead;
  }

  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.writeSync(fd, buffer, position);
    } else {
      return this.writeSync(fd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    const entry = this.fds.get(fd);
    if (typeof entry === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EBADF(`read`);
    throw new Error(`Unimplemented`);
  }

  async closePromise(fd) {
    return this.closeSync(fd);
  }

  closeSync(fd) {
    const entry = this.fds.get(fd);
    if (typeof entry === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EBADF(`read`);
    this.fds.delete(fd);
  }

  createReadStream(p, {
    encoding
  } = {}) {
    if (p === null) throw new Error(`Unimplemented`);
    const fd = this.openSync(p, `r`);
    const stream = Object.assign(new stream__WEBPACK_IMPORTED_MODULE_1__.PassThrough({
      emitClose: true,
      autoDestroy: true,
      destroy: (error, callback) => {
        clearImmediate(immediate);
        this.closeSync(fd);
        callback(error);
      }
    }), {
      close() {
        stream.destroy();
      },

      bytesRead: 0,
      path: p
    });
    const immediate = setImmediate(async () => {
      try {
        const data = await this.readFilePromise(p, encoding);
        stream.bytesRead = data.length;
        stream.end(data);
      } catch (error) {
        stream.destroy(error);
      }
    });
    return stream;
  }

  createWriteStream(p, {
    encoding
  } = {}) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`open '${p}'`);
    if (p === null) throw new Error(`Unimplemented`);
    const chunks = [];
    const fd = this.openSync(p, `w`);
    const stream = Object.assign(new stream__WEBPACK_IMPORTED_MODULE_1__.PassThrough({
      autoDestroy: true,
      emitClose: true,
      destroy: (error, callback) => {
        try {
          if (error) {
            callback(error);
          } else {
            this.writeFileSync(p, Buffer.concat(chunks), encoding);
            callback(null);
          }
        } catch (err) {
          callback(err);
        } finally {
          this.closeSync(fd);
        }
      }
    }), {
      bytesWritten: 0,
      path: p,

      close() {
        stream.destroy();
      }

    });
    stream.on(`data`, chunk => {
      const chunkBuffer = Buffer.from(chunk);
      stream.bytesWritten += chunkBuffer.length;
      chunks.push(chunkBuffer);
    });
    return stream;
  }

  async realpathPromise(p) {
    return this.realpathSync(p);
  }

  realpathSync(p) {
    const resolvedP = this.resolveFilename(`lstat '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOENT(`lstat '${p}'`);
    return resolvedP;
  }

  async existsPromise(p) {
    return this.existsSync(p);
  }

  existsSync(p) {
    if (!this.ready) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EBUSY(`archive closed, existsSync '${p}'`);

    if (this.symlinkCount === 0) {
      const resolvedP = _path__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_path__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, p);
      return this.entries.has(resolvedP) || this.listings.has(resolvedP);
    }

    let resolvedP;

    try {
      resolvedP = this.resolveFilename(`stat '${p}'`, p);
    } catch (error) {
      return false;
    }

    return this.entries.has(resolvedP) || this.listings.has(resolvedP);
  }

  async accessPromise(p, mode) {
    return this.accessSync(p, mode);
  }

  accessSync(p, mode = fs__WEBPACK_IMPORTED_MODULE_0__.constants.F_OK) {
    const resolvedP = this.resolveFilename(`access '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOENT(`access '${p}'`);

    if (this.readOnly && mode & fs__WEBPACK_IMPORTED_MODULE_0__.constants.W_OK) {
      throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`access '${p}'`);
    }
  }

  async statPromise(p) {
    return this.statSync(p);
  }

  statSync(p) {
    const resolvedP = this.resolveFilename(`stat '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOENT(`stat '${p}'`);
    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOTDIR(`stat '${p}'`);
    return this.statImpl(`stat '${p}'`, resolvedP);
  }

  async lstatPromise(p) {
    return this.lstatSync(p);
  }

  lstatSync(p) {
    const resolvedP = this.resolveFilename(`lstat '${p}'`, p, false);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOENT(`lstat '${p}'`);
    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOTDIR(`lstat '${p}'`);
    return this.statImpl(`lstat '${p}'`, resolvedP);
  }

  statImpl(reason, p) {
    const entry = this.entries.get(p); // File, or explicit directory

    if (typeof entry !== `undefined`) {
      const stat = this.libzip.struct.statS();
      const rc = this.libzip.statIndex(this.zip, entry, 0, 0, stat);
      if (rc === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
      const uid = this.stats.uid;
      const gid = this.stats.gid;
      const size = this.libzip.struct.statSize(stat) >>> 0;
      const blksize = 512;
      const blocks = Math.ceil(size / blksize);
      const mtimeMs = (this.libzip.struct.statMtime(stat) >>> 0) * 1000;
      const atimeMs = mtimeMs;
      const birthtimeMs = mtimeMs;
      const ctimeMs = mtimeMs;
      const atime = new Date(atimeMs);
      const birthtime = new Date(birthtimeMs);
      const ctime = new Date(ctimeMs);
      const mtime = new Date(mtimeMs);
      const type = this.listings.has(p) ? _constants__WEBPACK_IMPORTED_MODULE_11__.S_IFDIR : this.isSymbolicLink(entry) ? _constants__WEBPACK_IMPORTED_MODULE_11__.S_IFLNK : _constants__WEBPACK_IMPORTED_MODULE_11__.S_IFREG;
      const defaultMode = type === _constants__WEBPACK_IMPORTED_MODULE_11__.S_IFDIR ? 0o755 : 0o644;
      const mode = type | this.getUnixMode(entry, defaultMode) & 0o777;
      return Object.assign(new _statUtils__WEBPACK_IMPORTED_MODULE_6__.StatEntry(), {
        uid,
        gid,
        size,
        blksize,
        blocks,
        atime,
        birthtime,
        ctime,
        mtime,
        atimeMs,
        birthtimeMs,
        ctimeMs,
        mtimeMs,
        mode
      });
    } // Implicit directory


    if (this.listings.has(p)) {
      const uid = this.stats.uid;
      const gid = this.stats.gid;
      const size = 0;
      const blksize = 512;
      const blocks = 0;
      const atimeMs = this.stats.mtimeMs;
      const birthtimeMs = this.stats.mtimeMs;
      const ctimeMs = this.stats.mtimeMs;
      const mtimeMs = this.stats.mtimeMs;
      const atime = new Date(atimeMs);
      const birthtime = new Date(birthtimeMs);
      const ctime = new Date(ctimeMs);
      const mtime = new Date(mtimeMs);
      const mode = _constants__WEBPACK_IMPORTED_MODULE_11__.S_IFDIR | 0o755;
      return Object.assign(new _statUtils__WEBPACK_IMPORTED_MODULE_6__.StatEntry(), {
        uid,
        gid,
        size,
        blksize,
        blocks,
        atime,
        birthtime,
        ctime,
        mtime,
        atimeMs,
        birthtimeMs,
        ctimeMs,
        mtimeMs,
        mode
      });
    }

    throw new Error(`Unreachable`);
  }

  getUnixMode(index, defaultMode) {
    const rc = this.libzip.file.getExternalAttributes(this.zip, index, 0, 0, this.libzip.uint08S, this.libzip.uint32S);
    if (rc === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
    const opsys = this.libzip.getValue(this.libzip.uint08S, `i8`) >>> 0;
    if (opsys !== this.libzip.ZIP_OPSYS_UNIX) return defaultMode;
    return this.libzip.getValue(this.libzip.uint32S, `i32`) >>> 16;
  }

  registerListing(p) {
    let listing = this.listings.get(p);
    if (listing) return listing;
    const parentListing = this.registerListing(_path__WEBPACK_IMPORTED_MODULE_7__.ppath.dirname(p));
    listing = new Set();
    parentListing.add(_path__WEBPACK_IMPORTED_MODULE_7__.ppath.basename(p));
    this.listings.set(p, listing);
    return listing;
  }

  registerEntry(p, index) {
    const parentListing = this.registerListing(_path__WEBPACK_IMPORTED_MODULE_7__.ppath.dirname(p));
    parentListing.add(_path__WEBPACK_IMPORTED_MODULE_7__.ppath.basename(p));
    this.entries.set(p, index);
  }

  unregisterListing(p) {
    this.listings.delete(p);
    const parentListing = this.listings.get(_path__WEBPACK_IMPORTED_MODULE_7__.ppath.dirname(p));
    parentListing === null || parentListing === void 0 ? void 0 : parentListing.delete(_path__WEBPACK_IMPORTED_MODULE_7__.ppath.basename(p));
  }

  unregisterEntry(p) {
    this.unregisterListing(p);
    const entry = this.entries.get(p);
    this.entries.delete(p);
    if (typeof entry === `undefined`) return;
    this.fileSources.delete(entry);

    if (this.isSymbolicLink(entry)) {
      this.symlinkCount--;
    }
  }

  deleteEntry(p, index) {
    this.unregisterEntry(p);
    const rc = this.libzip.delete(this.zip, index);

    if (rc === -1) {
      throw this.makeLibzipError(this.libzip.getError(this.zip));
    }
  }

  resolveFilename(reason, p, resolveLastComponent = true) {
    if (!this.ready) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EBUSY(`archive closed, ${reason}`);
    let resolvedP = _path__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_path__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, p);
    if (resolvedP === `/`) return _path__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root;
    const fileIndex = this.entries.get(resolvedP);

    if (resolveLastComponent && fileIndex !== undefined) {
      if (this.symlinkCount !== 0 && this.isSymbolicLink(fileIndex)) {
        const target = this.getFileSource(fileIndex).toString();
        return this.resolveFilename(reason, _path__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_path__WEBPACK_IMPORTED_MODULE_7__.ppath.dirname(resolvedP), target), true);
      } else {
        return resolvedP;
      }
    }

    while (true) {
      const parentP = this.resolveFilename(reason, _path__WEBPACK_IMPORTED_MODULE_7__.ppath.dirname(resolvedP), true);
      const isDir = this.listings.has(parentP);
      const doesExist = this.entries.has(parentP);
      if (!isDir && !doesExist) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOENT(reason);
      if (!isDir) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOTDIR(reason);
      resolvedP = _path__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(parentP, _path__WEBPACK_IMPORTED_MODULE_7__.ppath.basename(resolvedP));
      if (!resolveLastComponent || this.symlinkCount === 0) break;
      const index = this.libzip.name.locate(this.zip, resolvedP.slice(1));
      if (index === -1) break;

      if (this.isSymbolicLink(index)) {
        const target = this.getFileSource(index).toString();
        resolvedP = _path__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_path__WEBPACK_IMPORTED_MODULE_7__.ppath.dirname(resolvedP), target);
      } else {
        break;
      }
    }

    return resolvedP;
  }

  allocateBuffer(content) {
    if (!Buffer.isBuffer(content)) content = Buffer.from(content);
    const buffer = this.libzip.malloc(content.byteLength);
    if (!buffer) throw new Error(`Couldn't allocate enough memory`); // Copy the file into the Emscripten heap

    const heap = new Uint8Array(this.libzip.HEAPU8.buffer, buffer, content.byteLength);
    heap.set(content);
    return {
      buffer,
      byteLength: content.byteLength
    };
  }

  allocateUnattachedSource(content) {
    const error = this.libzip.struct.errorS();
    const {
      buffer,
      byteLength
    } = this.allocateBuffer(content);
    const source = this.libzip.source.fromUnattachedBuffer(buffer, byteLength, 0, true, error);

    if (source === 0) {
      this.libzip.free(error);
      throw this.makeLibzipError(error);
    }

    return source;
  }

  allocateSource(content) {
    const {
      buffer,
      byteLength
    } = this.allocateBuffer(content);
    const source = this.libzip.source.fromBuffer(this.zip, buffer, byteLength, 0, true);

    if (source === 0) {
      this.libzip.free(buffer);
      throw this.makeLibzipError(this.libzip.getError(this.zip));
    }

    return source;
  }

  setFileSource(p, content) {
    const buffer = Buffer.isBuffer(content) ? content : Buffer.from(content);
    const target = _path__WEBPACK_IMPORTED_MODULE_7__.ppath.relative(_path__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, p);
    const lzSource = this.allocateSource(content);

    try {
      const newIndex = this.libzip.file.add(this.zip, target, lzSource, this.libzip.ZIP_FL_OVERWRITE);
      if (newIndex === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));

      if (this.level !== `mixed`) {
        // Use store for level 0, and deflate for 1..9
        let method;
        if (this.level === 0) method = this.libzip.ZIP_CM_STORE;else method = this.libzip.ZIP_CM_DEFLATE;
        const rc = this.libzip.file.setCompression(this.zip, newIndex, 0, method, this.level);

        if (rc === -1) {
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        }
      }

      this.fileSources.set(newIndex, buffer);
      return newIndex;
    } catch (error) {
      this.libzip.source.free(lzSource);
      throw error;
    }
  }

  isSymbolicLink(index) {
    if (this.symlinkCount === 0) return false;
    const attrs = this.libzip.file.getExternalAttributes(this.zip, index, 0, 0, this.libzip.uint08S, this.libzip.uint32S);
    if (attrs === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
    const opsys = this.libzip.getValue(this.libzip.uint08S, `i8`) >>> 0;
    if (opsys !== this.libzip.ZIP_OPSYS_UNIX) return false;
    const attributes = this.libzip.getValue(this.libzip.uint32S, `i32`) >>> 16;
    return (attributes & _constants__WEBPACK_IMPORTED_MODULE_11__.S_IFMT) === _constants__WEBPACK_IMPORTED_MODULE_11__.S_IFLNK;
  }

  getFileSource(index, opts = {
    asyncDecompress: false
  }) {
    const cachedFileSource = this.fileSources.get(index);
    if (typeof cachedFileSource !== `undefined`) return cachedFileSource;
    const stat = this.libzip.struct.statS();
    const rc = this.libzip.statIndex(this.zip, index, 0, 0, stat);
    if (rc === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
    const size = this.libzip.struct.statCompSize(stat);
    const compressionMethod = this.libzip.struct.statCompMethod(stat);
    const buffer = this.libzip.malloc(size);

    try {
      const file = this.libzip.fopenIndex(this.zip, index, 0, this.libzip.ZIP_FL_COMPRESSED);
      if (file === 0) throw this.makeLibzipError(this.libzip.getError(this.zip));

      try {
        const rc = this.libzip.fread(file, buffer, size, 0);
        if (rc === -1) throw this.makeLibzipError(this.libzip.file.getError(file));else if (rc < size) throw new Error(`Incomplete read`);else if (rc > size) throw new Error(`Overread`);
        const memory = this.libzip.HEAPU8.subarray(buffer, buffer + size);
        const data = Buffer.from(memory);

        if (compressionMethod === 0) {
          this.fileSources.set(index, data);
          return data;
        } else if (opts.asyncDecompress) {
          return new Promise((resolve, reject) => {
            zlib__WEBPACK_IMPORTED_MODULE_3___default().inflateRaw(data, (error, result) => {
              if (error) {
                reject(error);
              } else {
                this.fileSources.set(index, result);
                resolve(result);
              }
            });
          });
        } else {
          const decompressedData = zlib__WEBPACK_IMPORTED_MODULE_3___default().inflateRawSync(data);
          this.fileSources.set(index, decompressedData);
          return decompressedData;
        }
      } finally {
        this.libzip.fclose(file);
      }
    } finally {
      this.libzip.free(buffer);
    }
  }

  async chmodPromise(p, mask) {
    return this.chmodSync(p, mask);
  }

  chmodSync(p, mask) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`chmod '${p}'`); // We don't allow to make the extracted entries group-writable

    mask &= 0o755;
    const resolvedP = this.resolveFilename(`chmod '${p}'`, p, false);
    const entry = this.entries.get(resolvedP);
    if (typeof entry === `undefined`) throw new Error(`Assertion failed: The entry should have been registered (${resolvedP})`);
    const oldMod = this.getUnixMode(entry, _constants__WEBPACK_IMPORTED_MODULE_11__.S_IFREG | 0o000);
    const newMod = oldMod & ~0o777 | mask;
    const rc = this.libzip.file.setExternalAttributes(this.zip, entry, 0, 0, this.libzip.ZIP_OPSYS_UNIX, newMod << 16);

    if (rc === -1) {
      throw this.makeLibzipError(this.libzip.getError(this.zip));
    }
  }

  async chownPromise(p, uid, gid) {
    return this.chownSync(p, uid, gid);
  }

  chownSync(p, uid, gid) {
    throw new Error(`Unimplemented`);
  }

  async renamePromise(oldP, newP) {
    return this.renameSync(oldP, newP);
  }

  renameSync(oldP, newP) {
    throw new Error(`Unimplemented`);
  }

  async copyFilePromise(sourceP, destP, flags) {
    const {
      indexSource,
      indexDest,
      resolvedDestP
    } = this.prepareCopyFile(sourceP, destP, flags);
    const source = await this.getFileSource(indexSource, {
      asyncDecompress: true
    });
    const newIndex = this.setFileSource(resolvedDestP, source);

    if (newIndex !== indexDest) {
      this.registerEntry(resolvedDestP, newIndex);
    }
  }

  copyFileSync(sourceP, destP, flags = 0) {
    const {
      indexSource,
      indexDest,
      resolvedDestP
    } = this.prepareCopyFile(sourceP, destP, flags);
    const source = this.getFileSource(indexSource);
    const newIndex = this.setFileSource(resolvedDestP, source);

    if (newIndex !== indexDest) {
      this.registerEntry(resolvedDestP, newIndex);
    }
  }

  prepareCopyFile(sourceP, destP, flags = 0) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`copyfile '${sourceP} -> '${destP}'`);
    if ((flags & fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_FICLONE_FORCE) !== 0) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOSYS(`unsupported clone operation`, `copyfile '${sourceP}' -> ${destP}'`);
    const resolvedSourceP = this.resolveFilename(`copyfile '${sourceP} -> ${destP}'`, sourceP);
    const indexSource = this.entries.get(resolvedSourceP);
    if (typeof indexSource === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EINVAL(`copyfile '${sourceP}' -> '${destP}'`);
    const resolvedDestP = this.resolveFilename(`copyfile '${sourceP}' -> ${destP}'`, destP);
    const indexDest = this.entries.get(resolvedDestP);
    if ((flags & (fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_EXCL | fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_FICLONE_FORCE)) !== 0 && typeof indexDest !== `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EEXIST(`copyfile '${sourceP}' -> '${destP}'`);
    return {
      indexSource,
      resolvedDestP,
      indexDest
    };
  }

  async appendFilePromise(p, content, opts) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`open '${p}'`);
    if (typeof opts === `undefined`) opts = {
      flag: `a`
    };else if (typeof opts === `string`) opts = {
      flag: `a`,
      encoding: opts
    };else if (typeof opts.flag === `undefined`) opts = {
      flag: `a`,
      ...opts
    };
    return this.writeFilePromise(p, content, opts);
  }

  appendFileSync(p, content, opts = {}) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`open '${p}'`);
    if (typeof opts === `undefined`) opts = {
      flag: `a`
    };else if (typeof opts === `string`) opts = {
      flag: `a`,
      encoding: opts
    };else if (typeof opts.flag === `undefined`) opts = {
      flag: `a`,
      ...opts
    };
    return this.writeFileSync(p, content, opts);
  }

  async writeFilePromise(p, content, opts) {
    const {
      encoding,
      index,
      resolvedP
    } = this.prepareWriteFile(p, opts);
    if (index !== undefined && typeof opts === `object` && opts.flag && opts.flag.includes(`a`)) content = Buffer.concat([await this.getFileSource(index, {
      asyncDecompress: true
    }), Buffer.from(content)]);
    if (encoding !== null) content = content.toString(encoding);
    const newIndex = this.setFileSource(resolvedP, content);

    if (newIndex !== index) {
      this.registerEntry(resolvedP, newIndex);
    }
  }

  writeFileSync(p, content, opts) {
    const {
      encoding,
      index,
      resolvedP
    } = this.prepareWriteFile(p, opts);
    if (index !== undefined && typeof opts === `object` && opts.flag && opts.flag.includes(`a`)) content = Buffer.concat([this.getFileSource(index), Buffer.from(content)]);
    if (encoding !== null) content = content.toString(encoding);
    const newIndex = this.setFileSource(resolvedP, content);

    if (newIndex !== index) {
      this.registerEntry(resolvedP, newIndex);
    }
  }

  prepareWriteFile(p, opts) {
    if (typeof p !== `string`) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EBADF(`read`);
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`open '${p}'`);
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    if (this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EISDIR(`open '${p}'`);
    let encoding = null;
    if (typeof opts === `string`) encoding = opts;else if (typeof opts === `object` && opts.encoding) encoding = opts.encoding;
    const index = this.entries.get(resolvedP);
    return {
      encoding,
      resolvedP,
      index
    };
  }

  async unlinkPromise(p) {
    return this.unlinkSync(p);
  }

  unlinkSync(p) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`unlink '${p}'`);
    const resolvedP = this.resolveFilename(`unlink '${p}'`, p);
    if (this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EISDIR(`unlink '${p}'`);
    const index = this.entries.get(resolvedP);
    if (typeof index === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EINVAL(`unlink '${p}'`);
    this.deleteEntry(resolvedP, index);
  }

  async utimesPromise(p, atime, mtime) {
    return this.utimesSync(p, atime, mtime);
  }

  utimesSync(p, atime, mtime) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`utimes '${p}'`);
    const resolvedP = this.resolveFilename(`utimes '${p}'`, p);
    this.utimesImpl(resolvedP, mtime);
  }

  async lutimesPromise(p, atime, mtime) {
    return this.lutimesSync(p, atime, mtime);
  }

  lutimesSync(p, atime, mtime) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`lutimes '${p}'`);
    const resolvedP = this.resolveFilename(`utimes '${p}'`, p, false);
    this.utimesImpl(resolvedP, mtime);
  }

  utimesImpl(resolvedP, mtime) {
    if (this.listings.has(resolvedP)) if (!this.entries.has(resolvedP)) this.hydrateDirectory(resolvedP);
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    const rc = this.libzip.file.setMtime(this.zip, entry, 0, toUnixTimestamp(mtime), 0);

    if (rc === -1) {
      throw this.makeLibzipError(this.libzip.getError(this.zip));
    }
  }

  async mkdirPromise(p, opts) {
    return this.mkdirSync(p, opts);
  }

  mkdirSync(p, {
    mode = 0o755,
    recursive = false
  } = {}) {
    if (recursive) {
      this.mkdirpSync(p, {
        chmod: mode
      });
      return;
    }

    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`mkdir '${p}'`);
    const resolvedP = this.resolveFilename(`mkdir '${p}'`, p);
    if (this.entries.has(resolvedP) || this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EEXIST(`mkdir '${p}'`);
    this.hydrateDirectory(resolvedP);
    this.chmodSync(resolvedP, mode);
  }

  async rmdirPromise(p, opts) {
    return this.rmdirSync(p, opts);
  }

  rmdirSync(p, {
    recursive = false
  } = {}) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`rmdir '${p}'`);

    if (recursive) {
      this.removeSync(p);
      return;
    }

    const resolvedP = this.resolveFilename(`rmdir '${p}'`, p);
    const directoryListing = this.listings.get(resolvedP);
    if (!directoryListing) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOTDIR(`rmdir '${p}'`);
    if (directoryListing.size > 0) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOTEMPTY(`rmdir '${p}'`);
    const index = this.entries.get(resolvedP);
    if (typeof index === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EINVAL(`rmdir '${p}'`);
    this.deleteEntry(p, index);
  }

  hydrateDirectory(resolvedP) {
    const index = this.libzip.dir.add(this.zip, _path__WEBPACK_IMPORTED_MODULE_7__.ppath.relative(_path__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, resolvedP));
    if (index === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
    this.registerListing(resolvedP);
    this.registerEntry(resolvedP, index);
    return index;
  }

  async linkPromise(existingP, newP) {
    return this.linkSync(existingP, newP);
  }

  linkSync(existingP, newP) {
    // Zip archives don't support hard links:
    // https://stackoverflow.com/questions/8859616/are-hard-links-possible-within-a-zip-archive
    throw _errors__WEBPACK_IMPORTED_MODULE_8__.EOPNOTSUPP(`link '${existingP}' -> '${newP}'`);
  }

  async symlinkPromise(target, p) {
    return this.symlinkSync(target, p);
  }

  symlinkSync(target, p) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EROFS(`symlink '${target}' -> '${p}'`);
    const resolvedP = this.resolveFilename(`symlink '${target}' -> '${p}'`, p);
    if (this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EISDIR(`symlink '${target}' -> '${p}'`);
    if (this.entries.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EEXIST(`symlink '${target}' -> '${p}'`);
    const index = this.setFileSource(resolvedP, target);
    this.registerEntry(resolvedP, index);
    const rc = this.libzip.file.setExternalAttributes(this.zip, index, 0, 0, this.libzip.ZIP_OPSYS_UNIX, (_constants__WEBPACK_IMPORTED_MODULE_11__.S_IFLNK | 0o777) << 16);
    if (rc === -1) throw this.makeLibzipError(this.libzip.getError(this.zip));
    this.symlinkCount += 1;
  }

  async readFilePromise(p, encoding) {
    // This is messed up regarding the TS signatures
    if (typeof encoding === `object`) // @ts-expect-error
      encoding = encoding ? encoding.encoding : undefined;
    const data = await this.readFileBuffer(p, {
      asyncDecompress: true
    });
    return encoding ? data.toString(encoding) : data;
  }

  readFileSync(p, encoding) {
    // This is messed up regarding the TS signatures
    if (typeof encoding === `object`) // @ts-expect-error
      encoding = encoding ? encoding.encoding : undefined;
    const data = this.readFileBuffer(p);
    return encoding ? data.toString(encoding) : data;
  }

  readFileBuffer(p, opts = {
    asyncDecompress: false
  }) {
    if (typeof p !== `string`) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EBADF(`read`);
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOENT(`open '${p}'`); // Ensures that the last component is a directory, if the user said so (even if it is we'll throw right after with EISDIR anyway)

    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOTDIR(`open '${p}'`);
    if (this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EISDIR(`read`);
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    return this.getFileSource(entry, opts);
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return this.readdirSync(p, {
      withFileTypes: withFileTypes
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    const resolvedP = this.resolveFilename(`scandir '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOENT(`scandir '${p}'`);
    const directoryListing = this.listings.get(resolvedP);
    if (!directoryListing) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOTDIR(`scandir '${p}'`);
    const entries = [...directoryListing];
    if (!withFileTypes) return entries;
    return entries.map(name => {
      return Object.assign(this.statImpl(`lstat`, _path__WEBPACK_IMPORTED_MODULE_7__.ppath.join(p, name)), {
        name
      });
    });
  }

  async readlinkPromise(p) {
    const entry = this.prepareReadlink(p);
    return (await this.getFileSource(entry, {
      asyncDecompress: true
    })).toString();
  }

  readlinkSync(p) {
    const entry = this.prepareReadlink(p);
    return this.getFileSource(entry).toString();
  }

  prepareReadlink(p) {
    const resolvedP = this.resolveFilename(`readlink '${p}'`, p, false);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOENT(`readlink '${p}'`); // Ensure that the last component is a directory (if it is we'll throw right after with EISDIR anyway)

    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.ENOTDIR(`open '${p}'`);
    if (this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EINVAL(`readlink '${p}'`);
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    if (!this.isSymbolicLink(entry)) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EINVAL(`readlink '${p}'`);
    return entry;
  }

  async truncatePromise(p, len = 0) {
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    const index = this.entries.get(resolvedP);
    if (typeof index === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EINVAL(`open '${p}'`);
    const source = await this.getFileSource(index, {
      asyncDecompress: true
    });
    const truncated = Buffer.alloc(len, 0x00);
    source.copy(truncated);
    return await this.writeFilePromise(p, truncated);
  }

  truncateSync(p, len = 0) {
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    const index = this.entries.get(resolvedP);
    if (typeof index === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_8__.EINVAL(`open '${p}'`);
    const source = this.getFileSource(index);
    const truncated = Buffer.alloc(len, 0x00);
    source.copy(truncated);
    return this.writeFileSync(p, truncated);
  }

  watch(p, a, b) {
    let persistent;

    switch (typeof a) {
      case `function`:
      case `string`:
      case `undefined`:
        {
          persistent = true;
        }
        break;

      default:
        {
          ({
            persistent = true
          } = a);
        }
        break;
    }

    if (!persistent) return {
      on: () => {},
      close: () => {}
    };
    const interval = setInterval(() => {}, 24 * 60 * 60 * 1000);
    return {
      on: () => {},
      close: () => {
        clearInterval(interval);
      }
    };
  }

  watchFile(p, a, b) {
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    return (0,_algorithms_watchFile__WEBPACK_IMPORTED_MODULE_9__.watchFile)(this, resolvedP, a, b);
  }

  unwatchFile(p, cb) {
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    return (0,_algorithms_watchFile__WEBPACK_IMPORTED_MODULE_9__.unwatchFile)(this, resolvedP, cb);
  }

}

/***/ }),
/* 164 */
/***/ ((module) => {

"use strict";
module.exports = require("zlib");;

/***/ }),
/* 165 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodeFS": () => /* binding */ NodeFS
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _FakeFS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(160);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(157);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);




class NodeFS extends _FakeFS__WEBPACK_IMPORTED_MODULE_1__.BasePortableFakeFS {
  constructor(realFs = (fs__WEBPACK_IMPORTED_MODULE_0___default())) {
    super();
    this.realFs = realFs; // @ts-expect-error

    if (typeof this.realFs.lutimes !== `undefined`) {
      this.lutimesPromise = this.lutimesPromiseImpl;
      this.lutimesSync = this.lutimesSyncImpl;
    }
  }

  getExtractHint() {
    return false;
  }

  getRealPath() {
    return _path__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root;
  }

  resolve(p) {
    return _path__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(p);
  }

  async openPromise(p, flags, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.open(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
    });
  }

  openSync(p, flags, mode) {
    return this.realFs.openSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), flags, mode);
  }

  async opendirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (typeof opts !== `undefined`) {
        this.realFs.opendir(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.opendir(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    }).then(dir => {
      return Object.defineProperty(dir, `path`, {
        value: p,
        configurable: true,
        writable: true
      });
    });
  }

  opendirSync(p, opts) {
    const dir = typeof opts !== `undefined` ? this.realFs.opendirSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), opts) : this.realFs.opendirSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p));
    return Object.defineProperty(dir, `path`, {
      value: p,
      configurable: true,
      writable: true
    });
  }

  async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
    return await new Promise((resolve, reject) => {
      this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
        if (error) {
          reject(error);
        } else {
          resolve(bytesRead);
        }
      });
    });
  }

  readSync(fd, buffer, offset, length, position) {
    return this.realFs.readSync(fd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    return await new Promise((resolve, reject) => {
      if (typeof buffer === `string`) {
        return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
      } else {
        return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
      }
    });
  }

  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.realFs.writeSync(fd, buffer, offset);
    } else {
      return this.realFs.writeSync(fd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    await new Promise((resolve, reject) => {
      this.realFs.close(fd, this.makeCallback(resolve, reject));
    });
  }

  closeSync(fd) {
    this.realFs.closeSync(fd);
  }

  createReadStream(p, opts) {
    const realPath = p !== null ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;
    return this.realFs.createReadStream(realPath, opts);
  }

  createWriteStream(p, opts) {
    const realPath = p !== null ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;
    return this.realFs.createWriteStream(realPath, opts);
  }

  async realpathPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.realpath(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
    }).then(path => {
      return _path__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path);
    });
  }

  realpathSync(p) {
    return _path__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(this.realFs.realpathSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), {}));
  }

  async existsPromise(p) {
    return await new Promise(resolve => {
      this.realFs.exists(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), resolve);
    });
  }

  accessSync(p, mode) {
    return this.realFs.accessSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), mode);
  }

  async accessPromise(p, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.access(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
    });
  }

  existsSync(p) {
    return this.realFs.existsSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p));
  }

  async statPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.stat(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  statSync(p) {
    return this.realFs.statSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p));
  }

  async lstatPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.lstat(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  lstatSync(p) {
    return this.realFs.lstatSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p));
  }

  async chmodPromise(p, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.chmod(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
    });
  }

  chmodSync(p, mask) {
    return this.realFs.chmodSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), mask);
  }

  async chownPromise(p, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.chown(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), uid, gid, this.makeCallback(resolve, reject));
    });
  }

  chownSync(p, uid, gid) {
    return this.realFs.chownSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), uid, gid);
  }

  async renamePromise(oldP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.rename(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(oldP), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }

  renameSync(oldP, newP) {
    return this.realFs.renameSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(oldP), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(newP));
  }

  async copyFilePromise(sourceP, destP, flags = 0) {
    return await new Promise((resolve, reject) => {
      this.realFs.copyFile(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(sourceP), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
    });
  }

  copyFileSync(sourceP, destP, flags = 0) {
    return this.realFs.copyFileSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(sourceP), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(destP), flags);
  }

  async appendFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;

      if (opts) {
        this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }

  appendFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;

    if (opts) {
      this.realFs.appendFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.appendFileSync(fsNativePath, content);
    }
  }

  async writeFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;

      if (opts) {
        this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }

  writeFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;

    if (opts) {
      this.realFs.writeFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.writeFileSync(fsNativePath, content);
    }
  }

  async unlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.unlink(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  unlinkSync(p) {
    return this.realFs.unlinkSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p));
  }

  async utimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.utimes(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }

  utimesSync(p, atime, mtime) {
    this.realFs.utimesSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), atime, mtime);
  }

  async lutimesPromiseImpl(p, atime, mtime) {
    // @ts-expect-error: Not yet in DefinitelyTyped
    const lutimes = this.realFs.lutimes;
    if (typeof lutimes === `undefined`) throw (0,_errors__WEBPACK_IMPORTED_MODULE_3__.ENOSYS)(`unavailable Node binding`, `lutimes '${p}'`);
    return await new Promise((resolve, reject) => {
      lutimes.call(this.realFs, _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }

  lutimesSyncImpl(p, atime, mtime) {
    // @ts-expect-error: Not yet in DefinitelyTyped
    const lutimesSync = this.realFs.lutimesSync;
    if (typeof lutimesSync === `undefined`) throw (0,_errors__WEBPACK_IMPORTED_MODULE_3__.ENOSYS)(`unavailable Node binding`, `lutimes '${p}'`);
    lutimesSync.call(this.realFs, _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), atime, mtime);
  }

  async mkdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      this.realFs.mkdir(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
    });
  }

  mkdirSync(p, opts) {
    return this.realFs.mkdirSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), opts);
  }

  async rmdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      // TODO: always pass opts when min node version is 12.10+
      if (opts) {
        this.realFs.rmdir(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.rmdir(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }

  rmdirSync(p, opts) {
    return this.realFs.rmdirSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), opts);
  }

  async linkPromise(existingP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.link(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(existingP), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }

  linkSync(existingP, newP) {
    return this.realFs.linkSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(existingP), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(newP));
  }

  async symlinkPromise(target, p, type) {
    const symlinkType = type || (target.endsWith(`/`) ? `dir` : `file`);
    return await new Promise((resolve, reject) => {
      this.realFs.symlink(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(target.replace(/\/+$/, ``)), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), symlinkType, this.makeCallback(resolve, reject));
    });
  }

  symlinkSync(target, p, type) {
    const symlinkType = type || (target.endsWith(`/`) ? `dir` : `file`);
    return this.realFs.symlinkSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(target.replace(/\/+$/, ``)), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), symlinkType);
  }

  async readFilePromise(p, encoding) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;
      this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
    });
  }

  readFileSync(p, encoding) {
    const fsNativePath = typeof p === `string` ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;
    return this.realFs.readFileSync(fsNativePath, encoding);
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return await new Promise((resolve, reject) => {
      if (withFileTypes) {
        this.realFs.readdir(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), {
          withFileTypes: true
        }, this.makeCallback(resolve, reject));
      } else {
        this.realFs.readdir(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(value => resolve(value), reject));
      }
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    if (withFileTypes) {
      return this.realFs.readdirSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), {
        withFileTypes: true
      });
    } else {
      return this.realFs.readdirSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p));
    }
  }

  async readlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.readlink(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    }).then(path => {
      return _path__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path);
    });
  }

  readlinkSync(p) {
    return _path__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(this.realFs.readlinkSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p)));
  }

  async truncatePromise(p, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.truncate(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), len, this.makeCallback(resolve, reject));
    });
  }

  truncateSync(p, len) {
    return this.realFs.truncateSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), len);
  }

  watch(p, a, b) {
    return this.realFs.watch(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), // @ts-expect-error
    a, b);
  }

  watchFile(p, a, b) {
    return this.realFs.watchFile(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), // @ts-expect-error
    a, b);
  }

  unwatchFile(p, cb) {
    return this.realFs.unwatchFile(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), cb);
  }

  makeCallback(resolve, reject) {
    return (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
  }

}

/***/ }),
/* 166 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "watchFile": () => /* binding */ watchFile,
/* harmony export */   "unwatchFile": () => /* binding */ unwatchFile,
/* harmony export */   "unwatchAllFiles": () => /* binding */ unwatchAllFiles
/* harmony export */ });
/* harmony import */ var _watchFile_CustomStatWatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(167);

const statWatchersByFakeFS = new WeakMap();
function watchFile(fakeFs, path, a, b) {
  let bigint;
  let persistent;
  let interval;
  let listener;

  switch (typeof a) {
    case `function`:
      {
        bigint = false;
        persistent = true;
        interval = 5007;
        listener = a;
      }
      break;

    default:
      {
        ({
          bigint = false,
          persistent = true,
          interval = 5007
        } = a);
        listener = b;
      }
      break;
  }

  let statWatchers = statWatchersByFakeFS.get(fakeFs);
  if (typeof statWatchers === `undefined`) statWatchersByFakeFS.set(fakeFs, statWatchers = new Map());
  let statWatcher = statWatchers.get(path);

  if (typeof statWatcher === `undefined`) {
    statWatcher = _watchFile_CustomStatWatcher__WEBPACK_IMPORTED_MODULE_0__.CustomStatWatcher.create(fakeFs, path, {
      bigint
    });
    statWatchers.set(path, statWatcher);
  }

  statWatcher.registerChangeListener(listener, {
    persistent,
    interval
  });
  return statWatcher;
}
function unwatchFile(fakeFs, path, cb) {
  const statWatchers = statWatchersByFakeFS.get(fakeFs);
  if (typeof statWatchers === `undefined`) return;
  const statWatcher = statWatchers.get(path);
  if (typeof statWatcher === `undefined`) return;
  if (typeof cb === `undefined`) statWatcher.unregisterAllChangeListeners();else statWatcher.unregisterChangeListener(cb);

  if (!statWatcher.hasChangeListeners()) {
    statWatcher.stop();
    statWatchers.delete(path);
  }
}
function unwatchAllFiles(fakeFs) {
  const statWatchers = statWatchersByFakeFS.get(fakeFs);
  if (typeof statWatchers === `undefined`) return;

  for (const path of statWatchers.keys()) {
    unwatchFile(fakeFs, path);
  }
}

/***/ }),
/* 167 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Event": () => /* binding */ Event,
/* harmony export */   "Status": () => /* binding */ Status,
/* harmony export */   "assertStatus": () => /* binding */ assertStatus,
/* harmony export */   "CustomStatWatcher": () => /* binding */ CustomStatWatcher
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _statUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(158);


var Event;

(function (Event) {
  Event["Change"] = "change";
  Event["Stop"] = "stop";
})(Event || (Event = {}));

var Status;

(function (Status) {
  Status["Ready"] = "ready";
  Status["Running"] = "running";
  Status["Stopped"] = "stopped";
})(Status || (Status = {}));

function assertStatus(current, expected) {
  if (current !== expected) {
    throw new Error(`Invalid StatWatcher status: expected '${expected}', got '${current}'`);
  }
}
class CustomStatWatcher extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
  constructor(fakeFs, path, {
    bigint = false
  } = {}) {
    super();
    this.status = Status.Ready;
    this.changeListeners = new Map();
    this.startTimeout = null;
    this.fakeFs = fakeFs;
    this.path = path;
    this.bigint = bigint;
    this.lastStats = this.stat();
  }

  static create(fakeFs, path, opts) {
    const statWatcher = new CustomStatWatcher(fakeFs, path, opts);
    statWatcher.start();
    return statWatcher;
  }

  start() {
    assertStatus(this.status, Status.Ready);
    this.status = Status.Running; // Node allows other listeners to be registered up to 3 milliseconds
    // after the watcher has been started, so that's what we're doing too

    this.startTimeout = setTimeout(() => {
      this.startTimeout = null; // Per the Node FS docs:
      // "When an fs.watchFile operation results in an ENOENT error,
      // it will invoke the listener once, with all the fields zeroed
      // (or, for dates, the Unix Epoch)."

      if (!this.fakeFs.existsSync(this.path)) {
        this.emit(Event.Change, this.lastStats, this.lastStats);
      }
    }, 3);
  }

  stop() {
    assertStatus(this.status, Status.Running);
    this.status = Status.Stopped;

    if (this.startTimeout !== null) {
      clearTimeout(this.startTimeout);
      this.startTimeout = null;
    }

    this.emit(Event.Stop);
  }

  stat() {
    try {
      return this.fakeFs.statSync(this.path);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return _statUtils__WEBPACK_IMPORTED_MODULE_1__.makeEmptyStats();
      } else {
        throw error;
      }
    }
  }
  /**
   * Creates an interval whose callback compares the current stats with the previous stats and notifies all listeners in case of changes.
   *
   * @param opts.persistent Decides whether the interval should be immediately unref-ed.
   */


  makeInterval(opts) {
    const interval = setInterval(() => {
      const currentStats = this.stat();
      const previousStats = this.lastStats;
      if (_statUtils__WEBPACK_IMPORTED_MODULE_1__.areStatsEqual(currentStats, previousStats)) return;
      this.lastStats = currentStats;
      this.emit(Event.Change, currentStats, previousStats);
    }, opts.interval);
    return opts.persistent ? interval : interval.unref();
  }
  /**
   * Registers a listener and assigns it an interval.
   */


  registerChangeListener(listener, opts) {
    this.addListener(Event.Change, listener);
    this.changeListeners.set(listener, this.makeInterval(opts));
  }
  /**
   * Unregisters the listener and clears the assigned interval.
   */


  unregisterChangeListener(listener) {
    this.removeListener(Event.Change, listener);
    const interval = this.changeListeners.get(listener);
    if (typeof interval !== `undefined`) clearInterval(interval);
    this.changeListeners.delete(listener);
  }
  /**
   * Unregisters all listeners and clears all assigned intervals.
   */


  unregisterAllChangeListeners() {
    for (const listener of this.changeListeners.keys()) {
      this.unregisterChangeListener(listener);
    }
  }

  hasChangeListeners() {
    return this.changeListeners.size > 0;
  }
  /**
   * Refs all stored intervals.
   */


  ref() {
    for (const interval of this.changeListeners.values()) interval.ref();

    return this;
  }
  /**
   * Unrefs all stored intervals.
   */


  unref() {
    for (const interval of this.changeListeners.values()) interval.unref();

    return this;
  }

}

/***/ }),
/* 168 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AliasFS": () => /* binding */ AliasFS
/* harmony export */ });
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(169);

class AliasFS extends _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__.ProxiedFS {
  constructor(target, {
    baseFs,
    pathUtils
  }) {
    super(pathUtils);
    this.target = target;
    this.baseFs = baseFs;
  }

  getRealPath() {
    return this.target;
  }

  getBaseFs() {
    return this.baseFs;
  }

  mapFromBase(p) {
    return p;
  }

  mapToBase(p) {
    return p;
  }

}

/***/ }),
/* 169 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProxiedFS": () => /* binding */ ProxiedFS
/* harmony export */ });
/* harmony import */ var _FakeFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(160);

class ProxiedFS extends _FakeFS__WEBPACK_IMPORTED_MODULE_0__.FakeFS {
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }

  resolve(path) {
    return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
  }

  getRealPath() {
    return this.mapFromBase(this.baseFs.getRealPath());
  }

  async openPromise(p, flags, mode) {
    return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
  }

  openSync(p, flags, mode) {
    return this.baseFs.openSync(this.mapToBase(p), flags, mode);
  }

  async opendirPromise(p, opts) {
    return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(p), opts), {
      path: p
    });
  }

  opendirSync(p, opts) {
    return Object.assign(this.baseFs.opendirSync(this.mapToBase(p), opts), {
      path: p
    });
  }

  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    return this.baseFs.closePromise(fd);
  }

  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }

  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
  }

  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
  }

  async realpathPromise(p) {
    return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
  }

  realpathSync(p) {
    return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
  }

  async existsPromise(p) {
    return this.baseFs.existsPromise(this.mapToBase(p));
  }

  existsSync(p) {
    return this.baseFs.existsSync(this.mapToBase(p));
  }

  accessSync(p, mode) {
    return this.baseFs.accessSync(this.mapToBase(p), mode);
  }

  async accessPromise(p, mode) {
    return this.baseFs.accessPromise(this.mapToBase(p), mode);
  }

  async statPromise(p) {
    return this.baseFs.statPromise(this.mapToBase(p));
  }

  statSync(p) {
    return this.baseFs.statSync(this.mapToBase(p));
  }

  async lstatPromise(p) {
    return this.baseFs.lstatPromise(this.mapToBase(p));
  }

  lstatSync(p) {
    return this.baseFs.lstatSync(this.mapToBase(p));
  }

  async chmodPromise(p, mask) {
    return this.baseFs.chmodPromise(this.mapToBase(p), mask);
  }

  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.mapToBase(p), mask);
  }

  async chownPromise(p, uid, gid) {
    return this.baseFs.chownPromise(this.mapToBase(p), uid, gid);
  }

  chownSync(p, uid, gid) {
    return this.baseFs.chownSync(this.mapToBase(p), uid, gid);
  }

  async renamePromise(oldP, newP) {
    return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
  }

  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
  }

  async copyFilePromise(sourceP, destP, flags = 0) {
    return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }

  copyFileSync(sourceP, destP, flags = 0) {
    return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }

  async appendFilePromise(p, content, opts) {
    return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
  }

  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
  }

  async writeFilePromise(p, content, opts) {
    return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
  }

  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
  }

  async unlinkPromise(p) {
    return this.baseFs.unlinkPromise(this.mapToBase(p));
  }

  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.mapToBase(p));
  }

  async utimesPromise(p, atime, mtime) {
    return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
  }

  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
  }

  async mkdirPromise(p, opts) {
    return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
  }

  mkdirSync(p, opts) {
    return this.baseFs.mkdirSync(this.mapToBase(p), opts);
  }

  async rmdirPromise(p, opts) {
    return this.baseFs.rmdirPromise(this.mapToBase(p), opts);
  }

  rmdirSync(p, opts) {
    return this.baseFs.rmdirSync(this.mapToBase(p), opts);
  }

  async linkPromise(existingP, newP) {
    return this.baseFs.linkPromise(this.mapToBase(existingP), this.mapToBase(newP));
  }

  linkSync(existingP, newP) {
    return this.baseFs.linkSync(this.mapToBase(existingP), this.mapToBase(newP));
  }

  async symlinkPromise(target, p, type) {
    return this.baseFs.symlinkPromise(this.mapToBase(target), this.mapToBase(p), type);
  }

  symlinkSync(target, p, type) {
    return this.baseFs.symlinkSync(this.mapToBase(target), this.mapToBase(p), type);
  }

  async readFilePromise(p, encoding) {
    // This weird condition is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    if (encoding === `utf8`) {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    }
  }

  readFileSync(p, encoding) {
    // This weird condition is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    if (encoding === `utf8`) {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    }
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return this.baseFs.readdirPromise(this.mapToBase(p), {
      withFileTypes: withFileTypes
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    return this.baseFs.readdirSync(this.mapToBase(p), {
      withFileTypes: withFileTypes
    });
  }

  async readlinkPromise(p) {
    return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
  }

  readlinkSync(p) {
    return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
  }

  async truncatePromise(p, len) {
    return this.baseFs.truncatePromise(this.mapToBase(p), len);
  }

  truncateSync(p, len) {
    return this.baseFs.truncateSync(this.mapToBase(p), len);
  }

  watch(p, a, b) {
    return this.baseFs.watch(this.mapToBase(p), // @ts-expect-error
    a, b);
  }

  watchFile(p, a, b) {
    return this.baseFs.watchFile(this.mapToBase(p), // @ts-expect-error
    a, b);
  }

  unwatchFile(p, cb) {
    return this.baseFs.unwatchFile(this.mapToBase(p), cb);
  }

  fsMapToBase(p) {
    if (typeof p === `number`) {
      return p;
    } else {
      return this.mapToBase(p);
    }
  }

}

/***/ }),
/* 170 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CwdFS": () => /* binding */ CwdFS
/* harmony export */ });
/* harmony import */ var _NodeFS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(165);
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(169);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);



class CwdFS extends _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__.ProxiedFS {
  constructor(target, {
    baseFs = new _NodeFS__WEBPACK_IMPORTED_MODULE_1__.NodeFS()
  } = {}) {
    super(_path__WEBPACK_IMPORTED_MODULE_2__.ppath);
    this.target = this.pathUtils.normalize(target);
    this.baseFs = baseFs;
  }

  getRealPath() {
    return this.pathUtils.resolve(this.baseFs.getRealPath(), this.target);
  }

  resolve(p) {
    if (this.pathUtils.isAbsolute(p)) {
      return _path__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(p);
    } else {
      return this.baseFs.resolve(_path__WEBPACK_IMPORTED_MODULE_2__.ppath.join(this.target, p));
    }
  }

  mapFromBase(path) {
    return path;
  }

  mapToBase(path) {
    if (this.pathUtils.isAbsolute(path)) {
      return path;
    } else {
      return this.pathUtils.join(this.target, path);
    }
  }

}

/***/ }),
/* 171 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JailFS": () => /* binding */ JailFS
/* harmony export */ });
/* harmony import */ var _NodeFS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(165);
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(169);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(162);



const JAIL_ROOT = _path__WEBPACK_IMPORTED_MODULE_0__.PortablePath.root;
class JailFS extends _ProxiedFS__WEBPACK_IMPORTED_MODULE_1__.ProxiedFS {
  constructor(target, {
    baseFs = new _NodeFS__WEBPACK_IMPORTED_MODULE_2__.NodeFS()
  } = {}) {
    super(_path__WEBPACK_IMPORTED_MODULE_0__.ppath);
    this.target = this.pathUtils.resolve(_path__WEBPACK_IMPORTED_MODULE_0__.PortablePath.root, target);
    this.baseFs = baseFs;
  }

  getRealPath() {
    return this.pathUtils.resolve(this.baseFs.getRealPath(), this.pathUtils.relative(_path__WEBPACK_IMPORTED_MODULE_0__.PortablePath.root, this.target));
  }

  getTarget() {
    return this.target;
  }

  getBaseFs() {
    return this.baseFs;
  }

  mapToBase(p) {
    const normalized = this.pathUtils.normalize(p);
    if (this.pathUtils.isAbsolute(p)) return this.pathUtils.resolve(this.target, this.pathUtils.relative(JAIL_ROOT, p));
    if (normalized.match(/^\.\.\/?/)) throw new Error(`Resolving this path (${p}) would escape the jail`);
    return this.pathUtils.resolve(this.target, p);
  }

  mapFromBase(p) {
    return this.pathUtils.resolve(JAIL_ROOT, this.pathUtils.relative(this.target, p));
  }

}

/***/ }),
/* 172 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LazyFS": () => /* binding */ LazyFS
/* harmony export */ });
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(169);

class LazyFS extends _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__.ProxiedFS {
  constructor(factory, pathUtils) {
    super(pathUtils);
    this.instance = null;
    this.factory = factory;
  }

  get baseFs() {
    if (!this.instance) this.instance = this.factory();
    return this.instance;
  }

  set baseFs(value) {
    this.instance = value;
  }

  mapFromBase(p) {
    return p;
  }

  mapToBase(p) {
    return p;
  }

}

/***/ }),
/* 173 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NoFS": () => /* binding */ NoFS
/* harmony export */ });
/* harmony import */ var _FakeFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(160);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(162);



const makeError = () => Object.assign(new Error(`ENOSYS: unsupported filesystem access`), {
  code: `ENOSYS`
});

class NoFS extends _FakeFS__WEBPACK_IMPORTED_MODULE_0__.FakeFS {
  constructor() {
    super(_path__WEBPACK_IMPORTED_MODULE_1__.ppath);
  }

  getExtractHint() {
    throw makeError();
  }

  getRealPath() {
    throw makeError();
  }

  resolve() {
    throw makeError();
  }

  async openPromise() {
    throw makeError();
  }

  openSync() {
    throw makeError();
  }

  async opendirPromise() {
    throw makeError();
  }

  opendirSync() {
    throw makeError();
  }

  async readPromise() {
    throw makeError();
  }

  readSync() {
    throw makeError();
  }

  async writePromise() {
    throw makeError();
  }

  writeSync() {
    throw makeError();
  }

  async closePromise() {
    throw makeError();
  }

  closeSync() {
    throw makeError();
  }

  createWriteStream() {
    throw makeError();
  }

  createReadStream() {
    throw makeError();
  }

  async realpathPromise() {
    throw makeError();
  }

  realpathSync() {
    throw makeError();
  }

  async readdirPromise() {
    throw makeError();
  }

  readdirSync() {
    throw makeError();
  }

  async existsPromise(p) {
    throw makeError();
  }

  existsSync(p) {
    throw makeError();
  }

  async accessPromise() {
    throw makeError();
  }

  accessSync() {
    throw makeError();
  }

  async statPromise() {
    throw makeError();
  }

  statSync() {
    throw makeError();
  }

  async lstatPromise(p) {
    throw makeError();
  }

  lstatSync(p) {
    throw makeError();
  }

  async chmodPromise() {
    throw makeError();
  }

  chmodSync() {
    throw makeError();
  }

  async chownPromise() {
    throw makeError();
  }

  chownSync() {
    throw makeError();
  }

  async mkdirPromise() {
    throw makeError();
  }

  mkdirSync() {
    throw makeError();
  }

  async rmdirPromise() {
    throw makeError();
  }

  rmdirSync() {
    throw makeError();
  }

  async linkPromise() {
    throw makeError();
  }

  linkSync() {
    throw makeError();
  }

  async symlinkPromise() {
    throw makeError();
  }

  symlinkSync() {
    throw makeError();
  }

  async renamePromise() {
    throw makeError();
  }

  renameSync() {
    throw makeError();
  }

  async copyFilePromise() {
    throw makeError();
  }

  copyFileSync() {
    throw makeError();
  }

  async appendFilePromise() {
    throw makeError();
  }

  appendFileSync() {
    throw makeError();
  }

  async writeFilePromise() {
    throw makeError();
  }

  writeFileSync() {
    throw makeError();
  }

  async unlinkPromise() {
    throw makeError();
  }

  unlinkSync() {
    throw makeError();
  }

  async utimesPromise() {
    throw makeError();
  }

  utimesSync() {
    throw makeError();
  }

  async readFilePromise() {
    throw makeError();
  }

  readFileSync() {
    throw makeError();
  }

  async readlinkPromise() {
    throw makeError();
  }

  readlinkSync() {
    throw makeError();
  }

  async truncatePromise() {
    throw makeError();
  }

  truncateSync() {
    throw makeError();
  }

  watch() {
    throw makeError();
  }

  watchFile() {
    throw makeError();
  }

  unwatchFile() {
    throw makeError();
  }

}
NoFS.instance = new NoFS();

/***/ }),
/* 174 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PosixFS": () => /* binding */ PosixFS
/* harmony export */ });
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(169);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(162);


class PosixFS extends _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__.ProxiedFS {
  constructor(baseFs) {
    super(_path__WEBPACK_IMPORTED_MODULE_1__.npath);
    this.baseFs = baseFs;
  }

  mapFromBase(path) {
    return _path__WEBPACK_IMPORTED_MODULE_1__.npath.fromPortablePath(path);
  }

  mapToBase(path) {
    return _path__WEBPACK_IMPORTED_MODULE_1__.npath.toPortablePath(path);
  }

}

/***/ }),
/* 175 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VirtualFS": () => /* binding */ VirtualFS
/* harmony export */ });
/* harmony import */ var _NodeFS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(165);
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(169);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);



const NUMBER_REGEXP = /^[0-9]+$/; // $0: full path
// $1: virtual folder
// $2: virtual segment
// $3: hash
// $4: depth
// $5: subpath

const VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?\$\$virtual)((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
const VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;
class VirtualFS extends _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__.ProxiedFS {
  constructor({
    baseFs = new _NodeFS__WEBPACK_IMPORTED_MODULE_1__.NodeFS()
  } = {}) {
    super(_path__WEBPACK_IMPORTED_MODULE_2__.ppath);
    this.baseFs = baseFs;
  }

  static makeVirtualPath(base, component, to) {
    if (_path__WEBPACK_IMPORTED_MODULE_2__.ppath.basename(base) !== `$$virtual`) throw new Error(`Assertion failed: Virtual folders must be named "$$virtual"`);
    if (!_path__WEBPACK_IMPORTED_MODULE_2__.ppath.basename(component).match(VALID_COMPONENT)) throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`); // Obtains the relative distance between the virtual path and its actual target

    const target = _path__WEBPACK_IMPORTED_MODULE_2__.ppath.relative(_path__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(base), to);
    const segments = target.split(`/`); // Counts how many levels we need to go back to start applying the rest of the path

    let depth = 0;

    while (depth < segments.length && segments[depth] === `..`) depth += 1;

    const finalSegments = segments.slice(depth);
    const fullVirtualPath = _path__WEBPACK_IMPORTED_MODULE_2__.ppath.join(base, component, String(depth), ...finalSegments);
    return fullVirtualPath;
  }

  static resolveVirtual(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match || !match[3] && match[5]) return p;
    const target = _path__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(match[1]);
    if (!match[3] || !match[4]) return target;
    const isnum = NUMBER_REGEXP.test(match[4]);
    if (!isnum) return p;
    const depth = Number(match[4]);
    const backstep = `../`.repeat(depth);
    const subpath = match[5] || `.`;
    return VirtualFS.resolveVirtual(_path__WEBPACK_IMPORTED_MODULE_2__.ppath.join(target, backstep, subpath));
  }

  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }

  getRealPath() {
    return this.baseFs.getRealPath();
  }

  realpathSync(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match) return this.baseFs.realpathSync(p);
    if (!match[5]) return p;
    const realpath = this.baseFs.realpathSync(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }

  async realpathPromise(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match) return await this.baseFs.realpathPromise(p);
    if (!match[5]) return p;
    const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }

  mapToBase(p) {
    return VirtualFS.resolveVirtual(p);
  }

  mapFromBase(p) {
    return p;
  }

}

/***/ }),
/* 176 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ZipOpenFS": () => /* binding */ ZipOpenFS
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _FakeFS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(160);
/* harmony import */ var _NodeFS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(165);
/* harmony import */ var _ZipFS__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(163);
/* harmony import */ var _algorithms_watchFile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(166);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(162);






const ZIP_FD = 0x80000000;
const FILE_PARTS_REGEX = /.*?(?<!\/)\.zip(?=\/|$)/;
class ZipOpenFS extends _FakeFS__WEBPACK_IMPORTED_MODULE_1__.BasePortableFakeFS {
  constructor({
    libzip,
    baseFs = new _NodeFS__WEBPACK_IMPORTED_MODULE_2__.NodeFS(),
    filter = null,
    maxOpenFiles = Infinity,
    readOnlyArchives = false,
    useCache = true,
    maxAge = 5000
  }) {
    super();
    this.fdMap = new Map();
    this.nextFd = 3;
    this.isZip = new Set();
    this.notZip = new Set();
    this.realPaths = new Map();
    this.limitOpenFilesTimeout = null;
    this.libzip = libzip;
    this.baseFs = baseFs;
    this.zipInstances = useCache ? new Map() : null;
    this.filter = filter;
    this.maxOpenFiles = maxOpenFiles;
    this.readOnlyArchives = readOnlyArchives;
    this.maxAge = maxAge;
  }

  static async openPromise(fn, opts) {
    const zipOpenFs = new ZipOpenFS(opts);

    try {
      return await fn(zipOpenFs);
    } finally {
      zipOpenFs.saveAndClose();
    }
  }

  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }

  getRealPath() {
    return this.baseFs.getRealPath();
  }

  saveAndClose() {
    (0,_algorithms_watchFile__WEBPACK_IMPORTED_MODULE_3__.unwatchAllFiles)(this);

    if (this.zipInstances) {
      for (const [path, {
        zipFs
      }] of this.zipInstances.entries()) {
        zipFs.saveAndClose();
        this.zipInstances.delete(path);
      }
    }
  }

  discardAndClose() {
    (0,_algorithms_watchFile__WEBPACK_IMPORTED_MODULE_3__.unwatchAllFiles)(this);

    if (this.zipInstances) {
      for (const [path, {
        zipFs
      }] of this.zipInstances.entries()) {
        zipFs.discardAndClose();
        this.zipInstances.delete(path);
      }
    }
  }

  resolve(p) {
    return this.baseFs.resolve(p);
  }

  remapFd(zipFs, fd) {
    const remappedFd = this.nextFd++ | ZIP_FD;
    this.fdMap.set(remappedFd, [zipFs, fd]);
    return remappedFd;
  }

  async openPromise(p, flags, mode) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.openPromise(p, flags, mode);
    }, async (zipFs, {
      subPath
    }) => {
      return this.remapFd(zipFs, await zipFs.openPromise(subPath, flags, mode));
    });
  }

  openSync(p, flags, mode) {
    return this.makeCallSync(p, () => {
      return this.baseFs.openSync(p, flags, mode);
    }, (zipFs, {
      subPath
    }) => {
      return this.remapFd(zipFs, zipFs.openSync(subPath, flags, mode));
    });
  }

  async opendirPromise(p, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.opendirPromise(p, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.opendirPromise(subPath, opts);
    }, {
      requireSubpath: false
    });
  }

  opendirSync(p, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.opendirSync(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.opendirSync(subPath, opts);
    }, {
      requireSubpath: false
    });
  }

  async readPromise(fd, buffer, offset, length, position) {
    if ((fd & ZIP_FD) === 0) return await this.baseFs.readPromise(fd, buffer, offset, length, position);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, read`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;
    return await zipFs.readPromise(realFd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset, length, position) {
    if ((fd & ZIP_FD) === 0) return this.baseFs.readSync(fd, buffer, offset, length, position);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, read`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;
    return zipFs.readSync(realFd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    if ((fd & ZIP_FD) === 0) {
      if (typeof buffer === `string`) {
        return await this.baseFs.writePromise(fd, buffer, offset);
      } else {
        return await this.baseFs.writePromise(fd, buffer, offset, length, position);
      }
    }

    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, write`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;

    if (typeof buffer === `string`) {
      return await zipFs.writePromise(realFd, buffer, offset);
    } else {
      return await zipFs.writePromise(realFd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    if ((fd & ZIP_FD) === 0) {
      if (typeof buffer === `string`) {
        return this.baseFs.writeSync(fd, buffer, offset);
      } else {
        return this.baseFs.writeSync(fd, buffer, offset, length, position);
      }
    }

    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, write`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;

    if (typeof buffer === `string`) {
      return zipFs.writeSync(realFd, buffer, offset);
    } else {
      return zipFs.writeSync(realFd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    if ((fd & ZIP_FD) === 0) return await this.baseFs.closePromise(fd);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, close`), {
      code: `EBADF`
    });
    this.fdMap.delete(fd);
    const [zipFs, realFd] = entry;
    return await zipFs.closePromise(realFd);
  }

  closeSync(fd) {
    if ((fd & ZIP_FD) === 0) return this.baseFs.closeSync(fd);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, close`), {
      code: `EBADF`
    });
    this.fdMap.delete(fd);
    const [zipFs, realFd] = entry;
    return zipFs.closeSync(realFd);
  }

  createReadStream(p, opts) {
    if (p === null) return this.baseFs.createReadStream(p, opts);
    return this.makeCallSync(p, () => {
      return this.baseFs.createReadStream(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.createReadStream(subPath, opts);
    });
  }

  createWriteStream(p, opts) {
    if (p === null) return this.baseFs.createWriteStream(p, opts);
    return this.makeCallSync(p, () => {
      return this.baseFs.createWriteStream(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.createWriteStream(subPath, opts);
    });
  }

  async realpathPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.realpathPromise(p);
    }, async (zipFs, {
      archivePath,
      subPath
    }) => {
      let realArchivePath = this.realPaths.get(archivePath);

      if (typeof realArchivePath === `undefined`) {
        realArchivePath = await this.baseFs.realpathPromise(archivePath);
        this.realPaths.set(archivePath, realArchivePath);
      }

      return this.pathUtils.join(realArchivePath, this.pathUtils.relative(_path__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, await zipFs.realpathPromise(subPath)));
    });
  }

  realpathSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.realpathSync(p);
    }, (zipFs, {
      archivePath,
      subPath
    }) => {
      let realArchivePath = this.realPaths.get(archivePath);

      if (typeof realArchivePath === `undefined`) {
        realArchivePath = this.baseFs.realpathSync(archivePath);
        this.realPaths.set(archivePath, realArchivePath);
      }

      return this.pathUtils.join(realArchivePath, this.pathUtils.relative(_path__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, zipFs.realpathSync(subPath)));
    });
  }

  async existsPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.existsPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.existsPromise(subPath);
    });
  }

  existsSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.existsSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.existsSync(subPath);
    });
  }

  async accessPromise(p, mode) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.accessPromise(p, mode);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.accessPromise(subPath, mode);
    });
  }

  accessSync(p, mode) {
    return this.makeCallSync(p, () => {
      return this.baseFs.accessSync(p, mode);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.accessSync(subPath, mode);
    });
  }

  async statPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.statPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.statPromise(subPath);
    });
  }

  statSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.statSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.statSync(subPath);
    });
  }

  async lstatPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.lstatPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.lstatPromise(subPath);
    });
  }

  lstatSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.lstatSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.lstatSync(subPath);
    });
  }

  async chmodPromise(p, mask) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.chmodPromise(p, mask);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.chmodPromise(subPath, mask);
    });
  }

  chmodSync(p, mask) {
    return this.makeCallSync(p, () => {
      return this.baseFs.chmodSync(p, mask);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.chmodSync(subPath, mask);
    });
  }

  async chownPromise(p, uid, gid) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.chownPromise(p, uid, gid);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.chownPromise(subPath, uid, gid);
    });
  }

  chownSync(p, uid, gid) {
    return this.makeCallSync(p, () => {
      return this.baseFs.chownSync(p, uid, gid);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.chownSync(subPath, uid, gid);
    });
  }

  async renamePromise(oldP, newP) {
    return await this.makeCallPromise(oldP, async () => {
      return await this.makeCallPromise(newP, async () => {
        return await this.baseFs.renamePromise(oldP, newP);
      }, async () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      });
    }, async (zipFsO, {
      subPath: subPathO
    }) => {
      return await this.makeCallPromise(newP, async () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      }, async (zipFsN, {
        subPath: subPathN
      }) => {
        if (zipFsO !== zipFsN) {
          throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
            code: `EEXDEV`
          });
        } else {
          return await zipFsO.renamePromise(subPathO, subPathN);
        }
      });
    });
  }

  renameSync(oldP, newP) {
    return this.makeCallSync(oldP, () => {
      return this.makeCallSync(newP, () => {
        return this.baseFs.renameSync(oldP, newP);
      }, async () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      });
    }, (zipFsO, {
      subPath: subPathO
    }) => {
      return this.makeCallSync(newP, () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      }, (zipFsN, {
        subPath: subPathN
      }) => {
        if (zipFsO !== zipFsN) {
          throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
            code: `EEXDEV`
          });
        } else {
          return zipFsO.renameSync(subPathO, subPathN);
        }
      });
    });
  }

  async copyFilePromise(sourceP, destP, flags = 0) {
    const fallback = async (sourceFs, sourceP, destFs, destP) => {
      if ((flags & fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_FICLONE_FORCE) !== 0) throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP}' -> ${destP}'`), {
        code: `EXDEV`
      });
      if (flags & fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_EXCL && (await this.existsPromise(sourceP))) throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP}' -> '${destP}'`), {
        code: `EEXIST`
      });
      let content;

      try {
        content = await sourceFs.readFilePromise(sourceP);
      } catch (error) {
        throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP}' -> '${destP}'`), {
          code: `EINVAL`
        });
      }

      await destFs.writeFilePromise(destP, content);
    };

    return await this.makeCallPromise(sourceP, async () => {
      return await this.makeCallPromise(destP, async () => {
        return await this.baseFs.copyFilePromise(sourceP, destP, flags);
      }, async (zipFsD, {
        subPath: subPathD
      }) => {
        return await fallback(this.baseFs, sourceP, zipFsD, subPathD);
      });
    }, async (zipFsS, {
      subPath: subPathS
    }) => {
      return await this.makeCallPromise(destP, async () => {
        return await fallback(zipFsS, subPathS, this.baseFs, destP);
      }, async (zipFsD, {
        subPath: subPathD
      }) => {
        if (zipFsS !== zipFsD) {
          return await fallback(zipFsS, subPathS, zipFsD, subPathD);
        } else {
          return await zipFsS.copyFilePromise(subPathS, subPathD, flags);
        }
      });
    });
  }

  copyFileSync(sourceP, destP, flags = 0) {
    const fallback = (sourceFs, sourceP, destFs, destP) => {
      if ((flags & fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_FICLONE_FORCE) !== 0) throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP}' -> ${destP}'`), {
        code: `EXDEV`
      });
      if (flags & fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_EXCL && this.existsSync(sourceP)) throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP}' -> '${destP}'`), {
        code: `EEXIST`
      });
      let content;

      try {
        content = sourceFs.readFileSync(sourceP);
      } catch (error) {
        throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP}' -> '${destP}'`), {
          code: `EINVAL`
        });
      }

      destFs.writeFileSync(destP, content);
    };

    return this.makeCallSync(sourceP, () => {
      return this.makeCallSync(destP, () => {
        return this.baseFs.copyFileSync(sourceP, destP, flags);
      }, (zipFsD, {
        subPath: subPathD
      }) => {
        return fallback(this.baseFs, sourceP, zipFsD, subPathD);
      });
    }, (zipFsS, {
      subPath: subPathS
    }) => {
      return this.makeCallSync(destP, () => {
        return fallback(zipFsS, subPathS, this.baseFs, destP);
      }, (zipFsD, {
        subPath: subPathD
      }) => {
        if (zipFsS !== zipFsD) {
          return fallback(zipFsS, subPathS, zipFsD, subPathD);
        } else {
          return zipFsS.copyFileSync(subPathS, subPathD, flags);
        }
      });
    });
  }

  async appendFilePromise(p, content, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.appendFilePromise(p, content, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.appendFilePromise(subPath, content, opts);
    });
  }

  appendFileSync(p, content, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.appendFileSync(p, content, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.appendFileSync(subPath, content, opts);
    });
  }

  async writeFilePromise(p, content, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.writeFilePromise(p, content, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.writeFilePromise(subPath, content, opts);
    });
  }

  writeFileSync(p, content, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.writeFileSync(p, content, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.writeFileSync(subPath, content, opts);
    });
  }

  async unlinkPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.unlinkPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.unlinkPromise(subPath);
    });
  }

  unlinkSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.unlinkSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.unlinkSync(subPath);
    });
  }

  async utimesPromise(p, atime, mtime) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.utimesPromise(p, atime, mtime);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.utimesPromise(subPath, atime, mtime);
    });
  }

  utimesSync(p, atime, mtime) {
    return this.makeCallSync(p, () => {
      return this.baseFs.utimesSync(p, atime, mtime);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.utimesSync(subPath, atime, mtime);
    });
  }

  async mkdirPromise(p, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.mkdirPromise(p, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.mkdirPromise(subPath, opts);
    });
  }

  mkdirSync(p, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.mkdirSync(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.mkdirSync(subPath, opts);
    });
  }

  async rmdirPromise(p, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.rmdirPromise(p, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.rmdirPromise(subPath, opts);
    });
  }

  rmdirSync(p, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.rmdirSync(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.rmdirSync(subPath, opts);
    });
  }

  async linkPromise(existingP, newP) {
    return await this.makeCallPromise(newP, async () => {
      return await this.baseFs.linkPromise(existingP, newP);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.linkPromise(existingP, subPath);
    });
  }

  linkSync(existingP, newP) {
    return this.makeCallSync(newP, () => {
      return this.baseFs.linkSync(existingP, newP);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.linkSync(existingP, subPath);
    });
  }

  async symlinkPromise(target, p, type) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.symlinkPromise(target, p, type);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.symlinkPromise(target, subPath);
    });
  }

  symlinkSync(target, p, type) {
    return this.makeCallSync(p, () => {
      return this.baseFs.symlinkSync(target, p, type);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.symlinkSync(target, subPath);
    });
  }

  async readFilePromise(p, encoding) {
    return this.makeCallPromise(p, async () => {
      // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
      switch (encoding) {
        case `utf8`:
          return await this.baseFs.readFilePromise(p, encoding);

        default:
          return await this.baseFs.readFilePromise(p, encoding);
      }
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.readFilePromise(subPath, encoding);
    });
  }

  readFileSync(p, encoding) {
    return this.makeCallSync(p, () => {
      // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
      switch (encoding) {
        case `utf8`:
          return this.baseFs.readFileSync(p, encoding);

        default:
          return this.baseFs.readFileSync(p, encoding);
      }
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.readFileSync(subPath, encoding);
    });
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.readdirPromise(p, {
        withFileTypes: withFileTypes
      });
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.readdirPromise(subPath, {
        withFileTypes: withFileTypes
      });
    }, {
      requireSubpath: false
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    return this.makeCallSync(p, () => {
      return this.baseFs.readdirSync(p, {
        withFileTypes: withFileTypes
      });
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.readdirSync(subPath, {
        withFileTypes: withFileTypes
      });
    }, {
      requireSubpath: false
    });
  }

  async readlinkPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.readlinkPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.readlinkPromise(subPath);
    });
  }

  readlinkSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.readlinkSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.readlinkSync(subPath);
    });
  }

  async truncatePromise(p, len) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.truncatePromise(p, len);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.truncatePromise(subPath, len);
    });
  }

  truncateSync(p, len) {
    return this.makeCallSync(p, () => {
      return this.baseFs.truncateSync(p, len);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.truncateSync(subPath, len);
    });
  }

  watch(p, a, b) {
    return this.makeCallSync(p, () => {
      return this.baseFs.watch(p, // @ts-expect-error
      a, b);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.watch(subPath, // @ts-expect-error
      a, b);
    });
  }

  watchFile(p, a, b) {
    return this.makeCallSync(p, () => {
      return this.baseFs.watchFile(p, // @ts-expect-error
      a, b);
    }, () => {
      return (0,_algorithms_watchFile__WEBPACK_IMPORTED_MODULE_3__.watchFile)(this, p, a, b);
    });
  }

  unwatchFile(p, cb) {
    return this.makeCallSync(p, () => {
      return this.baseFs.unwatchFile(p, cb);
    }, () => {
      return (0,_algorithms_watchFile__WEBPACK_IMPORTED_MODULE_3__.unwatchFile)(this, p, cb);
    });
  }

  async makeCallPromise(p, discard, accept, {
    requireSubpath = true
  } = {}) {
    if (typeof p !== `string`) return await discard();
    const normalizedP = this.resolve(p);
    const zipInfo = this.findZip(normalizedP);
    if (!zipInfo) return await discard();
    if (requireSubpath && zipInfo.subPath === `/`) return await discard();
    return await this.getZipPromise(zipInfo.archivePath, async zipFs => await accept(zipFs, zipInfo));
  }

  makeCallSync(p, discard, accept, {
    requireSubpath = true
  } = {}) {
    if (typeof p !== `string`) return discard();
    const normalizedP = this.resolve(p);
    const zipInfo = this.findZip(normalizedP);
    if (!zipInfo) return discard();
    if (requireSubpath && zipInfo.subPath === `/`) return discard();
    return this.getZipSync(zipInfo.archivePath, zipFs => accept(zipFs, zipInfo));
  }

  findZip(p) {
    if (this.filter && !this.filter.test(p)) return null;
    let filePath = ``;

    while (true) {
      const parts = FILE_PARTS_REGEX.exec(p.substr(filePath.length));
      if (!parts) return null;
      filePath = this.pathUtils.join(filePath, parts[0]);

      if (this.isZip.has(filePath) === false) {
        if (this.notZip.has(filePath)) continue;

        try {
          if (!this.baseFs.lstatSync(filePath).isFile()) {
            this.notZip.add(filePath);
            continue;
          }
        } catch (_a) {
          return null;
        }

        this.isZip.add(filePath);
      }

      return {
        archivePath: filePath,
        subPath: this.pathUtils.join(_path__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, p.substr(filePath.length))
      };
    }
  }

  limitOpenFiles(max) {
    if (this.zipInstances === null) return;
    const now = Date.now();
    let nextExpiresAt = now + this.maxAge;
    let closeCount = max === null ? 0 : this.zipInstances.size - max;

    for (const [path, {
      zipFs,
      expiresAt,
      refCount
    }] of this.zipInstances.entries()) {
      if (refCount !== 0 || zipFs.hasOpenFileHandles()) {
        continue;
      } else if (now >= expiresAt) {
        zipFs.saveAndClose();
        this.zipInstances.delete(path);
        closeCount -= 1;
        continue;
      } else if (max === null || closeCount <= 0) {
        nextExpiresAt = expiresAt;
        break;
      }

      zipFs.saveAndClose();
      this.zipInstances.delete(path);
      closeCount -= 1;
    }

    if (this.limitOpenFilesTimeout === null && (max === null && this.zipInstances.size > 0 || max !== null)) {
      this.limitOpenFilesTimeout = setTimeout(() => {
        this.limitOpenFilesTimeout = null;
        this.limitOpenFiles(null);
      }, nextExpiresAt - now).unref();
    }
  }

  async getZipPromise(p, accept) {
    const getZipOptions = async () => ({
      baseFs: this.baseFs,
      libzip: this.libzip,
      readOnly: this.readOnlyArchives,
      stats: await this.baseFs.statPromise(p)
    });

    if (this.zipInstances) {
      let cachedZipFs = this.zipInstances.get(p);

      if (!cachedZipFs) {
        const zipOptions = await getZipOptions(); // We need to recheck because concurrent getZipPromise calls may
        // have instantiated the zip archive while we were waiting

        cachedZipFs = this.zipInstances.get(p);

        if (!cachedZipFs) {
          cachedZipFs = {
            zipFs: new _ZipFS__WEBPACK_IMPORTED_MODULE_5__.ZipFS(p, zipOptions),
            expiresAt: 0,
            refCount: 0
          };
        }
      } // Removing then re-adding the field allows us to easily implement
      // a basic LRU garbage collection strategy


      this.zipInstances.delete(p);
      this.limitOpenFiles(this.maxOpenFiles - 1);
      this.zipInstances.set(p, cachedZipFs);
      cachedZipFs.expiresAt = Date.now() + this.maxAge;
      cachedZipFs.refCount += 1;

      try {
        return await accept(cachedZipFs.zipFs);
      } finally {
        cachedZipFs.refCount -= 1;
      }
    } else {
      const zipFs = new _ZipFS__WEBPACK_IMPORTED_MODULE_5__.ZipFS(p, await getZipOptions());

      try {
        return await accept(zipFs);
      } finally {
        zipFs.saveAndClose();
      }
    }
  }

  getZipSync(p, accept) {
    const getZipOptions = () => ({
      baseFs: this.baseFs,
      libzip: this.libzip,
      readOnly: this.readOnlyArchives,
      stats: this.baseFs.statSync(p)
    });

    if (this.zipInstances) {
      let cachedZipFs = this.zipInstances.get(p);

      if (!cachedZipFs) {
        cachedZipFs = {
          zipFs: new _ZipFS__WEBPACK_IMPORTED_MODULE_5__.ZipFS(p, getZipOptions()),
          expiresAt: 0,
          refCount: 0
        };
      } // Removing then re-adding the field allows us to easily implement
      // a basic LRU garbage collection strategy


      this.zipInstances.delete(p);
      this.limitOpenFiles(this.maxOpenFiles - 1);
      this.zipInstances.set(p, cachedZipFs);
      cachedZipFs.expiresAt = Date.now() + this.maxAge;
      return accept(cachedZipFs.zipFs);
    } else {
      const zipFs = new _ZipFS__WEBPACK_IMPORTED_MODULE_5__.ZipFS(p, getZipOptions());

      try {
        return accept(zipFs);
      } finally {
        zipFs.saveAndClose();
      }
    }
  }

}

/***/ }),
/* 177 */
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "escapeRegExp": () => /* binding */ escapeRegExp,
/* harmony export */   "overrideType": () => /* binding */ overrideType,
/* harmony export */   "assertNever": () => /* binding */ assertNever,
/* harmony export */   "validateEnum": () => /* binding */ validateEnum,
/* harmony export */   "mapAndFilter": () => /* binding */ mapAndFilter,
/* harmony export */   "mapAndFind": () => /* binding */ mapAndFind,
/* harmony export */   "isIndexableObject": () => /* binding */ isIndexableObject,
/* harmony export */   "convertMapsToIndexableObjects": () => /* binding */ convertMapsToIndexableObjects,
/* harmony export */   "getFactoryWithDefault": () => /* binding */ getFactoryWithDefault,
/* harmony export */   "getArrayWithDefault": () => /* binding */ getArrayWithDefault,
/* harmony export */   "getSetWithDefault": () => /* binding */ getSetWithDefault,
/* harmony export */   "getMapWithDefault": () => /* binding */ getMapWithDefault,
/* harmony export */   "releaseAfterUseAsync": () => /* binding */ releaseAfterUseAsync,
/* harmony export */   "prettifyAsyncErrors": () => /* binding */ prettifyAsyncErrors,
/* harmony export */   "prettifySyncErrors": () => /* binding */ prettifySyncErrors,
/* harmony export */   "bufferStream": () => /* binding */ bufferStream,
/* harmony export */   "BufferStream": () => /* binding */ BufferStream,
/* harmony export */   "DefaultStream": () => /* binding */ DefaultStream,
/* harmony export */   "dynamicRequire": () => /* binding */ dynamicRequire,
/* harmony export */   "dynamicRequireNoCache": () => /* binding */ dynamicRequireNoCache,
/* harmony export */   "sortMap": () => /* binding */ sortMap,
/* harmony export */   "buildIgnorePattern": () => /* binding */ buildIgnorePattern,
/* harmony export */   "replaceEnvVariables": () => /* binding */ replaceEnvVariables,
/* harmony export */   "parseBoolean": () => /* binding */ parseBoolean,
/* harmony export */   "parseOptionalBoolean": () => /* binding */ parseOptionalBoolean,
/* harmony export */   "tryParseOptionalBoolean": () => /* binding */ tryParseOptionalBoolean
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_2__);
/* module decorator */ module = __webpack_require__.hmd(module);




function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, `\\$&`);
}
function overrideType(val) {}
function assertNever(arg) {
  throw new Error(`Assertion failed: Unexpected object '${arg}'`);
}
function validateEnum(def, value) {
  if (!Object.values(def).includes(value)) throw new Error(`Assertion failed: Invalid value for enumeration`);
  return value;
}
function mapAndFilter(iterable, cb) {
  const output = [];

  for (const value of iterable) {
    const out = cb(value);

    if (out !== mapAndFilterSkip) {
      output.push(out);
    }
  }

  return output;
}
const mapAndFilterSkip = Symbol();
mapAndFilter.skip = mapAndFilterSkip;
function mapAndFind(iterable, cb) {
  for (const value of iterable) {
    const out = cb(value);

    if (out !== mapAndFindSkip) {
      return out;
    }
  }

  return undefined;
}
const mapAndFindSkip = Symbol();
mapAndFind.skip = mapAndFindSkip;
function isIndexableObject(value) {
  return typeof value === `object` && value !== null;
}
/**
 * Converts Maps to indexable objects recursively.
 */

function convertMapsToIndexableObjects(arg) {
  if (arg instanceof Map) arg = Object.fromEntries(arg);

  if (isIndexableObject(arg)) {
    for (const key of Object.keys(arg)) {
      const value = arg[key];

      if (isIndexableObject(value)) {
        // @ts-expect-error: Apparently nothing in this world can be used to index type 'T & { [key: string]: unknown; }'
        arg[key] = convertMapsToIndexableObjects(value);
      }
    }
  }

  return arg;
}
function getFactoryWithDefault(map, key, factory) {
  let value = map.get(key);
  if (typeof value === `undefined`) map.set(key, value = factory());
  return value;
}
function getArrayWithDefault(map, key) {
  let value = map.get(key);
  if (typeof value === `undefined`) map.set(key, value = []);
  return value;
}
function getSetWithDefault(map, key) {
  let value = map.get(key);
  if (typeof value === `undefined`) map.set(key, value = new Set());
  return value;
}
function getMapWithDefault(map, key) {
  let value = map.get(key);
  if (typeof value === `undefined`) map.set(key, value = new Map());
  return value;
} // Executes a chunk of code and calls a cleanup function once it returns (even
// if it throws an exception)

async function releaseAfterUseAsync(fn, cleanup) {
  if (cleanup == null) return await fn();

  try {
    return await fn();
  } finally {
    await cleanup();
  }
} // Executes a chunk of code but slightly modify its exception message if it
// throws something

async function prettifyAsyncErrors(fn, update) {
  try {
    return await fn();
  } catch (error) {
    error.message = update(error.message);
    throw error;
  }
} // Same thing but synchronous

function prettifySyncErrors(fn, update) {
  try {
    return fn();
  } catch (error) {
    error.message = update(error.message);
    throw error;
  }
} // Converts a Node stream into a Buffer instance

async function bufferStream(stream) {
  return await new Promise((resolve, reject) => {
    const chunks = [];
    stream.on(`error`, error => {
      reject(error);
    });
    stream.on(`data`, chunk => {
      chunks.push(chunk);
    });
    stream.on(`end`, () => {
      resolve(Buffer.concat(chunks));
    });
  });
} // A stream implementation that buffers a stream to send it all at once

class BufferStream extends stream__WEBPACK_IMPORTED_MODULE_2__.Transform {
  constructor() {
    super(...arguments);
    this.chunks = [];
  }

  _transform(chunk, encoding, cb) {
    if (encoding !== `buffer` || !Buffer.isBuffer(chunk)) throw new Error(`Assertion failed: BufferStream only accept buffers`);
    this.chunks.push(chunk);
    cb(null, null);
  }

  _flush(cb) {
    cb(null, Buffer.concat(this.chunks));
  }

} // A stream implementation that prints a message if nothing was output

class DefaultStream extends stream__WEBPACK_IMPORTED_MODULE_2__.Transform {
  constructor(ifEmpty = Buffer.alloc(0)) {
    super();
    this.active = true;
    this.ifEmpty = ifEmpty;
  }

  _transform(chunk, encoding, cb) {
    if (encoding !== `buffer` || !Buffer.isBuffer(chunk)) throw new Error(`Assertion failed: DefaultStream only accept buffers`);
    this.active = false;
    cb(null, chunk);
  }

  _flush(cb) {
    if (this.active && this.ifEmpty.length > 0) {
      cb(null, this.ifEmpty);
    }
  }

} // Webpack has this annoying tendency to replace dynamic requires by a stub
// code that simply throws when called. It's all fine and dandy in the context
// of a web application, but is quite annoying when working with Node projects!

function dynamicRequire(path) {
  // @ts-expect-error
  if (typeof require !== `undefined`) {
    // @ts-expect-error
    return require(path);
  } else {
    return __webpack_require__(178)(path);
  }
}
function dynamicRequireNoCache(path) {
  const physicalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(path);
  const currentCacheEntry = __webpack_require__.c[physicalPath];
  delete __webpack_require__.c[physicalPath];
  let result;

  try {
    result = dynamicRequire(physicalPath);
    const freshCacheEntry = __webpack_require__.c[physicalPath];
    const freshCacheIndex = module.children.indexOf(freshCacheEntry);

    if (freshCacheIndex !== -1) {
      module.children.splice(freshCacheIndex, 1);
    }
  } finally {
    __webpack_require__.c[physicalPath] = currentCacheEntry;
  }

  return result;
} // This function transforms an iterable into an array and sorts it according to
// the mapper functions provided as parameter. The mappers are expected to take
// each element from the iterable and generate a string from it, that will then
// be used to compare the entries.
//
// Using sortMap is more efficient than kinda reimplementing the logic in a sort
// predicate because sortMap caches the result of the mappers in such a way that
// they are guaranteed to be executed exactly once for each element.

function sortMap(values, mappers) {
  const asArray = Array.from(values);
  if (!Array.isArray(mappers)) mappers = [mappers];
  const stringified = [];

  for (const mapper of mappers) stringified.push(asArray.map(value => mapper(value)));

  const indices = asArray.map((_, index) => index);
  indices.sort((a, b) => {
    for (const layer of stringified) {
      const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? +1 : 0;

      if (comparison !== 0) {
        return comparison;
      }
    }

    return 0;
  });
  return indices.map(index => {
    return asArray[index];
  });
}
/**
 * Combines an Array of glob patterns into a regular expression.
 *
 * @param ignorePatterns An array of glob patterns
 *
 * @returns A `string` representing a regular expression or `null` if no glob patterns are provided
 */

function buildIgnorePattern(ignorePatterns) {
  if (ignorePatterns.length === 0) return null;
  return ignorePatterns.map(pattern => {
    return `(${micromatch__WEBPACK_IMPORTED_MODULE_1___default().makeRe(pattern, {
      windows: false
    }).source})`;
  }).join(`|`);
}
function replaceEnvVariables(value, {
  env
}) {
  const regex = /\${(?<variableName>[\d\w_]+)(?<colon>:)?(?:-(?<fallback>[^}]*))?}/g;
  return value.replace(regex, (...args) => {
    const {
      variableName,
      colon,
      fallback
    } = args[args.length - 1];
    const variableExist = Object.prototype.hasOwnProperty.call(env, variableName);
    const variableValue = env[variableName];
    if (variableValue) return variableValue;
    if (variableExist && !colon) return variableValue;
    if (fallback != null) return fallback;
    throw new clipanion__WEBPACK_IMPORTED_MODULE_0__.UsageError(`Environment variable not found (${variableName})`);
  });
}
function parseBoolean(value) {
  switch (value) {
    case `true`:
    case `1`:
    case 1:
    case true:
      {
        return true;
      }

    case `false`:
    case `0`:
    case 0:
    case false:
      {
        return false;
      }

    default:
      {
        throw new Error(`Couldn't parse "${value}" as a boolean`);
      }
  }
}
function parseOptionalBoolean(value) {
  if (typeof value === `undefined`) return value;
  return parseBoolean(value);
}
function tryParseOptionalBoolean(value) {
  try {
    return parseOptionalBoolean(value);
  } catch (_a) {
    return null;
  }
}

/***/ }),
/* 178 */
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => [];
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 178;
module.exports = webpackEmptyContext;

/***/ }),
/* 179 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkType": () => /* binding */ LinkType,
/* harmony export */   "PackageExtensionType": () => /* binding */ PackageExtensionType,
/* harmony export */   "PackageExtensionStatus": () => /* binding */ PackageExtensionStatus
/* harmony export */ });
/**
 * Describes in which capacity the linkers can manipulate the package sources.
 */
var LinkType;

(function (LinkType) {
  /**
   * The package manager owns the location (typically things within the cache)
   * and can transform it at will (for instance the PnP linker may decide to
   * unplug those packages).
   */
  LinkType["HARD"] = "HARD";
  /**
   * The package manager doesn't own the location (symlinks, workspaces, etc),
   * so the linkers aren't allowed to do anything with them except use them as
   * they are.
   */

  LinkType["SOFT"] = "SOFT";
})(LinkType || (LinkType = {}));

var PackageExtensionType;

(function (PackageExtensionType) {
  PackageExtensionType["Dependency"] = "Dependency";
  PackageExtensionType["PeerDependency"] = "PeerDependency";
  PackageExtensionType["PeerDependencyMeta"] = "PeerDependencyMeta";
})(PackageExtensionType || (PackageExtensionType = {}));

var PackageExtensionStatus;

(function (PackageExtensionStatus) {
  PackageExtensionStatus["Inactive"] = "inactive";
  PackageExtensionStatus["Redundant"] = "redundant";
  PackageExtensionStatus["Active"] = "active";
})(PackageExtensionStatus || (PackageExtensionStatus = {}));

/***/ }),
/* 180 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageName": () => /* binding */ MessageName,
/* harmony export */   "stringifyMessageName": () => /* binding */ stringifyMessageName
/* harmony export */ });
// The values in this enum should never be reassigned, even if some are removed
// over time (it would mess up the search results, which are the whole point of
// having this system)
var MessageName;

(function (MessageName) {
  MessageName[MessageName["UNNAMED"] = 0] = "UNNAMED";
  MessageName[MessageName["EXCEPTION"] = 1] = "EXCEPTION";
  MessageName[MessageName["MISSING_PEER_DEPENDENCY"] = 2] = "MISSING_PEER_DEPENDENCY";
  MessageName[MessageName["CYCLIC_DEPENDENCIES"] = 3] = "CYCLIC_DEPENDENCIES";
  MessageName[MessageName["DISABLED_BUILD_SCRIPTS"] = 4] = "DISABLED_BUILD_SCRIPTS";
  MessageName[MessageName["BUILD_DISABLED"] = 5] = "BUILD_DISABLED";
  MessageName[MessageName["SOFT_LINK_BUILD"] = 6] = "SOFT_LINK_BUILD";
  MessageName[MessageName["MUST_BUILD"] = 7] = "MUST_BUILD";
  MessageName[MessageName["MUST_REBUILD"] = 8] = "MUST_REBUILD";
  MessageName[MessageName["BUILD_FAILED"] = 9] = "BUILD_FAILED";
  MessageName[MessageName["RESOLVER_NOT_FOUND"] = 10] = "RESOLVER_NOT_FOUND";
  MessageName[MessageName["FETCHER_NOT_FOUND"] = 11] = "FETCHER_NOT_FOUND";
  MessageName[MessageName["LINKER_NOT_FOUND"] = 12] = "LINKER_NOT_FOUND";
  MessageName[MessageName["FETCH_NOT_CACHED"] = 13] = "FETCH_NOT_CACHED";
  MessageName[MessageName["YARN_IMPORT_FAILED"] = 14] = "YARN_IMPORT_FAILED";
  MessageName[MessageName["REMOTE_INVALID"] = 15] = "REMOTE_INVALID";
  MessageName[MessageName["REMOTE_NOT_FOUND"] = 16] = "REMOTE_NOT_FOUND";
  MessageName[MessageName["RESOLUTION_PACK"] = 17] = "RESOLUTION_PACK";
  MessageName[MessageName["CACHE_CHECKSUM_MISMATCH"] = 18] = "CACHE_CHECKSUM_MISMATCH";
  MessageName[MessageName["UNUSED_CACHE_ENTRY"] = 19] = "UNUSED_CACHE_ENTRY";
  MessageName[MessageName["MISSING_LOCKFILE_ENTRY"] = 20] = "MISSING_LOCKFILE_ENTRY";
  MessageName[MessageName["WORKSPACE_NOT_FOUND"] = 21] = "WORKSPACE_NOT_FOUND";
  MessageName[MessageName["TOO_MANY_MATCHING_WORKSPACES"] = 22] = "TOO_MANY_MATCHING_WORKSPACES";
  MessageName[MessageName["CONSTRAINTS_MISSING_DEPENDENCY"] = 23] = "CONSTRAINTS_MISSING_DEPENDENCY";
  MessageName[MessageName["CONSTRAINTS_INCOMPATIBLE_DEPENDENCY"] = 24] = "CONSTRAINTS_INCOMPATIBLE_DEPENDENCY";
  MessageName[MessageName["CONSTRAINTS_EXTRANEOUS_DEPENDENCY"] = 25] = "CONSTRAINTS_EXTRANEOUS_DEPENDENCY";
  MessageName[MessageName["CONSTRAINTS_INVALID_DEPENDENCY"] = 26] = "CONSTRAINTS_INVALID_DEPENDENCY";
  MessageName[MessageName["CANT_SUGGEST_RESOLUTIONS"] = 27] = "CANT_SUGGEST_RESOLUTIONS";
  MessageName[MessageName["FROZEN_LOCKFILE_EXCEPTION"] = 28] = "FROZEN_LOCKFILE_EXCEPTION";
  MessageName[MessageName["CROSS_DRIVE_VIRTUAL_LOCAL"] = 29] = "CROSS_DRIVE_VIRTUAL_LOCAL";
  MessageName[MessageName["FETCH_FAILED"] = 30] = "FETCH_FAILED";
  MessageName[MessageName["DANGEROUS_NODE_MODULES"] = 31] = "DANGEROUS_NODE_MODULES";
  MessageName[MessageName["NODE_GYP_INJECTED"] = 32] = "NODE_GYP_INJECTED";
  MessageName[MessageName["AUTHENTICATION_NOT_FOUND"] = 33] = "AUTHENTICATION_NOT_FOUND";
  MessageName[MessageName["INVALID_CONFIGURATION_KEY"] = 34] = "INVALID_CONFIGURATION_KEY";
  MessageName[MessageName["NETWORK_ERROR"] = 35] = "NETWORK_ERROR";
  MessageName[MessageName["LIFECYCLE_SCRIPT"] = 36] = "LIFECYCLE_SCRIPT";
  MessageName[MessageName["CONSTRAINTS_MISSING_FIELD"] = 37] = "CONSTRAINTS_MISSING_FIELD";
  MessageName[MessageName["CONSTRAINTS_INCOMPATIBLE_FIELD"] = 38] = "CONSTRAINTS_INCOMPATIBLE_FIELD";
  MessageName[MessageName["CONSTRAINTS_EXTRANEOUS_FIELD"] = 39] = "CONSTRAINTS_EXTRANEOUS_FIELD";
  MessageName[MessageName["CONSTRAINTS_INVALID_FIELD"] = 40] = "CONSTRAINTS_INVALID_FIELD";
  MessageName[MessageName["AUTHENTICATION_INVALID"] = 41] = "AUTHENTICATION_INVALID";
  MessageName[MessageName["PROLOG_UNKNOWN_ERROR"] = 42] = "PROLOG_UNKNOWN_ERROR";
  MessageName[MessageName["PROLOG_SYNTAX_ERROR"] = 43] = "PROLOG_SYNTAX_ERROR";
  MessageName[MessageName["PROLOG_EXISTENCE_ERROR"] = 44] = "PROLOG_EXISTENCE_ERROR";
  MessageName[MessageName["STACK_OVERFLOW_RESOLUTION"] = 45] = "STACK_OVERFLOW_RESOLUTION";
  MessageName[MessageName["AUTOMERGE_FAILED_TO_PARSE"] = 46] = "AUTOMERGE_FAILED_TO_PARSE";
  MessageName[MessageName["AUTOMERGE_IMMUTABLE"] = 47] = "AUTOMERGE_IMMUTABLE";
  MessageName[MessageName["AUTOMERGE_SUCCESS"] = 48] = "AUTOMERGE_SUCCESS";
  MessageName[MessageName["AUTOMERGE_REQUIRED"] = 49] = "AUTOMERGE_REQUIRED";
  MessageName[MessageName["DEPRECATED_CLI_SETTINGS"] = 50] = "DEPRECATED_CLI_SETTINGS";
  MessageName[MessageName["PLUGIN_NAME_NOT_FOUND"] = 51] = "PLUGIN_NAME_NOT_FOUND";
  MessageName[MessageName["INVALID_PLUGIN_REFERENCE"] = 52] = "INVALID_PLUGIN_REFERENCE";
  MessageName[MessageName["CONSTRAINTS_AMBIGUITY"] = 53] = "CONSTRAINTS_AMBIGUITY";
  MessageName[MessageName["CACHE_OUTSIDE_PROJECT"] = 54] = "CACHE_OUTSIDE_PROJECT";
  MessageName[MessageName["IMMUTABLE_INSTALL"] = 55] = "IMMUTABLE_INSTALL";
  MessageName[MessageName["IMMUTABLE_CACHE"] = 56] = "IMMUTABLE_CACHE";
  MessageName[MessageName["INVALID_MANIFEST"] = 57] = "INVALID_MANIFEST";
  MessageName[MessageName["PACKAGE_PREPARATION_FAILED"] = 58] = "PACKAGE_PREPARATION_FAILED";
  MessageName[MessageName["INVALID_RANGE_PEER_DEPENDENCY"] = 59] = "INVALID_RANGE_PEER_DEPENDENCY";
  MessageName[MessageName["INCOMPATIBLE_PEER_DEPENDENCY"] = 60] = "INCOMPATIBLE_PEER_DEPENDENCY";
  MessageName[MessageName["DEPRECATED_PACKAGE"] = 61] = "DEPRECATED_PACKAGE";
  MessageName[MessageName["INCOMPATIBLE_OS"] = 62] = "INCOMPATIBLE_OS";
  MessageName[MessageName["INCOMPATIBLE_CPU"] = 63] = "INCOMPATIBLE_CPU";
  MessageName[MessageName["FROZEN_ARTIFACT_EXCEPTION"] = 64] = "FROZEN_ARTIFACT_EXCEPTION";
  MessageName[MessageName["TELEMETRY_NOTICE"] = 65] = "TELEMETRY_NOTICE";
  MessageName[MessageName["PATCH_HUNK_FAILED"] = 66] = "PATCH_HUNK_FAILED";
  MessageName[MessageName["INVALID_CONFIGURATION_VALUE"] = 67] = "INVALID_CONFIGURATION_VALUE";
  MessageName[MessageName["UNUSED_PACKAGE_EXTENSION"] = 68] = "UNUSED_PACKAGE_EXTENSION";
  MessageName[MessageName["REDUNDANT_PACKAGE_EXTENSION"] = 69] = "REDUNDANT_PACKAGE_EXTENSION";
})(MessageName || (MessageName = {}));

function stringifyMessageName(name) {
  return `YN${name.toString(10).padStart(4, `0`)}`;
}

/***/ }),
/* 181 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ENVIRONMENT_PREFIX": () => /* binding */ ENVIRONMENT_PREFIX,
/* harmony export */   "DEFAULT_RC_FILENAME": () => /* binding */ DEFAULT_RC_FILENAME,
/* harmony export */   "DEFAULT_LOCK_FILENAME": () => /* binding */ DEFAULT_LOCK_FILENAME,
/* harmony export */   "SECRET": () => /* binding */ SECRET,
/* harmony export */   "SettingsType": () => /* binding */ SettingsType,
/* harmony export */   "FormatType": () => /* binding */ FormatType,
/* harmony export */   "coreDefinitions": () => /* binding */ coreDefinitions,
/* harmony export */   "ProjectLookup": () => /* binding */ ProjectLookup,
/* harmony export */   "Configuration": () => /* binding */ Configuration
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(163);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(182);
/* harmony import */ var camelcase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(220);
/* harmony import */ var camelcase__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(camelcase__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ci_info__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var ci_info__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ci_info__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(221);
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(p_limit__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(76);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _CorePlugin__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(224);
/* harmony import */ var _Manifest__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(237);
/* harmony import */ var _MultiFetcher__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(232);
/* harmony import */ var _MultiResolver__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(227);
/* harmony import */ var _ProtocolResolver__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(230);
/* harmony import */ var _VirtualFetcher__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(235);
/* harmony import */ var _VirtualResolver__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(228);
/* harmony import */ var _WorkspaceFetcher__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(236);
/* harmony import */ var _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(229);
/* harmony import */ var _folderUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(223);
/* harmony import */ var _formatUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(177);
/* harmony import */ var _nodeUtils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(225);
/* harmony import */ var _semverUtils__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(231);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(26);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(179);

























const IGNORED_ENV_VARIABLES = new Set([// "binFolder" is the magic location where the parent process stored the
// current binaries; not an actual configuration settings
`binFolder`, // "version" is set by Docker:
// https://github.com/nodejs/docker-node/blob/5a6a5e91999358c5b04fddd6c22a9a4eb0bf3fbf/10/alpine/Dockerfile#L51
`version`, // "flags" is set by Netlify; they use it to specify the flags to send to the
// CLI when running the automatic `yarn install`
`flags`, // "gpg" and "profile" are used by the install.sh script:
// https://classic.yarnpkg.com/install.sh
`profile`, `gpg`, // "ignoreNode" is used to disable the Node version check
`ignoreNode`, // "wrapOutput" was a variable used to indicate nested "yarn run" processes
// back in Yarn 1.
`wrapOutput`]);
const ENVIRONMENT_PREFIX = `yarn_`;
const DEFAULT_RC_FILENAME = `.yarnrc.yml`;
const DEFAULT_LOCK_FILENAME = `yarn.lock`;
const SECRET = `********`;
var SettingsType;

(function (SettingsType) {
  SettingsType["ANY"] = "ANY";
  SettingsType["BOOLEAN"] = "BOOLEAN";
  SettingsType["ABSOLUTE_PATH"] = "ABSOLUTE_PATH";
  SettingsType["LOCATOR"] = "LOCATOR";
  SettingsType["LOCATOR_LOOSE"] = "LOCATOR_LOOSE";
  SettingsType["NUMBER"] = "NUMBER";
  SettingsType["STRING"] = "STRING";
  SettingsType["SECRET"] = "SECRET";
  SettingsType["SHAPE"] = "SHAPE";
  SettingsType["MAP"] = "MAP";
})(SettingsType || (SettingsType = {}));

const FormatType = _formatUtils__WEBPACK_IMPORTED_MODULE_7__.Type; // General rules:
//
// - filenames that don't accept actual paths must end with the "Filename" suffix
//   prefer to use absolute paths instead, since they are automatically resolved
//   ex: lockfileFilename
//
// - folders must end with the "Folder" suffix
//   ex: cacheFolder, pnpVirtualFolder
//
// - actual paths to a file must end with the "Path" suffix
//   ex: pnpPath
//
// - options that tweaks the strictness must begin with the "allow" prefix
//   ex: allowInvalidChecksums
//
// - options that enable a feature must begin with the "enable" prefix
//   ex: enableEmojis, enableColors

const coreDefinitions = {
  // Not implemented for now, but since it's part of all Yarn installs we want to declare it in order to improve drop-in compatibility
  lastUpdateCheck: {
    description: `Last timestamp we checked whether new Yarn versions were available`,
    type: SettingsType.STRING,
    default: null
  },
  // Settings related to proxying all Yarn calls to a specific executable
  yarnPath: {
    description: `Path to the local executable that must be used over the global one`,
    type: SettingsType.ABSOLUTE_PATH,
    default: null
  },
  ignorePath: {
    description: `If true, the local executable will be ignored when using the global one`,
    type: SettingsType.BOOLEAN,
    default: false
  },
  ignoreCwd: {
    description: `If true, the \`--cwd\` flag will be ignored`,
    type: SettingsType.BOOLEAN,
    default: false
  },
  // Settings related to the package manager internal names
  cacheKeyOverride: {
    description: `A global cache key override; used only for test purposes`,
    type: SettingsType.STRING,
    default: null
  },
  globalFolder: {
    description: `Folder where are stored the system-wide settings`,
    type: SettingsType.ABSOLUTE_PATH,
    default: _folderUtils__WEBPACK_IMPORTED_MODULE_8__.getDefaultGlobalFolder()
  },
  cacheFolder: {
    description: `Folder where the cache files must be written`,
    type: SettingsType.ABSOLUTE_PATH,
    default: `./.yarn/cache`
  },
  compressionLevel: {
    description: `Zip files compression level, from 0 to 9 or mixed (a variant of 9, which stores some files uncompressed, when compression doesn't yield good results)`,
    type: SettingsType.NUMBER,
    values: [`mixed`, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    default: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.DEFAULT_COMPRESSION_LEVEL
  },
  virtualFolder: {
    description: `Folder where the virtual packages (cf doc) will be mapped on the disk (must be named $$virtual)`,
    type: SettingsType.ABSOLUTE_PATH,
    default: `./.yarn/$$virtual`
  },
  bstatePath: {
    description: `Path of the file where the current state of the built packages must be stored`,
    type: SettingsType.ABSOLUTE_PATH,
    default: `./.yarn/build-state.yml`
  },
  lockfileFilename: {
    description: `Name of the files where the Yarn dependency tree entries must be stored`,
    type: SettingsType.STRING,
    default: DEFAULT_LOCK_FILENAME
  },
  installStatePath: {
    description: `Path of the file where the install state will be persisted`,
    type: SettingsType.ABSOLUTE_PATH,
    default: `./.yarn/install-state.gz`
  },
  immutablePatterns: {
    description: `Array of glob patterns; files matching them won't be allowed to change during immutable installs`,
    type: SettingsType.STRING,
    default: [],
    isArray: true
  },
  rcFilename: {
    description: `Name of the files where the configuration can be found`,
    type: SettingsType.STRING,
    default: getRcFilename()
  },
  enableGlobalCache: {
    description: `If true, the system-wide cache folder will be used regardless of \`cache-folder\``,
    type: SettingsType.BOOLEAN,
    default: false
  },
  enableAbsoluteVirtuals: {
    description: `If true, the virtual symlinks will use absolute paths if required [non portable!!]`,
    type: SettingsType.BOOLEAN,
    default: false
  },
  // Settings related to the output style
  enableColors: {
    description: `If true, the CLI is allowed to use colors in its output`,
    type: SettingsType.BOOLEAN,
    default: _formatUtils__WEBPACK_IMPORTED_MODULE_7__.supportsColor,
    defaultText: `<dynamic>`
  },
  enableHyperlinks: {
    description: `If true, the CLI is allowed to use hyperlinks in its output`,
    type: SettingsType.BOOLEAN,
    default: _formatUtils__WEBPACK_IMPORTED_MODULE_7__.supportsHyperlinks,
    defaultText: `<dynamic>`
  },
  enableInlineBuilds: {
    description: `If true, the CLI will print the build output on the command line`,
    type: SettingsType.BOOLEAN,
    default: ci_info__WEBPACK_IMPORTED_MODULE_2__.isCI,
    defaultText: `<dynamic>`
  },
  enableProgressBars: {
    description: `If true, the CLI is allowed to show a progress bar for long-running events`,
    type: SettingsType.BOOLEAN,
    default: !ci_info__WEBPACK_IMPORTED_MODULE_2__.isCI && process.stdout.isTTY && process.stdout.columns > 22,
    defaultText: `<dynamic>`
  },
  enableTimers: {
    description: `If true, the CLI is allowed to print the time spent executing commands`,
    type: SettingsType.BOOLEAN,
    default: true
  },
  preferAggregateCacheInfo: {
    description: `If true, the CLI will only print a one-line report of any cache changes`,
    type: SettingsType.BOOLEAN,
    default: ci_info__WEBPACK_IMPORTED_MODULE_2__.isCI
  },
  preferInteractive: {
    description: `If true, the CLI will automatically use the interactive mode when called from a TTY`,
    type: SettingsType.BOOLEAN,
    default: false
  },
  preferTruncatedLines: {
    description: `If true, the CLI will truncate lines that would go beyond the size of the terminal`,
    type: SettingsType.BOOLEAN,
    default: false
  },
  progressBarStyle: {
    description: `Which style of progress bar should be used (only when progress bars are enabled)`,
    type: SettingsType.STRING,
    default: undefined,
    defaultText: `<dynamic>`
  },
  // Settings related to how packages are interpreted by default
  defaultLanguageName: {
    description: `Default language mode that should be used when a package doesn't offer any insight`,
    type: SettingsType.STRING,
    default: `node`
  },
  defaultProtocol: {
    description: `Default resolution protocol used when resolving pure semver and tag ranges`,
    type: SettingsType.STRING,
    default: `npm:`
  },
  enableTransparentWorkspaces: {
    description: `If false, Yarn won't automatically resolve workspace dependencies unless they use the \`workspace:\` protocol`,
    type: SettingsType.BOOLEAN,
    default: true
  },
  // Settings related to network access
  enableMirror: {
    description: `If true, the downloaded packages will be retrieved and stored in both the local and global folders`,
    type: SettingsType.BOOLEAN,
    default: true
  },
  enableNetwork: {
    description: `If false, the package manager will refuse to use the network if required to`,
    type: SettingsType.BOOLEAN,
    default: true
  },
  httpProxy: {
    description: `URL of the http proxy that must be used for outgoing http requests`,
    type: SettingsType.STRING,
    default: null
  },
  httpsProxy: {
    description: `URL of the http proxy that must be used for outgoing https requests`,
    type: SettingsType.STRING,
    default: null
  },
  unsafeHttpWhitelist: {
    description: `List of the hostnames for which http queries are allowed (glob patterns are supported)`,
    type: SettingsType.STRING,
    default: [],
    isArray: true
  },
  httpTimeout: {
    description: `Timeout of each http request in milliseconds`,
    type: SettingsType.NUMBER,
    default: 60000
  },
  httpRetry: {
    description: `Retry times on http failure`,
    type: SettingsType.NUMBER,
    default: 3
  },
  networkConcurrency: {
    description: `Maximal number of concurrent requests`,
    type: SettingsType.NUMBER,
    default: Infinity
  },
  networkSettings: {
    description: `Network settings per hostname (glob patterns are supported)`,
    type: SettingsType.MAP,
    valueDefinition: {
      description: ``,
      type: SettingsType.SHAPE,
      properties: {
        caFilePath: {
          description: `Path to file containing one or multiple Certificate Authority signing certificates`,
          type: SettingsType.ABSOLUTE_PATH,
          default: null
        },
        enableNetwork: {
          description: `If false, the package manager will refuse to use the network if required to`,
          type: SettingsType.BOOLEAN,
          default: null
        }
      }
    }
  },
  caFilePath: {
    description: `A path to a file containing one or multiple Certificate Authority signing certificates`,
    type: SettingsType.ABSOLUTE_PATH,
    default: null
  },
  enableStrictSsl: {
    description: `If false, SSL certificate errors will be ignored`,
    type: SettingsType.BOOLEAN,
    default: true
  },
  logFilters: {
    description: `Overrides for log levels`,
    type: SettingsType.SHAPE,
    isArray: true,
    concatenateValues: true,
    properties: {
      code: {
        description: `Code of the messages covered by this override`,
        type: SettingsType.STRING,
        default: undefined
      },
      text: {
        description: `Code of the texts covered by this override`,
        type: SettingsType.STRING,
        default: undefined
      },
      level: {
        description: `Log level override, set to null to remove override`,
        type: SettingsType.STRING,
        values: Object.values(_formatUtils__WEBPACK_IMPORTED_MODULE_7__.LogLevel),
        isNullable: true,
        default: undefined
      }
    }
  },
  // Settings related to telemetry
  enableTelemetry: {
    description: `If true, telemetry will be periodically sent, following the rules in https://yarnpkg.com/advanced/telemetry`,
    type: SettingsType.BOOLEAN,
    default: true
  },
  telemetryInterval: {
    description: `Minimal amount of time between two telemetry uploads, in days`,
    type: SettingsType.NUMBER,
    default: 7
  },
  telemetryUserId: {
    description: `If you desire to tell us which project you are, you can set this field. Completely optional and opt-in.`,
    type: SettingsType.STRING,
    default: null
  },
  // Settings related to security
  enableScripts: {
    description: `If true, packages are allowed to have install scripts by default`,
    type: SettingsType.BOOLEAN,
    default: true
  },
  enableImmutableCache: {
    description: `If true, the cache is reputed immutable and actions that would modify it will throw`,
    type: SettingsType.BOOLEAN,
    default: false
  },
  checksumBehavior: {
    description: `Enumeration defining what to do when a checksum doesn't match expectations`,
    type: SettingsType.STRING,
    default: `throw`
  },
  // Package patching - to fix incorrect definitions
  packageExtensions: {
    description: `Map of package corrections to apply on the dependency tree`,
    type: SettingsType.MAP,
    valueDefinition: {
      description: `The extension that will be applied to any package whose version matches the specified range`,
      type: SettingsType.SHAPE,
      properties: {
        dependencies: {
          description: `The set of dependencies that must be made available to the current package in order for it to work properly`,
          type: SettingsType.MAP,
          valueDefinition: {
            description: `A range`,
            type: SettingsType.STRING
          }
        },
        peerDependencies: {
          description: `Inherited dependencies - the consumer of the package will be tasked to provide them`,
          type: SettingsType.MAP,
          valueDefinition: {
            description: `A semver range`,
            type: SettingsType.STRING
          }
        },
        peerDependenciesMeta: {
          description: `Extra information related to the dependencies listed in the peerDependencies field`,
          type: SettingsType.MAP,
          valueDefinition: {
            description: `The peerDependency meta`,
            type: SettingsType.SHAPE,
            properties: {
              optional: {
                description: `If true, the selected peer dependency will be marked as optional by the package manager and the consumer omitting it won't be reported as an error`,
                type: SettingsType.BOOLEAN,
                default: false
              }
            }
          }
        }
      }
    }
  }
};

function parseValue(configuration, path, value, definition, folder) {
  if (definition.isArray) {
    if (!Array.isArray(value)) {
      return String(value).split(/,/).map(segment => {
        return parseSingleValue(configuration, path, segment, definition, folder);
      });
    } else {
      return value.map((sub, i) => parseSingleValue(configuration, `${path}[${i}]`, sub, definition, folder));
    }
  } else {
    if (Array.isArray(value)) {
      throw new Error(`Non-array configuration settings "${path}" cannot be an array`);
    } else {
      return parseSingleValue(configuration, path, value, definition, folder);
    }
  }
}

function parseSingleValue(configuration, path, value, definition, folder) {
  var _a;

  switch (definition.type) {
    case SettingsType.ANY:
      return value;

    case SettingsType.SHAPE:
      return parseShape(configuration, path, value, definition, folder);

    case SettingsType.MAP:
      return parseMap(configuration, path, value, definition, folder);
  }

  if (value === null && !definition.isNullable && definition.default !== null) throw new Error(`Non-nullable configuration settings "${path}" cannot be set to null`);
  if ((_a = definition.values) === null || _a === void 0 ? void 0 : _a.includes(value)) return value;

  const interpretValue = () => {
    if (definition.type === SettingsType.BOOLEAN) return _miscUtils__WEBPACK_IMPORTED_MODULE_10__.parseBoolean(value);
    if (typeof value !== `string`) throw new Error(`Expected value (${value}) to be a string`);
    const valueWithReplacedVariables = _miscUtils__WEBPACK_IMPORTED_MODULE_10__.replaceEnvVariables(value, {
      env: process.env
    });

    switch (definition.type) {
      case SettingsType.ABSOLUTE_PATH:
        return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(folder, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.toPortablePath(valueWithReplacedVariables));

      case SettingsType.LOCATOR_LOOSE:
        return _structUtils__WEBPACK_IMPORTED_MODULE_12__.parseLocator(valueWithReplacedVariables, false);

      case SettingsType.NUMBER:
        return parseInt(valueWithReplacedVariables);

      case SettingsType.LOCATOR:
        return _structUtils__WEBPACK_IMPORTED_MODULE_12__.parseLocator(valueWithReplacedVariables);

      default:
        return valueWithReplacedVariables;
    }
  };

  const interpreted = interpretValue();
  if (definition.values && !definition.values.includes(interpreted)) throw new Error(`Invalid value, expected one of ${definition.values.join(`, `)}`);
  return interpreted;
}

function parseShape(configuration, path, value, definition, folder) {
  if (typeof value !== `object` || Array.isArray(value)) throw new clipanion__WEBPACK_IMPORTED_MODULE_3__.UsageError(`Object configuration settings "${path}" must be an object`);
  const result = getDefaultValue(configuration, definition, {
    ignoreArrays: true
  });
  if (value === null) return result;

  for (const [propKey, propValue] of Object.entries(value)) {
    const subPath = `${path}.${propKey}`;
    const subDefinition = definition.properties[propKey];
    if (!subDefinition) throw new clipanion__WEBPACK_IMPORTED_MODULE_3__.UsageError(`Unrecognized configuration settings found: ${path}.${propKey} - run "yarn config -v" to see the list of settings supported in Yarn`);
    result.set(propKey, parseValue(configuration, subPath, propValue, definition.properties[propKey], folder));
  }

  return result;
}

function parseMap(configuration, path, value, definition, folder) {
  const result = new Map();
  if (typeof value !== `object` || Array.isArray(value)) throw new clipanion__WEBPACK_IMPORTED_MODULE_3__.UsageError(`Map configuration settings "${path}" must be an object`);
  if (value === null) return result;

  for (const [propKey, propValue] of Object.entries(value)) {
    const normalizedKey = definition.normalizeKeys ? definition.normalizeKeys(propKey) : propKey;
    const subPath = `${path}['${normalizedKey}']`; // @ts-expect-error: SettingsDefinitionNoDefault has ... no default ... but
    // that's fine because we're guaranteed it's not undefined.

    const valueDefinition = definition.valueDefinition;
    result.set(normalizedKey, parseValue(configuration, subPath, propValue, valueDefinition, folder));
  }

  return result;
}

function getDefaultValue(configuration, definition, {
  ignoreArrays = false
} = {}) {
  switch (definition.type) {
    case SettingsType.SHAPE:
      {
        if (definition.isArray && !ignoreArrays) return [];
        const result = new Map();

        for (const [propKey, propDefinition] of Object.entries(definition.properties)) result.set(propKey, getDefaultValue(configuration, propDefinition));

        return result;
      }
      break;

    case SettingsType.MAP:
      {
        if (definition.isArray && !ignoreArrays) return [];
        return new Map();
      }
      break;

    case SettingsType.ABSOLUTE_PATH:
      {
        if (definition.default === null) return null;

        if (configuration.projectCwd === null) {
          if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.isAbsolute(definition.default)) {
            return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.normalize(definition.default);
          } else if (definition.isNullable) {
            return null;
          } else {
            // Reached when a relative path is the default but the current
            // context is evaluated outside of a Yarn project
            return undefined;
          }
        } else {
          if (Array.isArray(definition.default)) {
            return definition.default.map(entry => _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(configuration.projectCwd, entry));
          } else {
            return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(configuration.projectCwd, definition.default);
          }
        }
      }
      break;

    default:
      {
        return definition.default;
      }
      break;
  }
}

function transformConfiguration(rawValue, definition, transforms) {
  if (definition.type === SettingsType.SECRET && typeof rawValue === `string` && transforms.hideSecrets) return SECRET;
  if (definition.type === SettingsType.ABSOLUTE_PATH && typeof rawValue === `string` && transforms.getNativePaths) return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.fromPortablePath(rawValue);

  if (definition.isArray && Array.isArray(rawValue)) {
    const newValue = [];

    for (const value of rawValue) newValue.push(transformConfiguration(value, definition, transforms));

    return newValue;
  }

  if (definition.type === SettingsType.MAP && rawValue instanceof Map) {
    const newValue = new Map();

    for (const [key, value] of rawValue.entries()) newValue.set(key, transformConfiguration(value, definition.valueDefinition, transforms));

    return newValue;
  }

  if (definition.type === SettingsType.SHAPE && rawValue instanceof Map) {
    const newValue = new Map();

    for (const [key, value] of rawValue.entries()) {
      const propertyDefinition = definition.properties[key];
      newValue.set(key, transformConfiguration(value, propertyDefinition, transforms));
    }

    return newValue;
  }

  return rawValue;
}

function getEnvironmentSettings() {
  const environmentSettings = {};

  for (let [key, value] of Object.entries(process.env)) {
    key = key.toLowerCase();
    if (!key.startsWith(ENVIRONMENT_PREFIX)) continue;
    key = camelcase__WEBPACK_IMPORTED_MODULE_1___default()(key.slice(ENVIRONMENT_PREFIX.length));
    environmentSettings[key] = value;
  }

  return environmentSettings;
}

function getRcFilename() {
  const rcKey = `${ENVIRONMENT_PREFIX}rc_filename`;

  for (const [key, value] of Object.entries(process.env)) if (key.toLowerCase() === rcKey && typeof value === `string`) return value;

  return DEFAULT_RC_FILENAME;
}

var ProjectLookup;

(function (ProjectLookup) {
  ProjectLookup[ProjectLookup["LOCKFILE"] = 0] = "LOCKFILE";
  ProjectLookup[ProjectLookup["MANIFEST"] = 1] = "MANIFEST";
  ProjectLookup[ProjectLookup["NONE"] = 2] = "NONE";
})(ProjectLookup || (ProjectLookup = {}));

class Configuration {
  constructor(startingCwd) {
    this.projectCwd = null;
    this.plugins = new Map();
    this.settings = new Map();
    this.values = new Map();
    this.sources = new Map();
    this.invalid = new Map();
    this.packageExtensions = new Map();
    this.limits = new Map();
    this.startingCwd = startingCwd;
  }

  static create(startingCwd, projectCwdOrPlugins, maybePlugins) {
    const configuration = new Configuration(startingCwd);
    if (typeof projectCwdOrPlugins !== `undefined` && !(projectCwdOrPlugins instanceof Map)) configuration.projectCwd = projectCwdOrPlugins;
    configuration.importSettings(coreDefinitions);
    const plugins = typeof maybePlugins !== `undefined` ? maybePlugins : projectCwdOrPlugins instanceof Map ? projectCwdOrPlugins : new Map();

    for (const [name, plugin] of plugins) configuration.activatePlugin(name, plugin);

    return configuration;
  }
  /**
   * Instantiate a new configuration object exposing the configuration obtained
   * from reading the various rc files and the environment settings.
   *
   * The `pluginConfiguration` parameter is expected to indicate:
   *
   * 1. which modules should be made available to plugins when they require a
   *    package (this is the dynamic linking part - for example we want all the
   *    plugins to use the exact same version of @yarnpkg/core, which also is the
   *    version used by the running Yarn instance).
   *
   * 2. which of those modules are actually plugins that need to be injected
   *    within the configuration.
   *
   * Note that some extra plugins will be automatically added based on the
   * content of the rc files - with the rc plugins taking precedence over
   * the other ones.
   *
   * One particularity: the plugin initialization order is quite strict, with
   * plugins listed in /foo/bar/.yarnrc.yml taking precedence over plugins
   * listed in /foo/.yarnrc.yml and /.yarnrc.yml. Additionally, while plugins
   * can depend on one another, they can only depend on plugins that have been
   * instantiated before them (so a plugin listed in /foo/.yarnrc.yml can
   * depend on another one listed on /foo/bar/.yarnrc.yml, but not the other
   * way around).
   */


  static async find(startingCwd, pluginConfiguration, {
    lookup = ProjectLookup.LOCKFILE,
    strict = true,
    usePath = false,
    useRc = true
  } = {}) {
    const environmentSettings = getEnvironmentSettings();
    delete environmentSettings.rcFilename;
    const rcFiles = await Configuration.findRcFiles(startingCwd);
    const homeRcFile = await Configuration.findHomeRcFile();

    const pickCoreFields = ({
      ignoreCwd,
      yarnPath,
      ignorePath,
      lockfileFilename
    }) => ({
      ignoreCwd,
      yarnPath,
      ignorePath,
      lockfileFilename
    });

    const excludeCoreFields = ({
      ignoreCwd,
      yarnPath,
      ignorePath,
      lockfileFilename,
      ...rest
    }) => rest;

    const configuration = new Configuration(startingCwd);
    configuration.importSettings(pickCoreFields(coreDefinitions));
    configuration.useWithSource(`<environment>`, pickCoreFields(environmentSettings), startingCwd, {
      strict: false
    });

    for (const {
      path,
      cwd,
      data
    } of rcFiles) configuration.useWithSource(path, pickCoreFields(data), cwd, {
      strict: false
    });

    if (homeRcFile) configuration.useWithSource(homeRcFile.path, pickCoreFields(homeRcFile.data), homeRcFile.cwd, {
      strict: false
    });

    if (usePath) {
      const yarnPath = configuration.get(`yarnPath`);
      const ignorePath = configuration.get(`ignorePath`);

      if (yarnPath !== null && !ignorePath) {
        return configuration;
      }
    } // We need to know the project root before being able to truly instantiate
    // our configuration, and to know that we need to know the lockfile name


    const lockfileFilename = configuration.get(`lockfileFilename`);
    let projectCwd;

    switch (lookup) {
      case ProjectLookup.LOCKFILE:
        {
          projectCwd = await Configuration.findProjectCwd(startingCwd, lockfileFilename);
        }
        break;

      case ProjectLookup.MANIFEST:
        {
          projectCwd = await Configuration.findProjectCwd(startingCwd, null);
        }
        break;

      case ProjectLookup.NONE:
        {
          if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(startingCwd, `package.json`))) {
            projectCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(startingCwd);
          } else {
            projectCwd = null;
          }
        }
        break;
    } // Great! We now have enough information to really start to setup the
    // core configuration object.


    configuration.startingCwd = startingCwd;
    configuration.projectCwd = projectCwd;
    configuration.importSettings(excludeCoreFields(coreDefinitions)); // Now that the configuration object is almost ready, we need to load all
    // the configured plugins

    const plugins = new Map([[`@@core`, _CorePlugin__WEBPACK_IMPORTED_MODULE_14__.CorePlugin]]);

    const interop = obj => obj.__esModule ? obj.default : obj;

    if (pluginConfiguration !== null) {
      for (const request of pluginConfiguration.plugins.keys()) plugins.set(request, interop(pluginConfiguration.modules.get(request)));

      const requireEntries = new Map();

      for (const request of _nodeUtils__WEBPACK_IMPORTED_MODULE_15__.builtinModules()) requireEntries.set(request, () => _nodeUtils__WEBPACK_IMPORTED_MODULE_15__.dynamicRequire(request));

      for (const [request, embedModule] of pluginConfiguration.modules) requireEntries.set(request, () => embedModule);

      const dynamicPlugins = new Set();

      const getDefault = object => {
        return object.default || object;
      };

      const importPlugin = (pluginPath, source) => {
        const {
          factory,
          name
        } = _nodeUtils__WEBPACK_IMPORTED_MODULE_15__.dynamicRequire(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.fromPortablePath(pluginPath)); // Prevent plugin redefinition so that the ones declared deeper in the
        // filesystem always have precedence over the ones below.

        if (dynamicPlugins.has(name)) return;
        const pluginRequireEntries = new Map(requireEntries);

        const pluginRequire = request => {
          if (pluginRequireEntries.has(request)) {
            return pluginRequireEntries.get(request)();
          } else {
            throw new clipanion__WEBPACK_IMPORTED_MODULE_3__.UsageError(`This plugin cannot access the package referenced via ${request} which is neither a builtin, nor an exposed entry`);
          }
        };

        const plugin = _miscUtils__WEBPACK_IMPORTED_MODULE_10__.prettifySyncErrors(() => {
          return getDefault(factory(pluginRequire));
        }, message => {
          return `${message} (when initializing ${name}, defined in ${source})`;
        });
        requireEntries.set(name, () => plugin);
        dynamicPlugins.add(name);
        plugins.set(name, plugin);
      };

      if (environmentSettings.plugins) {
        for (const userProvidedPath of environmentSettings.plugins.split(`;`)) {
          const pluginPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(startingCwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.toPortablePath(userProvidedPath));
          importPlugin(pluginPath, `<environment>`);
        }
      }

      for (const {
        path,
        cwd,
        data
      } of rcFiles) {
        if (!useRc) continue;
        if (!Array.isArray(data.plugins)) continue;

        for (const userPluginEntry of data.plugins) {
          const userProvidedPath = typeof userPluginEntry !== `string` ? userPluginEntry.path : userPluginEntry;
          const pluginPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.toPortablePath(userProvidedPath));
          importPlugin(pluginPath, path);
        }
      }
    }

    for (const [name, plugin] of plugins) configuration.activatePlugin(name, plugin);

    configuration.useWithSource(`<environment>`, excludeCoreFields(environmentSettings), startingCwd, {
      strict
    });

    for (const {
      path,
      cwd,
      data
    } of rcFiles) configuration.useWithSource(path, excludeCoreFields(data), cwd, {
      strict
    }); // The home configuration is never strict because it improves support for
    // multiple projects using different Yarn versions on the same machine


    if (homeRcFile) configuration.useWithSource(homeRcFile.path, excludeCoreFields(homeRcFile.data), homeRcFile.cwd, {
      strict: false
    });

    if (configuration.get(`enableGlobalCache`)) {
      configuration.values.set(`cacheFolder`, `${configuration.get(`globalFolder`)}/cache`);
      configuration.sources.set(`cacheFolder`, `<internal>`);
    }

    await configuration.refreshPackageExtensions();
    return configuration;
  }

  static async findRcFiles(startingCwd) {
    const rcFilename = getRcFilename();
    const rcFiles = [];
    let nextCwd = startingCwd;
    let currentCwd = null;

    while (nextCwd !== currentCwd) {
      currentCwd = nextCwd;
      const rcPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(currentCwd, rcFilename);

      if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.existsSync(rcPath)) {
        const content = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.readFilePromise(rcPath, `utf8`);
        let data;

        try {
          data = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseSyml)(content);
        } catch (error) {
          let tip = ``;
          if (content.match(/^\s+(?!-)[^:]+\s+\S+/m)) tip = ` (in particular, make sure you list the colons after each key name)`;
          throw new clipanion__WEBPACK_IMPORTED_MODULE_3__.UsageError(`Parse error when loading ${rcPath}; please check it's proper Yaml${tip}`);
        }

        rcFiles.push({
          path: rcPath,
          cwd: currentCwd,
          data
        });
      }

      nextCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.dirname(currentCwd);
    }

    return rcFiles;
  }

  static async findHomeRcFile() {
    const rcFilename = getRcFilename();
    const homeFolder = _folderUtils__WEBPACK_IMPORTED_MODULE_8__.getHomeFolder();
    const homeRcFilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(homeFolder, rcFilename);

    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.existsSync(homeRcFilePath)) {
      const content = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.readFilePromise(homeRcFilePath, `utf8`);
      const data = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseSyml)(content);
      return {
        path: homeRcFilePath,
        cwd: homeFolder,
        data
      };
    }

    return null;
  }

  static async findProjectCwd(startingCwd, lockfileFilename) {
    let projectCwd = null;
    let nextCwd = startingCwd;
    let currentCwd = null;

    while (nextCwd !== currentCwd) {
      currentCwd = nextCwd;
      if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(currentCwd, `package.json`))) projectCwd = currentCwd;

      if (lockfileFilename !== null) {
        if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(currentCwd, lockfileFilename))) {
          projectCwd = currentCwd;
          break;
        }
      } else {
        if (projectCwd !== null) {
          break;
        }
      }

      nextCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.dirname(currentCwd);
    }

    return projectCwd;
  }

  static async updateConfiguration(cwd, patch) {
    const rcFilename = getRcFilename();
    const configurationPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(cwd, rcFilename);
    const current = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.existsSync(configurationPath) ? (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseSyml)(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.readFilePromise(configurationPath, `utf8`)) : {};
    let patched = false;
    let replacement;

    if (typeof patch === `function`) {
      try {
        replacement = patch(current);
      } catch (_a) {
        replacement = patch({});
      }

      if (replacement === current) {
        return;
      }
    } else {
      replacement = current;

      for (const key of Object.keys(patch)) {
        const currentValue = current[key];
        const patchField = patch[key];
        let nextValue;

        if (typeof patchField === `function`) {
          try {
            nextValue = patchField(currentValue);
          } catch (_b) {
            nextValue = patchField(undefined);
          }
        } else {
          nextValue = patchField;
        }

        if (currentValue === nextValue) continue;
        replacement[key] = nextValue;
        patched = true;
      }

      if (!patched) {
        return;
      }
    }

    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.changeFilePromise(configurationPath, (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.stringifySyml)(replacement), {
      automaticNewlines: true
    });
  }

  static async updateHomeConfiguration(patch) {
    const homeFolder = _folderUtils__WEBPACK_IMPORTED_MODULE_8__.getHomeFolder();
    return await Configuration.updateConfiguration(homeFolder, patch);
  }

  activatePlugin(name, plugin) {
    this.plugins.set(name, plugin);

    if (typeof plugin.configuration !== `undefined`) {
      this.importSettings(plugin.configuration);
    }
  }

  importSettings(definitions) {
    for (const [name, definition] of Object.entries(definitions)) {
      if (definition == null) continue;
      if (this.settings.has(name)) throw new Error(`Cannot redefine settings "${name}"`);
      this.settings.set(name, definition);
      this.values.set(name, getDefaultValue(this, definition));
    }
  }

  useWithSource(source, data, folder, opts) {
    try {
      this.use(source, data, folder, opts);
    } catch (error) {
      error.message += ` (in ${_formatUtils__WEBPACK_IMPORTED_MODULE_7__.pretty(this, source, _formatUtils__WEBPACK_IMPORTED_MODULE_7__.Type.PATH)})`;
      throw error;
    }
  }

  use(source, data, folder, {
    strict = true,
    overwrite = false
  } = {}) {
    for (const key of Object.keys(data)) {
      const value = data[key];
      if (typeof value === `undefined`) continue; // The plugins have already been loaded at this point

      if (key === `plugins`) continue; // Some environment variables should be ignored when applying the configuration

      if (source === `<environment>` && IGNORED_ENV_VARIABLES.has(key)) continue; // It wouldn't make much sense, would it?

      if (key === `rcFilename`) throw new clipanion__WEBPACK_IMPORTED_MODULE_3__.UsageError(`The rcFilename settings can only be set via ${`${ENVIRONMENT_PREFIX}RC_FILENAME`.toUpperCase()}, not via a rc file`);
      const definition = this.settings.get(key);

      if (!definition) {
        if (strict) {
          throw new clipanion__WEBPACK_IMPORTED_MODULE_3__.UsageError(`Unrecognized or legacy configuration settings found: ${key} - run "yarn config -v" to see the list of settings supported in Yarn`);
        } else {
          this.invalid.set(key, source);
          continue;
        }
      }

      if (this.sources.has(key) && !(overwrite || definition.type === SettingsType.MAP || definition.isArray && definition.concatenateValues)) continue;
      let parsed;

      try {
        parsed = parseValue(this, key, data[key], definition, folder);
      } catch (error) {
        error.message += ` in ${_formatUtils__WEBPACK_IMPORTED_MODULE_7__.pretty(this, source, _formatUtils__WEBPACK_IMPORTED_MODULE_7__.Type.PATH)}`;
        throw error;
      }

      if (definition.type === SettingsType.MAP) {
        const previousValue = this.values.get(key);
        this.values.set(key, new Map(overwrite ? [...previousValue, ...parsed] : [...parsed, ...previousValue]));
        this.sources.set(key, `${this.sources.get(key)}, ${source}`);
      } else if (definition.isArray && definition.concatenateValues) {
        const previousValue = this.values.get(key);
        this.values.set(key, overwrite ? [...previousValue, ...parsed] : [...parsed, ...previousValue]);
        this.sources.set(key, `${this.sources.get(key)}, ${source}`);
      } else {
        this.values.set(key, parsed);
        this.sources.set(key, source);
      }
    }
  }

  get(key) {
    if (!this.values.has(key)) throw new Error(`Invalid configuration key "${key}"`);
    return this.values.get(key);
  }

  getSpecial(key, {
    hideSecrets = false,
    getNativePaths = false
  }) {
    const rawValue = this.get(key);
    const definition = this.settings.get(key);
    if (typeof definition === `undefined`) throw new clipanion__WEBPACK_IMPORTED_MODULE_3__.UsageError(`Couldn't find a configuration settings named "${key}"`);
    return transformConfiguration(rawValue, definition, {
      hideSecrets,
      getNativePaths
    });
  }

  getSubprocessStreams(logFile, {
    header,
    prefix,
    report
  }) {
    let stdout;
    let stderr;
    const logStream = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.createWriteStream(logFile);

    if (this.get(`enableInlineBuilds`)) {
      const stdoutLineReporter = report.createStreamReporter(`${prefix} ${_formatUtils__WEBPACK_IMPORTED_MODULE_7__.pretty(this, `STDOUT`, `green`)}`);
      const stderrLineReporter = report.createStreamReporter(`${prefix} ${_formatUtils__WEBPACK_IMPORTED_MODULE_7__.pretty(this, `STDERR`, `red`)}`);
      stdout = new stream__WEBPACK_IMPORTED_MODULE_6__.PassThrough();
      stdout.pipe(stdoutLineReporter);
      stdout.pipe(logStream);
      stderr = new stream__WEBPACK_IMPORTED_MODULE_6__.PassThrough();
      stderr.pipe(stderrLineReporter);
      stderr.pipe(logStream);
    } else {
      stdout = logStream;
      stderr = logStream;

      if (typeof header !== `undefined`) {
        stdout.write(`${header}\n`);
      }
    }

    return {
      stdout,
      stderr
    };
  }

  makeResolver() {
    const pluginResolvers = [];

    for (const plugin of this.plugins.values()) for (const resolver of plugin.resolvers || []) pluginResolvers.push(new resolver());

    return new _MultiResolver__WEBPACK_IMPORTED_MODULE_16__.MultiResolver([new _VirtualResolver__WEBPACK_IMPORTED_MODULE_17__.VirtualResolver(), new _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_18__.WorkspaceResolver(), new _ProtocolResolver__WEBPACK_IMPORTED_MODULE_19__.ProtocolResolver(), ...pluginResolvers]);
  }

  makeFetcher() {
    const pluginFetchers = [];

    for (const plugin of this.plugins.values()) for (const fetcher of plugin.fetchers || []) pluginFetchers.push(new fetcher());

    return new _MultiFetcher__WEBPACK_IMPORTED_MODULE_20__.MultiFetcher([new _VirtualFetcher__WEBPACK_IMPORTED_MODULE_21__.VirtualFetcher(), new _WorkspaceFetcher__WEBPACK_IMPORTED_MODULE_22__.WorkspaceFetcher(), ...pluginFetchers]);
  }

  getLinkers() {
    const linkers = [];

    for (const plugin of this.plugins.values()) for (const linker of plugin.linkers || []) linkers.push(new linker());

    return linkers;
  }

  async refreshPackageExtensions() {
    this.packageExtensions = new Map();
    const packageExtensions = this.packageExtensions;

    const registerPackageExtension = (descriptor, extensionData, {
      userProvided = false
    } = {}) => {
      if (!semver__WEBPACK_IMPORTED_MODULE_5___default().validRange(descriptor.range)) throw new Error(`Only semver ranges are allowed as keys for the lockfileExtensions setting`);
      const extension = new _Manifest__WEBPACK_IMPORTED_MODULE_23__.Manifest();
      extension.load(extensionData, {
        yamlCompatibilityMode: true
      });
      const extensionsPerIdent = _miscUtils__WEBPACK_IMPORTED_MODULE_10__.getArrayWithDefault(packageExtensions, descriptor.identHash);
      const extensionsPerRange = [];
      extensionsPerIdent.push([descriptor.range, extensionsPerRange]);
      const baseExtension = {
        status: _types__WEBPACK_IMPORTED_MODULE_24__.PackageExtensionStatus.Inactive,
        userProvided,
        parentDescriptor: descriptor
      };

      for (const dependency of extension.dependencies.values()) extensionsPerRange.push({ ...baseExtension,
        type: _types__WEBPACK_IMPORTED_MODULE_24__.PackageExtensionType.Dependency,
        descriptor: dependency,
        description: `${_structUtils__WEBPACK_IMPORTED_MODULE_12__.stringifyIdent(descriptor)} > ${_structUtils__WEBPACK_IMPORTED_MODULE_12__.stringifyIdent(dependency)}`
      });

      for (const peerDependency of extension.peerDependencies.values()) extensionsPerRange.push({ ...baseExtension,
        type: _types__WEBPACK_IMPORTED_MODULE_24__.PackageExtensionType.PeerDependency,
        descriptor: peerDependency,
        description: `${_structUtils__WEBPACK_IMPORTED_MODULE_12__.stringifyIdent(descriptor)} >> ${_structUtils__WEBPACK_IMPORTED_MODULE_12__.stringifyIdent(peerDependency)}`
      });

      for (const [selector, meta] of extension.peerDependenciesMeta) {
        for (const [key, value] of Object.entries(meta)) {
          extensionsPerRange.push({ ...baseExtension,
            type: _types__WEBPACK_IMPORTED_MODULE_24__.PackageExtensionType.PeerDependencyMeta,
            selector,
            key: key,
            value,
            description: `${_structUtils__WEBPACK_IMPORTED_MODULE_12__.stringifyIdent(descriptor)} >> ${selector} / ${key}`
          });
        }
      }
    };

    for (const [descriptorString, extensionData] of this.get(`packageExtensions`)) registerPackageExtension(_structUtils__WEBPACK_IMPORTED_MODULE_12__.parseDescriptor(descriptorString, true), _miscUtils__WEBPACK_IMPORTED_MODULE_10__.convertMapsToIndexableObjects(extensionData), {
      userProvided: true
    });

    await this.triggerHook(hooks => {
      return hooks.registerPackageExtensions;
    }, this, registerPackageExtension);
  }

  normalizePackage(original) {
    const pkg = _structUtils__WEBPACK_IMPORTED_MODULE_12__.copyPackage(original); // We use the extensions to define additional dependencies that weren't
    // properly listed in the original package definition

    if (this.packageExtensions == null) throw new Error(`refreshPackageExtensions has to be called before normalizing packages`);
    const extensionsPerIdent = this.packageExtensions.get(original.identHash);

    if (typeof extensionsPerIdent !== `undefined`) {
      const version = original.version;

      if (version !== null) {
        for (const [range, extensionsPerRange] of extensionsPerIdent) {
          if (!_semverUtils__WEBPACK_IMPORTED_MODULE_25__.satisfiesWithPrereleases(version, range)) continue;

          for (const extension of extensionsPerRange) {
            // If an extension is active for a package but redundant
            // for another one, it should be considered active
            if (extension.status === _types__WEBPACK_IMPORTED_MODULE_24__.PackageExtensionStatus.Inactive) extension.status = _types__WEBPACK_IMPORTED_MODULE_24__.PackageExtensionStatus.Redundant;

            switch (extension.type) {
              case _types__WEBPACK_IMPORTED_MODULE_24__.PackageExtensionType.Dependency:
                {
                  const currentDependency = pkg.dependencies.get(extension.descriptor.identHash);

                  if (typeof currentDependency === `undefined`) {
                    extension.status = _types__WEBPACK_IMPORTED_MODULE_24__.PackageExtensionStatus.Active;
                    pkg.dependencies.set(extension.descriptor.identHash, extension.descriptor);
                  }
                }
                break;

              case _types__WEBPACK_IMPORTED_MODULE_24__.PackageExtensionType.PeerDependency:
                {
                  const currentPeerDependency = pkg.peerDependencies.get(extension.descriptor.identHash);

                  if (typeof currentPeerDependency === `undefined`) {
                    extension.status = _types__WEBPACK_IMPORTED_MODULE_24__.PackageExtensionStatus.Active;
                    pkg.peerDependencies.set(extension.descriptor.identHash, extension.descriptor);
                  }
                }
                break;

              case _types__WEBPACK_IMPORTED_MODULE_24__.PackageExtensionType.PeerDependencyMeta:
                {
                  const currentPeerDependencyMeta = pkg.peerDependenciesMeta.get(extension.selector);

                  if (typeof currentPeerDependencyMeta === `undefined` || !Object.prototype.hasOwnProperty.call(currentPeerDependencyMeta, extension.key) || currentPeerDependencyMeta[extension.key] !== extension.value) {
                    extension.status = _types__WEBPACK_IMPORTED_MODULE_24__.PackageExtensionStatus.Active;
                    _miscUtils__WEBPACK_IMPORTED_MODULE_10__.getFactoryWithDefault(pkg.peerDependenciesMeta, extension.selector, () => ({}))[extension.key] = extension.value;
                  }
                }
                break;

              default:
                {
                  _miscUtils__WEBPACK_IMPORTED_MODULE_10__.assertNever(extension);
                }
                break;
            }
          }
        }
      }
    } // We also add implicit optional @types peer dependencies for each peer
    // dependency. This is for compatibility reason, as many existing packages
    // forget to define their @types/react optional peer dependency when they
    // peer-depend on react.


    const getTypesName = descriptor => {
      return descriptor.scope ? `${descriptor.scope}__${descriptor.name}` : `${descriptor.name}`;
    };

    for (const descriptor of pkg.peerDependencies.values()) {
      if (descriptor.scope === `@types`) continue;
      const typesName = getTypesName(descriptor);
      const typesIdent = _structUtils__WEBPACK_IMPORTED_MODULE_12__.makeIdent(`types`, typesName);
      if (pkg.peerDependencies.has(typesIdent.identHash) || pkg.peerDependenciesMeta.has(typesIdent.identHash)) continue;
      pkg.peerDependenciesMeta.set(_structUtils__WEBPACK_IMPORTED_MODULE_12__.stringifyIdent(typesIdent), {
        optional: true
      });
    } // I don't like implicit dependencies, but package authors are reluctant to
    // use optional peer dependencies because they would print warnings in older
    // npm releases.


    for (const identString of pkg.peerDependenciesMeta.keys()) {
      const ident = _structUtils__WEBPACK_IMPORTED_MODULE_12__.parseIdent(identString);

      if (!pkg.peerDependencies.has(ident.identHash)) {
        pkg.peerDependencies.set(ident.identHash, _structUtils__WEBPACK_IMPORTED_MODULE_12__.makeDescriptor(ident, `*`));
      }
    } // We sort the dependencies so that further iterations always occur in the
    // same order, regardless how the various registries formatted their output


    pkg.dependencies = new Map(_miscUtils__WEBPACK_IMPORTED_MODULE_10__.sortMap(pkg.dependencies, ([, descriptor]) => _structUtils__WEBPACK_IMPORTED_MODULE_12__.stringifyDescriptor(descriptor)));
    pkg.peerDependencies = new Map(_miscUtils__WEBPACK_IMPORTED_MODULE_10__.sortMap(pkg.peerDependencies, ([, descriptor]) => _structUtils__WEBPACK_IMPORTED_MODULE_12__.stringifyDescriptor(descriptor)));
    return pkg;
  }

  getLimit(key) {
    return _miscUtils__WEBPACK_IMPORTED_MODULE_10__.getFactoryWithDefault(this.limits, key, () => {
      return p_limit__WEBPACK_IMPORTED_MODULE_4___default()(this.get(key));
    });
  }

  async triggerHook(get, ...args) {
    for (const plugin of this.plugins.values()) {
      const hooks = plugin.hooks;
      if (!hooks) continue;
      const hook = get(hooks);
      if (!hook) continue;
      await hook(...args);
    }
  }

  async triggerMultipleHooks(get, argsList) {
    for (const args of argsList) {
      await this.triggerHook(get, ...args);
    }
  }

  async reduceHook(get, initialValue, ...args) {
    let value = initialValue;

    for (const plugin of this.plugins.values()) {
      const hooks = plugin.hooks;
      if (!hooks) continue;
      const hook = get(hooks);
      if (!hook) continue;
      value = await hook(value, ...args);
    }

    return value;
  }

  async firstHook(get, ...args) {
    for (const plugin of this.plugins.values()) {
      const hooks = plugin.hooks;
      if (!hooks) continue;
      const hook = get(hooks);
      if (!hook) continue;
      const ret = await hook(...args);

      if (typeof ret !== `undefined`) {
        // @ts-expect-error
        return ret;
      }
    }

    return null;
  }
  /**
   * @deprecated Prefer using formatUtils.pretty instead, which is type-safe
   */


  format(value, formatType) {
    return _formatUtils__WEBPACK_IMPORTED_MODULE_7__.pretty(this, value, formatType);
  }

}
Configuration.telemetry = null;

/***/ }),
/* 182 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseShell": () => /* reexport safe */ _shell__WEBPACK_IMPORTED_MODULE_0__.parseShell,
/* harmony export */   "parseResolution": () => /* reexport safe */ _resolution__WEBPACK_IMPORTED_MODULE_1__.parseResolution,
/* harmony export */   "stringifyResolution": () => /* reexport safe */ _resolution__WEBPACK_IMPORTED_MODULE_1__.stringifyResolution,
/* harmony export */   "parseSyml": () => /* reexport safe */ _syml__WEBPACK_IMPORTED_MODULE_2__.parseSyml,
/* harmony export */   "stringifySyml": () => /* reexport safe */ _syml__WEBPACK_IMPORTED_MODULE_2__.stringifySyml
/* harmony export */ });
/* harmony import */ var _shell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(183);
/* harmony import */ var _resolution__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(185);
/* harmony import */ var _syml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(187);




/***/ }),
/* 183 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseShell": () => /* binding */ parseShell
/* harmony export */ });
/* harmony import */ var _grammars_shell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(184);
/* harmony import */ var _grammars_shell__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_grammars_shell__WEBPACK_IMPORTED_MODULE_0__);

function parseShell(source, options = {
  isGlobPattern: () => false
}) {
  try {
    return (0,_grammars_shell__WEBPACK_IMPORTED_MODULE_0__.parse)(source, options);
  } catch (error) {
    if (error.location) error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
    throw error;
  }
}

/***/ }),
/* 184 */
/***/ ((module) => {

"use strict";
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */



function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { Start: peg$parseStart },
      peg$startRuleFunction  = peg$parseStart,

      peg$c0 = function(line) { return line ? line : [] },
      peg$c1 = function(command, type, then) { return [ command ].concat(then || []) },
      peg$c2 = function(command, type) { return [ command ] },
      peg$c3 = function(then) { return then },
      peg$c4 = ";",
      peg$c5 = peg$literalExpectation(";", false),
      peg$c6 = function(chain, then) { return then ? { chain, then } : { chain } },
      peg$c7 = function(type, then) { return { type, line: then } },
      peg$c8 = "&&",
      peg$c9 = peg$literalExpectation("&&", false),
      peg$c10 = "||",
      peg$c11 = peg$literalExpectation("||", false),
      peg$c12 = function(main, then) { return then ? { ...main, then } : main },
      peg$c13 = function(type, then) { return { type, chain: then } },
      peg$c14 = "|&",
      peg$c15 = peg$literalExpectation("|&", false),
      peg$c16 = "|",
      peg$c17 = peg$literalExpectation("|", false),
      peg$c18 = "=",
      peg$c19 = peg$literalExpectation("=", false),
      peg$c20 = function(name, arg) { return { name, args: [arg] } },
      peg$c21 = function(name) { return { name, args: [] } },
      peg$c22 = "(",
      peg$c23 = peg$literalExpectation("(", false),
      peg$c24 = ")",
      peg$c25 = peg$literalExpectation(")", false),
      peg$c26 = function(subshell, args) { return { type: `subshell`, subshell, args } },
      peg$c27 = "{",
      peg$c28 = peg$literalExpectation("{", false),
      peg$c29 = "}",
      peg$c30 = peg$literalExpectation("}", false),
      peg$c31 = function(group, args) { return { type: `group`, group, args } },
      peg$c32 = function(envs, args) { return { type: `command`, args, envs } },
      peg$c33 = function(envs) { return { type: `envs`, envs } },
      peg$c34 = function(args) { return args },
      peg$c35 = function(arg) { return arg },
      peg$c36 = function(redirect, arg) { return { type: `redirection`, subtype: redirect, args: [arg] } },
      peg$c37 = ">>",
      peg$c38 = peg$literalExpectation(">>", false),
      peg$c39 = ">&",
      peg$c40 = peg$literalExpectation(">&", false),
      peg$c41 = ">",
      peg$c42 = peg$literalExpectation(">", false),
      peg$c43 = "<<<",
      peg$c44 = peg$literalExpectation("<<<", false),
      peg$c45 = "<&",
      peg$c46 = peg$literalExpectation("<&", false),
      peg$c47 = "<",
      peg$c48 = peg$literalExpectation("<", false),
      peg$c49 = function(segments) { return { type: `argument`, segments: [].concat(... segments) } },
      peg$c50 = function(string) { return string },
      peg$c51 = "'",
      peg$c52 = peg$literalExpectation("'", false),
      peg$c53 = function(text) { return [ { type: `text`, text } ] },
      peg$c54 = "\"",
      peg$c55 = peg$literalExpectation("\"", false),
      peg$c56 = function(segments) { return segments },
      peg$c57 = function(arithmetic) { return { type: `arithmetic`, arithmetic, quoted: true} },
      peg$c58 = function(shell) { return { type: `shell`, shell, quoted: true } },
      peg$c59 = function(variable) { return { type: `variable`, ...variable, quoted: true } },
      peg$c60 = function(text) { return { type: `text`, text } },
      peg$c61 = function(arithmetic) { return { type: `arithmetic`, arithmetic, quoted: false} },
      peg$c62 = function(shell) { return { type: `shell`, shell, quoted: false } },
      peg$c63 = function(variable) { return { type: `variable`, ...variable, quoted: false } },
      peg$c64 = function(pattern) { return { type: `glob`, pattern } },
      peg$c65 = "\\",
      peg$c66 = peg$literalExpectation("\\", false),
      peg$c67 = peg$anyExpectation(),
      peg$c68 = function(c) { return c },
      peg$c69 = /^[^']/,
      peg$c70 = peg$classExpectation(["'"], true, false),
      peg$c71 = function(chars) { return chars.join(``) },
      peg$c72 = /^[^$"]/,
      peg$c73 = peg$classExpectation(["$", "\""], true, false),
      peg$c74 = "-",
      peg$c75 = peg$literalExpectation("-", false),
      peg$c76 = "+",
      peg$c77 = peg$literalExpectation("+", false),
      peg$c78 = /^[0-9]/,
      peg$c79 = peg$classExpectation([["0", "9"]], false, false),
      peg$c80 = ".",
      peg$c81 = peg$literalExpectation(".", false),
      peg$c82 = function(sign, left, right) { return { type: `number`, value: (sign === '-' ? -1 : 1) * parseFloat(left.join(``) + `.` + right.join(``)) } },
      peg$c83 = function(sign, value) { return { type: `number`, value: (sign === '-' ? -1 : 1) *  parseInt(value.join(``)) } },
      peg$c84 = function(variable) { return { type: `variable`, ...variable } },
      peg$c85 = function(name) { return { type: `variable`, name } },
      peg$c86 = function(value) { return value },
      peg$c87 = "*",
      peg$c88 = peg$literalExpectation("*", false),
      peg$c89 = function(left, right) { return { type: `multiplication`, left, right } },
      peg$c90 = "/",
      peg$c91 = peg$literalExpectation("/", false),
      peg$c92 = function(left, right) { return { type: `division`, left, right } },
      peg$c93 = function(left, right) { return { type: `addition`, left, right } },
      peg$c94 = function(left, right) { return { type: `subtraction`, left, right } },
      peg$c95 = "$((",
      peg$c96 = peg$literalExpectation("$((", false),
      peg$c97 = "))",
      peg$c98 = peg$literalExpectation("))", false),
      peg$c99 = function(arithmetic) { return arithmetic },
      peg$c100 = "$(",
      peg$c101 = peg$literalExpectation("$(", false),
      peg$c102 = function(command) { return command },
      peg$c103 = "${",
      peg$c104 = peg$literalExpectation("${", false),
      peg$c105 = ":-",
      peg$c106 = peg$literalExpectation(":-", false),
      peg$c107 = function(name, arg) { return { name, defaultValue: arg } },
      peg$c108 = ":-}",
      peg$c109 = peg$literalExpectation(":-}", false),
      peg$c110 = function(name) { return { name, defaultValue: [] } },
      peg$c111 = function(name) { return { name } },
      peg$c112 = "$",
      peg$c113 = peg$literalExpectation("$", false),
      peg$c114 = function(pattern) { return options.isGlobPattern(pattern) },
      peg$c115 = function(pattern) { return pattern },
      peg$c116 = /^[a-zA-Z0-9_]/,
      peg$c117 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false),
      peg$c118 = function() { return text() },
      peg$c119 = /^[$@*?#a-zA-Z0-9_\-]/,
      peg$c120 = peg$classExpectation(["$", "@", "*", "?", "#", ["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false),
      peg$c121 = /^[(){}<>$|&; \t"']/,
      peg$c122 = peg$classExpectation(["(", ")", "{", "}", "<", ">", "$", "|", "&", ";", " ", "\t", "\"", "'"], false, false),
      peg$c123 = /^[<>&; \t"']/,
      peg$c124 = peg$classExpectation(["<", ">", "&", ";", " ", "\t", "\"", "'"], false, false),
      peg$c125 = /^[ \t]/,
      peg$c126 = peg$classExpectation([" ", "\t"], false, false),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parseStart() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseShellLine();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseShellLine() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseCommandLine();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseS();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseS();
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseShellLineType();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseShellLineThen();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseCommandLine();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseS();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseS();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseShellLineType();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c2(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseShellLineThen() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseShellLine();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c3(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseShellLineType() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 59) {
      s0 = peg$c4;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c5); }
    }

    return s0;
  }

  function peg$parseCommandLine() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseCommandChain();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseCommandLineThen();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c6(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandLineThen() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseCommandLineType();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseCommandLine();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseS();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseS();
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c7(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandLineType() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c8) {
      s0 = peg$c8;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c9); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c10) {
        s0 = peg$c10;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c11); }
      }
    }

    return s0;
  }

  function peg$parseCommandChain() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseCommand();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseCommandChainThen();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c12(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandChainThen() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseCommandChainType();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseCommandChain();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseS();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseS();
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c13(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandChainType() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c14) {
      s0 = peg$c14;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c15); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 124) {
        s0 = peg$c16;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c17); }
      }
    }

    return s0;
  }

  function peg$parseVariableAssignment() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseEnvVariable();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 61) {
        s2 = peg$c18;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c19); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseStrictValueArgument();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseS();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseS();
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c20(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseEnvVariable();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s2 = peg$c18;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c19); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c21(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseCommand() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c22;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c23); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseShellLine();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseS();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseS();
            }
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s6 = peg$c24;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c25); }
              }
              if (s6 !== peg$FAILED) {
                s7 = [];
                s8 = peg$parseS();
                while (s8 !== peg$FAILED) {
                  s7.push(s8);
                  s8 = peg$parseS();
                }
                if (s7 !== peg$FAILED) {
                  s8 = [];
                  s9 = peg$parseRedirectArgument();
                  while (s9 !== peg$FAILED) {
                    s8.push(s9);
                    s9 = peg$parseRedirectArgument();
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = [];
                    s10 = peg$parseS();
                    while (s10 !== peg$FAILED) {
                      s9.push(s10);
                      s10 = peg$parseS();
                    }
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c26(s4, s8);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c27;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseShellLine();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseS();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseS();
              }
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s6 = peg$c29;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c30); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parseS();
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parseS();
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = [];
                    s9 = peg$parseRedirectArgument();
                    while (s9 !== peg$FAILED) {
                      s8.push(s9);
                      s9 = peg$parseRedirectArgument();
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = [];
                      s10 = peg$parseS();
                      while (s10 !== peg$FAILED) {
                        s9.push(s10);
                        s10 = peg$parseS();
                      }
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c31(s4, s8);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseVariableAssignment();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseVariableAssignment();
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseArgument();
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseArgument();
                }
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c32(s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseVariableAssignment();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseVariableAssignment();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c33(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
    }

    return s0;
  }

  function peg$parseCommandString() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseValueArgument();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseValueArgument();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c34(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseArgument() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseRedirectArgument();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c35(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseValueArgument();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c35(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseRedirectArgument() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseRedirectType();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseValueArgument();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c36(s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseRedirectType() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c37) {
      s0 = peg$c37;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c38); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c39) {
        s0 = peg$c39;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c40); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 62) {
          s0 = peg$c41;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c42); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c43) {
            s0 = peg$c43;
            peg$currPos += 3;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c44); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c45) {
              s0 = peg$c45;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c46); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 60) {
                s0 = peg$c47;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c48); }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseValueArgument() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseStrictValueArgument();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c35(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseStrictValueArgument() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseArgumentSegment();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseArgumentSegment();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c49(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseArgumentSegment() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseSglQuoteString();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c50(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseDblQuoteString();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c50(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsePlainString();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c50(s1);
        }
        s0 = s1;
      }
    }

    return s0;
  }

  function peg$parseSglQuoteString() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c51;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c52); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseSglQuoteStringText();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s3 = peg$c51;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c52); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c53(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDblQuoteString() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c54;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c55); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseDblQuoteStringSegment();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseDblQuoteStringSegment();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c54;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c55); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c56(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsePlainString() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsePlainStringSegment();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsePlainStringSegment();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c56(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseDblQuoteStringSegment() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseArithmetic();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c57(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseSubshell();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c58(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c59(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseDblQuoteStringText();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c60(s1);
          }
          s0 = s1;
        }
      }
    }

    return s0;
  }

  function peg$parsePlainStringSegment() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseArithmetic();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c61(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseSubshell();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c62(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c63(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseGlob();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c64(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsePlainStringText();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c60(s1);
            }
            s0 = s1;
          }
        }
      }
    }

    return s0;
  }

  function peg$parseSglQuoteStringText() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s3 = peg$c65;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c66); }
    }
    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c68(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 === peg$FAILED) {
      if (peg$c69.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c70); }
      }
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s3 = peg$c65;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c66); }
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c67); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c68(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        if (peg$c69.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c70); }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c71(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseDblQuoteStringText() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s3 = peg$c65;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c66); }
    }
    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c68(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 === peg$FAILED) {
      if (peg$c72.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c73); }
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s3 = peg$c65;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c66); }
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c67); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c68(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          if (peg$c72.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c73); }
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c71(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsePlainStringText() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s3 = peg$c65;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c66); }
    }
    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c68(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 === peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parseSpecialShellChars();
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c67); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c68(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s3 = peg$c65;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c66); }
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c67); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c68(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parseSpecialShellChars();
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c67); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c68(s4);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c71(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseArithmeticPrimary() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s1 = peg$c74;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c75); }
    }
    if (s1 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 43) {
        s1 = peg$c76;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c77); }
      }
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c78.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c79); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c78.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c79); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c80;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c81); }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          if (peg$c78.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c79); }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c78.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c79); }
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c82(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c74;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c75); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c76;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c77); }
        }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c78.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c79); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c78.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c79); }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c83(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c84(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c85(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
              s1 = peg$c22;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c23); }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseArithmeticExpression();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s5 = peg$c24;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c25); }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c86(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseArithmeticTimesExpression() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseArithmeticPrimary();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseS();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseS();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 42) {
          s3 = peg$c87;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c88); }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseS();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseS();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseArithmeticTimesExpression();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c89(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseArithmeticPrimary();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseS();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseS();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s3 = peg$c90;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c91); }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseS();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseS();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseArithmeticTimesExpression();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c92(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseArithmeticPrimary();
      }
    }

    return s0;
  }

  function peg$parseArithmeticExpression() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseArithmeticTimesExpression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseS();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseS();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s3 = peg$c76;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c77); }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseS();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseS();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseArithmeticExpression();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c93(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseArithmeticTimesExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseS();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseS();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s3 = peg$c74;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c75); }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseS();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseS();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseArithmeticExpression();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c94(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseArithmeticTimesExpression();
      }
    }

    return s0;
  }

  function peg$parseArithmetic() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c95) {
      s1 = peg$c95;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c96); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseS();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseS();
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseArithmeticExpression();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseS();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseS();
          }
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c97) {
              s5 = peg$c97;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c98); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c99(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseSubshell() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c100) {
      s1 = peg$c100;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c101); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseShellLine();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 41) {
          s3 = peg$c24;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c102(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseVariable() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c103) {
      s1 = peg$c103;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c104); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseIdentifier();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c105) {
          s3 = peg$c105;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c106); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseCommandString();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c29;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c30); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c107(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c103) {
        s1 = peg$c103;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c104); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseIdentifier();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c108) {
            s3 = peg$c108;
            peg$currPos += 3;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c109); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c110(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c103) {
          s1 = peg$c103;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c104); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s3 = peg$c29;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c30); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c111(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 36) {
            s1 = peg$c112;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c113); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c111(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
    }

    return s0;
  }

  function peg$parseGlob() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseGlobText();
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c114(s1);
      if (s2) {
        s2 = void 0;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c115(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseGlobText() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$currPos;
    peg$silentFails++;
    s4 = peg$parseGlobSpecialShellChars();
    peg$silentFails--;
    if (s4 === peg$FAILED) {
      s3 = void 0;
    } else {
      peg$currPos = s3;
      s3 = peg$FAILED;
    }
    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c68(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseGlobSpecialShellChars();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c67); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c68(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c71(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseEnvVariable() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c116.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c117); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c116.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c117); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c118();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseIdentifier() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c119.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c120); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c119.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c120); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c118();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseSpecialShellChars() {
    var s0;

    if (peg$c121.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c122); }
    }

    return s0;
  }

  function peg$parseGlobSpecialShellChars() {
    var s0;

    if (peg$c123.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c124); }
    }

    return s0;
  }

  function peg$parseS() {
    var s0, s1;

    s0 = [];
    if (peg$c125.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c126); }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c125.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c126); }
        }
      }
    } else {
      s0 = peg$FAILED;
    }

    return s0;
  }

  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};


/***/ }),
/* 185 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseResolution": () => /* binding */ parseResolution,
/* harmony export */   "stringifyResolution": () => /* binding */ stringifyResolution
/* harmony export */ });
/* harmony import */ var _grammars_resolution__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _grammars_resolution__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_grammars_resolution__WEBPACK_IMPORTED_MODULE_0__);

function parseResolution(source) {
  const legacyResolution = source.match(/^\*{1,2}\/(.*)/);
  if (legacyResolution) throw new Error(`The override for '${source}' includes a glob pattern. Glob patterns have been removed since their behaviours don't match what you'd expect. Set the override to '${legacyResolution[1]}' instead.`);

  try {
    return (0,_grammars_resolution__WEBPACK_IMPORTED_MODULE_0__.parse)(source);
  } catch (error) {
    if (error.location) error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
    throw error;
  }
}
function stringifyResolution(resolution) {
  let str = ``;

  if (resolution.from) {
    str += resolution.from.fullName;
    if (resolution.from.description) str += `@${resolution.from.description}`;
    str += `/`;
  }

  str += resolution.descriptor.fullName;
  if (resolution.descriptor.description) str += `@${resolution.descriptor.description}`;
  return str;
}

/***/ }),
/* 186 */
/***/ ((module) => {

"use strict";
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */



function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function(expectation) {
      return `"${literalEscape(expectation.text)}"`;
    },

    "class": function(expectation) {
      var escapedParts = "",
        i;

      for (i = 0; i < expectation.parts.length; i++)
        escapedParts += expectation.parts[i] instanceof Array
          ? `${classEscape(expectation.parts[i][0])}-${classEscape(expectation.parts[i][1])}`
          : classEscape(expectation.parts[i]);


      return `[${expectation.inverted ? "^" : ""}${escapedParts}]`;
    },

    any: function(expectation) {
      return "any character";
    },

    end: function(expectation) {
      return "end of input";
    },

    other: function(expectation) {
      return expectation.description;
    },
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return `\\x0${hex(ch)}`; })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return `\\x${hex(ch)}`; });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return `\\x0${hex(ch)}`; })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return `\\x${hex(ch)}`; });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
      i, j;

    for (i = 0; i < expected.length; i++)
      descriptions[i] = describeExpectation(expected[i]);


    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return `${descriptions[0]} or ${descriptions[1]}`;

      default:
        return `${descriptions.slice(0, -1).join(", ")
        }, or ${
          descriptions[descriptions.length - 1]}`;
    }
  }

  function describeFound(found) {
    return found ? `"${literalEscape(found)}"` : "end of input";
  }

  return `Expected ${describeExpected(expected)} but ${describeFound(found)} found.`;
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

    peg$startRuleFunctions = {resolution: peg$parseresolution},
    peg$startRuleFunction  = peg$parseresolution,

    peg$c0 = "/",
    peg$c1 = peg$literalExpectation("/", false),
    peg$c2 = function(from, descriptor) { return {from, descriptor}; },
    peg$c3 = function(descriptor) { return {descriptor}; },
    peg$c4 = "@",
    peg$c5 = peg$literalExpectation("@", false),
    peg$c6 = function(fullName, description) { return {fullName, description}; },
    peg$c7 = function(fullName) { return {fullName}; },
    peg$c8 = function() { return text(); },
    peg$c9 = /^[^\/@]/,
    peg$c10 = peg$classExpectation(["/", "@"], true, false),
    peg$c11 = /^[^\/]/,
    peg$c12 = peg$classExpectation(["/"], true, false),

    peg$currPos          = 0,
    peg$savedPos         = 0,
    peg$posDetailsCache  = [{line: 1, column: 1}],
    peg$maxFailPos       = 0,
    peg$maxFailExpected  = [],
    peg$silentFails      = 0,

    peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions))
      throw new Error(`Can't start parsing from rule "${options.startRule}".`);


    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return {type: "literal", text: text, ignoreCase: ignoreCase};
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return {type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase};
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function peg$anyExpectation() {
    return {type: "any"};
  }

  function peg$endExpectation() {
    return {type: "end"};
  }

  function peg$otherExpectation(description) {
    return {type: "other", description: description};
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p])
        p--;


      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column,
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
      endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column,
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column,
      },
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos)  return;

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parseresolution() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsespecifier();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 47) {
        s2 = peg$c0;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c1); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsespecifier();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c2(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsespecifier();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c3(s1);
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parsespecifier() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsefullName();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 64) {
        s2 = peg$c4;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsedescription();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c6(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsefullName();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c7(s1);
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parsefullName() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 64) {
      s1 = peg$c4;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c5); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseident();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s3 = peg$c0;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c1); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseident();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c8();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c8();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parseident() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c9.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c10); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c9.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c10); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c8();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsedescription() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c11.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c12); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c11.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c8();
    }
    s0 = s1;

    return s0;
  }

  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length)
      peg$fail(peg$endExpectation());


    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse,
};


/***/ }),
/* 187 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PreserveOrdering": () => /* binding */ PreserveOrdering,
/* harmony export */   "stringifySyml": () => /* binding */ stringifySyml,
/* harmony export */   "parseSyml": () => /* binding */ parseSyml
/* harmony export */ });
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(188);
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_yaml__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grammars_syml__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(219);
/* harmony import */ var _grammars_syml__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_grammars_syml__WEBPACK_IMPORTED_MODULE_1__);
// @ts-expect-error


const simpleStringPattern = /^(?![-?:,\][{}#&*!|>'"%@` \t\r\n]).([ \t]*(?![,\][{}:# \t\r\n]).)*$/; // The following keys will always be stored at the top of the object, in the
// specified order. It's not fair but life isn't fair either.

const specialObjectKeys = [`__metadata`, `version`, `resolution`, `dependencies`, `peerDependencies`, `dependenciesMeta`, `peerDependenciesMeta`, `binaries`];
class PreserveOrdering {
  constructor(data) {
    this.data = data;
  }

}

function stringifyString(value) {
  if (value.match(simpleStringPattern)) {
    return value;
  } else {
    return JSON.stringify(value);
  }
}

function isRemovableField(value) {
  if (typeof value === `undefined`) return true;
  if (typeof value === `object` && value !== null) return Object.keys(value).every(key => isRemovableField(value[key]));
  return false;
}

function stringifyValue(value, indentLevel, newLineIfObject) {
  if (value === null) return `null\n`;
  if (typeof value === `number` || typeof value === `boolean`) return `${value.toString()}\n`;
  if (typeof value === `string`) return `${stringifyString(value)}\n`;

  if (Array.isArray(value)) {
    if (value.length === 0) return `[]\n`;
    const indent = `  `.repeat(indentLevel);
    const serialized = value.map(sub => {
      return `${indent}- ${stringifyValue(sub, indentLevel + 1, false)}`;
    }).join(``);
    return `\n${serialized}`;
  }

  if (typeof value === `object` && value) {
    let data;
    let sort;

    if (value instanceof PreserveOrdering) {
      data = value.data;
      sort = false;
    } else {
      data = value;
      sort = true;
    }

    const indent = `  `.repeat(indentLevel);
    const keys = Object.keys(data);

    if (sort) {
      keys.sort((a, b) => {
        const aIndex = specialObjectKeys.indexOf(a);
        const bIndex = specialObjectKeys.indexOf(b);
        if (aIndex === -1 && bIndex === -1) return a < b ? -1 : a > b ? +1 : 0;
        if (aIndex !== -1 && bIndex === -1) return -1;
        if (aIndex === -1 && bIndex !== -1) return +1;
        return aIndex - bIndex;
      });
    }

    const fields = keys.filter(key => {
      return !isRemovableField(data[key]);
    }).map((key, index) => {
      const value = data[key];
      const stringifiedKey = stringifyString(key);
      const stringifiedValue = stringifyValue(value, indentLevel + 1, true);
      const recordIndentation = index > 0 || newLineIfObject ? indent : ``;

      if (stringifiedValue.startsWith(`\n`)) {
        return `${recordIndentation}${stringifiedKey}:${stringifiedValue}`;
      } else {
        return `${recordIndentation}${stringifiedKey}: ${stringifiedValue}`;
      }
    }).join(indentLevel === 0 ? `\n` : ``) || `\n`;

    if (!newLineIfObject) {
      return `${fields}`;
    } else {
      return `\n${fields}`;
    }
  }

  throw new Error(`Unsupported value type (${value})`);
}

function stringifySyml(value) {
  try {
    const stringified = stringifyValue(value, 0, false);
    return stringified !== `\n` ? stringified : ``;
  } catch (error) {
    if (error.location) error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
    throw error;
  }
}
stringifySyml.PreserveOrdering = PreserveOrdering;

function parseViaPeg(source) {
  if (!source.endsWith(`\n`)) source += `\n`;
  return (0,_grammars_syml__WEBPACK_IMPORTED_MODULE_1__.parse)(source);
}

const LEGACY_REGEXP = /^(#.*(\r?\n))*?#\s+yarn\s+lockfile\s+v1\r?\n/i;

function parseViaJsYaml(source) {
  if (LEGACY_REGEXP.test(source)) return parseViaPeg(source);
  const value = (0,js_yaml__WEBPACK_IMPORTED_MODULE_0__.safeLoad)(source, {
    schema: js_yaml__WEBPACK_IMPORTED_MODULE_0__.FAILSAFE_SCHEMA
  }); // Empty files are parsed as `undefined` instead of an empty object
  // Empty files with 2 newlines or more are `null` instead

  if (value === undefined || value === null) return {};
  if (typeof value !== `object`) throw new Error(`Expected an indexed object, got a ${typeof value} instead. Does your file follow Yaml's rules?`);
  if (Array.isArray(value)) throw new Error(`Expected an indexed object, got an array instead. Does your file follow Yaml's rules?`);
  return value;
}

function parseSyml(source) {
  return parseViaJsYaml(source);
}

/***/ }),
/* 188 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var yaml = __webpack_require__(189);


module.exports = yaml;


/***/ }),
/* 189 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var loader = __webpack_require__(190);
var dumper = __webpack_require__(218);


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type = __webpack_require__(196);
module.exports.Schema = __webpack_require__(195);
module.exports.FAILSAFE_SCHEMA = __webpack_require__(199);
module.exports.JSON_SCHEMA = __webpack_require__(198);
module.exports.CORE_SCHEMA = __webpack_require__(197);
module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(194);
module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(214);
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException = __webpack_require__(192);

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __webpack_require__(199);
module.exports.SAFE_SCHEMA = __webpack_require__(194);
module.exports.DEFAULT_SCHEMA = __webpack_require__(214);

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');


/***/ }),
/* 190 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*eslint-disable max-len,no-use-before-define*/

var common              = __webpack_require__(191);
var YAMLException       = __webpack_require__(192);
var Mark                = __webpack_require__(193);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(194);
var DEFAULT_FULL_SCHEMA = __webpack_require__(214);


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  if (typeof output === 'function') {
    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  } else {
    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;


/***/ }),
/* 191 */
/***/ ((module) => {

"use strict";



function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;


/***/ }),
/* 192 */
/***/ ((module) => {

"use strict";
// YAML error class. http://stackoverflow.com/questions/8458984
//


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;


/***/ }),
/* 193 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var common = __webpack_require__(191);


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;


/***/ }),
/* 194 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)





var Schema = __webpack_require__(195);


module.exports = new Schema({
  include: [
    __webpack_require__(197)
  ],
  implicit: [
    __webpack_require__(207),
    __webpack_require__(208)
  ],
  explicit: [
    __webpack_require__(209),
    __webpack_require__(211),
    __webpack_require__(212),
    __webpack_require__(213)
  ]
});


/***/ }),
/* 195 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*eslint-disable max-len*/

var common        = __webpack_require__(191);
var YAMLException = __webpack_require__(192);
var Type          = __webpack_require__(196);


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;


/***/ }),
/* 196 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var YAMLException = __webpack_require__(192);

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;


/***/ }),
/* 197 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.





var Schema = __webpack_require__(195);


module.exports = new Schema({
  include: [
    __webpack_require__(198)
  ]
});


/***/ }),
/* 198 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.





var Schema = __webpack_require__(195);


module.exports = new Schema({
  include: [
    __webpack_require__(199)
  ],
  implicit: [
    __webpack_require__(203),
    __webpack_require__(204),
    __webpack_require__(205),
    __webpack_require__(206)
  ]
});


/***/ }),
/* 199 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346





var Schema = __webpack_require__(195);


module.exports = new Schema({
  explicit: [
    __webpack_require__(200),
    __webpack_require__(201),
    __webpack_require__(202)
  ]
});


/***/ }),
/* 200 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(196);

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});


/***/ }),
/* 201 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(196);

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});


/***/ }),
/* 202 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(196);

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});


/***/ }),
/* 203 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(196);

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),
/* 204 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(196);

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),
/* 205 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var common = __webpack_require__(191);
var Type   = __webpack_require__(196);

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});


/***/ }),
/* 206 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var common = __webpack_require__(191);
var Type   = __webpack_require__(196);

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});


/***/ }),
/* 207 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(196);

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});


/***/ }),
/* 208 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(196);

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});


/***/ }),
/* 209 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = undefined;
  NodeBuffer = __webpack_require__(210).Buffer;
} catch (__) {}

var Type       = __webpack_require__(196);


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});


/***/ }),
/* 210 */
/***/ ((module) => {

"use strict";
module.exports = require("buffer");;

/***/ }),
/* 211 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(196);

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});


/***/ }),
/* 212 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(196);

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});


/***/ }),
/* 213 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(196);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});


/***/ }),
/* 214 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.





var Schema = __webpack_require__(195);


module.exports = Schema.DEFAULT = new Schema({
  include: [
    __webpack_require__(194)
  ],
  explicit: [
    __webpack_require__(215),
    __webpack_require__(216),
    __webpack_require__(217)
  ]
});


/***/ }),
/* 215 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(196);

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});


/***/ }),
/* 216 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(196);

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});


/***/ }),
/* 217 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = undefined;
  esprima = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'esprima'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = __webpack_require__(196);

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});


/***/ }),
/* 218 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*eslint-disable no-use-before-define*/

var common              = __webpack_require__(191);
var YAMLException       = __webpack_require__(192);
var DEFAULT_FULL_SCHEMA = __webpack_require__(214);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(194);

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    && c !== CHAR_COLON
    && c !== CHAR_SHARP;
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // - | ? | : | , | [ | ] | { | }
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | # | & | * | ! | | | > | ' | "
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | % | @ | `)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = state.condenseFlow ? '"' : '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;


/***/ }),
/* 219 */
/***/ ((module) => {

"use strict";
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */



function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function(expectation) {
      return `"${literalEscape(expectation.text)}"`;
    },

    "class": function(expectation) {
      var escapedParts = "",
        i;

      for (i = 0; i < expectation.parts.length; i++)
        escapedParts += expectation.parts[i] instanceof Array
          ? `${classEscape(expectation.parts[i][0])}-${classEscape(expectation.parts[i][1])}`
          : classEscape(expectation.parts[i]);


      return `[${expectation.inverted ? "^" : ""}${escapedParts}]`;
    },

    any: function(expectation) {
      return "any character";
    },

    end: function(expectation) {
      return "end of input";
    },

    other: function(expectation) {
      return expectation.description;
    },
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return `\\x0${hex(ch)}`; })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return `\\x${hex(ch)}`; });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return `\\x0${hex(ch)}`; })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return `\\x${hex(ch)}`; });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
      i, j;

    for (i = 0; i < expected.length; i++)
      descriptions[i] = describeExpectation(expected[i]);


    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return `${descriptions[0]} or ${descriptions[1]}`;

      default:
        return `${descriptions.slice(0, -1).join(", ")
        }, or ${
          descriptions[descriptions.length - 1]}`;
    }
  }

  function describeFound(found) {
    return found ? `"${literalEscape(found)}"` : "end of input";
  }

  return `Expected ${describeExpected(expected)} but ${describeFound(found)} found.`;
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

    peg$startRuleFunctions = {Start: peg$parseStart},
    peg$startRuleFunction  = peg$parseStart,

    peg$c0 = function(statements) { return [].concat(...statements); },
    peg$c1 = "-",
    peg$c2 = peg$literalExpectation("-", false),
    peg$c3 = function(value) { return value; },
    peg$c4 = function(statements) { return Object.assign({}, ...statements); },
    peg$c5 = "#",
    peg$c6 = peg$literalExpectation("#", false),
    peg$c7 = peg$anyExpectation(),
    peg$c8 = function() { return {}; },
    peg$c9 = ":",
    peg$c10 = peg$literalExpectation(":", false),
    peg$c11 = function(property, value) { return {[property]: value}; },
    peg$c12 = ",",
    peg$c13 = peg$literalExpectation(",", false),
    peg$c14 = function(property, other) { return other; },
    peg$c15 = function(property, others, value) { return Object.assign({}, ...[property].concat(others).map(property => ({[property]: value}))); },
    peg$c16 = function(statements) { return statements; },
    peg$c17 = function(expression) { return expression; },
    peg$c18 = peg$otherExpectation("correct indentation"),
    peg$c19 = " ",
    peg$c20 = peg$literalExpectation(" ", false),
    peg$c21 = function(spaces) { return spaces.length === indentLevel * INDENT_STEP; },
    peg$c22 = function(spaces) { return spaces.length === (indentLevel + 1) * INDENT_STEP; },
    peg$c23 = function() { indentLevel++; return true; },
    peg$c24 = function() { indentLevel--; return true; },
    peg$c25 = function() { return text(); },
    peg$c26 = peg$otherExpectation("pseudostring"),
    peg$c27 = /^[^\r\n\t ?:,\][{}#&*!|>'"%@`\-]/,
    peg$c28 = peg$classExpectation(["\r", "\n", "\t", " ", "?", ":", ",", "]", "[", "{", "}", "#", "&", "*", "!", "|", ">", "'", "\"", "%", "@", "`", "-"], true, false),
    peg$c29 = /^[^\r\n\t ,\][{}:#"']/,
    peg$c30 = peg$classExpectation(["\r", "\n", "\t", " ", ",", "]", "[", "{", "}", ":", "#", "\"", "'"], true, false),
    peg$c31 = function() { return text().replace(/^ *| *$/g, ''); },
    peg$c32 = "--",
    peg$c33 = peg$literalExpectation("--", false),
    peg$c34 = /^[a-zA-Z\/0-9]/,
    peg$c35 = peg$classExpectation([["a", "z"], ["A", "Z"], "/", ["0", "9"]], false, false),
    peg$c36 = /^[^\r\n\t :,]/,
    peg$c37 = peg$classExpectation(["\r", "\n", "\t", " ", ":", ","], true, false),
    peg$c38 = "null",
    peg$c39 = peg$literalExpectation("null", false),
    peg$c40 = function() { return null; },
    peg$c41 = "true",
    peg$c42 = peg$literalExpectation("true", false),
    peg$c43 = function() { return true; },
    peg$c44 = "false",
    peg$c45 = peg$literalExpectation("false", false),
    peg$c46 = function() { return false; },
    peg$c47 = peg$otherExpectation("string"),
    peg$c48 = "\"",
    peg$c49 = peg$literalExpectation("\"", false),
    peg$c50 = function() { return ""; },
    peg$c51 = function(chars) { return chars; },
    peg$c52 = function(chars) { return chars.join(``); },
    peg$c53 = /^[^"\\\0-\x1F\x7F]/,
    peg$c54 = peg$classExpectation(["\"", "\\", ["\0", "\x1F"], "\x7F"], true, false),
    peg$c55 = "\\\"",
    peg$c56 = peg$literalExpectation("\\\"", false),
    peg$c57 = function() { return `"`; },
    peg$c58 = "\\\\",
    peg$c59 = peg$literalExpectation("\\\\", false),
    peg$c60 = function() { return `\\`; },
    peg$c61 = "\\/",
    peg$c62 = peg$literalExpectation("\\/", false),
    peg$c63 = function() { return `/`;  },
    peg$c64 = "\\b",
    peg$c65 = peg$literalExpectation("\\b", false),
    peg$c66 = function() { return `\b`; },
    peg$c67 = "\\f",
    peg$c68 = peg$literalExpectation("\\f", false),
    peg$c69 = function() { return `\f`; },
    peg$c70 = "\\n",
    peg$c71 = peg$literalExpectation("\\n", false),
    peg$c72 = function() { return `\n`; },
    peg$c73 = "\\r",
    peg$c74 = peg$literalExpectation("\\r", false),
    peg$c75 = function() { return `\r`; },
    peg$c76 = "\\t",
    peg$c77 = peg$literalExpectation("\\t", false),
    peg$c78 = function() { return `\t`; },
    peg$c79 = "\\u",
    peg$c80 = peg$literalExpectation("\\u", false),
    peg$c81 = function(h1, h2, h3, h4) {
      return String.fromCharCode(parseInt(`0x${h1}${h2}${h3}${h4}`));
    },
    peg$c82 = /^[0-9a-fA-F]/,
    peg$c83 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false),
    peg$c84 = peg$otherExpectation("blank space"),
    peg$c85 = /^[ \t]/,
    peg$c86 = peg$classExpectation([" ", "\t"], false, false),
    peg$c87 = peg$otherExpectation("white space"),
    peg$c88 = /^[ \t\n\r]/,
    peg$c89 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),
    peg$c90 = "\r\n",
    peg$c91 = peg$literalExpectation("\r\n", false),
    peg$c92 = "\n",
    peg$c93 = peg$literalExpectation("\n", false),
    peg$c94 = "\r",
    peg$c95 = peg$literalExpectation("\r", false),

    peg$currPos          = 0,
    peg$savedPos         = 0,
    peg$posDetailsCache  = [{line: 1, column: 1}],
    peg$maxFailPos       = 0,
    peg$maxFailExpected  = [],
    peg$silentFails      = 0,

    peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions))
      throw new Error(`Can't start parsing from rule "${options.startRule}".`);


    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return {type: "literal", text: text, ignoreCase: ignoreCase};
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return {type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase};
  }

  function peg$anyExpectation() {
    return {type: "any"};
  }

  function peg$endExpectation() {
    return {type: "end"};
  }

  function peg$otherExpectation(description) {
    return {type: "other", description: description};
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p])
        p--;


      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column,
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
      endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column,
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column,
      },
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos)  return;

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parseStart() {
    var s0;

    s0 = peg$parsePropertyStatements();

    return s0;
  }

  function peg$parseItemStatements() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseItemStatement();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseItemStatement();
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseItemStatement() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseSamedent();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c1;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c2); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseB();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseExpression();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c3(s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsePropertyStatements() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsePropertyStatement();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsePropertyStatement();
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c4(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsePropertyStatement() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    s0 = peg$currPos;
    s1 = peg$parseB();
    if (s1 === peg$FAILED)
      s1 = null;

    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s3 = peg$c5;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c6); }
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$currPos;
        s6 = peg$currPos;
        peg$silentFails++;
        s7 = peg$parseEOL();
        peg$silentFails--;
        if (s7 === peg$FAILED) {
          s6 = void 0;
        } else {
          peg$currPos = s6;
          s6 = peg$FAILED;
        }
        if (s6 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c7); }
          }
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseEOL();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c7); }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED)
        s2 = null;

      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseEOL_ANY();
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseEOL_ANY();
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c8();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseSamedent();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseName();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseB();
          if (s3 === peg$FAILED)
            s3 = null;

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c9;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c10); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseB();
              if (s5 === peg$FAILED)
                s5 = null;

              if (s5 !== peg$FAILED) {
                s6 = peg$parseExpression();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c11(s2, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseSamedent();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseLegacyName();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseB();
            if (s3 === peg$FAILED)
              s3 = null;

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c10); }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseB();
                if (s5 === peg$FAILED)
                  s5 = null;

                if (s5 !== peg$FAILED) {
                  s6 = peg$parseExpression();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11(s2, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseSamedent();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLegacyName();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseB();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseLegacyLiteral();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseEOL_ANY();
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseEOL_ANY();
                    }
                  } else {
                    s5 = peg$FAILED;
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11(s2, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseSamedent();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseLegacyName();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$currPos;
                s5 = peg$parseB();
                if (s5 === peg$FAILED)
                  s5 = null;

                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s6 = peg$c12;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c13); }
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseB();
                    if (s7 === peg$FAILED)
                      s7 = null;

                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseLegacyName();
                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s4;
                        s5 = peg$c14(s2, s8);
                        s4 = s5;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    s5 = peg$parseB();
                    if (s5 === peg$FAILED)
                      s5 = null;

                    if (s5 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 44) {
                        s6 = peg$c12;
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c13); }
                      }
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseB();
                        if (s7 === peg$FAILED)
                          s7 = null;

                        if (s7 !== peg$FAILED) {
                          s8 = peg$parseLegacyName();
                          if (s8 !== peg$FAILED) {
                            peg$savedPos = s4;
                            s5 = peg$c14(s2, s8);
                            s4 = s5;
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  }
                } else {
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseB();
                  if (s4 === peg$FAILED)
                    s4 = null;

                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s5 = peg$c9;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c10); }
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseB();
                      if (s6 === peg$FAILED)
                        s6 = null;

                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseExpression();
                        if (s7 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c15(s2, s3, s7);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseExpression() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parseEOL();
    if (s3 !== peg$FAILED) {
      s4 = peg$parseExtradent();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s5 = peg$c1;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c2); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parseB();
          if (s6 !== peg$FAILED) {
            s3 = [s3, s4, s5, s6];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 !== peg$FAILED) {
      peg$currPos = s1;
      s1 = void 0;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseEOL_ANY();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseIndent();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseItemStatements();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseDedent();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c16(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseEOL();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseIndent();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsePropertyStatements();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDedent();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c16(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseLiteral();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseEOL_ANY();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseEOL_ANY();
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c17(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parseSamedent() {
    var s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (input.charCodeAt(peg$currPos) === 32) {
      s2 = peg$c19;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c20); }
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      if (input.charCodeAt(peg$currPos) === 32) {
        s2 = peg$c19;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c20); }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c21(s1);
      if (s2)
        s2 = void 0;
      else
        s2 = peg$FAILED;

      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c18); }
    }

    return s0;
  }

  function peg$parseExtradent() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (input.charCodeAt(peg$currPos) === 32) {
      s2 = peg$c19;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c20); }
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      if (input.charCodeAt(peg$currPos) === 32) {
        s2 = peg$c19;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c20); }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c22(s1);
      if (s2)
        s2 = void 0;
      else
        s2 = peg$FAILED;

      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIndent() {
    var s0;

    peg$savedPos = peg$currPos;
    s0 = peg$c23();
    if (s0)
      s0 = void 0;
    else
      s0 = peg$FAILED;


    return s0;
  }

  function peg$parseDedent() {
    var s0;

    peg$savedPos = peg$currPos;
    s0 = peg$c24();
    if (s0)
      s0 = void 0;
    else
      s0 = peg$FAILED;


    return s0;
  }

  function peg$parseName() {
    var s0;

    s0 = peg$parsestring();
    if (s0 === peg$FAILED)
      s0 = peg$parsepseudostring();


    return s0;
  }

  function peg$parseLegacyName() {
    var s0, s1, s2;

    s0 = peg$parsestring();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsepseudostringLegacy();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsepseudostringLegacy();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c25();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parseLiteral() {
    var s0;

    s0 = peg$parsenull();
    if (s0 === peg$FAILED) {
      s0 = peg$parseboolean();
      if (s0 === peg$FAILED) {
        s0 = peg$parsestring();
        if (s0 === peg$FAILED) {
          s0 = peg$parsepseudostring();
        }
      }
    }

    return s0;
  }

  function peg$parseLegacyLiteral() {
    var s0;

    s0 = peg$parsenull();
    if (s0 === peg$FAILED) {
      s0 = peg$parsestring();
      if (s0 === peg$FAILED) {
        s0 = peg$parsepseudostringLegacy();
      }
    }

    return s0;
  }

  function peg$parsepseudostring() {
    var s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    if (peg$c27.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c28); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseB();
      if (s4 === peg$FAILED)
        s4 = null;

      if (s4 !== peg$FAILED) {
        if (peg$c29.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c30); }
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseB();
        if (s4 === peg$FAILED)
          s4 = null;

        if (s4 !== peg$FAILED) {
          if (peg$c29.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c30); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c31();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c26); }
    }

    return s0;
  }

  function peg$parsepseudostringLegacy() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c32) {
      s1 = peg$c32;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c33); }
    }
    if (s1 === peg$FAILED)
      s1 = null;

    if (s1 !== peg$FAILED) {
      if (peg$c34.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c35); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$c36.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c37); }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c36.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c37); }
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenull() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c38) {
      s1 = peg$c38;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c39); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c40();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseboolean() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c41) {
      s1 = peg$c41;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c42); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c43();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c44) {
        s1 = peg$c44;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c46();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parsestring() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c48;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c49); }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 34) {
        s2 = peg$c48;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c49); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c50();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c48;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c49); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsechars();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c48;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c49); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c51(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c47); }
    }

    return s0;
  }

  function peg$parsechars() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsechar();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsechar();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c52(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsechar() {
    var s0, s1, s2, s3, s4, s5;

    if (peg$c53.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c54); }
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c55) {
        s1 = peg$c55;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c56); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c57();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c58) {
          s1 = peg$c58;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c59); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c60();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c61) {
            s1 = peg$c61;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c62); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c63();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c64) {
              s1 = peg$c64;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c65); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c67) {
                s1 = peg$c67;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c68); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c69();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c70) {
                  s1 = peg$c70;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c71); }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c72();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c73) {
                    s1 = peg$c73;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c74); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c75();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c76) {
                      s1 = peg$c76;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c77); }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c78();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c79) {
                        s1 = peg$c79;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c80); }
                      }
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parsehexDigit();
                        if (s2 !== peg$FAILED) {
                          s3 = peg$parsehexDigit();
                          if (s3 !== peg$FAILED) {
                            s4 = peg$parsehexDigit();
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parsehexDigit();
                              if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c81(s2, s3, s4, s5);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsehexDigit() {
    var s0;

    if (peg$c82.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c83); }
    }

    return s0;
  }

  function peg$parseB() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    if (peg$c85.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c86); }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c85.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c86); }
        }
      }
    } else {
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c84); }
    }

    return s0;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function peg$parseS() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    if (peg$c88.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c89); }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c88.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c89); }
        }
      }
    } else {
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c87); }
    }

    return s0;
  }

  // eslint-disable-next-line @typescript-eslint/camelcase
  function peg$parseEOL_ANY() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseEOL();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseB();
      if (s4 === peg$FAILED)
        s4 = null;

      if (s4 !== peg$FAILED) {
        s5 = peg$parseEOL();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseB();
        if (s4 === peg$FAILED)
          s4 = null;

        if (s4 !== peg$FAILED) {
          s5 = peg$parseEOL();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEOL() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c90) {
      s0 = peg$c90;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c91); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 10) {
        s0 = peg$c92;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c93); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 13) {
          s0 = peg$c94;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c95); }
        }
      }
    }

    return s0;
  }


  const INDENT_STEP = 2;

  let indentLevel = 0;


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length)
      peg$fail(peg$endExpectation());


    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse,
};


/***/ }),
/* 220 */
/***/ ((module) => {

"use strict";


const preserveCamelCase = string => {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;

	for (let i = 0; i < string.length; i++) {
		const character = string[i];

		if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
			string = string.slice(0, i) + '-' + string.slice(i);
			isLastCharLower = false;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = true;
			i++;
		} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
			string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = false;
			isLastCharLower = true;
		} else {
			isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
		}
	}

	return string;
};

const camelCase = (input, options) => {
	if (!(typeof input === 'string' || Array.isArray(input))) {
		throw new TypeError('Expected the input to be `string | string[]`');
	}

	options = Object.assign({
		pascalCase: false
	}, options);

	const postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;

	if (Array.isArray(input)) {
		input = input.map(x => x.trim())
			.filter(x => x.length)
			.join('-');
	} else {
		input = input.trim();
	}

	if (input.length === 0) {
		return '';
	}

	if (input.length === 1) {
		return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
	}

	const hasUpperCase = input !== input.toLowerCase();

	if (hasUpperCase) {
		input = preserveCamelCase(input);
	}

	input = input
		.replace(/^[_.\- ]+/, '')
		.toLowerCase()
		.replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase())
		.replace(/\d+(\w|$)/g, m => m.toUpperCase());

	return postProcess(input);
};

module.exports = camelCase;
// TODO: Remove this for the next major release
module.exports.default = camelCase;


/***/ }),
/* 221 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const pTry = __webpack_require__(222);

const pLimit = concurrency => {
	if (concurrency < 1) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const queue = [];
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.length > 0) {
			queue.shift()();
		}
	};

	const run = (fn, resolve, ...args) => {
		activeCount++;

		const result = pTry(fn, ...args);

		resolve(result);

		result.then(next, next);
	};

	const enqueue = (fn, resolve, ...args) => {
		if (activeCount < concurrency) {
			run(fn, resolve, ...args);
		} else {
			queue.push(run.bind(null, fn, resolve, ...args));
		}
	};

	const generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));
	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount
		},
		pendingCount: {
			get: () => queue.length
		}
	});

	return generator;
};

module.exports = pLimit;
module.exports.default = pLimit;


/***/ }),
/* 222 */
/***/ ((module) => {

"use strict";


module.exports = (callback, ...args) => new Promise(resolve => {
	resolve(callback(...args));
});


/***/ }),
/* 223 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDefaultGlobalFolder": () => /* binding */ getDefaultGlobalFolder,
/* harmony export */   "getHomeFolder": () => /* binding */ getHomeFolder,
/* harmony export */   "isFolderInside": () => /* binding */ isFolderInside
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(162);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);


function getDefaultGlobalFolder() {
  if (process.platform === `win32`) {
    const base = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.toPortablePath(process.env.LOCALAPPDATA || _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.join((0,os__WEBPACK_IMPORTED_MODULE_0__.homedir)(), `AppData`, `Local`));
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.resolve(base, `Yarn/Berry`);
  }

  if (process.env.XDG_DATA_HOME) {
    const base = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.toPortablePath(process.env.XDG_DATA_HOME);
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.resolve(base, `yarn/berry`);
  }

  return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.resolve(getHomeFolder(), `.yarn/berry`);
}
function getHomeFolder() {
  return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.toPortablePath((0,os__WEBPACK_IMPORTED_MODULE_0__.homedir)() || `/usr/local/share`);
}
function isFolderInside(target, parent) {
  const relative = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.relative(parent, target);
  return relative && !relative.startsWith(`..`) && !_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.isAbsolute(relative);
}

/***/ }),
/* 224 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CorePlugin": () => /* binding */ CorePlugin
/* harmony export */ });
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(180);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);


const CorePlugin = {
  hooks: {
    reduceDependency: (dependency, project, locator, initialDependency, {
      resolver,
      resolveOptions
    }) => {
      for (const {
        pattern,
        reference
      } of project.topLevelWorkspace.manifest.resolutions) {
        if (pattern.from && pattern.from.fullName !== _structUtils__WEBPACK_IMPORTED_MODULE_0__.requirableIdent(locator)) continue;
        if (pattern.from && pattern.from.description && pattern.from.description !== locator.reference) continue;
        if (pattern.descriptor.fullName !== _structUtils__WEBPACK_IMPORTED_MODULE_0__.requirableIdent(dependency)) continue;
        if (pattern.descriptor.description && pattern.descriptor.description !== dependency.range) continue;
        const alias = resolver.bindDescriptor(_structUtils__WEBPACK_IMPORTED_MODULE_0__.makeDescriptor(dependency, reference), project.topLevelWorkspace.anchoredLocator, resolveOptions);
        return alias;
      }

      return dependency;
    },
    validateProject: async (project, report) => {
      for (const workspace of project.workspaces) {
        const workspaceName = _structUtils__WEBPACK_IMPORTED_MODULE_0__.prettyWorkspace(project.configuration, workspace);
        await project.configuration.triggerHook(hooks => {
          return hooks.validateWorkspace;
        }, workspace, {
          reportWarning: (name, text) => report.reportWarning(name, `${workspaceName}: ${text}`),
          reportError: (name, text) => report.reportError(name, `${workspaceName}: ${text}`)
        });
      }
    },
    validateWorkspace: async (workspace, report) => {
      // Validate manifest
      const {
        manifest
      } = workspace;
      if (manifest.resolutions.length && workspace.cwd !== workspace.project.cwd) manifest.errors.push(new Error(`Resolutions field will be ignored`));

      for (const manifestError of manifest.errors) {
        report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.INVALID_MANIFEST, manifestError.message);
      }
    }
  }
};

/***/ }),
/* 225 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dynamicRequire": () => /* binding */ dynamicRequire,
/* harmony export */   "builtinModules": () => /* binding */ builtinModules
/* harmony export */ });
/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(226);
/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(module__WEBPACK_IMPORTED_MODULE_0__);

function dynamicRequire(request) {
  const req = typeof require !== `undefined` ? require : __webpack_require__(178);
  return req(request);
}
function builtinModules() {
  // @ts-expect-error
  return new Set((module__WEBPACK_IMPORTED_MODULE_0___default().builtinModules) || Object.keys(process.binding(`natives`)));
}

/***/ }),
/* 226 */
/***/ ((module) => {

"use strict";
module.exports = require("module");;

/***/ }),
/* 227 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultiResolver": () => /* binding */ MultiResolver
/* harmony export */ });
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);

class MultiResolver {
  constructor(resolvers) {
    this.resolvers = resolvers.filter(resolver => resolver);
  }

  supportsDescriptor(descriptor, opts) {
    const resolver = this.tryResolverByDescriptor(descriptor, opts);
    return !!resolver;
  }

  supportsLocator(locator, opts) {
    const resolver = this.tryResolverByLocator(locator, opts);
    return !!resolver;
  }

  shouldPersistResolution(locator, opts) {
    const resolver = this.getResolverByLocator(locator, opts);
    return resolver.shouldPersistResolution(locator, opts);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    const resolver = this.getResolverByDescriptor(descriptor, opts);
    return resolver.bindDescriptor(descriptor, fromLocator, opts);
  }

  getResolutionDependencies(descriptor, opts) {
    const resolver = this.getResolverByDescriptor(descriptor, opts);
    return resolver.getResolutionDependencies(descriptor, opts);
  }

  async getCandidates(descriptor, dependencies, opts) {
    const resolver = this.getResolverByDescriptor(descriptor, opts);
    return await resolver.getCandidates(descriptor, dependencies, opts);
  }

  async getSatisfying(descriptor, references, opts) {
    const resolver = this.getResolverByDescriptor(descriptor, opts);
    return resolver.getSatisfying(descriptor, references, opts);
  }

  async resolve(locator, opts) {
    const resolver = this.getResolverByLocator(locator, opts);
    return await resolver.resolve(locator, opts);
  }

  tryResolverByDescriptor(descriptor, opts) {
    const resolver = this.resolvers.find(resolver => resolver.supportsDescriptor(descriptor, opts));
    if (!resolver) return null;
    return resolver;
  }

  getResolverByDescriptor(descriptor, opts) {
    const resolver = this.resolvers.find(resolver => resolver.supportsDescriptor(descriptor, opts));
    if (!resolver) throw new Error(`${_structUtils__WEBPACK_IMPORTED_MODULE_0__.prettyDescriptor(opts.project.configuration, descriptor)} isn't supported by any available resolver`);
    return resolver;
  }

  tryResolverByLocator(locator, opts) {
    const resolver = this.resolvers.find(resolver => resolver.supportsLocator(locator, opts));
    if (!resolver) return null;
    return resolver;
  }

  getResolverByLocator(locator, opts) {
    const resolver = this.resolvers.find(resolver => resolver.supportsLocator(locator, opts));
    if (!resolver) throw new Error(`${_structUtils__WEBPACK_IMPORTED_MODULE_0__.prettyLocator(opts.project.configuration, locator)} isn't supported by any available resolver`);
    return resolver;
  }

}

/***/ }),
/* 228 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VirtualResolver": () => /* binding */ VirtualResolver
/* harmony export */ });
class VirtualResolver {
  static isVirtualDescriptor(descriptor) {
    if (!descriptor.range.startsWith(VirtualResolver.protocol)) return false;
    return true;
  }

  static isVirtualLocator(locator) {
    if (!locator.reference.startsWith(VirtualResolver.protocol)) return false;
    return true;
  }

  supportsDescriptor(descriptor, opts) {
    return VirtualResolver.isVirtualDescriptor(descriptor);
  }

  supportsLocator(locator, opts) {
    return VirtualResolver.isVirtualLocator(locator);
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, locator, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `bindDescriptor` anymore.
    throw new Error(`Assertion failed: calling "bindDescriptor" on a virtual descriptor is unsupported`);
  }

  getResolutionDependencies(descriptor, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `bindDescriptor` anymore.
    throw new Error(`Assertion failed: calling "getResolutionDependencies" on a virtual descriptor is unsupported`);
  }

  async getCandidates(descriptor, dependencies, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `getCandidates` anymore.
    throw new Error(`Assertion failed: calling "getCandidates" on a virtual descriptor is unsupported`);
  }

  async getSatisfying(descriptor, candidates, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `getSatisfying` anymore.
    throw new Error(`Assertion failed: calling "getSatisfying" on a virtual descriptor is unsupported`);
  }

  async resolve(locator, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `resolve` anymore.
    throw new Error(`Assertion failed: calling "resolve" on a virtual locator is unsupported`);
  }

}
VirtualResolver.protocol = `virtual:`;

/***/ }),
/* 229 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WorkspaceResolver": () => /* binding */ WorkspaceResolver
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(179);

class WorkspaceResolver {
  supportsDescriptor(descriptor, opts) {
    if (descriptor.range.startsWith(WorkspaceResolver.protocol)) return true;
    const workspace = opts.project.tryWorkspaceByDescriptor(descriptor);
    if (workspace !== null) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith(WorkspaceResolver.protocol)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const workspace = opts.project.getWorkspaceByDescriptor(descriptor);
    return [workspace.anchoredLocator];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    const workspace = opts.project.getWorkspaceByCwd(locator.reference.slice(WorkspaceResolver.protocol.length));
    return { ...locator,
      version: workspace.manifest.version || `0.0.0`,
      languageName: `unknown`,
      linkType: _types__WEBPACK_IMPORTED_MODULE_0__.LinkType.SOFT,
      dependencies: new Map([...workspace.manifest.dependencies, ...workspace.manifest.devDependencies]),
      peerDependencies: new Map([...workspace.manifest.peerDependencies]),
      dependenciesMeta: workspace.manifest.dependenciesMeta,
      peerDependenciesMeta: workspace.manifest.peerDependenciesMeta,
      bin: workspace.manifest.bin
    };
  }

}
WorkspaceResolver.protocol = `workspace:`;

/***/ }),
/* 230 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TAG_REGEXP": () => /* binding */ TAG_REGEXP,
/* harmony export */   "ProtocolResolver": () => /* binding */ ProtocolResolver
/* harmony export */ });
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _semverUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(231);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);



const TAG_REGEXP = /^(?!v)[a-z0-9-.]+$/i;
class ProtocolResolver {
  supportsDescriptor(descriptor, opts) {
    if (_semverUtils__WEBPACK_IMPORTED_MODULE_1__.validRange(descriptor.range)) return true;
    if (TAG_REGEXP.test(descriptor.range)) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if (semver__WEBPACK_IMPORTED_MODULE_0___default().valid(locator.reference)) return true;
    if (TAG_REGEXP.test(locator.reference)) return true;
    return false;
  }

  shouldPersistResolution(locator, opts) {
    return opts.resolver.shouldPersistResolution(this.forwardLocator(locator, opts), opts);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return opts.resolver.bindDescriptor(this.forwardDescriptor(descriptor, opts), fromLocator, opts);
  }

  getResolutionDependencies(descriptor, opts) {
    return opts.resolver.getResolutionDependencies(this.forwardDescriptor(descriptor, opts), opts);
  }

  async getCandidates(descriptor, dependencies, opts) {
    return await opts.resolver.getCandidates(this.forwardDescriptor(descriptor, opts), dependencies, opts);
  }

  async getSatisfying(descriptor, references, opts) {
    return await opts.resolver.getSatisfying(this.forwardDescriptor(descriptor, opts), references, opts);
  }

  async resolve(locator, opts) {
    const pkg = await opts.resolver.resolve(this.forwardLocator(locator, opts), opts);
    return _structUtils__WEBPACK_IMPORTED_MODULE_2__.renamePackage(pkg, locator);
  }

  forwardDescriptor(descriptor, opts) {
    return _structUtils__WEBPACK_IMPORTED_MODULE_2__.makeDescriptor(descriptor, `${opts.project.configuration.get(`defaultProtocol`)}${descriptor.range}`);
  }

  forwardLocator(locator, opts) {
    return _structUtils__WEBPACK_IMPORTED_MODULE_2__.makeLocator(locator, `${opts.project.configuration.get(`defaultProtocol`)}${locator.reference}`);
  }

}

/***/ }),
/* 231 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "satisfiesWithPrereleases": () => /* binding */ satisfiesWithPrereleases,
/* harmony export */   "validRange": () => /* binding */ validRange
/* harmony export */ });
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Returns whether the given semver version satisfies the given range. Notably
 * this supports prerelease versions so that "2.0.0-rc.0" satisfies the range
 * ">=1.0.0", for example.
 *
 * This function exists because the semver.satisfies method does not include
 * pre releases. This means ranges such as * would not satisfy 1.0.0-rc. The
 * includePrerelease flag has a weird behavior and cannot be used (if you want
 * to try it out, just run the `semverUtils` testsuite using this flag instead
 * of our own implementation, and you'll see the failing cases).
 *
 * See https://github.com/yarnpkg/berry/issues/575 for more context.
 */

function satisfiesWithPrereleases(version, range, loose = false) {
  let semverRange;

  try {
    semverRange = new (semver__WEBPACK_IMPORTED_MODULE_0___default().Range)(range, {
      includePrerelease: true,
      loose
    });
  } catch (err) {
    return false;
  }

  if (!version) return false;
  let semverVersion;

  try {
    semverVersion = new (semver__WEBPACK_IMPORTED_MODULE_0___default().SemVer)(version, semverRange);

    if (semverVersion.prerelease) {
      semverVersion.prerelease = [];
    }
  } catch (err) {
    return false;
  } // A range has multiple sets of comparators. A version must satisfy all
  // comparators in a set and at least one set to satisfy the range.


  return semverRange.set.some(comparatorSet => {
    for (const comparator of comparatorSet) if (comparator.semver.prerelease) comparator.semver.prerelease = [];

    return comparatorSet.every(comparator => {
      return comparator.test(semverVersion);
    });
  });
}
const rangesCache = new Map();
/**
 * A cached version of `new semver.Range(potentialRange)` that returns `null` on invalid ranges
 */

function validRange(potentialRange) {
  if (potentialRange.indexOf(`:`) !== -1) return null;
  let range = rangesCache.get(potentialRange);
  if (typeof range !== `undefined`) return range;

  try {
    range = new (semver__WEBPACK_IMPORTED_MODULE_0___default().Range)(potentialRange);
  } catch (_a) {
    range = null;
  }

  rangesCache.set(potentialRange, range);
  return range;
}

/***/ }),
/* 232 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultiFetcher": () => /* binding */ MultiFetcher
/* harmony export */ });
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(180);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(233);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);



class MultiFetcher {
  constructor(fetchers) {
    this.fetchers = fetchers;
  }

  supports(locator, opts) {
    if (!this.tryFetcher(locator, opts)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    const fetcher = this.getFetcher(locator, opts);
    return fetcher.getLocalPath(locator, opts);
  }

  async fetch(locator, opts) {
    const fetcher = this.getFetcher(locator, opts);
    return await fetcher.fetch(locator, opts);
  }

  tryFetcher(locator, opts) {
    const fetcher = this.fetchers.find(fetcher => fetcher.supports(locator, opts));
    if (!fetcher) return null;
    return fetcher;
  }

  getFetcher(locator, opts) {
    const fetcher = this.fetchers.find(fetcher => fetcher.supports(locator, opts));
    if (!fetcher) throw new _Report__WEBPACK_IMPORTED_MODULE_0__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.FETCHER_NOT_FOUND, `${_structUtils__WEBPACK_IMPORTED_MODULE_2__.prettyLocator(opts.project.configuration, locator)} isn't supported by any available fetcher`);
    return fetcher;
  }

}

/***/ }),
/* 233 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReportError": () => /* binding */ ReportError,
/* harmony export */   "isReportError": () => /* binding */ isReportError,
/* harmony export */   "Report": () => /* binding */ Report
/* harmony export */ });
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var string_decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(234);
/* harmony import */ var string_decoder__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(string_decoder__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(180);



class ReportError extends Error {
  constructor(code, message, reportExtra) {
    super(message);
    this.reportExtra = reportExtra;
    this.reportCode = code;
  }

}
function isReportError(error) {
  return typeof error.reportCode !== `undefined`;
}
class Report {
  constructor() {
    this.reportedInfos = new Set();
    this.reportedWarnings = new Set();
    this.reportedErrors = new Set();
  }

  static progressViaCounter(max) {
    let current = 0;
    let unlock;
    let lock = new Promise(resolve => {
      unlock = resolve;
    });

    const set = n => {
      const thisUnlock = unlock;
      lock = new Promise(resolve => {
        unlock = resolve;
      });
      current = n;
      thisUnlock();
    };

    const tick = (n = 0) => {
      set(current + 1);
    };

    const gen = async function* () {
      while (current < max) {
        await lock;
        yield {
          progress: current / max
        };
      }
    }();

    return {
      [Symbol.asyncIterator]() {
        return gen;
      },

      set,
      tick
    };
  }

  reportInfoOnce(name, text, opts) {
    const key = opts && opts.key ? opts.key : text;

    if (!this.reportedInfos.has(key)) {
      this.reportedInfos.add(key);
      this.reportInfo(name, text);
    }
  }

  reportWarningOnce(name, text, opts) {
    const key = opts && opts.key ? opts.key : text;

    if (!this.reportedWarnings.has(key)) {
      this.reportedWarnings.add(key);
      this.reportWarning(name, text);
    }
  }

  reportErrorOnce(name, text, opts) {
    var _a;

    const key = opts && opts.key ? opts.key : text;

    if (!this.reportedErrors.has(key)) {
      this.reportedErrors.add(key);
      this.reportError(name, text);
      (_a = opts === null || opts === void 0 ? void 0 : opts.reportExtra) === null || _a === void 0 ? void 0 : _a.call(opts, this);
    }
  }

  reportExceptionOnce(error) {
    if (isReportError(error)) {
      this.reportErrorOnce(error.reportCode, error.message, {
        key: error,
        reportExtra: error.reportExtra
      });
    } else {
      this.reportErrorOnce(_MessageName__WEBPACK_IMPORTED_MODULE_2__.MessageName.EXCEPTION, error.stack || error.message, {
        key: error
      });
    }
  }

  createStreamReporter(prefix = null) {
    const stream = new stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough();
    const decoder = new string_decoder__WEBPACK_IMPORTED_MODULE_1__.StringDecoder();
    let buffer = ``;
    stream.on(`data`, chunk => {
      let chunkStr = decoder.write(chunk);
      let lineIndex;

      do {
        lineIndex = chunkStr.indexOf(`\n`);

        if (lineIndex !== -1) {
          const line = buffer + chunkStr.substr(0, lineIndex);
          chunkStr = chunkStr.substr(lineIndex + 1);
          buffer = ``;

          if (prefix !== null) {
            this.reportInfo(null, `${prefix} ${line}`);
          } else {
            this.reportInfo(null, line);
          }
        }
      } while (lineIndex !== -1);

      buffer += chunkStr;
    });
    stream.on(`end`, () => {
      const last = decoder.end();

      if (last !== ``) {
        if (prefix !== null) {
          this.reportInfo(null, `${prefix} ${last}`);
        } else {
          this.reportInfo(null, last);
        }
      }
    });
    return stream;
  }

}

/***/ }),
/* 234 */
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");;

/***/ }),
/* 235 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VirtualFetcher": () => /* binding */ VirtualFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(175);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(168);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);


class VirtualFetcher {
  supports(locator) {
    if (!locator.reference.startsWith(`virtual:`)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    const splitPoint = locator.reference.indexOf(`#`);
    if (splitPoint === -1) throw new Error(`Invalid virtual package reference`);
    const nextReference = locator.reference.slice(splitPoint + 1);
    const nextLocator = _structUtils__WEBPACK_IMPORTED_MODULE_0__.makeLocator(locator, nextReference);
    return opts.fetcher.getLocalPath(nextLocator, opts);
  }

  async fetch(locator, opts) {
    const splitPoint = locator.reference.indexOf(`#`);
    if (splitPoint === -1) throw new Error(`Invalid virtual package reference`);
    const nextReference = locator.reference.slice(splitPoint + 1);
    const nextLocator = _structUtils__WEBPACK_IMPORTED_MODULE_0__.makeLocator(locator, nextReference);
    const parentFetch = await opts.fetcher.fetch(nextLocator, opts);
    return await this.ensureVirtualLink(locator, parentFetch, opts);
  }

  getLocatorFilename(locator) {
    return _structUtils__WEBPACK_IMPORTED_MODULE_0__.slugifyLocator(locator);
  }

  async ensureVirtualLink(locator, sourceFetch, opts) {
    const to = sourceFetch.packageFs.getRealPath();
    const virtualFolder = opts.project.configuration.get(`virtualFolder`);
    const virtualName = this.getLocatorFilename(locator);
    const virtualPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.VirtualFS.makeVirtualPath(virtualFolder, virtualName, to); // We then use an alias to tell anyone that asks us that we're operating within the virtual folder, while still using the same old fs

    const aliasFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.AliasFS(virtualPath, {
      baseFs: sourceFetch.packageFs,
      pathUtils: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath
    });
    return { ...sourceFetch,
      packageFs: aliasFs
    };
  }

}

/***/ }),
/* 236 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WorkspaceFetcher": () => /* binding */ WorkspaceFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(170);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(229);


class WorkspaceFetcher {
  supports(locator) {
    if (!locator.reference.startsWith(_WorkspaceResolver__WEBPACK_IMPORTED_MODULE_0__.WorkspaceResolver.protocol)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return this.getWorkspace(locator, opts).cwd;
  }

  async fetch(locator, opts) {
    const sourcePath = this.getWorkspace(locator, opts).cwd;
    return {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.CwdFS(sourcePath),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
      localPath: sourcePath
    };
  }

  getWorkspace(locator, opts) {
    return opts.project.getWorkspaceByCwd(locator.reference.slice(_WorkspaceResolver__WEBPACK_IMPORTED_MODULE_0__.WorkspaceResolver.protocol.length));
  }

}

/***/ }),
/* 237 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Manifest": () => /* binding */ Manifest
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(165);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(182);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(177);
/* harmony import */ var _semverUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(231);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);






class Manifest {
  constructor() {
    this.indent = `  `;
    this.name = null;
    this.version = null;
    this.os = null;
    this.cpu = null;
    this.type = null;
    this["private"] = false;
    this.license = null;
    this.main = null;
    this.module = null;
    this.browser = null;
    this.languageName = null;
    this.bin = new Map();
    this.scripts = new Map();
    this.dependencies = new Map();
    this.devDependencies = new Map();
    this.peerDependencies = new Map();
    this.workspaceDefinitions = [];
    this.dependenciesMeta = new Map();
    this.peerDependenciesMeta = new Map();
    this.resolutions = [];
    this.files = null;
    this.publishConfig = null;
    this.installConfig = null;
    this.preferUnplugged = null;
    this.raw = {};
    /**
     * errors found in the raw manifest while loading
     */

    this.errors = [];
  }

  static async tryFind(path, {
    baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.NodeFS()
  } = {}) {
    const manifestPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.join(path, `package.json`);
    if (!(await baseFs.existsPromise(manifestPath))) return null;
    return await Manifest.fromFile(manifestPath, {
      baseFs
    });
  }

  static async find(path, {
    baseFs
  } = {}) {
    const manifest = await Manifest.tryFind(path, {
      baseFs
    });
    if (manifest === null) throw new Error(`Manifest not found`);
    return manifest;
  }

  static async fromFile(path, {
    baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.NodeFS()
  } = {}) {
    const manifest = new Manifest();
    await manifest.loadFile(path, {
      baseFs
    });
    return manifest;
  }

  static fromText(text) {
    const manifest = new Manifest();
    manifest.loadFromText(text);
    return manifest;
  }

  static isManifestFieldCompatible(rules, actual) {
    if (rules === null) return true;
    let isNotOnAllowlist = true;
    let isOnDenylist = false;

    for (const rule of rules) {
      if (rule[0] === `!`) {
        isOnDenylist = true;

        if (actual === rule.slice(1)) {
          return false;
        }
      } else {
        isNotOnAllowlist = false;

        if (rule === actual) {
          return true;
        }
      }
    } // Denylists with allowlisted items should be treated as allowlists for `os` and `cpu` in `package.json`


    return isOnDenylist && isNotOnAllowlist;
  }

  loadFromText(text) {
    let data;

    try {
      data = JSON.parse(stripBOM(text) || `{}`);
    } catch (error) {
      error.message += ` (when parsing ${text})`;
      throw error;
    }

    this.load(data);
    this.indent = getIndent(text);
  }

  async loadFile(path, {
    baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.NodeFS()
  }) {
    const content = await baseFs.readFilePromise(path, `utf8`);
    let data;

    try {
      data = JSON.parse(stripBOM(content) || `{}`);
    } catch (error) {
      error.message += ` (when parsing ${path})`;
      throw error;
    }

    this.load(data);
    this.indent = getIndent(content);
  }

  load(data, {
    yamlCompatibilityMode = false
  } = {}) {
    if (typeof data !== `object` || data === null) throw new Error(`Utterly invalid manifest data (${data})`);
    this.raw = data;
    const errors = [];

    if (typeof data.name === `string`) {
      try {
        this.name = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseIdent(data.name);
      } catch (error) {
        errors.push(new Error(`Parsing failed for the 'name' field`));
      }
    }

    if (typeof data.version === `string`) this.version = data.version;

    if (Array.isArray(data.os)) {
      const os = [];
      this.os = os;

      for (const item of data.os) {
        if (typeof item !== `string`) {
          errors.push(new Error(`Parsing failed for the 'os' field`));
        } else {
          os.push(item);
        }
      }
    }

    if (Array.isArray(data.cpu)) {
      const cpu = [];
      this.cpu = cpu;

      for (const item of data.cpu) {
        if (typeof item !== `string`) {
          errors.push(new Error(`Parsing failed for the 'cpu' field`));
        } else {
          cpu.push(item);
        }
      }
    }

    if (typeof data.type === `string`) this.type = data.type;
    if (typeof data.private === `boolean`) this.private = data.private;
    if (typeof data.license === `string`) this.license = data.license;
    if (typeof data.languageName === `string`) this.languageName = data.languageName;
    if (typeof data.main === `string`) this.main = normalizeSlashes(data.main);
    if (typeof data.module === `string`) this.module = normalizeSlashes(data.module);

    if (data.browser != null) {
      if (typeof data.browser === `string`) {
        this.browser = normalizeSlashes(data.browser);
      } else {
        this.browser = new Map();

        for (const [key, value] of Object.entries(data.browser)) {
          this.browser.set(normalizeSlashes(key), typeof value === `string` ? normalizeSlashes(value) : value);
        }
      }
    }

    if (typeof data.bin === `string`) {
      if (this.name !== null) {
        this.bin = new Map([[this.name.name, normalizeSlashes(data.bin)]]);
      } else {
        errors.push(new Error(`String bin field, but no attached package name`));
      }
    } else if (typeof data.bin === `object` && data.bin !== null) {
      for (const [key, value] of Object.entries(data.bin)) {
        if (typeof value !== `string`) {
          errors.push(new Error(`Invalid bin definition for '${key}'`));
          continue;
        }

        this.bin.set(key, normalizeSlashes(value));
      }
    }

    if (typeof data.scripts === `object` && data.scripts !== null) {
      for (const [key, value] of Object.entries(data.scripts)) {
        if (typeof value !== `string`) {
          errors.push(new Error(`Invalid script definition for '${key}'`));
          continue;
        }

        this.scripts.set(key, value);
      }
    }

    if (typeof data.dependencies === `object` && data.dependencies !== null) {
      for (const [name, range] of Object.entries(data.dependencies)) {
        if (typeof range !== `string`) {
          errors.push(new Error(`Invalid dependency range for '${name}'`));
          continue;
        }

        let ident;

        try {
          ident = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseIdent(name);
        } catch (error) {
          errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
          continue;
        }

        const descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(ident, range);
        this.dependencies.set(descriptor.identHash, descriptor);
      }
    }

    if (typeof data.devDependencies === `object` && data.devDependencies !== null) {
      for (const [name, range] of Object.entries(data.devDependencies)) {
        if (typeof range !== `string`) {
          errors.push(new Error(`Invalid dependency range for '${name}'`));
          continue;
        }

        let ident;

        try {
          ident = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseIdent(name);
        } catch (error) {
          errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
          continue;
        }

        const descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(ident, range);
        this.devDependencies.set(descriptor.identHash, descriptor);
      }
    }

    if (typeof data.peerDependencies === `object` && data.peerDependencies !== null) {
      for (let [name, range] of Object.entries(data.peerDependencies)) {
        let ident;

        try {
          ident = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseIdent(name);
        } catch (error) {
          errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
          continue;
        }

        if (typeof range !== `string` || !_semverUtils__WEBPACK_IMPORTED_MODULE_5__.validRange(range)) {
          errors.push(new Error(`Invalid dependency range for '${name}'`));
          range = `*`;
        }

        const descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(ident, range);
        this.peerDependencies.set(descriptor.identHash, descriptor);
      }
    }

    if (typeof data.workspaces === `object` && data.workspaces.nohoist) errors.push(new Error(`'nohoist' is deprecated, please use 'installConfig.hoistingLimits' instead`));
    const workspaces = Array.isArray(data.workspaces) ? data.workspaces : typeof data.workspaces === `object` && data.workspaces !== null && Array.isArray(data.workspaces.packages) ? data.workspaces.packages : [];

    for (const entry of workspaces) {
      if (typeof entry !== `string`) {
        errors.push(new Error(`Invalid workspace definition for '${entry}'`));
        continue;
      }

      this.workspaceDefinitions.push({
        pattern: entry
      });
    }

    if (typeof data.dependenciesMeta === `object` && data.dependenciesMeta !== null) {
      for (const [pattern, meta] of Object.entries(data.dependenciesMeta)) {
        if (typeof meta !== `object` || meta === null) {
          errors.push(new Error(`Invalid meta field for '${pattern}`));
          continue;
        }

        const descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseDescriptor(pattern);
        const dependencyMeta = this.ensureDependencyMeta(descriptor);
        const built = tryParseOptionalBoolean(meta.built, {
          yamlCompatibilityMode
        });

        if (built === null) {
          errors.push(new Error(`Invalid built meta field for '${pattern}'`));
          continue;
        }

        const optional = tryParseOptionalBoolean(meta.optional, {
          yamlCompatibilityMode
        });

        if (optional === null) {
          errors.push(new Error(`Invalid optional meta field for '${pattern}'`));
          continue;
        }

        const unplugged = tryParseOptionalBoolean(meta.unplugged, {
          yamlCompatibilityMode
        });

        if (unplugged === null) {
          errors.push(new Error(`Invalid unplugged meta field for '${pattern}'`));
          continue;
        }

        Object.assign(dependencyMeta, {
          built,
          optional,
          unplugged
        });
      }
    }

    if (typeof data.peerDependenciesMeta === `object` && data.peerDependenciesMeta !== null) {
      for (const [pattern, meta] of Object.entries(data.peerDependenciesMeta)) {
        if (typeof meta !== `object` || meta === null) {
          errors.push(new Error(`Invalid meta field for '${pattern}'`));
          continue;
        }

        const descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseDescriptor(pattern);
        const peerDependencyMeta = this.ensurePeerDependencyMeta(descriptor);
        const optional = tryParseOptionalBoolean(meta.optional, {
          yamlCompatibilityMode
        });

        if (optional === null) {
          errors.push(new Error(`Invalid optional meta field for '${pattern}'`));
          continue;
        }

        Object.assign(peerDependencyMeta, {
          optional
        });
      }
    }

    if (typeof data.resolutions === `object` && data.resolutions !== null) {
      for (const [pattern, reference] of Object.entries(data.resolutions)) {
        if (typeof reference !== `string`) {
          errors.push(new Error(`Invalid resolution entry for '${pattern}'`));
          continue;
        }

        try {
          this.resolutions.push({
            pattern: (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseResolution)(pattern),
            reference
          });
        } catch (error) {
          errors.push(error);
          continue;
        }
      }
    }

    if (Array.isArray(data.files)) {
      this.files = new Set();

      for (const filename of data.files) {
        if (typeof filename !== `string`) {
          errors.push(new Error(`Invalid files entry for '${filename}'`));
          continue;
        }

        this.files.add(filename);
      }
    }

    if (typeof data.publishConfig === `object` && data.publishConfig !== null) {
      this.publishConfig = {};
      if (typeof data.publishConfig.access === `string`) this.publishConfig.access = data.publishConfig.access;
      if (typeof data.publishConfig.main === `string`) this.publishConfig.main = normalizeSlashes(data.publishConfig.main);
      if (typeof data.publishConfig.module === `string`) this.publishConfig.module = normalizeSlashes(data.publishConfig.module);

      if (data.publishConfig.browser != null) {
        if (typeof data.publishConfig.browser === `string`) {
          this.publishConfig.browser = normalizeSlashes(data.publishConfig.browser);
        } else {
          this.publishConfig.browser = new Map();

          for (const [key, value] of Object.entries(data.publishConfig.browser)) {
            this.publishConfig.browser.set(normalizeSlashes(key), typeof value === `string` ? normalizeSlashes(value) : value);
          }
        }
      }

      if (typeof data.publishConfig.registry === `string`) this.publishConfig.registry = data.publishConfig.registry;

      if (typeof data.publishConfig.bin === `string`) {
        if (this.name !== null) {
          this.publishConfig.bin = new Map([[this.name.name, normalizeSlashes(data.publishConfig.bin)]]);
        } else {
          errors.push(new Error(`String bin field, but no attached package name`));
        }
      } else if (typeof data.publishConfig.bin === `object` && data.publishConfig.bin !== null) {
        this.publishConfig.bin = new Map();

        for (const [key, value] of Object.entries(data.publishConfig.bin)) {
          if (typeof value !== `string`) {
            errors.push(new Error(`Invalid bin definition for '${key}'`));
            continue;
          }

          this.publishConfig.bin.set(key, normalizeSlashes(value));
        }
      }

      if (Array.isArray(data.publishConfig.executableFiles)) {
        this.publishConfig.executableFiles = new Set();

        for (const value of data.publishConfig.executableFiles) {
          if (typeof value !== `string`) {
            errors.push(new Error(`Invalid executable file definition`));
            continue;
          }

          this.publishConfig.executableFiles.add(normalizeSlashes(value));
        }
      }
    }

    if (typeof data.installConfig === `object` && data.installConfig !== null) {
      this.installConfig = {};

      for (const key of Object.keys(data.installConfig)) {
        if (key === `hoistingLimits`) {
          if (typeof data.installConfig.hoistingLimits === `string`) {
            this.installConfig.hoistingLimits = data.installConfig.hoistingLimits;
          } else {
            errors.push(new Error(`Invalid hoisting limits definition`));
          }
        } else {
          errors.push(new Error(`Unrecognized installConfig key: ${key}`));
        }
      }
    } // We treat optional dependencies after both the regular dependency field
    // and the dependenciesMeta field have been generated (because we will
    // override them)


    if (typeof data.optionalDependencies === `object` && data.optionalDependencies !== null) {
      for (const [name, range] of Object.entries(data.optionalDependencies)) {
        if (typeof range !== `string`) {
          errors.push(new Error(`Invalid dependency range for '${name}'`));
          continue;
        }

        let ident;

        try {
          ident = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseIdent(name);
        } catch (error) {
          errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
          continue;
        } // Note that we store the optional dependencies in the same store as
        // the one that keep the regular dependencies, because they're
        // effectively the same (the only difference is that optional
        // dependencies have an extra field set in dependenciesMeta).


        const realDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(ident, range);
        this.dependencies.set(realDescriptor.identHash, realDescriptor);
        const identDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(ident, `unknown`);
        const dependencyMeta = this.ensureDependencyMeta(identDescriptor);
        Object.assign(dependencyMeta, {
          optional: true
        });
      }
    }

    if (typeof data.preferUnplugged === `boolean`) this.preferUnplugged = data.preferUnplugged;
    this.errors = errors;
  }

  getForScope(type) {
    switch (type) {
      case `dependencies`:
        return this.dependencies;

      case `devDependencies`:
        return this.devDependencies;

      case `peerDependencies`:
        return this.peerDependencies;

      default:
        {
          throw new Error(`Unsupported value ("${type}")`);
        }
    }
  }

  hasConsumerDependency(ident) {
    if (this.dependencies.has(ident.identHash)) return true;
    if (this.peerDependencies.has(ident.identHash)) return true;
    return false;
  }

  hasHardDependency(ident) {
    if (this.dependencies.has(ident.identHash)) return true;
    if (this.devDependencies.has(ident.identHash)) return true;
    return false;
  }

  hasSoftDependency(ident) {
    if (this.peerDependencies.has(ident.identHash)) return true;
    return false;
  }

  hasDependency(ident) {
    if (this.hasHardDependency(ident)) return true;
    if (this.hasSoftDependency(ident)) return true;
    return false;
  }

  isCompatibleWithOS(os) {
    return Manifest.isManifestFieldCompatible(this.os, os);
  }

  isCompatibleWithCPU(cpu) {
    return Manifest.isManifestFieldCompatible(this.cpu, cpu);
  }

  ensureDependencyMeta(descriptor) {
    if (descriptor.range !== `unknown` && !semver__WEBPACK_IMPORTED_MODULE_1___default().valid(descriptor.range)) throw new Error(`Invalid meta field range for '${_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyDescriptor(descriptor)}'`);
    const identString = _structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(descriptor);
    const range = descriptor.range !== `unknown` ? descriptor.range : null;
    let dependencyMetaSet = this.dependenciesMeta.get(identString);
    if (!dependencyMetaSet) this.dependenciesMeta.set(identString, dependencyMetaSet = new Map());
    let dependencyMeta = dependencyMetaSet.get(range);
    if (!dependencyMeta) dependencyMetaSet.set(range, dependencyMeta = {});
    return dependencyMeta;
  }

  ensurePeerDependencyMeta(descriptor) {
    if (descriptor.range !== `unknown`) throw new Error(`Invalid meta field range for '${_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyDescriptor(descriptor)}'`);
    const identString = _structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(descriptor);
    let peerDependencyMeta = this.peerDependenciesMeta.get(identString);
    if (!peerDependencyMeta) this.peerDependenciesMeta.set(identString, peerDependencyMeta = {});
    return peerDependencyMeta;
  }

  setRawField(name, value, {
    after = []
  } = {}) {
    const afterSet = new Set(after.filter(key => {
      return Object.prototype.hasOwnProperty.call(this.raw, key);
    }));

    if (afterSet.size === 0 || Object.prototype.hasOwnProperty.call(this.raw, name)) {
      this.raw[name] = value;
    } else {
      const oldRaw = this.raw;
      const newRaw = this.raw = {};
      let inserted = false;

      for (const key of Object.keys(oldRaw)) {
        newRaw[key] = oldRaw[key];

        if (!inserted) {
          afterSet.delete(key);

          if (afterSet.size === 0) {
            newRaw[name] = value;
            inserted = true;
          }
        }
      }
    }
  }

  exportTo(data, {
    compatibilityMode = true
  } = {}) {
    // Note that we even set the fields that we re-set later; it
    // allows us to preserve the key ordering
    Object.assign(data, this.raw);
    if (this.name !== null) data.name = _structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(this.name);else delete data.name;
    if (this.version !== null) data.version = this.version;else delete data.version;
    if (this.os !== null) data.os = this.os;else delete data.os;
    if (this.cpu !== null) data.cpu = this.cpu;else delete data.cpu;
    if (this.type !== null) data.type = this.type;else delete data.type;
    if (this.private) data.private = true;else delete data.private;
    if (this.license !== null) data.license = this.license;else delete data.license;
    if (this.languageName !== null) data.languageName = this.languageName;else delete data.languageName;
    if (this.main !== null) data.main = this.main;else delete data.main;
    if (this.module !== null) data.module = this.module;else delete data.module;

    if (this.browser !== null) {
      const browser = this.browser;

      if (typeof browser === `string`) {
        data.browser = browser;
      } else if (browser instanceof Map) {
        data.browser = Object.assign({}, ...Array.from(browser.keys()).sort().map(name => {
          return {
            [name]: browser.get(name)
          };
        }));
      }
    } else {
      delete data.browser;
    }

    if (this.bin.size === 1 && this.name !== null && this.bin.has(this.name.name)) {
      data.bin = this.bin.get(this.name.name);
    } else if (this.bin.size > 0) {
      data.bin = Object.assign({}, ...Array.from(this.bin.keys()).sort().map(name => {
        return {
          [name]: this.bin.get(name)
        };
      }));
    } else {
      delete data.bin;
    }

    if (this.workspaceDefinitions.length > 0) {
      if (this.raw.workspaces && !Array.isArray(this.raw.workspaces)) {
        data.workspaces = { ...this.raw.workspaces,
          packages: this.workspaceDefinitions.map(({
            pattern
          }) => pattern)
        };
      } else {
        data.workspaces = this.workspaceDefinitions.map(({
          pattern
        }) => pattern);
      }
    } else if (this.raw.workspaces && !Array.isArray(this.raw.workspaces) && Object.keys(this.raw.workspaces).length > 0) {
      data.workspaces = this.raw.workspaces;
    } else {
      delete data.workspaces;
    }

    const regularDependencies = [];
    const optionalDependencies = [];

    for (const dependency of this.dependencies.values()) {
      const dependencyMetaSet = this.dependenciesMeta.get(_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(dependency));
      let isOptionallyBuilt = false;

      if (compatibilityMode) {
        if (dependencyMetaSet) {
          const meta = dependencyMetaSet.get(null);

          if (meta && meta.optional) {
            isOptionallyBuilt = true;
          }
        }
      }

      if (isOptionallyBuilt) {
        optionalDependencies.push(dependency);
      } else {
        regularDependencies.push(dependency);
      }
    }

    if (regularDependencies.length > 0) {
      data.dependencies = Object.assign({}, ..._structUtils__WEBPACK_IMPORTED_MODULE_4__.sortDescriptors(regularDependencies).map(dependency => {
        return {
          [_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(dependency)]: dependency.range
        };
      }));
    } else {
      delete data.dependencies;
    }

    if (optionalDependencies.length > 0) {
      data.optionalDependencies = Object.assign({}, ..._structUtils__WEBPACK_IMPORTED_MODULE_4__.sortDescriptors(optionalDependencies).map(dependency => {
        return {
          [_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(dependency)]: dependency.range
        };
      }));
    } else {
      delete data.optionalDependencies;
    }

    if (this.devDependencies.size > 0) {
      data.devDependencies = Object.assign({}, ..._structUtils__WEBPACK_IMPORTED_MODULE_4__.sortDescriptors(this.devDependencies.values()).map(dependency => {
        return {
          [_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(dependency)]: dependency.range
        };
      }));
    } else {
      delete data.devDependencies;
    }

    if (this.peerDependencies.size > 0) {
      data.peerDependencies = Object.assign({}, ..._structUtils__WEBPACK_IMPORTED_MODULE_4__.sortDescriptors(this.peerDependencies.values()).map(dependency => {
        return {
          [_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(dependency)]: dependency.range
        };
      }));
    } else {
      delete data.peerDependencies;
    }

    data.dependenciesMeta = {};

    for (const [identString, dependencyMetaSet] of _miscUtils__WEBPACK_IMPORTED_MODULE_6__.sortMap(this.dependenciesMeta.entries(), ([identString, dependencyMetaSet]) => identString)) {
      for (const [range, meta] of _miscUtils__WEBPACK_IMPORTED_MODULE_6__.sortMap(dependencyMetaSet.entries(), ([range, meta]) => range !== null ? `0${range}` : `1`)) {
        const key = range !== null ? _structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyDescriptor(_structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(_structUtils__WEBPACK_IMPORTED_MODULE_4__.parseIdent(identString), range)) : identString;
        const metaCopy = { ...meta
        };
        if (compatibilityMode && range === null) delete metaCopy.optional;
        if (Object.keys(metaCopy).length === 0) continue;
        data.dependenciesMeta[key] = metaCopy;
      }
    }

    if (Object.keys(data.dependenciesMeta).length === 0) delete data.dependenciesMeta;

    if (this.peerDependenciesMeta.size > 0) {
      data.peerDependenciesMeta = Object.assign({}, ..._miscUtils__WEBPACK_IMPORTED_MODULE_6__.sortMap(this.peerDependenciesMeta.entries(), ([identString, meta]) => identString).map(([identString, meta]) => {
        return {
          [identString]: meta
        };
      }));
    } else {
      delete data.peerDependenciesMeta;
    }

    if (this.resolutions.length > 0) {
      data.resolutions = Object.assign({}, ...this.resolutions.map(({
        pattern,
        reference
      }) => {
        return {
          [(0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.stringifyResolution)(pattern)]: reference
        };
      }));
    } else {
      delete data.resolutions;
    }

    if (this.files !== null) data.files = Array.from(this.files);else delete data.files;
    if (this.preferUnplugged !== null) data.preferUnplugged = this.preferUnplugged;else delete data.preferUnplugged;
    return data;
  }

}
Manifest.fileName = `package.json`;
Manifest.allDependencies = [`dependencies`, `devDependencies`, `peerDependencies`];
Manifest.hardDependencies = [`dependencies`, `devDependencies`];

function getIndent(content) {
  const indentMatch = content.match(/^[ \t]+/m);

  if (indentMatch) {
    return indentMatch[0];
  } else {
    return `  `;
  }
}

function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    return content.slice(1);
  } else {
    return content;
  }
}

function normalizeSlashes(str) {
  return str.replace(/\\/g, `/`);
}

function tryParseOptionalBoolean(value, {
  yamlCompatibilityMode
}) {
  if (yamlCompatibilityMode) return _miscUtils__WEBPACK_IMPORTED_MODULE_6__.tryParseOptionalBoolean(value);
  if (typeof value === `undefined` || typeof value === `boolean`) return value;
  return null;
}

/***/ }),
/* 238 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MetricName": () => /* binding */ MetricName,
/* harmony export */   "TelemetryManager": () => /* binding */ TelemetryManager
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _httpUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(239);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(177);



var MetricName;

(function (MetricName) {
  MetricName["VERSION"] = "version";
  MetricName["COMMAND_NAME"] = "commandName";
  MetricName["PLUGIN_NAME"] = "pluginName";
  MetricName["INSTALL_COUNT"] = "installCount";
  MetricName["PROJECT_COUNT"] = "projectCount";
  MetricName["WORKSPACE_COUNT"] = "workspaceCount";
  MetricName["DEPENDENCY_COUNT"] = "dependencyCount";
  MetricName["EXTENSION"] = "packageExtension";
})(MetricName || (MetricName = {}));

class TelemetryManager {
  constructor(configuration, accountId) {
    this.values = new Map();
    this.hits = new Map();
    this.enumerators = new Map();
    this.configuration = configuration;
    const registryFile = this.getRegistryPath();
    this.isNew = !_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.existsSync(registryFile);
    this.sendReport(accountId);
    this.startBuffer();
  }

  reportVersion(value) {
    this.reportValue(MetricName.VERSION, value);
  }

  reportCommandName(value) {
    this.reportValue(MetricName.COMMAND_NAME, value || `<none>`);
  }

  reportPluginName(value) {
    this.reportValue(MetricName.PLUGIN_NAME, value);
  }

  reportProject(cwd) {
    this.reportEnumerator(MetricName.PROJECT_COUNT, cwd);
  }

  reportInstall(nodeLinker) {
    this.reportHit(MetricName.INSTALL_COUNT, nodeLinker);
  }

  reportPackageExtension(value) {
    this.reportValue(MetricName.EXTENSION, value);
  }

  reportWorkspaceCount(count) {
    this.reportValue(MetricName.WORKSPACE_COUNT, String(count));
  }

  reportDependencyCount(count) {
    this.reportValue(MetricName.DEPENDENCY_COUNT, String(count));
  }

  reportValue(metric, value) {
    _miscUtils__WEBPACK_IMPORTED_MODULE_1__.getSetWithDefault(this.values, metric).add(value);
  }

  reportEnumerator(metric, value) {
    _miscUtils__WEBPACK_IMPORTED_MODULE_1__.getSetWithDefault(this.enumerators, metric).add(value);
  }

  reportHit(metric, extra = `*`) {
    const ns = _miscUtils__WEBPACK_IMPORTED_MODULE_1__.getMapWithDefault(this.hits, metric);
    const current = _miscUtils__WEBPACK_IMPORTED_MODULE_1__.getFactoryWithDefault(ns, extra, () => 0);
    ns.set(extra, current + 1);
  }

  getRegistryPath() {
    const registryFile = this.configuration.get(`globalFolder`);
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(registryFile, `telemetry.json`);
  }

  sendReport(accountId) {
    var _a, _b, _c;

    const registryFile = this.getRegistryPath();
    let content;

    try {
      content = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.readJsonSync(registryFile);
    } catch (_d) {
      content = {};
    }

    const now = Date.now();
    const interval = this.configuration.get(`telemetryInterval`) * 24 * 60 * 60 * 1000;
    const lastUpdate = (_a = content.lastUpdate) !== null && _a !== void 0 ? _a : now + interval + Math.floor(interval * Math.random());
    const nextUpdate = lastUpdate + interval;
    if (nextUpdate > now && content.lastUpdate != null) return;

    try {
      _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.mkdirSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(registryFile), {
        recursive: true
      });
      _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.writeJsonSync(registryFile, {
        lastUpdate: now
      });
    } catch (_e) {
      // In some cases this location is read-only. Too bad 
      return;
    }

    if (nextUpdate > now) return;
    if (!content.blocks) return;

    for (const [userId, block] of Object.entries((_b = content.blocks) !== null && _b !== void 0 ? _b : {})) {
      if (Object.keys(block).length === 0) continue;
      const upload = block;
      upload.userId = userId;

      for (const key of Object.keys((_c = upload.enumerators) !== null && _c !== void 0 ? _c : {})) upload.enumerators[key] = upload.enumerators[key].length;

      const rawUrl = `https://browser-http-intake.logs.datadoghq.eu/v1/input/${accountId}?ddsource=yarn`;
      _httpUtils__WEBPACK_IMPORTED_MODULE_3__.post(rawUrl, upload, {
        configuration: this.configuration
      }).catch(() => {// Nothing we can do
      });
    }
  }

  applyChanges() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;

    const registryFile = this.getRegistryPath();
    let content;

    try {
      content = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.readJsonSync(registryFile);
    } catch (_k) {
      content = {};
    }

    const userId = (_a = this.configuration.get(`telemetryUserId`)) !== null && _a !== void 0 ? _a : `*`;
    const blocks = content.blocks = (_b = content.blocks) !== null && _b !== void 0 ? _b : {};
    const block = blocks[userId] = (_c = blocks[userId]) !== null && _c !== void 0 ? _c : {};

    for (const key of this.hits.keys()) {
      const store = block.hits = (_d = block.hits) !== null && _d !== void 0 ? _d : {};
      const ns = store[key] = (_e = store[key]) !== null && _e !== void 0 ? _e : {};

      for (const [extra, value] of this.hits.get(key)) {
        ns[extra] = ((_f = ns[extra]) !== null && _f !== void 0 ? _f : 0) + value;
      }
    }

    for (const field of [`values`, `enumerators`]) {
      for (const key of this[field].keys()) {
        const store = block[field] = (_g = block[field]) !== null && _g !== void 0 ? _g : {};
        store[key] = [...new Set([...((_h = store[key]) !== null && _h !== void 0 ? _h : []), ...((_j = this[field].get(key)) !== null && _j !== void 0 ? _j : [])])];
      }
    }

    _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.mkdirSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(registryFile), {
      recursive: true
    });
    _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.writeJsonSync(registryFile, content);
  }

  startBuffer() {
    process.on(`exit`, () => {
      try {
        this.applyChanges();
      } catch (_a) {// Explicitly ignore errors
      }
    });
  }

}

/***/ }),
/* 239 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getNetworkSettings": () => /* binding */ getNetworkSettings,
/* harmony export */   "Method": () => /* binding */ Method,
/* harmony export */   "request": () => /* binding */ request,
/* harmony export */   "get": () => /* binding */ get,
/* harmony export */   "put": () => /* binding */ put,
/* harmony export */   "post": () => /* binding */ post,
/* harmony export */   "del": () => /* binding */ del
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(155);
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(240);
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(241);
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var tunnel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(242);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(247);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_4__);






const cache = new Map();
const certCache = new Map();
const globalHttpAgent = new http__WEBPACK_IMPORTED_MODULE_1__.Agent({
  keepAlive: true
});
const globalHttpsAgent = new https__WEBPACK_IMPORTED_MODULE_0__.Agent({
  keepAlive: true
});

function parseProxy(specifier) {
  const url = new url__WEBPACK_IMPORTED_MODULE_4__.URL(specifier);
  const proxy = {
    host: url.hostname,
    headers: {}
  };
  if (url.port) proxy.port = Number(url.port);
  return {
    proxy
  };
}

async function getCachedCertificate(caFilePath) {
  let certificate = certCache.get(caFilePath);

  if (!certificate) {
    certificate = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.readFilePromise(caFilePath).then(cert => {
      certCache.set(caFilePath, cert);
      return cert;
    });
    certCache.set(caFilePath, certificate);
  }

  return certificate;
}
/**
 * Searches through networkSettings and returns the most specific match
 */


function getNetworkSettings(target, opts) {
  // Sort the config by key length to match on the most specific pattern
  const networkSettings = [...opts.configuration.get(`networkSettings`)].sort(([keyA], [keyB]) => {
    return keyB.length - keyA.length;
  });
  const mergedNetworkSettings = {};
  const url = new url__WEBPACK_IMPORTED_MODULE_4__.URL(target);

  for (const [glob, config] of networkSettings) {
    if (micromatch__WEBPACK_IMPORTED_MODULE_2___default().isMatch(url.hostname, glob)) {
      const enableNetwork = config.get(`enableNetwork`);
      if (enableNetwork !== null && typeof mergedNetworkSettings.enableNetwork === `undefined`) mergedNetworkSettings.enableNetwork = enableNetwork;
      const caFilePath = config.get(`caFilePath`);

      if (caFilePath !== null && typeof mergedNetworkSettings.caFilePath === `undefined`) {
        mergedNetworkSettings.caFilePath = caFilePath;
      }
    }
  }

  if (typeof mergedNetworkSettings.caFilePath === `undefined`) mergedNetworkSettings.caFilePath = opts.configuration.get(`caFilePath`);
  if (typeof mergedNetworkSettings.enableNetwork === `undefined`) mergedNetworkSettings.enableNetwork = opts.configuration.get(`enableNetwork`);
  return mergedNetworkSettings;
}
var Method;

(function (Method) {
  Method["GET"] = "GET";
  Method["PUT"] = "PUT";
  Method["POST"] = "POST";
  Method["DELETE"] = "DELETE";
})(Method || (Method = {}));

async function request(target, body, {
  configuration,
  headers,
  json,
  jsonRequest = json,
  jsonResponse = json,
  method = Method.GET
}) {
  const networkConfig = getNetworkSettings(target, {
    configuration
  });
  if (networkConfig.enableNetwork === false) throw new Error(`Request to '${target}' has been blocked because of your configuration settings`);
  const url = new url__WEBPACK_IMPORTED_MODULE_4__.URL(target);
  if (url.protocol === `http:` && !micromatch__WEBPACK_IMPORTED_MODULE_2___default().isMatch(url.hostname, configuration.get(`unsafeHttpWhitelist`))) throw new Error(`Unsafe http requests must be explicitly whitelisted in your configuration (${url.hostname})`);
  const httpProxy = configuration.get(`httpProxy`);
  const httpsProxy = configuration.get(`httpsProxy`);
  const agent = {
    http: httpProxy ? tunnel__WEBPACK_IMPORTED_MODULE_3__.httpOverHttp(parseProxy(httpProxy)) : globalHttpAgent,
    https: httpsProxy ? tunnel__WEBPACK_IMPORTED_MODULE_3__.httpsOverHttp(parseProxy(httpsProxy)) : globalHttpsAgent
  };
  const gotOptions = {
    agent,
    headers,
    method
  };
  gotOptions.responseType = jsonResponse ? `json` : `buffer`;

  if (body !== null) {
    if (Buffer.isBuffer(body) || !jsonRequest && typeof body === `string`) {
      gotOptions.body = body;
    } else {
      // @ts-expect-error: The got types only allow an object, but got can stringify any valid JSON
      gotOptions.json = body;
    }
  }

  const socketTimeout = configuration.get(`httpTimeout`);
  const retry = configuration.get(`httpRetry`);
  const rejectUnauthorized = configuration.get(`enableStrictSsl`);
  const caFilePath = networkConfig.caFilePath;
  const {
    default: got
  } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 755, 7));
  const certificateAuthority = caFilePath ? await getCachedCertificate(caFilePath) : undefined;
  const gotClient = got.extend({
    timeout: {
      socket: socketTimeout
    },
    retry,
    https: {
      rejectUnauthorized,
      certificateAuthority
    },
    ...gotOptions
  });
  return configuration.getLimit(`networkConcurrency`)(() => {
    return gotClient(target);
  });
}
async function get(target, {
  configuration,
  json,
  jsonResponse = json,
  ...rest
}) {
  let entry = cache.get(target);

  if (!entry) {
    entry = request(target, null, {
      configuration,
      ...rest
    }).then(response => {
      cache.set(target, response.body);
      return response.body;
    });
    cache.set(target, entry);
  }

  if (Buffer.isBuffer(entry) === false) entry = await entry;

  if (jsonResponse) {
    return JSON.parse(entry.toString());
  } else {
    return entry;
  }
}
async function put(target, body, options) {
  const response = await request(target, body, { ...options,
    method: Method.PUT
  });
  return response.body;
}
async function post(target, body, options) {
  const response = await request(target, body, { ...options,
    method: Method.POST
  });
  return response.body;
}
async function del(target, options) {
  const response = await request(target, null, { ...options,
    method: Method.DELETE
  });
  return response.body;
}

/***/ }),
/* 240 */
/***/ ((module) => {

"use strict";
module.exports = require("https");;

/***/ }),
/* 241 */
/***/ ((module) => {

"use strict";
module.exports = require("http");;

/***/ }),
/* 242 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(243);


/***/ }),
/* 243 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var net = __webpack_require__(244);
var tls = __webpack_require__(245);
var http = __webpack_require__(241);
var https = __webpack_require__(240);
var events = __webpack_require__(119);
var assert = __webpack_require__(246);
var util = __webpack_require__(90);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),
/* 244 */
/***/ ((module) => {

"use strict";
module.exports = require("net");;

/***/ }),
/* 245 */
/***/ ((module) => {

"use strict";
module.exports = require("tls");;

/***/ }),
/* 246 */
/***/ ((module) => {

"use strict";
module.exports = require("assert");;

/***/ }),
/* 247 */
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),
/* 248 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.getPluginConfiguration = () => ({
  modules: new Map([
    ["@yarnpkg/cli", __webpack_require__(249)],
    ["@yarnpkg/core", __webpack_require__(377)],
    ["@yarnpkg/fslib", __webpack_require__(155)],
    ["@yarnpkg/libzip", __webpack_require__(341)],
    ["@yarnpkg/parsers", __webpack_require__(182)],
    ["@yarnpkg/shell", __webpack_require__(344)],
    ["clipanion", __webpack_require__(7)],
    ["semver", __webpack_require__(28)],
    ["yup", __webpack_require__(413)],
    ["@yarnpkg/plugin-essentials", __webpack_require__(554)],
    ["@yarnpkg/plugin-compat", __webpack_require__(637)],
    ["@yarnpkg/plugin-dlx", __webpack_require__(642)],
    ["@yarnpkg/plugin-file", __webpack_require__(645)],
    ["@yarnpkg/plugin-git", __webpack_require__(652)],
    ["@yarnpkg/plugin-github", __webpack_require__(656)],
    ["@yarnpkg/plugin-http", __webpack_require__(659)],
    ["@yarnpkg/plugin-init", __webpack_require__(663)],
    ["@yarnpkg/plugin-link", __webpack_require__(676)],
    ["@yarnpkg/plugin-node-modules", __webpack_require__(682)],
    ["@yarnpkg/plugin-npm", __webpack_require__(707)],
    ["@yarnpkg/plugin-npm-cli", __webpack_require__(733)],
    ["@yarnpkg/plugin-pack", __webpack_require__(717)],
    ["@yarnpkg/plugin-patch", __webpack_require__(745)],
    ["@yarnpkg/plugin-pnp", __webpack_require__(684)],

  ]),
  plugins: new Set([
    "@yarnpkg/plugin-essentials",
    "@yarnpkg/plugin-compat",
    "@yarnpkg/plugin-dlx",
    "@yarnpkg/plugin-file",
    "@yarnpkg/plugin-git",
    "@yarnpkg/plugin-github",
    "@yarnpkg/plugin-http",
    "@yarnpkg/plugin-init",
    "@yarnpkg/plugin-link",
    "@yarnpkg/plugin-node-modules",
    "@yarnpkg/plugin-npm",
    "@yarnpkg/plugin-npm-cli",
    "@yarnpkg/plugin-pack",
    "@yarnpkg/plugin-patch",
    "@yarnpkg/plugin-pnp",

  ]),
});


/***/ }),
/* 249 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseCommand": () => /* reexport safe */ _tools_BaseCommand__WEBPACK_IMPORTED_MODULE_0__.BaseCommand,
/* harmony export */   "WorkspaceRequiredError": () => /* reexport safe */ _tools_WorkspaceRequiredError__WEBPACK_IMPORTED_MODULE_1__.WorkspaceRequiredError,
/* harmony export */   "getDynamicLibs": () => /* reexport safe */ _tools_getDynamicLibs__WEBPACK_IMPORTED_MODULE_2__.getDynamicLibs,
/* harmony export */   "getPluginConfiguration": () => /* reexport safe */ _tools_getPluginConfiguration__WEBPACK_IMPORTED_MODULE_3__.getPluginConfiguration,
/* harmony export */   "openWorkspace": () => /* reexport safe */ _tools_openWorkspace__WEBPACK_IMPORTED_MODULE_4__.openWorkspace,
/* harmony export */   "main": () => /* reexport safe */ _main__WEBPACK_IMPORTED_MODULE_5__.main,
/* harmony export */   "pluginCommands": () => /* reexport safe */ _pluginCommands__WEBPACK_IMPORTED_MODULE_6__.pluginCommands
/* harmony export */ });
/* harmony import */ var _tools_BaseCommand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);
/* harmony import */ var _tools_WorkspaceRequiredError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(250);
/* harmony import */ var _tools_getDynamicLibs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(251);
/* harmony import */ var _tools_getPluginConfiguration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(248);
/* harmony import */ var _tools_openWorkspace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(253);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);
/* harmony import */ var _pluginCommands__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9);








/***/ }),
/* 250 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WorkspaceRequiredError": () => /* binding */ WorkspaceRequiredError
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(162);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);



class WorkspaceRequiredError extends clipanion__WEBPACK_IMPORTED_MODULE_0__.UsageError {
  constructor(projectCwd, cwd) {
    const relativePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.relative(projectCwd, cwd);
    const manifestPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.join(projectCwd, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Manifest.fileName);
    super(`This command can only be run from within a workspace of your project (${relativePath} isn't a workspace of ${manifestPath}).`);
  }

}

/***/ }),
/* 251 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDynamicLibs": () => /* binding */ getDynamicLibs
/* harmony export */ });
const DYNAMIC_LIBS = [`@yarnpkg/cli`, `@yarnpkg/core`, `@yarnpkg/fslib`, `@yarnpkg/libzip`, `@yarnpkg/parsers`, `@yarnpkg/shell`, // Those ones are always useful
`clipanion`, `semver`, `yup`];
const getDynamicLibs = () => {
  return new Map(DYNAMIC_LIBS.map(name => {
    return [name, __webpack_require__(252)(name)];
  }));
};

/***/ }),
/* 252 */
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => [];
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 252;
module.exports = webpackEmptyContext;

/***/ }),
/* 253 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "openWorkspace": () => /* binding */ openWorkspace
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(254);
/* harmony import */ var _WorkspaceRequiredError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(250);


async function openWorkspace(configuration, cwd) {
  const {
    project,
    workspace
  } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.Project.find(configuration, cwd);
  if (!workspace) throw new _WorkspaceRequiredError__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, cwd);
  return workspace;
}

/***/ }),
/* 254 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Project": () => /* binding */ Project
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(160);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(182);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var diff__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(255);
/* harmony import */ var lodash_pick__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(256);
/* harmony import */ var lodash_pick__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_pick__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(221);
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(p_limit__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(90);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var v8__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(333);
/* harmony import */ var v8__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(v8__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(164);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _Configuration__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(181);
/* harmony import */ var _Installer__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(339);
/* harmony import */ var _LegacyMigrationResolver__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(336);
/* harmony import */ var _LockfileResolver__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(337);
/* harmony import */ var _Manifest__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(237);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(180);
/* harmony import */ var _MultiResolver__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(227);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(233);
/* harmony import */ var _RunInstallPleaseResolver__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(338);
/* harmony import */ var _ThrowReport__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(335);
/* harmony import */ var _Workspace__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(334);
/* harmony import */ var _folderUtils__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(223);
/* harmony import */ var _formatUtils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(13);
/* harmony import */ var _hashUtils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(71);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(177);
/* harmony import */ var _scriptUtils__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(340);
/* harmony import */ var _semverUtils__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(231);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(26);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(179);






























 // When upgraded, the lockfile entries have to be resolved again (but the specific
// versions are still pinned, no worry). Bump it when you change the fields within
// the Package type; no more no less.

const LOCKFILE_VERSION = 4; // Same thing but must be bumped when the members of the Project class changes (we
// don't recommend our users to check-in this file, so it's fine to bump it even
// between patch or minor releases).

const INSTALL_STATE_VERSION = 1;
const MULTIPLE_KEYS_REGEXP = / *, */g;
const TRAILING_SLASH_REGEXP = /\/$/;
const FETCHER_CONCURRENCY = 32;
const gzip = (0,util__WEBPACK_IMPORTED_MODULE_7__.promisify)((zlib__WEBPACK_IMPORTED_MODULE_9___default().gzip));
const gunzip = (0,util__WEBPACK_IMPORTED_MODULE_7__.promisify)((zlib__WEBPACK_IMPORTED_MODULE_9___default().gunzip));
const INSTALL_STATE_FIELDS = {
  restoreInstallersCustomData: [`installersCustomData`],
  restoreResolutions: [`accessibleLocators`, `optionalBuilds`, `storedDescriptors`, `storedResolutions`, `storedPackages`, `lockFileChecksum`]
};
class Project {
  constructor(projectCwd, {
    configuration
  }) {
    /**
     * Is meant to be populated by the consumer. Should the descriptor referenced
     * by the key be requested, the descriptor referenced in the value will be
     * resolved instead. The resolved data will then be used as final resolution
     * for the initial descriptor.
     *
     * Note that the lockfile will contain the second descriptor but not the
     * first one (meaning that if you remove the alias during a subsequent
     * install, it'll be lost and the real package will be resolved / installed).
     */
    this.resolutionAliases = new Map();
    this.workspaces = [];
    this.workspacesByCwd = new Map();
    this.workspacesByIdent = new Map();
    this.storedResolutions = new Map();
    this.storedDescriptors = new Map();
    this.storedPackages = new Map();
    this.storedChecksums = new Map();
    this.accessibleLocators = new Set();
    this.originalPackages = new Map();
    this.optionalBuilds = new Set();
    this.installersCustomData = new Map();
    this.lockFileChecksum = null;
    this.configuration = configuration;
    this.cwd = projectCwd;
  }

  static async find(configuration, startingCwd) {
    var _a, _b, _c;

    if (!configuration.projectCwd) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`No project found in ${startingCwd}`);
    let packageCwd = configuration.projectCwd;
    let nextCwd = startingCwd;
    let currentCwd = null;

    while (currentCwd !== configuration.projectCwd) {
      currentCwd = nextCwd;

      if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(currentCwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.Filename.manifest))) {
        packageCwd = currentCwd;
        break;
      }

      nextCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.dirname(currentCwd);
    }

    const project = new Project(configuration.projectCwd, {
      configuration
    });
    (_a = _Configuration__WEBPACK_IMPORTED_MODULE_12__.Configuration.telemetry) === null || _a === void 0 ? void 0 : _a.reportProject(project.cwd);
    await project.setupResolutions();
    await project.setupWorkspaces();
    (_b = _Configuration__WEBPACK_IMPORTED_MODULE_12__.Configuration.telemetry) === null || _b === void 0 ? void 0 : _b.reportWorkspaceCount(project.workspaces.length);
    (_c = _Configuration__WEBPACK_IMPORTED_MODULE_12__.Configuration.telemetry) === null || _c === void 0 ? void 0 : _c.reportDependencyCount(project.workspaces.reduce((sum, workspace) => sum + workspace.manifest.dependencies.size + workspace.manifest.devDependencies.size, 0)); // If we're in a workspace, no need to go any further to find which package we're in

    const workspace = project.tryWorkspaceByCwd(packageCwd);
    if (workspace) return {
      project,
      workspace,
      locator: workspace.anchoredLocator
    }; // Otherwise, we need to ask the project (which will in turn ask the linkers for help)
    // Note: the trailing slash is caused by a quirk in the PnP implementation that requires folders to end with a trailing slash to disambiguate them from regular files

    const locator = await project.findLocatorForLocation(`${packageCwd}/`, {
      strict: true
    });
    if (locator) return {
      project,
      locator,
      workspace: null
    };
    throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The nearest package directory (${_formatUtils__WEBPACK_IMPORTED_MODULE_13__.pretty(configuration, packageCwd, _formatUtils__WEBPACK_IMPORTED_MODULE_13__.Type.PATH)}) doesn't seem to be part of the project declared in ${_formatUtils__WEBPACK_IMPORTED_MODULE_13__.pretty(configuration, project.cwd, _formatUtils__WEBPACK_IMPORTED_MODULE_13__.Type.PATH)}.\n\n- If the project directory is right, it might be that you forgot to list ${_formatUtils__WEBPACK_IMPORTED_MODULE_13__.pretty(configuration, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.relative(project.cwd, packageCwd), _formatUtils__WEBPACK_IMPORTED_MODULE_13__.Type.PATH)} as a workspace.\n- If it isn't, it's likely because you have a yarn.lock or package.json file there, confusing the project root detection.`);
  }

  static generateBuildStateFile(buildState, locatorStore) {
    let bstateFile = `# Warning: This file is automatically generated. Removing it is fine, but will\n# cause all your builds to become invalidated.\n`;
    const bstateData = [...buildState].map(([locatorHash, hash]) => {
      const locator = locatorStore.get(locatorHash);
      if (typeof locator === `undefined`) throw new Error(`Assertion failed: The locator should have been registered`);
      return [_structUtils__WEBPACK_IMPORTED_MODULE_14__.stringifyLocator(locator), locator.locatorHash, hash];
    });

    for (const [locatorString, locatorHash, buildHash] of _miscUtils__WEBPACK_IMPORTED_MODULE_15__.sortMap(bstateData, [d => d[0], d => d[1]])) {
      bstateFile += `\n`;
      bstateFile += `# ${locatorString}\n`;
      bstateFile += `${JSON.stringify(locatorHash)}:\n`;
      bstateFile += `  ${buildHash}\n`;
    }

    return bstateFile;
  }

  async setupResolutions() {
    this.storedResolutions = new Map();
    this.storedDescriptors = new Map();
    this.storedPackages = new Map();
    this.lockFileChecksum = null;
    const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(this.cwd, this.configuration.get(`lockfileFilename`));
    const defaultLanguageName = this.configuration.get(`defaultLanguageName`);

    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsSync(lockfilePath)) {
      const content = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readFilePromise(lockfilePath, `utf8`); // We store the salted checksum of the lockfile in order to invalidate the install state when needed

      this.lockFileChecksum = _hashUtils__WEBPACK_IMPORTED_MODULE_16__.makeHash(`${INSTALL_STATE_VERSION}`, content);
      const parsed = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseSyml)(content); // Protects against v1 lockfiles

      if (parsed.__metadata) {
        const lockfileVersion = parsed.__metadata.version;
        const cacheKey = parsed.__metadata.cacheKey;

        for (const key of Object.keys(parsed)) {
          if (key === `__metadata`) continue;
          const data = parsed[key];
          if (typeof data.resolution === `undefined`) throw new Error(`Assertion failed: Expected the lockfile entry to have a resolution field (${key})`);
          const locator = _structUtils__WEBPACK_IMPORTED_MODULE_14__.parseLocator(data.resolution, true);
          const manifest = new _Manifest__WEBPACK_IMPORTED_MODULE_17__.Manifest();
          manifest.load(data, {
            yamlCompatibilityMode: true
          });
          const version = manifest.version;
          const languageName = manifest.languageName || defaultLanguageName;
          const linkType = data.linkType.toUpperCase();
          const dependencies = manifest.dependencies;
          const peerDependencies = manifest.peerDependencies;
          const dependenciesMeta = manifest.dependenciesMeta;
          const peerDependenciesMeta = manifest.peerDependenciesMeta;
          const bin = manifest.bin;

          if (data.checksum != null) {
            const checksum = typeof cacheKey !== `undefined` && !data.checksum.includes(`/`) ? `${cacheKey}/${data.checksum}` : data.checksum;
            this.storedChecksums.set(locator.locatorHash, checksum);
          }

          if (lockfileVersion >= LOCKFILE_VERSION) {
            const pkg = { ...locator,
              version,
              languageName,
              linkType,
              dependencies,
              peerDependencies,
              dependenciesMeta,
              peerDependenciesMeta,
              bin
            };
            this.originalPackages.set(pkg.locatorHash, pkg);
          }

          for (const entry of key.split(MULTIPLE_KEYS_REGEXP)) {
            const descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_14__.parseDescriptor(entry);
            this.storedDescriptors.set(descriptor.descriptorHash, descriptor);

            if (lockfileVersion >= LOCKFILE_VERSION) {
              // If the lockfile is up-to-date, we can simply register the
              // resolution as a done deal.
              this.storedResolutions.set(descriptor.descriptorHash, locator.locatorHash);
            } else {
              // But if it isn't, then we instead setup an alias so that the
              // descriptor will be re-resolved (so that we get to retrieve the
              // new fields) while still resolving to the same locators.
              const resolutionDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_14__.convertLocatorToDescriptor(locator);

              if (resolutionDescriptor.descriptorHash !== descriptor.descriptorHash) {
                this.storedDescriptors.set(resolutionDescriptor.descriptorHash, resolutionDescriptor);
                this.resolutionAliases.set(descriptor.descriptorHash, resolutionDescriptor.descriptorHash);
              }
            }
          }
        }
      }
    }
  }

  async setupWorkspaces() {
    this.workspaces = [];
    this.workspacesByCwd = new Map();
    this.workspacesByIdent = new Map();
    let workspaceCwds = [this.cwd];

    while (workspaceCwds.length > 0) {
      const passCwds = workspaceCwds;
      workspaceCwds = [];

      for (const workspaceCwd of passCwds) {
        if (this.workspacesByCwd.has(workspaceCwd)) continue;
        const workspace = await this.addWorkspace(workspaceCwd);
        const workspacePkg = this.storedPackages.get(workspace.anchoredLocator.locatorHash);
        if (workspacePkg) workspace.dependencies = workspacePkg.dependencies;

        for (const workspaceCwd of workspace.workspacesCwds) {
          workspaceCwds.push(workspaceCwd);
        }
      }
    }
  }

  async addWorkspace(workspaceCwd) {
    const workspace = new _Workspace__WEBPACK_IMPORTED_MODULE_18__.Workspace(workspaceCwd, {
      project: this
    });
    await workspace.setup();
    const dup = this.workspacesByIdent.get(workspace.locator.identHash);
    if (typeof dup !== `undefined`) throw new Error(`Duplicate workspace name ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyIdent(this.configuration, workspace.locator)}: ${workspaceCwd} conflicts with ${dup.cwd}`);
    this.workspaces.push(workspace);
    this.workspacesByCwd.set(workspaceCwd, workspace);
    this.workspacesByIdent.set(workspace.locator.identHash, workspace);
    return workspace;
  }

  get topLevelWorkspace() {
    return this.getWorkspaceByCwd(this.cwd);
  }

  tryWorkspaceByCwd(workspaceCwd) {
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.isAbsolute(workspaceCwd)) workspaceCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(this.cwd, workspaceCwd);
    workspaceCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.normalize(workspaceCwd).replace(/\/+$/, ``);
    const workspace = this.workspacesByCwd.get(workspaceCwd);
    if (!workspace) return null;
    return workspace;
  }

  getWorkspaceByCwd(workspaceCwd) {
    const workspace = this.tryWorkspaceByCwd(workspaceCwd);
    if (!workspace) throw new Error(`Workspace not found (${workspaceCwd})`);
    return workspace;
  }

  tryWorkspaceByFilePath(filePath) {
    let bestWorkspace = null;

    for (const workspace of this.workspaces) {
      const rel = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.relative(workspace.cwd, filePath);
      if (rel.startsWith(`../`)) continue;
      if (bestWorkspace && bestWorkspace.cwd.length >= workspace.cwd.length) continue;
      bestWorkspace = workspace;
    }

    if (!bestWorkspace) return null;
    return bestWorkspace;
  }

  getWorkspaceByFilePath(filePath) {
    const workspace = this.tryWorkspaceByFilePath(filePath);
    if (!workspace) throw new Error(`Workspace not found (${filePath})`);
    return workspace;
  }

  tryWorkspaceByIdent(ident) {
    const workspace = this.workspacesByIdent.get(ident.identHash);
    if (typeof workspace === `undefined`) return null;
    return workspace;
  }

  getWorkspaceByIdent(ident) {
    const workspace = this.tryWorkspaceByIdent(ident);
    if (!workspace) throw new Error(`Workspace not found (${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyIdent(this.configuration, ident)})`);
    return workspace;
  }

  tryWorkspaceByDescriptor(descriptor) {
    const workspace = this.tryWorkspaceByIdent(descriptor);
    if (workspace === null || !workspace.accepts(descriptor.range)) return null;
    return workspace;
  }

  getWorkspaceByDescriptor(descriptor) {
    const workspace = this.tryWorkspaceByDescriptor(descriptor);
    if (workspace === null) throw new Error(`Workspace not found (${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyDescriptor(this.configuration, descriptor)})`);
    return workspace;
  }

  tryWorkspaceByLocator(locator) {
    if (_structUtils__WEBPACK_IMPORTED_MODULE_14__.isVirtualLocator(locator)) locator = _structUtils__WEBPACK_IMPORTED_MODULE_14__.devirtualizeLocator(locator);
    const workspace = this.tryWorkspaceByIdent(locator);
    if (workspace === null || workspace.locator.locatorHash !== locator.locatorHash && workspace.anchoredLocator.locatorHash !== locator.locatorHash) return null;
    return workspace;
  }

  getWorkspaceByLocator(locator) {
    const workspace = this.tryWorkspaceByLocator(locator);
    if (!workspace) throw new Error(`Workspace not found (${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, locator)})`);
    return workspace;
  }
  /**
   * Import the dependencies of each resolved workspace into their own
   * `Workspace` instance.
   */


  refreshWorkspaceDependencies() {
    for (const workspace of this.workspaces) {
      const pkg = this.storedPackages.get(workspace.anchoredLocator.locatorHash);
      if (!pkg) throw new Error(`Assertion failed: Expected workspace to have been resolved`);
      workspace.dependencies = new Map(pkg.dependencies);
    }
  }

  forgetResolution(dataStructure) {
    const deleteDescriptor = descriptorHash => {
      this.storedResolutions.delete(descriptorHash);
      this.storedDescriptors.delete(descriptorHash);
    };

    const deleteLocator = locatorHash => {
      this.originalPackages.delete(locatorHash);
      this.storedPackages.delete(locatorHash);
      this.accessibleLocators.delete(locatorHash);
    };

    if (`descriptorHash` in dataStructure) {
      const locatorHash = this.storedResolutions.get(dataStructure.descriptorHash);
      deleteDescriptor(dataStructure.descriptorHash); // We delete unused locators

      const remainingResolutions = new Set(this.storedResolutions.values());

      if (typeof locatorHash !== `undefined` && !remainingResolutions.has(locatorHash)) {
        deleteLocator(locatorHash);
      }
    }

    if (`locatorHash` in dataStructure) {
      deleteLocator(dataStructure.locatorHash); // We delete all of the descriptors that have been resolved to the locator

      for (const [descriptorHash, locatorHash] of this.storedResolutions) {
        if (locatorHash === dataStructure.locatorHash) {
          deleteDescriptor(descriptorHash);
        }
      }
    }
  }

  forgetTransientResolutions() {
    const resolver = this.configuration.makeResolver();

    for (const pkg of this.originalPackages.values()) {
      let shouldPersistResolution;

      try {
        shouldPersistResolution = resolver.shouldPersistResolution(pkg, {
          project: this,
          resolver
        });
      } catch (_a) {
        shouldPersistResolution = false;
      }

      if (!shouldPersistResolution) {
        this.forgetResolution(pkg);
      }
    }
  }

  forgetVirtualResolutions() {
    for (const pkg of this.storedPackages.values()) {
      for (const [dependencyHash, dependency] of pkg.dependencies) {
        if (_structUtils__WEBPACK_IMPORTED_MODULE_14__.isVirtualDescriptor(dependency)) {
          pkg.dependencies.set(dependencyHash, _structUtils__WEBPACK_IMPORTED_MODULE_14__.devirtualizeDescriptor(dependency));
        }
      }
    }
  }

  getDependencyMeta(ident, version) {
    const dependencyMeta = {};
    const dependenciesMeta = this.topLevelWorkspace.manifest.dependenciesMeta;
    const dependencyMetaSet = dependenciesMeta.get(_structUtils__WEBPACK_IMPORTED_MODULE_14__.stringifyIdent(ident));
    if (!dependencyMetaSet) return dependencyMeta;
    const defaultMeta = dependencyMetaSet.get(null);
    if (defaultMeta) Object.assign(dependencyMeta, defaultMeta);
    if (version === null || !semver__WEBPACK_IMPORTED_MODULE_6___default().valid(version)) return dependencyMeta;

    for (const [range, meta] of dependencyMetaSet) if (range !== null && range === version) Object.assign(dependencyMeta, meta);

    return dependencyMeta;
  }

  async findLocatorForLocation(cwd, {
    strict = false
  } = {}) {
    const report = new _ThrowReport__WEBPACK_IMPORTED_MODULE_19__.ThrowReport();
    const linkers = this.configuration.getLinkers();
    const linkerOptions = {
      project: this,
      report
    };

    for (const linker of linkers) {
      const locator = await linker.findPackageLocator(cwd, linkerOptions);

      if (locator) {
        // If strict mode, the specified cwd must be a package,
        // not merely contained in a package.
        if (strict) {
          const location = await linker.findPackageLocation(locator, linkerOptions);

          if (location.replace(TRAILING_SLASH_REGEXP, ``) !== cwd.replace(TRAILING_SLASH_REGEXP, ``)) {
            continue;
          }
        }

        return locator;
      }
    }

    return null;
  }

  async resolveEverything(opts) {
    if (!this.workspacesByCwd || !this.workspacesByIdent) throw new Error(`Workspaces must have been setup before calling this function`); // Reverts the changes that have been applied to the tree because of any previous virtual resolution pass

    this.forgetVirtualResolutions(); // Ensures that we notice it when dependencies are added / removed from all sources coming from the filesystem

    if (!opts.lockfileOnly) this.forgetTransientResolutions(); // Note that the resolution process is "offline" until everything has been
    // successfully resolved; all the processing is expected to have zero side
    // effects until we're ready to set all the variables at once (the one
    // exception being when a resolver needs to fetch a package, in which case
    // we might need to populate the cache).
    //
    // This makes it possible to use the same Project instance for multiple
    // purposes at the same time (since `resolveEverything` is async, it might
    // happen that we want to do something while waiting for it to end; if we
    // were to mutate the project then it would end up in a partial state that
    // could lead to hard-to-debug issues).

    const realResolver = opts.resolver || this.configuration.makeResolver();
    const legacyMigrationResolver = new _LegacyMigrationResolver__WEBPACK_IMPORTED_MODULE_20__.LegacyMigrationResolver();
    await legacyMigrationResolver.setup(this, {
      report: opts.report
    });
    const resolver = opts.lockfileOnly ? new _MultiResolver__WEBPACK_IMPORTED_MODULE_21__.MultiResolver([new _LockfileResolver__WEBPACK_IMPORTED_MODULE_22__.LockfileResolver(), new _RunInstallPleaseResolver__WEBPACK_IMPORTED_MODULE_23__.RunInstallPleaseResolver(realResolver)]) : new _MultiResolver__WEBPACK_IMPORTED_MODULE_21__.MultiResolver([new _LockfileResolver__WEBPACK_IMPORTED_MODULE_22__.LockfileResolver(), legacyMigrationResolver, realResolver]);
    const fetcher = this.configuration.makeFetcher();
    const resolveOptions = opts.lockfileOnly ? {
      project: this,
      report: opts.report,
      resolver
    } : {
      project: this,
      report: opts.report,
      resolver,
      fetchOptions: {
        project: this,
        cache: opts.cache,
        checksums: this.storedChecksums,
        report: opts.report,
        fetcher
      }
    };
    const allDescriptors = new Map();
    const allPackages = new Map();
    const allResolutions = new Map();
    const originalPackages = new Map();
    const packageResolutionPromises = new Map();
    const descriptorResolutionPromises = new Map();
    const resolutionQueue = [];

    const startPackageResolution = async locator => {
      const originalPkg = await _miscUtils__WEBPACK_IMPORTED_MODULE_15__.prettifyAsyncErrors(async () => {
        return await resolver.resolve(locator, resolveOptions);
      }, message => {
        return `${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, locator)}: ${message}`;
      });
      if (!_structUtils__WEBPACK_IMPORTED_MODULE_14__.areLocatorsEqual(locator, originalPkg)) throw new Error(`Assertion failed: The locator cannot be changed by the resolver (went from ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, locator)} to ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, originalPkg)})`);
      originalPackages.set(originalPkg.locatorHash, originalPkg);
      const pkg = this.configuration.normalizePackage(originalPkg);

      for (const [identHash, descriptor] of pkg.dependencies) {
        const dependency = await this.configuration.reduceHook(hooks => {
          return hooks.reduceDependency;
        }, descriptor, this, pkg, descriptor, {
          resolver,
          resolveOptions
        });
        if (!_structUtils__WEBPACK_IMPORTED_MODULE_14__.areIdentsEqual(descriptor, dependency)) throw new Error(`Assertion failed: The descriptor ident cannot be changed through aliases`);
        const bound = resolver.bindDescriptor(dependency, locator, resolveOptions);
        pkg.dependencies.set(identHash, bound);
      }

      resolutionQueue.push(Promise.all([...pkg.dependencies.values()].map(descriptor => {
        return scheduleDescriptorResolution(descriptor);
      })));
      allPackages.set(pkg.locatorHash, pkg);
      return pkg;
    };

    const schedulePackageResolution = async locator => {
      const promise = packageResolutionPromises.get(locator.locatorHash);
      if (typeof promise !== `undefined`) return promise;
      const newPromise = Promise.resolve().then(() => startPackageResolution(locator));
      packageResolutionPromises.set(locator.locatorHash, newPromise);
      return newPromise;
    };

    const startDescriptorAliasing = async (descriptor, alias) => {
      const resolution = await scheduleDescriptorResolution(alias);
      allDescriptors.set(descriptor.descriptorHash, descriptor);
      allResolutions.set(descriptor.descriptorHash, resolution.locatorHash);
      return resolution;
    };

    const startDescriptorResolution = async descriptor => {
      const alias = this.resolutionAliases.get(descriptor.descriptorHash);
      if (typeof alias !== `undefined`) return startDescriptorAliasing(descriptor, this.storedDescriptors.get(alias));
      const resolutionDependencies = resolver.getResolutionDependencies(descriptor, resolveOptions);
      const resolvedDependencies = new Map(await Promise.all(resolutionDependencies.map(async dependency => {
        return [dependency.descriptorHash, await scheduleDescriptorResolution(dependency)];
      })));
      const candidateResolutions = await _miscUtils__WEBPACK_IMPORTED_MODULE_15__.prettifyAsyncErrors(async () => {
        return await resolver.getCandidates(descriptor, resolvedDependencies, resolveOptions);
      }, message => {
        return `${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyDescriptor(this.configuration, descriptor)}: ${message}`;
      });
      const finalResolution = candidateResolutions[0];
      if (typeof finalResolution === `undefined`) throw new Error(`${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyDescriptor(this.configuration, descriptor)}: No candidates found`);
      allDescriptors.set(descriptor.descriptorHash, descriptor);
      allResolutions.set(descriptor.descriptorHash, finalResolution.locatorHash);
      return schedulePackageResolution(finalResolution);
    };

    const scheduleDescriptorResolution = descriptor => {
      const promise = descriptorResolutionPromises.get(descriptor.descriptorHash);
      if (typeof promise !== `undefined`) return promise;
      allDescriptors.set(descriptor.descriptorHash, descriptor);
      const newPromise = Promise.resolve().then(() => startDescriptorResolution(descriptor));
      descriptorResolutionPromises.set(descriptor.descriptorHash, newPromise);
      return newPromise;
    };

    for (const workspace of this.workspaces) {
      const workspaceDescriptor = workspace.anchoredDescriptor;
      resolutionQueue.push(scheduleDescriptorResolution(workspaceDescriptor));
    }

    while (resolutionQueue.length > 0) {
      const copy = [...resolutionQueue];
      resolutionQueue.length = 0;
      await Promise.all(copy);
    } // In this step we now create virtual packages for each package with at
    // least one peer dependency. We also use it to search for the alias
    // descriptors that aren't depended upon by anything and can be safely
    // pruned.


    const volatileDescriptors = new Set(this.resolutionAliases.values());
    const optionalBuilds = new Set(allPackages.keys());
    const accessibleLocators = new Set();
    applyVirtualResolutionMutations({
      project: this,
      report: opts.report,
      accessibleLocators,
      volatileDescriptors,
      optionalBuilds,
      allDescriptors,
      allResolutions,
      allPackages
    }); // All descriptors still referenced within the volatileDescriptors set are
    // descriptors that aren't depended upon by anything in the dependency tree.

    for (const descriptorHash of volatileDescriptors) {
      allDescriptors.delete(descriptorHash);
      allResolutions.delete(descriptorHash);
    } // Everything is done, we can now update our internal resolutions to
    // reference the new ones


    this.storedResolutions = allResolutions;
    this.storedDescriptors = allDescriptors;
    this.storedPackages = allPackages;
    this.accessibleLocators = accessibleLocators;
    this.originalPackages = originalPackages;
    this.optionalBuilds = optionalBuilds; // Now that the internal resolutions have been updated, we can refresh the
    // dependencies of each resolved workspace's `Workspace` instance.

    this.refreshWorkspaceDependencies();
  }

  async fetchEverything({
    cache,
    report,
    fetcher: userFetcher
  }) {
    const fetcher = userFetcher || this.configuration.makeFetcher();
    const fetcherOptions = {
      checksums: this.storedChecksums,
      project: this,
      cache,
      fetcher,
      report
    };
    const locatorHashes = Array.from(new Set(_miscUtils__WEBPACK_IMPORTED_MODULE_15__.sortMap(this.storedResolutions.values(), [locatorHash => {
      const pkg = this.storedPackages.get(locatorHash);
      if (!pkg) throw new Error(`Assertion failed: The locator should have been registered`);
      return _structUtils__WEBPACK_IMPORTED_MODULE_14__.stringifyLocator(pkg);
    }])));
    let firstError = false;
    const progress = _Report__WEBPACK_IMPORTED_MODULE_24__.Report.progressViaCounter(locatorHashes.length);
    report.reportProgress(progress);
    const limit = p_limit__WEBPACK_IMPORTED_MODULE_5___default()(FETCHER_CONCURRENCY);
    await report.startCacheReport(async () => {
      await Promise.all(locatorHashes.map(locatorHash => limit(async () => {
        const pkg = this.storedPackages.get(locatorHash);
        if (!pkg) throw new Error(`Assertion failed: The locator should have been registered`);
        if (_structUtils__WEBPACK_IMPORTED_MODULE_14__.isVirtualLocator(pkg)) return;
        let fetchResult;

        try {
          fetchResult = await fetcher.fetch(pkg, fetcherOptions);
        } catch (error) {
          error.message = `${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, pkg)}: ${error.message}`;
          report.reportExceptionOnce(error);
          firstError = error;
          return;
        }

        if (fetchResult.checksum) this.storedChecksums.set(pkg.locatorHash, fetchResult.checksum);else this.storedChecksums.delete(pkg.locatorHash);

        if (fetchResult.releaseFs) {
          fetchResult.releaseFs();
        }
      }).finally(() => {
        progress.tick();
      })));
    });

    if (firstError) {
      throw firstError;
    }
  }

  async linkEverything({
    cache,
    report,
    fetcher: optFetcher,
    skipBuild
  }) {
    var _a;

    const fetcher = optFetcher || this.configuration.makeFetcher();
    const fetcherOptions = {
      checksums: this.storedChecksums,
      project: this,
      cache,
      fetcher,
      report,
      skipIntegrityCheck: true
    };
    const linkers = this.configuration.getLinkers();
    const linkerOptions = {
      project: this,
      report
    };
    const installers = new Map(linkers.map(linker => {
      const installer = linker.makeInstaller(linkerOptions);
      const customDataKey = installer.getCustomDataKey();
      const customData = this.installersCustomData.get(customDataKey);
      if (typeof customData !== `undefined`) installer.attachCustomData(customData);
      return [linker, installer];
    }));
    const packageLinkers = new Map();
    const packageLocations = new Map();
    const packageBuildDirectives = new Map();
    const fetchResultsPerPackage = new Map(await Promise.all([...this.accessibleLocators].map(async locatorHash => {
      const pkg = this.storedPackages.get(locatorHash);
      if (!pkg) throw new Error(`Assertion failed: The locator should have been registered`);
      return [locatorHash, await fetcher.fetch(pkg, fetcherOptions)];
    }))); // Step 1: Installing the packages on the disk

    for (const locatorHash of this.accessibleLocators) {
      const pkg = this.storedPackages.get(locatorHash);
      if (typeof pkg === `undefined`) throw new Error(`Assertion failed: The locator should have been registered`);
      const fetchResult = fetchResultsPerPackage.get(pkg.locatorHash);
      if (typeof fetchResult === `undefined`) throw new Error(`Assertion failed: The fetch result should have been registered`);
      const workspace = this.tryWorkspaceByLocator(pkg);

      if (workspace !== null) {
        const buildScripts = [];
        const {
          scripts
        } = workspace.manifest;

        for (const scriptName of [`preinstall`, `install`, `postinstall`]) if (scripts.has(scriptName)) buildScripts.push([_Installer__WEBPACK_IMPORTED_MODULE_25__.BuildType.SCRIPT, scriptName]);

        try {
          for (const installer of installers.values()) {
            const result = await installer.installPackage(pkg, fetchResult);

            if (result.buildDirective !== null) {
              throw new Error(`Assertion failed: Linkers can't return build directives for workspaces; this responsibility befalls to the Yarn core`);
            }
          }
        } finally {
          if (fetchResult.releaseFs) {
            fetchResult.releaseFs();
          }
        }

        const location = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(fetchResult.packageFs.getRealPath(), fetchResult.prefixPath);
        packageLocations.set(pkg.locatorHash, location);

        if (buildScripts.length > 0) {
          packageBuildDirectives.set(pkg.locatorHash, {
            directives: buildScripts,
            buildLocations: [location]
          });
        }
      } else {
        const linker = linkers.find(linker => linker.supportsPackage(pkg, linkerOptions));
        if (!linker) throw new _Report__WEBPACK_IMPORTED_MODULE_24__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.LINKER_NOT_FOUND, `${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, pkg)} isn't supported by any available linker`);
        const installer = installers.get(linker);
        if (!installer) throw new Error(`Assertion failed: The installer should have been registered`);
        let installStatus;

        try {
          installStatus = await installer.installPackage(pkg, fetchResult);
        } finally {
          if (fetchResult.releaseFs) {
            fetchResult.releaseFs();
          }
        }

        packageLinkers.set(pkg.locatorHash, linker);
        packageLocations.set(pkg.locatorHash, installStatus.packageLocation);

        if (installStatus.buildDirective && installStatus.packageLocation) {
          packageBuildDirectives.set(pkg.locatorHash, {
            directives: installStatus.buildDirective,
            buildLocations: [installStatus.packageLocation]
          });
        }
      }
    } // Step 2: Link packages together


    const externalDependents = new Map();

    for (const locatorHash of this.accessibleLocators) {
      const pkg = this.storedPackages.get(locatorHash);
      if (!pkg) throw new Error(`Assertion failed: The locator should have been registered`);
      const isWorkspace = this.tryWorkspaceByLocator(pkg) !== null;

      const linkPackage = async (packageLinker, installer) => {
        const packageLocation = packageLocations.get(pkg.locatorHash);
        if (typeof packageLocation === `undefined`) throw new Error(`Assertion failed: The package (${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, pkg)}) should have been registered`);
        const internalDependencies = [];

        for (const descriptor of pkg.dependencies.values()) {
          const resolution = this.storedResolutions.get(descriptor.descriptorHash);
          if (typeof resolution === `undefined`) throw new Error(`Assertion failed: The resolution (${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyDescriptor(this.configuration, descriptor)}, from ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, pkg)})should have been registered`);
          const dependency = this.storedPackages.get(resolution);
          if (typeof dependency === `undefined`) throw new Error(`Assertion failed: The package (${resolution}, resolved from ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
          const dependencyLinker = this.tryWorkspaceByLocator(dependency) === null ? packageLinkers.get(resolution) : null;
          if (typeof dependencyLinker === `undefined`) throw new Error(`Assertion failed: The package (${resolution}, resolved from ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
          const isWorkspaceDependency = dependencyLinker === null;

          if (dependencyLinker === packageLinker || isWorkspace || isWorkspaceDependency) {
            if (packageLocations.get(dependency.locatorHash) !== null) {
              internalDependencies.push([descriptor, dependency]);
            }
          } else if (packageLocation !== null) {
            const externalEntry = _miscUtils__WEBPACK_IMPORTED_MODULE_15__.getArrayWithDefault(externalDependents, resolution);
            externalEntry.push(packageLocation);
          }
        }

        if (packageLocation !== null) {
          await installer.attachInternalDependencies(pkg, internalDependencies);
        }
      };

      if (isWorkspace) {
        for (const [packageLinker, installer] of installers) {
          await linkPackage(packageLinker, installer);
        }
      } else {
        const packageLinker = packageLinkers.get(pkg.locatorHash);
        if (!packageLinker) throw new Error(`Assertion failed: The linker should have been found`);
        const installer = installers.get(packageLinker);
        if (!installer) throw new Error(`Assertion failed: The installer should have been registered`);
        await linkPackage(packageLinker, installer);
      }
    }

    for (const [locatorHash, dependentPaths] of externalDependents) {
      const pkg = this.storedPackages.get(locatorHash);
      if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
      const packageLinker = packageLinkers.get(pkg.locatorHash);
      if (!packageLinker) throw new Error(`Assertion failed: The linker should have been found`);
      const installer = installers.get(packageLinker);
      if (!installer) throw new Error(`Assertion failed: The installer should have been registered`);
      await installer.attachExternalDependents(pkg, dependentPaths);
    } // Step 3: Inform our linkers that they should have all the info needed


    const installersCustomData = new Map();

    for (const installer of installers.values()) {
      const finalizeInstallData = await installer.finalizeInstall();

      for (const installStatus of (_a = finalizeInstallData === null || finalizeInstallData === void 0 ? void 0 : finalizeInstallData.records) !== null && _a !== void 0 ? _a : []) {
        packageBuildDirectives.set(installStatus.locatorHash, {
          directives: installStatus.buildDirective,
          buildLocations: installStatus.buildLocations
        });
      }

      if (typeof (finalizeInstallData === null || finalizeInstallData === void 0 ? void 0 : finalizeInstallData.customData) !== `undefined`) {
        installersCustomData.set(installer.getCustomDataKey(), finalizeInstallData.customData);
      }
    }

    this.installersCustomData = installersCustomData;
    await this.persistInstallStateFile(); // Step 4: Build the packages in multiple steps

    if (skipBuild) return;
    const readyPackages = new Set(this.storedPackages.keys());
    const buildablePackages = new Set(packageBuildDirectives.keys());

    for (const locatorHash of buildablePackages) readyPackages.delete(locatorHash);

    const globalHashGenerator = (0,crypto__WEBPACK_IMPORTED_MODULE_2__.createHash)(`sha512`);
    globalHashGenerator.update(process.versions.node);
    this.configuration.triggerHook(hooks => {
      return hooks.globalHashGeneration;
    }, this, data => {
      globalHashGenerator.update(`\0`);
      globalHashGenerator.update(data);
    });
    const globalHash = globalHashGenerator.digest(`hex`);
    const packageHashMap = new Map(); // We'll use this function is order to compute a hash for each package
    // that exposes a build directive. If the hash changes compared to the
    // previous run, the package is rebuilt. This has the advantage of making
    // the rebuilds much more predictable than before, and to give us the tools
    // later to improve this further by explaining *why* a rebuild happened.

    const getBaseHash = locator => {
      let hash = packageHashMap.get(locator.locatorHash);
      if (typeof hash !== `undefined`) return hash;
      const pkg = this.storedPackages.get(locator.locatorHash);
      if (typeof pkg === `undefined`) throw new Error(`Assertion failed: The package should have been registered`);
      const builder = (0,crypto__WEBPACK_IMPORTED_MODULE_2__.createHash)(`sha512`);
      builder.update(locator.locatorHash); // To avoid the case where one dependency depends on itself somehow

      packageHashMap.set(locator.locatorHash, `<recursive>`);

      for (const descriptor of pkg.dependencies.values()) {
        const resolution = this.storedResolutions.get(descriptor.descriptorHash);
        if (typeof resolution === `undefined`) throw new Error(`Assertion failed: The resolution (${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
        const dependency = this.storedPackages.get(resolution);
        if (typeof dependency === `undefined`) throw new Error(`Assertion failed: The package should have been registered`);
        builder.update(getBaseHash(dependency));
      }

      hash = builder.digest(`hex`);
      packageHashMap.set(locator.locatorHash, hash);
      return hash;
    };

    const getBuildHash = (locator, buildLocations) => {
      const builder = (0,crypto__WEBPACK_IMPORTED_MODULE_2__.createHash)(`sha512`);
      builder.update(globalHash);
      builder.update(getBaseHash(locator));

      for (const location of buildLocations) builder.update(location);

      return builder.digest(`hex`);
    };

    const bstatePath = this.configuration.get(`bstatePath`);
    const bstate = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsSync(bstatePath) ? (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseSyml)(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readFilePromise(bstatePath, `utf8`)) : {}; // We reconstruct the build state from an empty object because we want to
    // remove the state from packages that got removed

    const nextBState = new Map();

    while (buildablePackages.size > 0) {
      const savedSize = buildablePackages.size;
      const buildPromises = [];

      for (const locatorHash of buildablePackages) {
        const pkg = this.storedPackages.get(locatorHash);
        if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
        let isBuildable = true;

        for (const dependency of pkg.dependencies.values()) {
          const resolution = this.storedResolutions.get(dependency.descriptorHash);
          if (!resolution) throw new Error(`Assertion failed: The resolution (${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyDescriptor(this.configuration, dependency)}) should have been registered`);

          if (buildablePackages.has(resolution)) {
            isBuildable = false;
            break;
          }
        } // Wait until all dependencies of the current package have been built
        // before trying to build it (since it might need them to build itself)


        if (!isBuildable) continue;
        buildablePackages.delete(locatorHash);
        const buildInfo = packageBuildDirectives.get(pkg.locatorHash);
        if (!buildInfo) throw new Error(`Assertion failed: The build directive should have been registered`);
        const buildHash = getBuildHash(pkg, buildInfo.buildLocations); // No need to rebuild the package if its hash didn't change

        if (Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash) && bstate[pkg.locatorHash] === buildHash) {
          nextBState.set(pkg.locatorHash, buildHash);
          continue;
        }

        if (Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash)) report.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.MUST_REBUILD, `${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, pkg)} must be rebuilt because its dependency tree changed`);else report.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.MUST_BUILD, `${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, pkg)} must be built because it never did before or the last one failed`);

        for (const location of buildInfo.buildLocations) {
          if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.isAbsolute(location)) throw new Error(`Assertion failed: Expected the build location to be absolute (not ${location})`);
          buildPromises.push((async () => {
            for (const [buildType, scriptName] of buildInfo.directives) {
              let header = `# This file contains the result of Yarn building a package (${_structUtils__WEBPACK_IMPORTED_MODULE_14__.stringifyLocator(pkg)})\n`;

              switch (buildType) {
                case _Installer__WEBPACK_IMPORTED_MODULE_25__.BuildType.SCRIPT:
                  {
                    header += `# Script name: ${scriptName}\n`;
                  }
                  break;

                case _Installer__WEBPACK_IMPORTED_MODULE_25__.BuildType.SHELLCODE:
                  {
                    header += `# Script code: ${scriptName}\n`;
                  }
                  break;
              }

              const stdin = null;
              await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.mktempPromise(async logDir => {
                const logFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(logDir, `build.log`);
                const {
                  stdout,
                  stderr
                } = this.configuration.getSubprocessStreams(logFile, {
                  header,
                  prefix: _structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, pkg),
                  report
                });
                let exitCode;

                try {
                  switch (buildType) {
                    case _Installer__WEBPACK_IMPORTED_MODULE_25__.BuildType.SCRIPT:
                      {
                        exitCode = await _scriptUtils__WEBPACK_IMPORTED_MODULE_27__.executePackageScript(pkg, scriptName, [], {
                          cwd: location,
                          project: this,
                          stdin,
                          stdout,
                          stderr
                        });
                      }
                      break;

                    case _Installer__WEBPACK_IMPORTED_MODULE_25__.BuildType.SHELLCODE:
                      {
                        exitCode = await _scriptUtils__WEBPACK_IMPORTED_MODULE_27__.executePackageShellcode(pkg, scriptName, [], {
                          cwd: location,
                          project: this,
                          stdin,
                          stdout,
                          stderr
                        });
                      }
                      break;
                  }
                } catch (error) {
                  stderr.write(error.stack);
                  exitCode = 1;
                }

                stdout.end();
                stderr.end();

                if (exitCode === 0) {
                  nextBState.set(pkg.locatorHash, buildHash);
                  return true;
                }

                _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.detachTemp(logDir);
                const buildMessage = `${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, pkg)} couldn't be built successfully (exit code ${_formatUtils__WEBPACK_IMPORTED_MODULE_13__.pretty(this.configuration, exitCode, _formatUtils__WEBPACK_IMPORTED_MODULE_13__.Type.NUMBER)}, logs can be found here: ${_formatUtils__WEBPACK_IMPORTED_MODULE_13__.pretty(this.configuration, logFile, _formatUtils__WEBPACK_IMPORTED_MODULE_13__.Type.PATH)})`;
                report.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.BUILD_FAILED, buildMessage);

                if (this.optionalBuilds.has(pkg.locatorHash)) {
                  nextBState.set(pkg.locatorHash, buildHash);
                  return true;
                }

                report.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.BUILD_FAILED, buildMessage);
                return false;
              });
            }
          })());
        }
      }

      await Promise.all(buildPromises); // If we reach this code, it means that we have circular dependencies
      // somewhere. Worst, it means that the circular dependencies both have
      // build scripts, making them unsatisfiable.

      if (savedSize === buildablePackages.size) {
        const prettyLocators = Array.from(buildablePackages).map(locatorHash => {
          const pkg = this.storedPackages.get(locatorHash);
          if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
          return _structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(this.configuration, pkg);
        }).join(`, `);
        report.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.CYCLIC_DEPENDENCIES, `Some packages have circular dependencies that make their build order unsatisfiable - as a result they won't be built (affected packages are: ${prettyLocators})`);
        break;
      }
    } // We can now generate the bstate file, which will allow us to "remember"
    // what's the dependency tree subset that we used to build a specific
    // package (and avoid rebuilding it later if it didn't change).


    if (nextBState.size > 0) {
      const bstatePath = this.configuration.get(`bstatePath`);
      const bstateFile = Project.generateBuildStateFile(nextBState, this.storedPackages);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.dirname(bstatePath), {
        recursive: true
      });
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.changeFilePromise(bstatePath, bstateFile, {
        automaticNewlines: true
      });
    } else {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.removePromise(bstatePath);
    }
  }

  async install(opts) {
    var _a, _b;

    const nodeLinker = this.configuration.get(`nodeLinker`);
    (_a = _Configuration__WEBPACK_IMPORTED_MODULE_12__.Configuration.telemetry) === null || _a === void 0 ? void 0 : _a.reportInstall(nodeLinker);
    await opts.report.startTimerPromise(`Project validation`, {
      skipIfEmpty: true
    }, async () => {
      await this.configuration.triggerHook(hooks => {
        return hooks.validateProject;
      }, this, {
        reportWarning: opts.report.reportWarning.bind(opts.report),
        reportError: opts.report.reportError.bind(opts.report)
      });
    });

    for (const extensionsByIdent of this.configuration.packageExtensions.values()) for (const [, extensionsByRange] of extensionsByIdent) for (const extension of extensionsByRange) extension.status = _types__WEBPACK_IMPORTED_MODULE_28__.PackageExtensionStatus.Inactive;

    const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(this.cwd, this.configuration.get(`lockfileFilename`)); // If we operate with a frozen lockfile, we take a snapshot of it to later make sure it didn't change

    let initialLockfile = null;

    if (opts.immutable) {
      try {
        initialLockfile = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readFilePromise(lockfilePath, `utf8`);
      } catch (error) {
        if (error.code === `ENOENT`) {
          throw new _Report__WEBPACK_IMPORTED_MODULE_24__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.FROZEN_LOCKFILE_EXCEPTION, `The lockfile would have been created by this install, which is explicitly forbidden.`);
        } else {
          throw error;
        }
      }
    }

    await opts.report.startTimerPromise(`Resolution step`, async () => {
      await this.resolveEverything(opts);
    });
    await opts.report.startTimerPromise(`Post-resolution validation`, {
      skipIfEmpty: true
    }, async () => {
      for (const [, extensionsPerRange] of this.configuration.packageExtensions) {
        for (const [, extensions] of extensionsPerRange) {
          for (const extension of extensions) {
            if (extension.userProvided) {
              const prettyPackageExtension = _formatUtils__WEBPACK_IMPORTED_MODULE_13__.pretty(this.configuration, extension, _formatUtils__WEBPACK_IMPORTED_MODULE_13__.Type.PACKAGE_EXTENSION);

              switch (extension.status) {
                case _types__WEBPACK_IMPORTED_MODULE_28__.PackageExtensionStatus.Inactive:
                  {
                    opts.report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.UNUSED_PACKAGE_EXTENSION, `${prettyPackageExtension}: No matching package in the dependency tree; you may not need this rule anymore.`);
                  }
                  break;

                case _types__WEBPACK_IMPORTED_MODULE_28__.PackageExtensionStatus.Redundant:
                  {
                    opts.report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.REDUNDANT_PACKAGE_EXTENSION, `${prettyPackageExtension}: This rule seems redundant when applied on the original package; the extension may have been applied upstream.`);
                  }
                  break;
              }
            }
          }
        }
      }

      if (initialLockfile !== null) {
        const newLockfile = (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_29__.normalizeLineEndings)(initialLockfile, this.generateLockfile());

        if (newLockfile !== initialLockfile) {
          const diff = (0,diff__WEBPACK_IMPORTED_MODULE_3__.structuredPatch)(lockfilePath, lockfilePath, initialLockfile, newLockfile);
          opts.report.reportSeparator();

          for (const hunk of diff.hunks) {
            opts.report.reportInfo(null, `@@ -${hunk.oldStart},${hunk.oldLines} +${hunk.newStart},${hunk.newLines} @@`);

            for (const line of hunk.lines) {
              if (line.startsWith(`+`)) {
                opts.report.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.FROZEN_LOCKFILE_EXCEPTION, _formatUtils__WEBPACK_IMPORTED_MODULE_13__.pretty(this.configuration, line, _formatUtils__WEBPACK_IMPORTED_MODULE_13__.Type.ADDED));
              } else if (line.startsWith(`-`)) {
                opts.report.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.FROZEN_LOCKFILE_EXCEPTION, _formatUtils__WEBPACK_IMPORTED_MODULE_13__.pretty(this.configuration, line, _formatUtils__WEBPACK_IMPORTED_MODULE_13__.Type.REMOVED));
              } else {
                opts.report.reportInfo(null, _formatUtils__WEBPACK_IMPORTED_MODULE_13__.pretty(this.configuration, line, `grey`));
              }
            }
          }

          opts.report.reportSeparator();
          throw new _Report__WEBPACK_IMPORTED_MODULE_24__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.FROZEN_LOCKFILE_EXCEPTION, `The lockfile would have been modified by this install, which is explicitly forbidden.`);
        }
      }
    });

    for (const extensionsByIdent of this.configuration.packageExtensions.values()) for (const [, extensionsByRange] of extensionsByIdent) for (const extension of extensionsByRange) if (extension.userProvided && extension.status === _types__WEBPACK_IMPORTED_MODULE_28__.PackageExtensionStatus.Active) (_b = _Configuration__WEBPACK_IMPORTED_MODULE_12__.Configuration.telemetry) === null || _b === void 0 ? void 0 : _b.reportPackageExtension(_formatUtils__WEBPACK_IMPORTED_MODULE_13__.json(extension, _formatUtils__WEBPACK_IMPORTED_MODULE_13__.Type.PACKAGE_EXTENSION));

    await opts.report.startTimerPromise(`Fetch step`, async () => {
      await this.fetchEverything(opts);

      if (typeof opts.persistProject === `undefined` || opts.persistProject) {
        await this.cacheCleanup(opts);
      }
    });
    if (typeof opts.persistProject === `undefined` || opts.persistProject) await this.persist();
    await opts.report.startTimerPromise(`Link step`, async () => {
      const immutablePatterns = opts.immutable ? [...new Set(this.configuration.get(`immutablePatterns`))].sort() : [];
      const before = await Promise.all(immutablePatterns.map(async pattern => {
        return _hashUtils__WEBPACK_IMPORTED_MODULE_16__.checksumPattern(pattern, {
          cwd: this.cwd
        });
      }));
      await this.linkEverything(opts);
      const after = await Promise.all(immutablePatterns.map(async pattern => {
        return _hashUtils__WEBPACK_IMPORTED_MODULE_16__.checksumPattern(pattern, {
          cwd: this.cwd
        });
      }));

      for (let t = 0; t < immutablePatterns.length; ++t) {
        if (before[t] !== after[t]) {
          opts.report.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.FROZEN_ARTIFACT_EXCEPTION, `The checksum for ${immutablePatterns[t]} has been modified by this install, which is explicitly forbidden.`);
        }
      }
    });
    await this.persistInstallStateFile();
    await this.configuration.triggerHook(hooks => {
      return hooks.afterAllInstalled;
    }, this, opts);
  }

  generateLockfile() {
    // We generate the data structure that will represent our lockfile. To do this, we create a
    // reverse lookup table, where the key will be the resolved locator and the value will be a set
    // of all the descriptors that resolved to it. Then we use it to construct an optimized version
    // if the final object.
    const reverseLookup = new Map();

    for (const [descriptorHash, locatorHash] of this.storedResolutions.entries()) {
      let descriptorHashes = reverseLookup.get(locatorHash);
      if (!descriptorHashes) reverseLookup.set(locatorHash, descriptorHashes = new Set());
      descriptorHashes.add(descriptorHash);
    }

    const optimizedLockfile = {};
    optimizedLockfile.__metadata = {
      version: LOCKFILE_VERSION
    };

    for (const [locatorHash, descriptorHashes] of reverseLookup.entries()) {
      const pkg = this.originalPackages.get(locatorHash); // A resolution that isn't in `originalPackages` is a virtual packages.
      // Since virtual packages can be derived from the information stored in
      // the rest of the lockfile we don't want to bother storing them.

      if (!pkg) continue;
      const descriptors = [];

      for (const descriptorHash of descriptorHashes) {
        const descriptor = this.storedDescriptors.get(descriptorHash);
        if (!descriptor) throw new Error(`Assertion failed: The descriptor should have been registered`);
        descriptors.push(descriptor);
      }

      const key = descriptors.map(descriptor => {
        return _structUtils__WEBPACK_IMPORTED_MODULE_14__.stringifyDescriptor(descriptor);
      }).sort().join(`, `);
      const manifest = new _Manifest__WEBPACK_IMPORTED_MODULE_17__.Manifest();
      manifest.version = pkg.linkType === _types__WEBPACK_IMPORTED_MODULE_28__.LinkType.HARD ? pkg.version : `0.0.0-use.local`;
      manifest.languageName = pkg.languageName;
      manifest.dependencies = new Map(pkg.dependencies);
      manifest.peerDependencies = new Map(pkg.peerDependencies);
      manifest.dependenciesMeta = new Map(pkg.dependenciesMeta);
      manifest.peerDependenciesMeta = new Map(pkg.peerDependenciesMeta);
      manifest.bin = new Map(pkg.bin);
      let entryChecksum;
      const checksum = this.storedChecksums.get(pkg.locatorHash);

      if (typeof checksum !== `undefined`) {
        const cacheKeyIndex = checksum.indexOf(`/`);
        if (cacheKeyIndex === -1) throw new Error(`Assertion failed: Expecte the checksum to reference its cache key`);
        const cacheKey = checksum.slice(0, cacheKeyIndex);
        const hash = checksum.slice(cacheKeyIndex + 1);
        if (typeof optimizedLockfile.__metadata.cacheKey === `undefined`) optimizedLockfile.__metadata.cacheKey = cacheKey;

        if (cacheKey === optimizedLockfile.__metadata.cacheKey) {
          entryChecksum = hash;
        } else {
          entryChecksum = checksum;
        }
      }

      optimizedLockfile[key] = { ...manifest.exportTo({}, {
          compatibilityMode: false
        }),
        linkType: pkg.linkType.toLowerCase(),
        resolution: _structUtils__WEBPACK_IMPORTED_MODULE_14__.stringifyLocator(pkg),
        checksum: entryChecksum
      };
    }

    const header = `${[`# This file is generated by running "yarn install" inside your project.\n`, `# Manual changes might be lost - proceed with caution!\n`].join(``)}\n`;
    return header + (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.stringifySyml)(optimizedLockfile);
  }

  async persistLockfile() {
    const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(this.cwd, this.configuration.get(`lockfileFilename`));
    const lockfileContent = this.generateLockfile();
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.changeFilePromise(lockfilePath, lockfileContent, {
      automaticNewlines: true
    });
  }

  async persistInstallStateFile() {
    const fields = [];

    for (const category of Object.values(INSTALL_STATE_FIELDS)) fields.push(...category);

    const installState = lodash_pick__WEBPACK_IMPORTED_MODULE_4___default()(this, fields);
    const serializedState = await gzip(v8__WEBPACK_IMPORTED_MODULE_8___default().serialize(installState));
    const installStatePath = this.configuration.get(`installStatePath`);
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.dirname(installStatePath), {
      recursive: true
    });
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.changeFilePromise(installStatePath, serializedState);
  }

  async restoreInstallState({
    restoreInstallersCustomData = true,
    restoreResolutions = true
  } = {}) {
    const installStatePath = this.configuration.get(`installStatePath`);

    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsSync(installStatePath)) {
      if (restoreResolutions) await this.applyLightResolution();
      return;
    }

    const serializedState = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readFilePromise(installStatePath);
    const installState = v8__WEBPACK_IMPORTED_MODULE_8___default().deserialize(await gunzip(serializedState));
    if (restoreInstallersCustomData) if (typeof installState.installersCustomData !== `undefined`) this.installersCustomData = installState.installersCustomData;

    if (restoreResolutions) {
      if (installState.lockFileChecksum === this.lockFileChecksum) {
        Object.assign(this, lodash_pick__WEBPACK_IMPORTED_MODULE_4___default()(installState, INSTALL_STATE_FIELDS.restoreResolutions));
        this.refreshWorkspaceDependencies();
      } else {
        await this.applyLightResolution();
      }
    }
  }

  async applyLightResolution() {
    await this.resolveEverything({
      lockfileOnly: true,
      report: new _ThrowReport__WEBPACK_IMPORTED_MODULE_19__.ThrowReport()
    });
    await this.persistInstallStateFile();
  }

  async persist() {
    await this.persistLockfile();

    for (const workspace of this.workspacesByCwd.values()) {
      await workspace.persistManifest();
    }
  }

  async cacheCleanup({
    cache,
    report
  }) {
    const PRESERVED_FILES = new Set([`.gitignore`]);
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsSync(cache.cwd)) return;
    if (!(0,_folderUtils__WEBPACK_IMPORTED_MODULE_30__.isFolderInside)(cache.cwd, this.cwd)) return;

    for (const entry of await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readdirPromise(cache.cwd)) {
      if (PRESERVED_FILES.has(entry)) continue;
      const entryPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(cache.cwd, entry);
      if (cache.markedFiles.has(entryPath)) continue;

      if (cache.immutable) {
        report.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.IMMUTABLE_CACHE, `${_formatUtils__WEBPACK_IMPORTED_MODULE_13__.pretty(this.configuration, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.basename(entryPath), `magenta`)} appears to be unused and would marked for deletion, but the cache is immutable`);
      } else {
        report.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.UNUSED_CACHE_ENTRY, `${_formatUtils__WEBPACK_IMPORTED_MODULE_13__.pretty(this.configuration, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.basename(entryPath), `magenta`)} appears to be unused - removing`);
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.removePromise(entryPath);
      }
    }

    cache.markedFiles.clear();
  }

}
/**
 * This function is worth some documentation. It takes a set of packages,
 * traverses them all, and generates virtual packages for each package that
 * lists peer dependencies.
 *
 * We also take advantage of the tree traversal to detect which packages are
 * actually used and which have disappeared, and to know which packages truly
 * have an optional build (since a package may be optional in one part of the
 * tree but not another).
 */

function applyVirtualResolutionMutations({
  project,
  allDescriptors,
  allResolutions,
  allPackages,
  accessibleLocators = new Set(),
  optionalBuilds = new Set(),
  volatileDescriptors = new Set(),
  report,
  tolerateMissingPackages = false
}) {
  const virtualStack = new Map();
  const resolutionStack = []; // We'll be keeping track of all virtual descriptors; once they have all
  // been generated we'll check whether they can be consolidated into one.

  const allVirtualInstances = new Map();
  const allVirtualDependents = new Map(); // We must keep a copy of the workspaces original dependencies, because they
  // may be overriden during the virtual package resolution - cf Dragon Test #5

  const originalWorkspaceDefinitions = new Map(project.workspaces.map(workspace => {
    const locatorHash = workspace.anchoredLocator.locatorHash;
    const pkg = allPackages.get(locatorHash);

    if (typeof pkg === `undefined`) {
      if (tolerateMissingPackages) {
        return [locatorHash, null];
      } else {
        throw new Error(`Assertion failed: The workspace should have an associated package`);
      }
    }

    return [locatorHash, _structUtils__WEBPACK_IMPORTED_MODULE_14__.copyPackage(pkg)];
  }));

  const reportStackOverflow = () => {
    const logDir = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.mktempSync();
    const logFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(logDir, `stacktrace.log`);
    const maxSize = String(resolutionStack.length + 1).length;
    const content = resolutionStack.map((locator, index) => {
      const prefix = `${index + 1}.`.padStart(maxSize, ` `);
      return `${prefix} ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.stringifyLocator(locator)}\n`;
    }).join(``);
    _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.writeFileSync(logFile, content);
    throw new _Report__WEBPACK_IMPORTED_MODULE_24__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.STACK_OVERFLOW_RESOLUTION, `Encountered a stack overflow when resolving peer dependencies; cf ${logFile}`);
  };

  const getPackageFromDescriptor = descriptor => {
    const resolution = allResolutions.get(descriptor.descriptorHash);
    if (typeof resolution === `undefined`) throw new Error(`Assertion failed: The resolution should have been registered`);
    const pkg = allPackages.get(resolution);
    if (!pkg) throw new Error(`Assertion failed: The package could not be found`);
    return pkg;
  };

  const resolvePeerDependencies = (parentLocator, first, optional) => {
    if (resolutionStack.length > 1000) reportStackOverflow();
    resolutionStack.push(parentLocator);
    const result = resolvePeerDependenciesImpl(parentLocator, first, optional);
    resolutionStack.pop();
    return result;
  };

  const resolvePeerDependenciesImpl = (parentLocator, first, optional) => {
    if (accessibleLocators.has(parentLocator.locatorHash)) return;
    accessibleLocators.add(parentLocator.locatorHash);
    if (!optional) optionalBuilds.delete(parentLocator.locatorHash);
    const parentPackage = allPackages.get(parentLocator.locatorHash);

    if (!parentPackage) {
      if (tolerateMissingPackages) {
        return;
      } else {
        throw new Error(`Assertion failed: The package (${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(project.configuration, parentLocator)}) should have been registered`);
      }
    }

    const newVirtualInstances = [];
    const firstPass = [];
    const secondPass = [];
    const thirdPass = [];
    const fourthPass = []; // During this first pass we virtualize the descriptors. This allows us
    // to reference them from their sibling without being order-dependent,
    // which is required to solve cases where packages with peer dependencies
    // have peer dependencies themselves.

    for (const descriptor of Array.from(parentPackage.dependencies.values())) {
      // We shouldn't virtualize the package if it was obtained through a peer
      // dependency (which can't be the case for workspaces when resolved
      // through their top-level)
      if (parentPackage.peerDependencies.has(descriptor.identHash) && !first) continue; // We had some issues where virtual packages were incorrectly set inside
      // workspaces, causing leaks. Check the Dragon Test #5 for more details.

      if (_structUtils__WEBPACK_IMPORTED_MODULE_14__.isVirtualDescriptor(descriptor)) throw new Error(`Assertion failed: Virtual packages shouldn't be encountered when virtualizing a branch`); // Mark this package as being used (won't be removed from the lockfile)

      volatileDescriptors.delete(descriptor.descriptorHash); // Detect whether this package is being required

      let isOptional = optional;

      if (!isOptional) {
        const dependencyMetaSet = parentPackage.dependenciesMeta.get(_structUtils__WEBPACK_IMPORTED_MODULE_14__.stringifyIdent(descriptor));

        if (typeof dependencyMetaSet !== `undefined`) {
          const dependencyMeta = dependencyMetaSet.get(null);

          if (typeof dependencyMeta !== `undefined` && dependencyMeta.optional) {
            isOptional = true;
          }
        }
      }

      const resolution = allResolutions.get(descriptor.descriptorHash);

      if (!resolution) {
        // Note that we can't use `getPackageFromDescriptor` (defined below,
        // because when doing the initial tree building right after loading the
        // project it's possible that we get some entries that haven't been
        // registered into the lockfile yet - for example when the user has
        // manually changed the package.json dependencies)
        if (tolerateMissingPackages) {
          continue;
        } else {
          throw new Error(`Assertion failed: The resolution (${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyDescriptor(project.configuration, descriptor)}) should have been registered`);
        }
      }

      const pkg = originalWorkspaceDefinitions.get(resolution) || allPackages.get(resolution);
      if (!pkg) throw new Error(`Assertion failed: The package (${resolution}, resolved from ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyDescriptor(project.configuration, descriptor)}) should have been registered`);

      if (pkg.peerDependencies.size === 0) {
        resolvePeerDependencies(pkg, false, isOptional);
        continue;
      } // The stack overflow is checked against two level because a workspace
      // may have a dev dependency on another workspace that lists the first
      // one as a regular dependency. In this case the loop will break so we
      // don't need to throw an exception.


      const stackDepth = virtualStack.get(pkg.locatorHash);
      if (typeof stackDepth === `number` && stackDepth >= 2) reportStackOverflow();
      let virtualizedDescriptor;
      let virtualizedPackage;
      const missingPeerDependencies = new Set();
      firstPass.push(() => {
        virtualizedDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_14__.virtualizeDescriptor(descriptor, parentLocator.locatorHash);
        virtualizedPackage = _structUtils__WEBPACK_IMPORTED_MODULE_14__.virtualizePackage(pkg, parentLocator.locatorHash);
        parentPackage.dependencies.delete(descriptor.identHash);
        parentPackage.dependencies.set(virtualizedDescriptor.identHash, virtualizedDescriptor);
        allResolutions.set(virtualizedDescriptor.descriptorHash, virtualizedPackage.locatorHash);
        allDescriptors.set(virtualizedDescriptor.descriptorHash, virtualizedDescriptor);
        allPackages.set(virtualizedPackage.locatorHash, virtualizedPackage); // Keep track of all new virtual packages since we'll want to dedupe them

        newVirtualInstances.push([pkg, virtualizedDescriptor, virtualizedPackage]);
      });
      secondPass.push(() => {
        for (const peerRequest of virtualizedPackage.peerDependencies.values()) {
          let peerDescriptor = parentPackage.dependencies.get(peerRequest.identHash);

          if (!peerDescriptor && _structUtils__WEBPACK_IMPORTED_MODULE_14__.areIdentsEqual(parentLocator, peerRequest)) {
            peerDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_14__.convertLocatorToDescriptor(parentLocator);
            allDescriptors.set(peerDescriptor.descriptorHash, peerDescriptor);
            allResolutions.set(peerDescriptor.descriptorHash, parentLocator.locatorHash);
            volatileDescriptors.delete(peerDescriptor.descriptorHash);
          }

          if (!peerDescriptor && virtualizedPackage.dependencies.has(peerRequest.identHash)) {
            virtualizedPackage.peerDependencies.delete(peerRequest.identHash);
            continue;
          }

          if (!peerDescriptor) {
            if (!parentPackage.peerDependencies.has(peerRequest.identHash)) {
              const peerDependencyMeta = virtualizedPackage.peerDependenciesMeta.get(_structUtils__WEBPACK_IMPORTED_MODULE_14__.stringifyIdent(peerRequest));

              if (report !== null && (!peerDependencyMeta || !peerDependencyMeta.optional)) {
                report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.MISSING_PEER_DEPENDENCY, `${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(project.configuration, parentLocator)} doesn't provide ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyDescriptor(project.configuration, peerRequest)} requested by ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(project.configuration, pkg)}`);
              }
            }

            peerDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_14__.makeDescriptor(peerRequest, `missing:`);
          }

          virtualizedPackage.dependencies.set(peerDescriptor.identHash, peerDescriptor); // Need to track when a virtual descriptor is set as a dependency in case
          // the descriptor will be consolidated.

          if (_structUtils__WEBPACK_IMPORTED_MODULE_14__.isVirtualDescriptor(peerDescriptor)) {
            const dependents = _miscUtils__WEBPACK_IMPORTED_MODULE_15__.getSetWithDefault(allVirtualDependents, peerDescriptor.descriptorHash);
            dependents.add(virtualizedPackage.locatorHash);
          }

          if (peerDescriptor.range === `missing:`) {
            missingPeerDependencies.add(peerDescriptor.identHash);
          } else if (report !== null) {
            // When the parent provides the peer dependency request it must be checked to ensure
            // it is a compatible version.
            const peerPackage = getPackageFromDescriptor(peerDescriptor);

            if (!_semverUtils__WEBPACK_IMPORTED_MODULE_31__.satisfiesWithPrereleases(peerPackage.version, peerRequest.range)) {
              report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_26__.MessageName.INCOMPATIBLE_PEER_DEPENDENCY, `${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(project.configuration, parentLocator)} provides ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(project.configuration, peerPackage)} with version ${peerPackage.version} which doesn't satisfy ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyRange(project.configuration, peerRequest.range)} requested by ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyLocator(project.configuration, pkg)}`);
            }
          }
        } // Since we've had to add new dependencies we need to sort them all over again


        virtualizedPackage.dependencies = new Map(_miscUtils__WEBPACK_IMPORTED_MODULE_15__.sortMap(virtualizedPackage.dependencies, ([identHash, descriptor]) => {
          return _structUtils__WEBPACK_IMPORTED_MODULE_14__.stringifyIdent(descriptor);
        }));
      });
      thirdPass.push(() => {
        if (!allPackages.has(virtualizedPackage.locatorHash)) return;
        const current = virtualStack.get(pkg.locatorHash);
        const next = typeof current !== `undefined` ? current + 1 : 1;
        virtualStack.set(pkg.locatorHash, next);
        resolvePeerDependencies(virtualizedPackage, false, isOptional);
        virtualStack.set(pkg.locatorHash, next - 1);
      });
      fourthPass.push(() => {
        if (!allPackages.has(virtualizedPackage.locatorHash)) return;

        for (const missingPeerDependency of missingPeerDependencies) {
          virtualizedPackage.dependencies.delete(missingPeerDependency);
        }
      });
    }

    for (const fn of [...firstPass, ...secondPass]) fn();

    let stable;

    do {
      stable = true;

      for (const [physicalLocator, virtualDescriptor, virtualPackage] of newVirtualInstances) {
        if (!allPackages.has(virtualPackage.locatorHash)) continue;
        const otherVirtualInstances = _miscUtils__WEBPACK_IMPORTED_MODULE_15__.getMapWithDefault(allVirtualInstances, physicalLocator.locatorHash); // We take all the dependencies from the new virtual instance and
        // generate a hash from it. By checking if this hash is already
        // registered, we know whether we can trim the new version.

        const dependencyHash = _hashUtils__WEBPACK_IMPORTED_MODULE_16__.makeHash(...[...virtualPackage.dependencies.values()].map(descriptor => {
          const resolution = descriptor.range !== `missing:` ? allResolutions.get(descriptor.descriptorHash) : `missing:`;
          if (typeof resolution === `undefined`) throw new Error(`Assertion failed: Expected the resolution for ${_structUtils__WEBPACK_IMPORTED_MODULE_14__.prettyDescriptor(project.configuration, descriptor)} to have been registered`);
          return resolution;
        }), // We use the identHash to disambiguate between virtual descriptors
        // with different base idents being resolved to the same virtual package.
        // Note: We don't use the descriptorHash because the whole point of duplicate
        // virtual descriptors is that they have different `virtual:` ranges.
        // This causes the virtual descriptors with different base idents
        // to be preserved, while the virtual package they resolve to gets deduped.
        virtualDescriptor.identHash);
        const masterDescriptor = otherVirtualInstances.get(dependencyHash);

        if (typeof masterDescriptor === `undefined`) {
          otherVirtualInstances.set(dependencyHash, virtualDescriptor);
          continue;
        } // Since we're applying multiple pass, we might have already registered
        // ourselves as the "master" descriptor in the previous pass.


        if (masterDescriptor === virtualDescriptor) continue;
        stable = false;
        allPackages.delete(virtualPackage.locatorHash);
        allDescriptors.delete(virtualDescriptor.descriptorHash);
        allResolutions.delete(virtualDescriptor.descriptorHash);
        accessibleLocators.delete(virtualPackage.locatorHash);
        const dependents = allVirtualDependents.get(virtualDescriptor.descriptorHash) || [];
        const allDependents = [parentPackage.locatorHash, ...dependents];

        for (const dependent of allDependents) {
          const pkg = allPackages.get(dependent);
          if (typeof pkg === `undefined`) continue;
          pkg.dependencies.set(virtualDescriptor.identHash, masterDescriptor);
        }
      }
    } while (!stable);

    for (const fn of [...thirdPass, ...fourthPass]) {
      fn();
    }
  };

  for (const workspace of project.workspaces) {
    volatileDescriptors.delete(workspace.anchoredDescriptor.descriptorHash);
    resolvePeerDependencies(workspace.anchoredLocator, true, false);
  }
}

/***/ }),
/* 255 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Diff": () => /* binding */ Diff,
/* harmony export */   "diffChars": () => /* binding */ diffChars,
/* harmony export */   "diffWords": () => /* binding */ diffWords,
/* harmony export */   "diffWordsWithSpace": () => /* binding */ diffWordsWithSpace,
/* harmony export */   "diffLines": () => /* binding */ diffLines,
/* harmony export */   "diffTrimmedLines": () => /* binding */ diffTrimmedLines,
/* harmony export */   "diffSentences": () => /* binding */ diffSentences,
/* harmony export */   "diffCss": () => /* binding */ diffCss,
/* harmony export */   "diffJson": () => /* binding */ diffJson,
/* harmony export */   "diffArrays": () => /* binding */ diffArrays,
/* harmony export */   "structuredPatch": () => /* binding */ structuredPatch,
/* harmony export */   "createTwoFilesPatch": () => /* binding */ createTwoFilesPatch,
/* harmony export */   "createPatch": () => /* binding */ createPatch,
/* harmony export */   "applyPatch": () => /* binding */ applyPatch,
/* harmony export */   "applyPatches": () => /* binding */ applyPatches,
/* harmony export */   "parsePatch": () => /* binding */ parsePatch,
/* harmony export */   "merge": () => /* binding */ merge,
/* harmony export */   "convertChangesToDMP": () => /* binding */ convertChangesToDMP,
/* harmony export */   "convertChangesToXML": () => /* binding */ convertChangesToXML,
/* harmony export */   "canonicalize": () => /* binding */ canonicalize
/* harmony export */ });
function Diff() {}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Main worker method. checks all permutations of a given edit length for acceptance.


    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath = void 0;

        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph


        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list

          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          // This should not happen, but we want to be safe.

          /* istanbul ignore next */
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },
  pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];

    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      };
    } else {
      components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }

    basePath.newPos = newPos;
    return oldPos;
  },
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return value.split('');
  },
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var lastComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}

var characterDiff = new Diff();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}

function generateOptions(options, defaults) {
  if (typeof options === 'function') {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      /* istanbul ignore else */
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }

  return defaults;
}

//
// Ranges and exceptions:
// Latin-1 Supplement, 008000FF
//  - U+00D7   Multiplication sign
//  - U+00F7   Division sign
// Latin Extended-A, 0100017F
// Latin Extended-B, 0180024F
// IPA Extensions, 025002AF
// Spacing Modifier Letters, 02B002FF
//  - U+02C7   &#711;  Caron
//  - U+02D8   &#728;  Breve
//  - U+02D9   &#729;  Dot Above
//  - U+02DA   &#730;  Ring Above
//  - U+02DB   &#731;  Ogonek
//  - U+02DC   &#732;  Small Tilde
//  - U+02DD   &#733;  Double Acute Accent
// Latin Extended Additional, 1E001EFF

var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();

wordDiff.equals = function (left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }

  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};

wordDiff.tokenize = function (value) {
  var tokens = value.split(/(\s+|[()[\]{}'"]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

  for (var i = 0; i < tokens.length - 1; i++) {
    // If we have an empty string in the next field and we have only word chars before and after, merge
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }

  return tokens;
};

function diffWords(oldStr, newStr, options) {
  options = generateOptions(options, {
    ignoreWhitespace: true
  });
  return wordDiff.diff(oldStr, newStr, options);
}
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordDiff.diff(oldStr, newStr, options);
}

var lineDiff = new Diff();

lineDiff.tokenize = function (value) {
  var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  } // Merge the content and line separators into single tokens


  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];

    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }

      retLines.push(line);
    }
  }

  return retLines;
};

function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
function diffTrimmedLines(oldStr, newStr, callback) {
  var options = generateOptions(callback, {
    ignoreWhitespace: true
  });
  return lineDiff.diff(oldStr, newStr, options);
}

var sentenceDiff = new Diff();

sentenceDiff.tokenize = function (value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};

function diffSentences(oldStr, newStr, callback) {
  return sentenceDiff.diff(oldStr, newStr, callback);
}

var cssDiff = new Diff();

cssDiff.tokenize = function (value) {
  return value.split(/([{}:;,]|\s+)/);
};

function diffCss(oldStr, newStr, callback) {
  return cssDiff.diff(oldStr, newStr, callback);
}

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;

jsonDiff.castInput = function (value) {
  var _this$options = this.options,
      undefinedReplacement = _this$options.undefinedReplacement,
      _this$options$stringi = _this$options.stringifyReplacer,
      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
    return typeof v === 'undefined' ? undefinedReplacement : v;
  } : _this$options$stringi;
  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
};

jsonDiff.equals = function (left, right) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
};

function diffJson(oldObj, newObj, options) {
  return jsonDiff.diff(oldObj, newObj, options);
} // This function handles the presence of circular references by bailing out when encountering an
// object that is already on the "stack" of items being processed. Accepts an optional replacer

function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];

  if (replacer) {
    obj = replacer(key, obj);
  }

  var i;

  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }

  var canonicalizedObj;

  if ('[object Array]' === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);

    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }

    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }

  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }

  if (_typeof(obj) === 'object' && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);

    var sortedKeys = [],
        _key;

    for (_key in obj) {
      /* istanbul ignore else */
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }

    sortedKeys.sort();

    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }

    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }

  return canonicalizedObj;
}

var arrayDiff = new Diff();

arrayDiff.tokenize = function (value) {
  return value.slice();
};

arrayDiff.join = arrayDiff.removeEmpty = function (value) {
  return value;
};

function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}

function parsePatch(uniDiff) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      list = [],
      i = 0;

  function parseIndex() {
    var index = {};
    list.push(index); // Parse diff metadata

    while (i < diffstr.length) {
      var line = diffstr[i]; // File header found, end parsing diff metadata

      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
        break;
      } // Diff index


      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);

      if (header) {
        index.index = header[1];
      }

      i++;
    } // Parse file headers if they are defined. Unified diff requires them, but
    // there's no technical issues to have an isolated hunk without file header


    parseFileHeader(index);
    parseFileHeader(index); // Parse hunks

    index.hunks = [];

    while (i < diffstr.length) {
      var _line = diffstr[i];

      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
        break;
      } else if (/^@@/.test(_line)) {
        index.hunks.push(parseHunk());
      } else if (_line && options.strict) {
        // Ignore unexpected content unless in strict mode
        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
      } else {
        i++;
      }
    }
  } // Parses the --- and +++ headers, if none are found, no lines
  // are consumed.


  function parseFileHeader(index) {
    var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);

    if (fileHeader) {
      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
      var data = fileHeader[2].split('\t', 2);
      var fileName = data[0].replace(/\\\\/g, '\\');

      if (/^".*"$/.test(fileName)) {
        fileName = fileName.substr(1, fileName.length - 2);
      }

      index[keyPrefix + 'FileName'] = fileName;
      index[keyPrefix + 'Header'] = (data[1] || '').trim();
      i++;
    }
  } // Parses a hunk
  // This assumes that we are at the start of a hunk.


  function parseHunk() {
    var chunkHeaderIndex = i,
        chunkHeaderLine = diffstr[i++],
        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
    var hunk = {
      oldStart: +chunkHeader[1],
      oldLines: +chunkHeader[2] || 1,
      newStart: +chunkHeader[3],
      newLines: +chunkHeader[4] || 1,
      lines: [],
      linedelimiters: []
    };
    var addCount = 0,
        removeCount = 0;

    for (; i < diffstr.length; i++) {
      // Lines starting with '---' could be mistaken for the "remove line" operation
      // But they could be the header for the next file. Therefore prune such cases out.
      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
        break;
      }

      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
        hunk.lines.push(diffstr[i]);
        hunk.linedelimiters.push(delimiters[i] || '\n');

        if (operation === '+') {
          addCount++;
        } else if (operation === '-') {
          removeCount++;
        } else if (operation === ' ') {
          addCount++;
          removeCount++;
        }
      } else {
        break;
      }
    } // Handle the empty block count case


    if (!addCount && hunk.newLines === 1) {
      hunk.newLines = 0;
    }

    if (!removeCount && hunk.oldLines === 1) {
      hunk.oldLines = 0;
    } // Perform optional sanity checking


    if (options.strict) {
      if (addCount !== hunk.newLines) {
        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }

      if (removeCount !== hunk.oldLines) {
        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }
    }

    return hunk;
  }

  while (i < diffstr.length) {
    parseIndex();
  }

  return list;
}

// Iterator that traverses in the range of [min, max], stepping
// by distance from a given start position. I.e. for [0, 4], with
// start of 2, this will iterate 2, 3, 1, 4, 0.
function distanceIterator (start, minLine, maxLine) {
  var wantForward = true,
      backwardExhausted = false,
      forwardExhausted = false,
      localOffset = 1;
  return function iterator() {
    if (wantForward && !forwardExhausted) {
      if (backwardExhausted) {
        localOffset++;
      } else {
        wantForward = false;
      } // Check if trying to fit beyond text length, and if not, check it fits
      // after offset location (or desired location on first iteration)


      if (start + localOffset <= maxLine) {
        return localOffset;
      }

      forwardExhausted = true;
    }

    if (!backwardExhausted) {
      if (!forwardExhausted) {
        wantForward = true;
      } // Check if trying to fit before text beginning, and if not, check it fits
      // before offset location


      if (minLine <= start - localOffset) {
        return -localOffset++;
      }

      backwardExhausted = true;
      return iterator();
    } // We tried to fit hunk before text beginning and beyond text length, then
    // hunk can't fit on the text. Return undefined

  };
}

function applyPatch(source, uniDiff) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof uniDiff === 'string') {
    uniDiff = parsePatch(uniDiff);
  }

  if (Array.isArray(uniDiff)) {
    if (uniDiff.length > 1) {
      throw new Error('applyPatch only works with a single input.');
    }

    uniDiff = uniDiff[0];
  } // Apply the diff to the input


  var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      hunks = uniDiff.hunks,
      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {
    return line === patchContent;
  },
      errorCount = 0,
      fuzzFactor = options.fuzzFactor || 0,
      minLine = 0,
      offset = 0,
      removeEOFNL,
      addEOFNL;
  /**
   * Checks if the hunk exactly fits on the provided location
   */


  function hunkFits(hunk, toPos) {
    for (var j = 0; j < hunk.lines.length; j++) {
      var line = hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line;

      if (operation === ' ' || operation === '-') {
        // Context sanity check
        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
          errorCount++;

          if (errorCount > fuzzFactor) {
            return false;
          }
        }

        toPos++;
      }
    }

    return true;
  } // Search best fit offsets for each hunk based on the previous ones


  for (var i = 0; i < hunks.length; i++) {
    var hunk = hunks[i],
        maxLine = lines.length - hunk.oldLines,
        localOffset = 0,
        toPos = offset + hunk.oldStart - 1;
    var iterator = distanceIterator(toPos, minLine, maxLine);

    for (; localOffset !== undefined; localOffset = iterator()) {
      if (hunkFits(hunk, toPos + localOffset)) {
        hunk.offset = offset += localOffset;
        break;
      }
    }

    if (localOffset === undefined) {
      return false;
    } // Set lower text limit to end of the current hunk, so next ones don't try
    // to fit over already patched text


    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
  } // Apply patch hunks


  var diffOffset = 0;

  for (var _i = 0; _i < hunks.length; _i++) {
    var _hunk = hunks[_i],
        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;

    diffOffset += _hunk.newLines - _hunk.oldLines;

    if (_toPos < 0) {
      // Creating a new file
      _toPos = 0;
    }

    for (var j = 0; j < _hunk.lines.length; j++) {
      var line = _hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line,
          delimiter = _hunk.linedelimiters[j];

      if (operation === ' ') {
        _toPos++;
      } else if (operation === '-') {
        lines.splice(_toPos, 1);
        delimiters.splice(_toPos, 1);
        /* istanbul ignore else */
      } else if (operation === '+') {
        lines.splice(_toPos, 0, content);
        delimiters.splice(_toPos, 0, delimiter);
        _toPos++;
      } else if (operation === '\\') {
        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;

        if (previousOperation === '+') {
          removeEOFNL = true;
        } else if (previousOperation === '-') {
          addEOFNL = true;
        }
      }
    }
  } // Handle EOFNL insertion/removal


  if (removeEOFNL) {
    while (!lines[lines.length - 1]) {
      lines.pop();
      delimiters.pop();
    }
  } else if (addEOFNL) {
    lines.push('');
    delimiters.push('\n');
  }

  for (var _k = 0; _k < lines.length - 1; _k++) {
    lines[_k] = lines[_k] + delimiters[_k];
  }

  return lines.join('');
} // Wrapper that supports multiple file patches via callbacks.

function applyPatches(uniDiff, options) {
  if (typeof uniDiff === 'string') {
    uniDiff = parsePatch(uniDiff);
  }

  var currentIndex = 0;

  function processIndex() {
    var index = uniDiff[currentIndex++];

    if (!index) {
      return options.complete();
    }

    options.loadFile(index, function (err, data) {
      if (err) {
        return options.complete(err);
      }

      var updatedContent = applyPatch(data, index, options);
      options.patched(index, updatedContent, function (err) {
        if (err) {
          return options.complete(err);
        }

        processIndex();
      });
    });
  }

  processIndex();
}

function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = {};
  }

  if (typeof options.context === 'undefined') {
    options.context = 4;
  }

  var diff = diffLines(oldStr, newStr, options);
  diff.push({
    value: '',
    lines: []
  }); // Append an empty value to make cleanup easier

  function contextLines(lines) {
    return lines.map(function (entry) {
      return ' ' + entry;
    });
  }

  var hunks = [];
  var oldRangeStart = 0,
      newRangeStart = 0,
      curRange = [],
      oldLine = 1,
      newLine = 1;

  var _loop = function _loop(i) {
    var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, '').split('\n');
    current.lines = lines;

    if (current.added || current.removed) {
      var _curRange;

      // If we have previous context, start with that
      if (!oldRangeStart) {
        var prev = diff[i - 1];
        oldRangeStart = oldLine;
        newRangeStart = newLine;

        if (prev) {
          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      } // Output our changes


      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
        return (current.added ? '+' : '-') + entry;
      }))); // Track the updated file position


      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      // Identical context lines. Track line changes
      if (oldRangeStart) {
        // Close out any changes that have been output (or join overlapping)
        if (lines.length <= options.context * 2 && i < diff.length - 2) {
          var _curRange2;

          // Overlapping
          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
        } else {
          var _curRange3;

          // end the range and output
          var contextSize = Math.min(lines.length, options.context);

          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));

          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };

          if (i >= diff.length - 2 && lines.length <= options.context) {
            // EOF is inside this hunk
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;

            if (!oldEOFNewline && noNlBeforeAdds) {
              // special case: old has no eol and no trailing context; no-nl can end up before adds
              curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
            }

            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
              curRange.push('\\ No newline at end of file');
            }
          }

          hunks.push(hunk);
          oldRangeStart = 0;
          newRangeStart = 0;
          curRange = [];
        }
      }

      oldLine += lines.length;
      newLine += lines.length;
    }
  };

  for (var i = 0; i < diff.length; i++) {
    _loop(i);
  }

  return {
    oldFileName: oldFileName,
    newFileName: newFileName,
    oldHeader: oldHeader,
    newHeader: newHeader,
    hunks: hunks
  };
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
  var ret = [];

  if (oldFileName == newFileName) {
    ret.push('Index: ' + oldFileName);
  }

  ret.push('===================================================================');
  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

  for (var i = 0; i < diff.hunks.length; i++) {
    var hunk = diff.hunks[i];
    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
    ret.push.apply(ret, hunk.lines);
  }

  return ret.join('\n') + '\n';
}
function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}

function arrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  return arrayStartsWith(a, b);
}
function arrayStartsWith(array, start) {
  if (start.length > array.length) {
    return false;
  }

  for (var i = 0; i < start.length; i++) {
    if (start[i] !== array[i]) {
      return false;
    }
  }

  return true;
}

function calcLineCount(hunk) {
  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),
      oldLines = _calcOldNewLineCount.oldLines,
      newLines = _calcOldNewLineCount.newLines;

  if (oldLines !== undefined) {
    hunk.oldLines = oldLines;
  } else {
    delete hunk.oldLines;
  }

  if (newLines !== undefined) {
    hunk.newLines = newLines;
  } else {
    delete hunk.newLines;
  }
}
function merge(mine, theirs, base) {
  mine = loadPatch(mine, base);
  theirs = loadPatch(theirs, base);
  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.
  // Leaving sanity checks on this to the API consumer that may know more about the
  // meaning in their own context.

  if (mine.index || theirs.index) {
    ret.index = mine.index || theirs.index;
  }

  if (mine.newFileName || theirs.newFileName) {
    if (!fileNameChanged(mine)) {
      // No header or no change in ours, use theirs (and ours if theirs does not exist)
      ret.oldFileName = theirs.oldFileName || mine.oldFileName;
      ret.newFileName = theirs.newFileName || mine.newFileName;
      ret.oldHeader = theirs.oldHeader || mine.oldHeader;
      ret.newHeader = theirs.newHeader || mine.newHeader;
    } else if (!fileNameChanged(theirs)) {
      // No header or no change in theirs, use ours
      ret.oldFileName = mine.oldFileName;
      ret.newFileName = mine.newFileName;
      ret.oldHeader = mine.oldHeader;
      ret.newHeader = mine.newHeader;
    } else {
      // Both changed... figure it out
      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
    }
  }

  ret.hunks = [];
  var mineIndex = 0,
      theirsIndex = 0,
      mineOffset = 0,
      theirsOffset = 0;

  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
    var mineCurrent = mine.hunks[mineIndex] || {
      oldStart: Infinity
    },
        theirsCurrent = theirs.hunks[theirsIndex] || {
      oldStart: Infinity
    };

    if (hunkBefore(mineCurrent, theirsCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
      mineIndex++;
      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
    } else if (hunkBefore(theirsCurrent, mineCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
      theirsIndex++;
      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
    } else {
      // Overlap, merge as best we can
      var mergedHunk = {
        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
        oldLines: 0,
        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
        newLines: 0,
        lines: []
      };
      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
      theirsIndex++;
      mineIndex++;
      ret.hunks.push(mergedHunk);
    }
  }

  return ret;
}

function loadPatch(param, base) {
  if (typeof param === 'string') {
    if (/^@@/m.test(param) || /^Index:/m.test(param)) {
      return parsePatch(param)[0];
    }

    if (!base) {
      throw new Error('Must provide a base reference or pass in a patch');
    }

    return structuredPatch(undefined, undefined, base, param);
  }

  return param;
}

function fileNameChanged(patch) {
  return patch.newFileName && patch.newFileName !== patch.oldFileName;
}

function selectField(index, mine, theirs) {
  if (mine === theirs) {
    return mine;
  } else {
    index.conflict = true;
    return {
      mine: mine,
      theirs: theirs
    };
  }
}

function hunkBefore(test, check) {
  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
}

function cloneHunk(hunk, offset) {
  return {
    oldStart: hunk.oldStart,
    oldLines: hunk.oldLines,
    newStart: hunk.newStart + offset,
    newLines: hunk.newLines,
    lines: hunk.lines
  };
}

function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
  // This will generally result in a conflicted hunk, but there are cases where the context
  // is the only overlap where we can successfully merge the content here.
  var mine = {
    offset: mineOffset,
    lines: mineLines,
    index: 0
  },
      their = {
    offset: theirOffset,
    lines: theirLines,
    index: 0
  }; // Handle any leading content

  insertLeading(hunk, mine, their);
  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.

  while (mine.index < mine.lines.length && their.index < their.lines.length) {
    var mineCurrent = mine.lines[mine.index],
        theirCurrent = their.lines[their.index];

    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
      // Both modified ...
      mutualChange(hunk, mine, their);
    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
      var _hunk$lines;

      // Mine inserted
      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
      var _hunk$lines2;

      // Theirs inserted
      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
      // Mine removed or edited
      removal(hunk, mine, their);
    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
      // Their removed or edited
      removal(hunk, their, mine, true);
    } else if (mineCurrent === theirCurrent) {
      // Context identity
      hunk.lines.push(mineCurrent);
      mine.index++;
      their.index++;
    } else {
      // Context mismatch
      conflict(hunk, collectChange(mine), collectChange(their));
    }
  } // Now push anything that may be remaining


  insertTrailing(hunk, mine);
  insertTrailing(hunk, their);
  calcLineCount(hunk);
}

function mutualChange(hunk, mine, their) {
  var myChanges = collectChange(mine),
      theirChanges = collectChange(their);

  if (allRemoves(myChanges) && allRemoves(theirChanges)) {
    // Special case for remove changes that are supersets of one another
    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
      var _hunk$lines3;

      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));

      return;
    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
      var _hunk$lines4;

      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));

      return;
    }
  } else if (arrayEqual(myChanges, theirChanges)) {
    var _hunk$lines5;

    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));

    return;
  }

  conflict(hunk, myChanges, theirChanges);
}

function removal(hunk, mine, their, swap) {
  var myChanges = collectChange(mine),
      theirChanges = collectContext(their, myChanges);

  if (theirChanges.merged) {
    var _hunk$lines6;

    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
  } else {
    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
  }
}

function conflict(hunk, mine, their) {
  hunk.conflict = true;
  hunk.lines.push({
    conflict: true,
    mine: mine,
    theirs: their
  });
}

function insertLeading(hunk, insert, their) {
  while (insert.offset < their.offset && insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
    insert.offset++;
  }
}

function insertTrailing(hunk, insert) {
  while (insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
  }
}

function collectChange(state) {
  var ret = [],
      operation = state.lines[state.index][0];

  while (state.index < state.lines.length) {
    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.

    if (operation === '-' && line[0] === '+') {
      operation = '+';
    }

    if (operation === line[0]) {
      ret.push(line);
      state.index++;
    } else {
      break;
    }
  }

  return ret;
}

function collectContext(state, matchChanges) {
  var changes = [],
      merged = [],
      matchIndex = 0,
      contextChanges = false,
      conflicted = false;

  while (matchIndex < matchChanges.length && state.index < state.lines.length) {
    var change = state.lines[state.index],
        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done

    if (match[0] === '+') {
      break;
    }

    contextChanges = contextChanges || change[0] !== ' ';
    merged.push(match);
    matchIndex++; // Consume any additions in the other block as a conflict to attempt
    // to pull in the remaining context after this

    if (change[0] === '+') {
      conflicted = true;

      while (change[0] === '+') {
        changes.push(change);
        change = state.lines[++state.index];
      }
    }

    if (match.substr(1) === change.substr(1)) {
      changes.push(change);
      state.index++;
    } else {
      conflicted = true;
    }
  }

  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
    conflicted = true;
  }

  if (conflicted) {
    return changes;
  }

  while (matchIndex < matchChanges.length) {
    merged.push(matchChanges[matchIndex++]);
  }

  return {
    merged: merged,
    changes: changes
  };
}

function allRemoves(changes) {
  return changes.reduce(function (prev, change) {
    return prev && change[0] === '-';
  }, true);
}

function skipRemoveSuperset(state, removeChanges, delta) {
  for (var i = 0; i < delta; i++) {
    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);

    if (state.lines[state.index + i] !== ' ' + changeContent) {
      return false;
    }
  }

  state.index += delta;
  return true;
}

function calcOldNewLineCount(lines) {
  var oldLines = 0;
  var newLines = 0;
  lines.forEach(function (line) {
    if (typeof line !== 'string') {
      var myCount = calcOldNewLineCount(line.mine);
      var theirCount = calcOldNewLineCount(line.theirs);

      if (oldLines !== undefined) {
        if (myCount.oldLines === theirCount.oldLines) {
          oldLines += myCount.oldLines;
        } else {
          oldLines = undefined;
        }
      }

      if (newLines !== undefined) {
        if (myCount.newLines === theirCount.newLines) {
          newLines += myCount.newLines;
        } else {
          newLines = undefined;
        }
      }
    } else {
      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
        newLines++;
      }

      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
        oldLines++;
      }
    }
  });
  return {
    oldLines: oldLines,
    newLines: newLines
  };
}

// See: http://code.google.com/p/google-diff-match-patch/wiki/API
function convertChangesToDMP(changes) {
  var ret = [],
      change,
      operation;

  for (var i = 0; i < changes.length; i++) {
    change = changes[i];

    if (change.added) {
      operation = 1;
    } else if (change.removed) {
      operation = -1;
    } else {
      operation = 0;
    }

    ret.push([operation, change.value]);
  }

  return ret;
}

function convertChangesToXML(changes) {
  var ret = [];

  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];

    if (change.added) {
      ret.push('<ins>');
    } else if (change.removed) {
      ret.push('<del>');
    }

    ret.push(escapeHTML(change.value));

    if (change.added) {
      ret.push('</ins>');
    } else if (change.removed) {
      ret.push('</del>');
    }
  }

  return ret.join('');
}

function escapeHTML(s) {
  var n = s;
  n = n.replace(/&/g, '&amp;');
  n = n.replace(/</g, '&lt;');
  n = n.replace(/>/g, '&gt;');
  n = n.replace(/"/g, '&quot;');
  return n;
}

/* See LICENSE file for terms of use */




/***/ }),
/* 256 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePick = __webpack_require__(257),
    flatRest = __webpack_require__(321);

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),
/* 257 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePickBy = __webpack_require__(258),
    hasIn = __webpack_require__(315);

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),
/* 258 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(259),
    baseSet = __webpack_require__(310),
    castPath = __webpack_require__(260);

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),
/* 259 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(260),
    toKey = __webpack_require__(309);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 260 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(261),
    isKey = __webpack_require__(262),
    stringToPath = __webpack_require__(271),
    toString = __webpack_require__(306);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 261 */
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 262 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(261),
    isSymbol = __webpack_require__(263);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 263 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(264),
    isObjectLike = __webpack_require__(270);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 264 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(265),
    getRawTag = __webpack_require__(268),
    objectToString = __webpack_require__(269);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 265 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(266);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 266 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(267);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 267 */
/***/ ((module) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;


/***/ }),
/* 268 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(265);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 269 */
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 270 */
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 271 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__(272);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 272 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__(273);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 273 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(274);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 274 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(275),
    mapCacheDelete = __webpack_require__(300),
    mapCacheGet = __webpack_require__(303),
    mapCacheHas = __webpack_require__(304),
    mapCacheSet = __webpack_require__(305);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 275 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(276),
    ListCache = __webpack_require__(291),
    Map = __webpack_require__(299);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 276 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(277),
    hashDelete = __webpack_require__(287),
    hashGet = __webpack_require__(288),
    hashHas = __webpack_require__(289),
    hashSet = __webpack_require__(290);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 277 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(278);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 278 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(279);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 279 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(280),
    getValue = __webpack_require__(286);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 280 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(281),
    isMasked = __webpack_require__(283),
    isObject = __webpack_require__(282),
    toSource = __webpack_require__(285);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 281 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(264),
    isObject = __webpack_require__(282);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 282 */
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 283 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(284);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 284 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(266);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 285 */
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 286 */
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 287 */
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 288 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(278);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 289 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(278);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 290 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(278);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 291 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(292),
    listCacheDelete = __webpack_require__(293),
    listCacheGet = __webpack_require__(296),
    listCacheHas = __webpack_require__(297),
    listCacheSet = __webpack_require__(298);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 292 */
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 293 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(294);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 294 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(295);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 295 */
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 296 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(294);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 297 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(294);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 298 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(294);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 299 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(279),
    root = __webpack_require__(266);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 300 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(301);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 301 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(302);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 302 */
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 303 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(301);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 304 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(301);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 305 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(301);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 306 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(307);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 307 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(265),
    arrayMap = __webpack_require__(308),
    isArray = __webpack_require__(261),
    isSymbol = __webpack_require__(263);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 308 */
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 309 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(263);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 310 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(311),
    castPath = __webpack_require__(260),
    isIndex = __webpack_require__(314),
    isObject = __webpack_require__(282),
    toKey = __webpack_require__(309);

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),
/* 311 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(312),
    eq = __webpack_require__(295);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 312 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(313);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 313 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(279);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 314 */
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 315 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHasIn = __webpack_require__(316),
    hasPath = __webpack_require__(317);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 316 */
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 317 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(260),
    isArguments = __webpack_require__(318),
    isArray = __webpack_require__(261),
    isIndex = __webpack_require__(314),
    isLength = __webpack_require__(320),
    toKey = __webpack_require__(309);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 318 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(319),
    isObjectLike = __webpack_require__(270);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 319 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(264),
    isObjectLike = __webpack_require__(270);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 320 */
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 321 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var flatten = __webpack_require__(322),
    overRest = __webpack_require__(326),
    setToString = __webpack_require__(328);

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),
/* 322 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(323);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),
/* 323 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(324),
    isFlattenable = __webpack_require__(325);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),
/* 324 */
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 325 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(265),
    isArguments = __webpack_require__(318),
    isArray = __webpack_require__(261);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),
/* 326 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(327);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 327 */
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 328 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSetToString = __webpack_require__(329),
    shortOut = __webpack_require__(332);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 329 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constant = __webpack_require__(330),
    defineProperty = __webpack_require__(313),
    identity = __webpack_require__(331);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 330 */
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 331 */
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 332 */
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 333 */
/***/ ((module) => {

"use strict";
module.exports = require("v8");;

/***/ }),
/* 334 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Workspace": () => /* binding */ Workspace
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var globby__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);
/* harmony import */ var globby__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(globby__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Manifest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(237);
/* harmony import */ var _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(229);
/* harmony import */ var _hashUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(71);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);







class Workspace {
  constructor(workspaceCwd, {
    project
  }) {
    this.workspacesCwds = new Set(); // Generated at resolution; basically dependencies + devDependencies + child workspaces

    this.dependencies = new Map();
    this.project = project;
    this.cwd = workspaceCwd;
  }

  async setup() {
    // @ts-expect-error: It's ok to initialize it now
    this.manifest = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.join(this.cwd, _Manifest__WEBPACK_IMPORTED_MODULE_4__.Manifest.fileName)) ? await _Manifest__WEBPACK_IMPORTED_MODULE_4__.Manifest.find(this.cwd) : new _Manifest__WEBPACK_IMPORTED_MODULE_4__.Manifest(); // We use ppath.relative to guarantee that the default hash will be consistent even if the project is installed on different OS / path
    // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    this.relativeCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.relative(this.project.cwd, this.cwd) || _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.PortablePath.dot;
    const ident = this.manifest.name ? this.manifest.name : _structUtils__WEBPACK_IMPORTED_MODULE_5__.makeIdent(null, `${this.computeCandidateName()}-${_hashUtils__WEBPACK_IMPORTED_MODULE_6__.makeHash(this.relativeCwd).substr(0, 6)}`);
    const reference = this.manifest.version ? this.manifest.version : `0.0.0`; // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    this.locator = _structUtils__WEBPACK_IMPORTED_MODULE_5__.makeLocator(ident, reference); // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    this.anchoredDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_5__.makeDescriptor(this.locator, `${_WorkspaceResolver__WEBPACK_IMPORTED_MODULE_7__.WorkspaceResolver.protocol}${this.relativeCwd}`); // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    this.anchoredLocator = _structUtils__WEBPACK_IMPORTED_MODULE_5__.makeLocator(this.locator, `${_WorkspaceResolver__WEBPACK_IMPORTED_MODULE_7__.WorkspaceResolver.protocol}${this.relativeCwd}`);
    const patterns = this.manifest.workspaceDefinitions.map(({
      pattern
    }) => pattern);
    const relativeCwds = await globby__WEBPACK_IMPORTED_MODULE_0___default()(patterns, {
      absolute: true,
      cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(this.cwd),
      expandDirectories: false,
      onlyDirectories: true,
      onlyFiles: false,
      ignore: [`**/node_modules`, `**/.git`, `**/.yarn`]
    }); // It seems that the return value of globby isn't in any guaranteed order - not even the directory listing order

    relativeCwds.sort();

    for (const relativeCwd of relativeCwds) {
      const candidateCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.resolve(this.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.toPortablePath(relativeCwd));

      if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.join(candidateCwd, `package.json`))) {
        this.workspacesCwds.add(candidateCwd);
      }
    }
  }

  accepts(range) {
    const protocolIndex = range.indexOf(`:`);
    const protocol = protocolIndex !== -1 ? range.slice(0, protocolIndex + 1) : null;
    const pathname = protocolIndex !== -1 ? range.slice(protocolIndex + 1) : range;
    if (protocol === _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_7__.WorkspaceResolver.protocol && _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.normalize(pathname) === this.relativeCwd) return true;
    if (protocol === _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_7__.WorkspaceResolver.protocol && pathname === `*`) return true;
    if (!semver__WEBPACK_IMPORTED_MODULE_1___default().validRange(pathname)) return false;
    if (protocol === _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_7__.WorkspaceResolver.protocol) return semver__WEBPACK_IMPORTED_MODULE_1___default().satisfies(this.manifest.version !== null ? this.manifest.version : `0.0.0`, pathname);
    if (!this.project.configuration.get(`enableTransparentWorkspaces`)) return false;
    if (this.manifest.version !== null) return semver__WEBPACK_IMPORTED_MODULE_1___default().satisfies(this.manifest.version, pathname);
    return false;
  }

  computeCandidateName() {
    if (this.cwd === this.project.cwd) {
      return `root-workspace`;
    } else {
      return `${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.basename(this.cwd)}` || `unnamed-workspace`;
    }
  }

  async persistManifest() {
    const data = {};
    this.manifest.exportTo(data);
    const path = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.join(this.cwd, _Manifest__WEBPACK_IMPORTED_MODULE_4__.Manifest.fileName);
    const content = `${JSON.stringify(data, null, this.manifest.indent)}\n`;
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.changeFilePromise(path, content, {
      automaticNewlines: true
    });
  }

}

/***/ }),
/* 335 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThrowReport": () => /* binding */ ThrowReport
/* harmony export */ });
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(233);

class ThrowReport extends _Report__WEBPACK_IMPORTED_MODULE_0__.Report {
  reportCacheHit(locator) {}

  reportCacheMiss(locator) {}

  startTimerSync(what, opts, cb) {
    const realCb = typeof opts === `function` ? opts : cb;
    return realCb();
  }

  async startTimerPromise(what, opts, cb) {
    const realCb = typeof opts === `function` ? opts : cb;
    return await realCb();
  }

  async startCacheReport(cb) {
    return await cb();
  }

  reportSeparator() {}

  reportInfo(name, text) {}

  reportWarning(name, text) {}

  reportError(name, text) {}

  reportProgress(progress) {
    const promise = Promise.resolve().then(async () => {
      // eslint-disable-next-line no-empty-pattern
      for await (const {} of progress) {// No need to do anything; we just want to consume the progress events
      }
    });

    const stop = () => {// Nothing to stop
    };

    return { ...promise,
      stop
    };
  }

  reportJson(data) {// Just ignore the json output
  }

  async finalize() {}

}

/***/ }),
/* 336 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LegacyMigrationResolver": () => /* binding */ LegacyMigrationResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(182);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(180);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);





const IMPORTED_PATTERNS = [// These ones come from Git urls
[/^(git(?:\+(?:https|ssh))?:\/\/.*(?:\.git)?)#(.*)$/, (version, $0, $1, $2) => `${$1}#commit=${$2}`], // These ones come from the GitHub HTTP endpoints
[/^https:\/\/((?:[^/]+?)@)?codeload\.github\.com\/([^/]+\/[^/]+)\/tar\.gz\/([0-9a-f]+)$/, (version, $0, $1 = ``, $2, $3) => `https://${$1}github.com/${$2}.git#commit=${$3}`], [/^https:\/\/((?:[^/]+?)@)?github\.com\/([^/]+\/[^/]+?)(?:\.git)?#([0-9a-f]+)$/, (version, $0, $1 = ``, $2, $3) => `https://${$1}github.com/${$2}.git#commit=${$3}`], // These ones come from the npm registry
// Note: /download/ is used by custom registries like Taobao
[/^(?:https?:\/\/)?[^/]+\/(?:[^/]+\/)*(?:@[^/]+\/)?([^/]+)\/(?:-|download)\/\1-[^/]+\.tgz(?:#|$)/, version => `npm:${version}`], // The GitHub package registry uses a different style of URLs
[/^https:\/\/npm\.pkg\.github\.com\/download\/(?:@[^/]+)\/(?:[^/]+)\/(?:[^/]+)\/(?:[0-9a-f]+)$/, version => `npm:${version}`], // FontAwesome too; what is it with these registries that made them think using a different url pattern was a good idea?
[/^https:\/\/npm\.fontawesome\.com\/(?:@[^/]+)\/([^/]+)\/-\/([^/]+)\/\1-\2.tgz(?:#|$)/, version => `npm:${version}`], // These ones come from the old Yarn offline mirror - we assume they came from npm
[/^[^/]+\.tgz#[0-9a-f]+$/, version => `npm:${version}`]];
class LegacyMigrationResolver {
  constructor() {
    this.resolutions = null;
  }

  async setup(project, {
    report
  }) {
    const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(project.cwd, project.configuration.get(`lockfileFilename`)); // No need to enable it if the lockfile doesn't exist

    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.existsSync(lockfilePath)) return;
    const content = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.readFilePromise(lockfilePath, `utf8`);
    const parsed = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseSyml)(content); // No need to enable it either if the lockfile is modern

    if (Object.prototype.hasOwnProperty.call(parsed, `__metadata`)) return;
    const resolutions = this.resolutions = new Map();

    for (const key of Object.keys(parsed)) {
      let descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.tryParseDescriptor(key);

      if (!descriptor) {
        report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_5__.MessageName.YARN_IMPORT_FAILED, `Failed to parse the string "${key}" into a proper descriptor`);
        continue;
      }

      if (semver__WEBPACK_IMPORTED_MODULE_1___default().validRange(descriptor.range)) descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(descriptor, `npm:${descriptor.range}`);
      const {
        version,
        resolved
      } = parsed[key]; // Workspaces don't have the "resolved" key; we can skip them, as their
      // resolution will be recomputed when needed anyway

      if (!resolved) continue;
      let reference;

      for (const [pattern, matcher] of IMPORTED_PATTERNS) {
        const match = resolved.match(pattern);

        if (match) {
          reference = matcher(version, ...match);
          break;
        }
      }

      if (!reference) {
        report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_5__.MessageName.YARN_IMPORT_FAILED, `${_structUtils__WEBPACK_IMPORTED_MODULE_4__.prettyDescriptor(project.configuration, descriptor)}: Only some patterns can be imported from legacy lockfiles (not "${resolved}")`);
        continue;
      }

      const resolution = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeLocator(descriptor, reference);
      resolutions.set(descriptor.descriptorHash, resolution);
    }
  }

  supportsDescriptor(descriptor, opts) {
    if (!this.resolutions) return false;
    return this.resolutions.has(descriptor.descriptorHash);
  }

  supportsLocator(locator, opts) {
    // This resolver only supports the descriptor -> locator part of the
    // resolution, not the locator -> package one.
    return false;
  }

  shouldPersistResolution(locator, opts) {
    throw new Error(`Assertion failed: This resolver doesn't support resolving locators to packages`);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    if (!this.resolutions) throw new Error(`Assertion failed: The resolution store should have been setup`);
    const resolution = this.resolutions.get(descriptor.descriptorHash);
    if (!resolution) throw new Error(`Assertion failed: The resolution should have been registered`);
    return [resolution];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    throw new Error(`Assertion failed: This resolver doesn't support resolving locators to packages`);
  }

}

/***/ }),
/* 337 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LockfileResolver": () => /* binding */ LockfileResolver
/* harmony export */ });
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);

class LockfileResolver {
  supportsDescriptor(descriptor, opts) {
    const resolution = opts.project.storedResolutions.get(descriptor.descriptorHash);
    if (resolution) return true; // If the descriptor matches a package that's already been used, we can just use it even if we never resolved the range before
    // Ex: foo depends on bar@^1.0.0 that we resolved to foo@1.1.0, then we add a package qux that depends on foo@1.1.0 (without the caret)

    if (opts.project.originalPackages.has(_structUtils__WEBPACK_IMPORTED_MODULE_0__.convertDescriptorToLocator(descriptor).locatorHash)) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if (opts.project.originalPackages.has(locator.locatorHash)) return true;
    return false;
  }

  shouldPersistResolution(locator, opts) {
    throw new Error(`The shouldPersistResolution method shouldn't be called on the lockfile resolver, which would always answer yes`);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    let pkg = opts.project.originalPackages.get(_structUtils__WEBPACK_IMPORTED_MODULE_0__.convertDescriptorToLocator(descriptor).locatorHash);
    if (pkg) return [pkg];
    const resolution = opts.project.storedResolutions.get(descriptor.descriptorHash);
    if (!resolution) throw new Error(`Expected the resolution to have been successful - resolution not found`);
    pkg = opts.project.originalPackages.get(resolution);
    if (!pkg) throw new Error(`Expected the resolution to have been successful - package not found`);
    return [pkg];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    const pkg = opts.project.originalPackages.get(locator.locatorHash);
    if (!pkg) throw new Error(`The lockfile resolver isn't meant to resolve packages - they should already have been stored into a cache`);
    return pkg;
  }

}

/***/ }),
/* 338 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RunInstallPleaseResolver": () => /* binding */ RunInstallPleaseResolver
/* harmony export */ });
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(180);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(233);


class RunInstallPleaseResolver {
  constructor(resolver) {
    this.resolver = resolver;
  }

  supportsDescriptor(descriptor, opts) {
    return this.resolver.supportsDescriptor(descriptor, opts);
  }

  supportsLocator(locator, opts) {
    return this.resolver.supportsLocator(locator, opts);
  }

  shouldPersistResolution(locator, opts) {
    return this.resolver.shouldPersistResolution(locator, opts);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return this.resolver.bindDescriptor(descriptor, fromLocator, opts);
  }

  getResolutionDependencies(descriptor, opts) {
    return this.resolver.getResolutionDependencies(descriptor, opts);
  }

  async getCandidates(descriptor, dependencies, opts) {
    throw new _Report__WEBPACK_IMPORTED_MODULE_0__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.MISSING_LOCKFILE_ENTRY, `This package doesn't seem to be present in your lockfile; try to make an install to update your resolutions`);
  }

  async getSatisfying(descriptor, references, opts) {
    throw new _Report__WEBPACK_IMPORTED_MODULE_0__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.MISSING_LOCKFILE_ENTRY, `This package doesn't seem to be present in your lockfile; try to make an install to update your resolutions`);
  }

  async resolve(locator, opts) {
    throw new _Report__WEBPACK_IMPORTED_MODULE_0__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.MISSING_LOCKFILE_ENTRY, `This package doesn't seem to be present in your lockfile; try to make an install to update your resolutions`);
  }

}

/***/ }),
/* 339 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BuildType": () => /* binding */ BuildType
/* harmony export */ });
var BuildType;

(function (BuildType) {
  BuildType[BuildType["SCRIPT"] = 0] = "SCRIPT";
  BuildType[BuildType["SHELLCODE"] = 1] = "SHELLCODE";
})(BuildType || (BuildType = {}));

/***/ }),
/* 340 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeScriptEnv": () => /* binding */ makeScriptEnv,
/* harmony export */   "prepareExternalProject": () => /* binding */ prepareExternalProject,
/* harmony export */   "hasPackageScript": () => /* binding */ hasPackageScript,
/* harmony export */   "executePackageScript": () => /* binding */ executePackageScript,
/* harmony export */   "executePackageShellcode": () => /* binding */ executePackageShellcode,
/* harmony export */   "executeWorkspaceScript": () => /* binding */ executeWorkspaceScript,
/* harmony export */   "hasWorkspaceScript": () => /* binding */ hasWorkspaceScript,
/* harmony export */   "executeWorkspaceLifecycleScript": () => /* binding */ executeWorkspaceLifecycleScript,
/* harmony export */   "maybeExecuteWorkspaceLifecycleScript": () => /* binding */ maybeExecuteWorkspaceLifecycleScript,
/* harmony export */   "getPackageAccessibleBinaries": () => /* binding */ getPackageAccessibleBinaries,
/* harmony export */   "getWorkspaceAccessibleBinaries": () => /* binding */ getWorkspaceAccessibleBinaries,
/* harmony export */   "executePackageAccessibleBinary": () => /* binding */ executePackageAccessibleBinary,
/* harmony export */   "executeWorkspaceAccessibleBinary": () => /* binding */ executeWorkspaceAccessibleBinary
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(176);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(170);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(341);
/* harmony import */ var _yarnpkg_shell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(344);
/* harmony import */ var binjumper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(361);
/* harmony import */ var lodash_capitalize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(363);
/* harmony import */ var lodash_capitalize__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_capitalize__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(221);
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(p_limit__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(76);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _Manifest__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(237);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(180);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(233);
/* harmony import */ var _StreamReport__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(374);
/* harmony import */ var _YarnVersion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(372);
/* harmony import */ var _execUtils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(373);
/* harmony import */ var _formatUtils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(13);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(177);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(26);

















var PackageManager;

(function (PackageManager) {
  PackageManager["Yarn1"] = "Yarn Classic";
  PackageManager["Yarn2"] = "Yarn";
  PackageManager["Npm"] = "npm";
  PackageManager["Pnpm"] = "pnpm";
})(PackageManager || (PackageManager = {}));

async function makePathWrapper(location, name, argv0, args = []) {
  if (process.platform === `win32`) {
    await Promise.all([_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.writeFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.format({
      dir: location,
      name,
      ext: `.exe`
    }), (0,binjumper__WEBPACK_IMPORTED_MODULE_2__.getBinjumper)()), _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.writeFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.format({
      dir: location,
      name,
      ext: `.exe.info`
    }), [argv0, ...args].join(`\n`)), _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.writeFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.format({
      dir: location,
      name,
      ext: `.cmd`
    }), `@"${argv0}" ${args.map(arg => `"${arg.replace(`"`, `""`)}"`).join(` `)} %*\n`)]);
  }

  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.writeFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, name), `#!/bin/sh\nexec "${argv0}" ${args.map(arg => `'${arg.replace(/'/g, `'"'"'`)}'`).join(` `)} "$@"\n`);
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.chmodPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, name), 0o755);
}

async function detectPackageManager(location) {
  let yarnLock = null;

  try {
    yarnLock = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.readFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.Filename.lockfile), `utf8`);
  } catch (_a) {}

  if (yarnLock !== null) {
    if (yarnLock.match(/^__metadata:$/m)) {
      return PackageManager.Yarn2;
    } else {
      return PackageManager.Yarn1;
    }
  }

  if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, `package-lock.json`))) return PackageManager.Npm;
  if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, `pnpm-lock.yaml`))) return PackageManager.Pnpm;
  return null;
}

async function makeScriptEnv({
  project,
  binFolder,
  lifecycleScript
}) {
  const scriptEnv = {};

  for (const [key, value] of Object.entries(process.env)) if (typeof value !== `undefined`) scriptEnv[key.toLowerCase() !== `path` ? key : `PATH`] = value;

  const nBinFolder = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(binFolder); // We expose the base folder in the environment so that we can later add the
  // binaries for the dependencies of the active package

  scriptEnv.BERRY_BIN_FOLDER = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(nBinFolder); // Register some binaries that must be made available in all subprocesses
  // spawned by Yarn (we thus ensure that they always use the right version)

  await makePathWrapper(binFolder, `node`, process.execPath);

  if (_YarnVersion__WEBPACK_IMPORTED_MODULE_8__.YarnVersion !== null) {
    await makePathWrapper(binFolder, `run`, process.execPath, [process.argv[1], `run`]);
    await makePathWrapper(binFolder, `yarn`, process.execPath, [process.argv[1]]);
    await makePathWrapper(binFolder, `yarnpkg`, process.execPath, [process.argv[1]]);
    await makePathWrapper(binFolder, `node-gyp`, process.execPath, [process.argv[1], `run`, `--top-level`, `node-gyp`]);
  }

  if (project) scriptEnv.INIT_CWD = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(project.configuration.startingCwd);
  scriptEnv.PATH = scriptEnv.PATH ? `${nBinFolder}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.delimiter}${scriptEnv.PATH}` : `${nBinFolder}`;
  scriptEnv.npm_execpath = `${nBinFolder}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.sep}yarn`;
  scriptEnv.npm_node_execpath = `${nBinFolder}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.sep}node`;
  const version = _YarnVersion__WEBPACK_IMPORTED_MODULE_8__.YarnVersion !== null ? `yarn/${_YarnVersion__WEBPACK_IMPORTED_MODULE_8__.YarnVersion}` : `yarn/${_miscUtils__WEBPACK_IMPORTED_MODULE_9__.dynamicRequire(`@yarnpkg/core`).version}-core`;
  scriptEnv.npm_config_user_agent = `${version} npm/? node/${process.versions.node} ${process.platform} ${process.arch}`;
  if (lifecycleScript) scriptEnv.npm_lifecycle_event = lifecycleScript;

  if (project) {
    await project.configuration.triggerHook(hook => hook.setupScriptEnvironment, project, scriptEnv, async (name, argv0, args) => {
      return await makePathWrapper(binFolder, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.toFilename)(name), argv0, args);
    });
  }

  return scriptEnv;
}
/**
 * Given a folder, prepares this project for use. Runs `yarn install` then
 * `yarn build` if a `package.json` is found.
 */

const MAX_PREPARE_CONCURRENCY = 2;
const prepareLimit = p_limit__WEBPACK_IMPORTED_MODULE_4___default()(MAX_PREPARE_CONCURRENCY);
async function prepareExternalProject(cwd, outputPath, {
  configuration,
  report,
  workspace = null
}) {
  await prepareLimit(async () => {
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mktempPromise(async logDir => {
      const logFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(logDir, `pack.log`);
      const stdin = null;
      const {
        stdout,
        stderr
      } = configuration.getSubprocessStreams(logFile, {
        prefix: cwd,
        report
      });
      const packageManager = await detectPackageManager(cwd);
      let effectivePackageManager;

      if (packageManager !== null) {
        stdout.write(`Installing the project using ${packageManager}\n\n`);
        effectivePackageManager = packageManager;
      } else {
        stdout.write(`No package manager detected; defaulting to Yarn\n\n`);
        effectivePackageManager = PackageManager.Yarn2;
      }

      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mktempPromise(async binFolder => {
        const env = await makeScriptEnv({
          binFolder
        });
        const workflows = new Map([[PackageManager.Yarn1, async () => {
          const workspaceCli = workspace !== null ? [`workspace`, workspace] : []; // Makes sure that we'll be using Yarn 1.x

          const version = await _execUtils__WEBPACK_IMPORTED_MODULE_10__.pipevp(`yarn`, [`set`, `version`, `classic`, `--only-if-needed`], {
            cwd,
            env,
            stdin,
            stdout,
            stderr,
            end: _execUtils__WEBPACK_IMPORTED_MODULE_10__.EndStrategy.ErrorCode
          });
          if (version.code !== 0) return version.code; // Otherwise Yarn 1 will pack the .yarn directory :(

          await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.appendFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(cwd, `.npmignore`), `/.yarn\n`);
          stdout.write(`\n`); // Run an install; we can't avoid it unless we inspect the
          // package.json, which I don't want to do to keep the codebase
          // clean (even if it has a slight perf cost when cloning v1 repos)

          const install = await _execUtils__WEBPACK_IMPORTED_MODULE_10__.pipevp(`yarn`, [`install`], {
            cwd,
            env,
            stdin,
            stdout,
            stderr,
            end: _execUtils__WEBPACK_IMPORTED_MODULE_10__.EndStrategy.ErrorCode
          });
          if (install.code !== 0) return install.code;
          stdout.write(`\n`);
          const pack = await _execUtils__WEBPACK_IMPORTED_MODULE_10__.pipevp(`yarn`, [...workspaceCli, `pack`, `--filename`, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(outputPath)], {
            cwd,
            env,
            stdin,
            stdout,
            stderr
          });
          if (pack.code !== 0) return pack.code;
          return 0;
        }], [PackageManager.Yarn2, async () => {
          const workspaceCli = workspace !== null ? [`workspace`, workspace] : []; // We enable inline builds, because nobody wants to
          // read a logfile telling them to open another logfile

          env.YARN_ENABLE_INLINE_BUILDS = `1`; // If a lockfile doesn't exist we create a empty one to
          // prevent the project root detection from thinking it's in an
          // undeclared workspace when the user has a lockfile in their home
          // directory on Windows

          const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.Filename.lockfile);
          if (!(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.existsPromise(lockfilePath))) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.writeFilePromise(lockfilePath, ``); // Yarn 2 supports doing the install and the pack in a single command,
          // so we leverage that. We also don't need the "set version" call since
          // we're already operating within a Yarn 2 context (plus people should
          // really check-in their Yarn versions anyway).

          const pack = await _execUtils__WEBPACK_IMPORTED_MODULE_10__.pipevp(`yarn`, [...workspaceCli, `pack`, `--install-if-needed`, `--filename`, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(outputPath)], {
            cwd,
            env,
            stdin,
            stdout,
            stderr
          });
          if (pack.code !== 0) return pack.code;
          return 0;
        }], [PackageManager.Npm, async () => {
          if (workspace !== null) throw new Error(`Workspaces aren't supported by npm, which has been detected as the primary package manager for ${cwd}`); // Otherwise npm won't properly set the user agent, using the Yarn
          // one instead

          delete env.npm_config_user_agent; // We can't use `npm ci` because some projects don't have npm
          // lockfiles that are up-to-date. Hopefully npm won't decide
          // to change the versions randomly.

          const install = await _execUtils__WEBPACK_IMPORTED_MODULE_10__.pipevp(`npm`, [`install`], {
            cwd,
            env,
            stdin,
            stdout,
            stderr,
            end: _execUtils__WEBPACK_IMPORTED_MODULE_10__.EndStrategy.ErrorCode
          });
          if (install.code !== 0) return install.code;
          const packStream = new stream__WEBPACK_IMPORTED_MODULE_5__.PassThrough();
          const packPromise = _miscUtils__WEBPACK_IMPORTED_MODULE_9__.bufferStream(packStream);
          packStream.pipe(stdout); // It seems that npm doesn't support specifying the pack output path,
          // so we have to extract the stdout on top of forking it to the logs.

          const pack = await _execUtils__WEBPACK_IMPORTED_MODULE_10__.pipevp(`npm`, [`pack`, `--silent`], {
            cwd,
            env,
            stdin,
            stdout: packStream,
            stderr
          });
          if (pack.code !== 0) return pack.code;
          const packOutput = (await packPromise).toString().trim();
          const packTarget = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath(packOutput)); // Only then can we move the pack to its rightful location

          await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.renamePromise(packTarget, outputPath);
          return 0;
        }]]);
        const workflow = workflows.get(effectivePackageManager);
        if (typeof workflow === `undefined`) throw new Error(`Assertion failed: Unsupported workflow`);
        const code = await workflow();
        if (code === 0 || typeof code === `undefined`) return;
        _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.detachTemp(logDir);
        throw new _Report__WEBPACK_IMPORTED_MODULE_11__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_12__.MessageName.PACKAGE_PREPARATION_FAILED, `Packing the package failed (exit code ${code}, logs can be found here: ${logFile})`);
      });
    });
  });
}
async function hasPackageScript(locator, scriptName, {
  project
}) {
  const pkg = project.storedPackages.get(locator.locatorHash);
  if (!pkg) throw new Error(`Package for ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(project.configuration, locator)} not found in the project`);
  return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_14__.ZipOpenFS.openPromise(async zipOpenFs => {
    const configuration = project.configuration;
    const linkers = project.configuration.getLinkers();
    const linkerOptions = {
      project,
      report: new _StreamReport__WEBPACK_IMPORTED_MODULE_15__.StreamReport({
        stdout: new stream__WEBPACK_IMPORTED_MODULE_5__.PassThrough(),
        configuration
      })
    };
    const linker = linkers.find(linker => linker.supportsPackage(pkg, linkerOptions));
    if (!linker) throw new Error(`The package ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(project.configuration, pkg)} isn't supported by any of the available linkers`);
    const packageLocation = await linker.findPackageLocation(pkg, linkerOptions);
    const packageFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_16__.CwdFS(packageLocation, {
      baseFs: zipOpenFs
    });
    const manifest = await _Manifest__WEBPACK_IMPORTED_MODULE_17__.Manifest.find(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.dot, {
      baseFs: packageFs
    });
    return manifest.scripts.has(scriptName);
  }, {
    libzip: await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)()
  });
}
async function executePackageScript(locator, scriptName, args, {
  cwd,
  project,
  stdin,
  stdout,
  stderr
}) {
  return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mktempPromise(async binFolder => {
    const {
      manifest,
      env,
      cwd: realCwd
    } = await initializePackageEnvironment(locator, {
      project,
      binFolder,
      cwd,
      lifecycleScript: scriptName
    });
    const script = manifest.scripts.get(scriptName);
    if (typeof script === `undefined`) return 1;

    const realExecutor = async () => {
      return await (0,_yarnpkg_shell__WEBPACK_IMPORTED_MODULE_1__.execute)(script, args, {
        cwd: realCwd,
        env,
        stdin,
        stdout,
        stderr
      });
    };

    const executor = await project.configuration.reduceHook(hooks => {
      return hooks.wrapScriptExecution;
    }, realExecutor, project, locator, scriptName, {
      script,
      args,
      cwd: realCwd,
      env,
      stdin,
      stdout,
      stderr
    });
    return await executor();
  });
}
async function executePackageShellcode(locator, command, args, {
  cwd,
  project,
  stdin,
  stdout,
  stderr
}) {
  return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mktempPromise(async binFolder => {
    const {
      env,
      cwd: realCwd
    } = await initializePackageEnvironment(locator, {
      project,
      binFolder,
      cwd
    });
    return await (0,_yarnpkg_shell__WEBPACK_IMPORTED_MODULE_1__.execute)(command, args, {
      cwd: realCwd,
      env,
      stdin,
      stdout,
      stderr
    });
  });
}

async function initializePackageEnvironment(locator, {
  project,
  binFolder,
  cwd,
  lifecycleScript
}) {
  const pkg = project.storedPackages.get(locator.locatorHash);
  if (!pkg) throw new Error(`Package for ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(project.configuration, locator)} not found in the project`);
  return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_14__.ZipOpenFS.openPromise(async zipOpenFs => {
    const configuration = project.configuration;
    const linkers = project.configuration.getLinkers();
    const linkerOptions = {
      project,
      report: new _StreamReport__WEBPACK_IMPORTED_MODULE_15__.StreamReport({
        stdout: new stream__WEBPACK_IMPORTED_MODULE_5__.PassThrough(),
        configuration
      })
    };
    const linker = linkers.find(linker => linker.supportsPackage(pkg, linkerOptions));
    if (!linker) throw new Error(`The package ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(project.configuration, pkg)} isn't supported by any of the available linkers`);
    const env = await makeScriptEnv({
      project,
      binFolder,
      lifecycleScript
    });
    await Promise.all(Array.from(await getPackageAccessibleBinaries(locator, {
      project
    }), ([binaryName, [, binaryPath]]) => makePathWrapper(binFolder, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.toFilename)(binaryName), process.execPath, [binaryPath])));
    const packageLocation = await linker.findPackageLocation(pkg, linkerOptions);
    const packageFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_16__.CwdFS(packageLocation, {
      baseFs: zipOpenFs
    });
    const manifest = await _Manifest__WEBPACK_IMPORTED_MODULE_17__.Manifest.find(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.dot, {
      baseFs: packageFs
    });
    if (typeof cwd === `undefined`) cwd = packageLocation;
    return {
      manifest,
      binFolder,
      env,
      cwd
    };
  }, {
    libzip: await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)()
  });
}

async function executeWorkspaceScript(workspace, scriptName, args, {
  cwd,
  stdin,
  stdout,
  stderr
}) {
  return await executePackageScript(workspace.anchoredLocator, scriptName, args, {
    cwd,
    project: workspace.project,
    stdin,
    stdout,
    stderr
  });
}
function hasWorkspaceScript(workspace, scriptName) {
  return workspace.manifest.scripts.has(scriptName);
}
async function executeWorkspaceLifecycleScript(workspace, lifecycleScriptName, {
  cwd,
  report
}) {
  const {
    configuration
  } = workspace.project;
  const stdin = null;
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mktempPromise(async logDir => {
    const logFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(logDir, `${lifecycleScriptName}.log`);
    const header = `# This file contains the result of Yarn calling the "${lifecycleScriptName}" lifecycle script inside a workspace ("${workspace.cwd}")\n`;
    const {
      stdout,
      stderr
    } = configuration.getSubprocessStreams(logFile, {
      report,
      prefix: _structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(configuration, workspace.anchoredLocator),
      header
    });
    report.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_12__.MessageName.LIFECYCLE_SCRIPT, `Calling the "${lifecycleScriptName}" lifecycle script`);
    const exitCode = await executeWorkspaceScript(workspace, lifecycleScriptName, [], {
      cwd,
      stdin,
      stdout,
      stderr
    });
    stdout.end();
    stderr.end();

    if (exitCode !== 0) {
      _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.detachTemp(logDir);
      throw new _Report__WEBPACK_IMPORTED_MODULE_11__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_12__.MessageName.LIFECYCLE_SCRIPT, `${lodash_capitalize__WEBPACK_IMPORTED_MODULE_3___default()(lifecycleScriptName)} script failed (exit code ${_formatUtils__WEBPACK_IMPORTED_MODULE_18__.pretty(configuration, exitCode, _formatUtils__WEBPACK_IMPORTED_MODULE_18__.Type.NUMBER)}, logs can be found here: ${_formatUtils__WEBPACK_IMPORTED_MODULE_18__.pretty(configuration, logFile, _formatUtils__WEBPACK_IMPORTED_MODULE_18__.Type.PATH)}); run ${_formatUtils__WEBPACK_IMPORTED_MODULE_18__.pretty(configuration, `yarn ${lifecycleScriptName}`, _formatUtils__WEBPACK_IMPORTED_MODULE_18__.Type.CODE)} to investigate`);
    }
  });
}
async function maybeExecuteWorkspaceLifecycleScript(workspace, lifecycleScriptName, opts) {
  if (hasWorkspaceScript(workspace, lifecycleScriptName)) {
    await executeWorkspaceLifecycleScript(workspace, lifecycleScriptName, opts);
  }
}
/**
 * Return the binaries that can be accessed by the specified package
 *
 * @param locator The queried package
 * @param project The project owning the package
 */

async function getPackageAccessibleBinaries(locator, {
  project
}) {
  const configuration = project.configuration;
  const binaries = new Map();
  const pkg = project.storedPackages.get(locator.locatorHash);
  if (!pkg) throw new Error(`Package for ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(configuration, locator)} not found in the project`);
  const stdout = new stream__WEBPACK_IMPORTED_MODULE_5__.Writable();
  const linkers = configuration.getLinkers();
  const linkerOptions = {
    project,
    report: new _StreamReport__WEBPACK_IMPORTED_MODULE_15__.StreamReport({
      configuration,
      stdout
    })
  };
  const visibleLocators = new Set([locator.locatorHash]);

  for (const descriptor of pkg.dependencies.values()) {
    const resolution = project.storedResolutions.get(descriptor.descriptorHash);
    if (!resolution) throw new Error(`Assertion failed: The resolution (${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(configuration, descriptor)}) should have been registered`);
    visibleLocators.add(resolution);
  }

  for (const locatorHash of visibleLocators) {
    const dependency = project.storedPackages.get(locatorHash);
    if (!dependency) throw new Error(`Assertion failed: The package (${locatorHash}) should have been registered`);
    if (dependency.bin.size === 0) continue;
    const linker = linkers.find(linker => linker.supportsPackage(dependency, linkerOptions));
    if (!linker) continue;
    let packageLocation = null;

    try {
      packageLocation = await linker.findPackageLocation(dependency, linkerOptions);
    } catch (err) {
      // Some packages may not be installed when they are incompatible
      // with the current system.
      if (err.code === `LOCATOR_NOT_INSTALLED`) {
        continue;
      } else {
        throw err;
      }
    }

    for (const [name, target] of dependency.bin) {
      binaries.set(name, [dependency, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(packageLocation, target))]);
    }
  }

  return binaries;
}
/**
 * Return the binaries that can be accessed by the specified workspace
 *
 * @param workspace The queried workspace
 */

async function getWorkspaceAccessibleBinaries(workspace) {
  return await getPackageAccessibleBinaries(workspace.anchoredLocator, {
    project: workspace.project
  });
}
/**
 * Execute a binary from the specified package.
 *
 * Note that "binary" in this sense means "a Javascript file". Actual native
 * binaries cannot be executed this way, because we use Node in order to
 * transparently read from the archives.
 *
 * @param locator The queried package
 * @param binaryName The name of the binary file to execute
 * @param args The arguments to pass to the file
 */

async function executePackageAccessibleBinary(locator, binaryName, args, {
  cwd,
  project,
  stdin,
  stdout,
  stderr,
  nodeArgs = []
}) {
  const packageAccessibleBinaries = await getPackageAccessibleBinaries(locator, {
    project
  });
  const binary = packageAccessibleBinaries.get(binaryName);
  if (!binary) throw new Error(`Binary not found (${binaryName}) for ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(project.configuration, locator)}`);
  return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mktempPromise(async binFolder => {
    const [, binaryPath] = binary;
    const env = await makeScriptEnv({
      project,
      binFolder
    });
    await Promise.all(Array.from(packageAccessibleBinaries, ([binaryName, [, binaryPath]]) => makePathWrapper(env.BERRY_BIN_FOLDER, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.toFilename)(binaryName), process.execPath, [binaryPath])));
    let result;

    try {
      result = await _execUtils__WEBPACK_IMPORTED_MODULE_10__.pipevp(process.execPath, [...nodeArgs, binaryPath, ...args], {
        cwd,
        env,
        stdin,
        stdout,
        stderr
      });
    } finally {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(env.BERRY_BIN_FOLDER);
    }

    return result.code;
  });
}
/**
 * Execute a binary from the specified workspace
 *
 * @param workspace The queried package
 * @param binaryName The name of the binary file to execute
 * @param args The arguments to pass to the file
 */

async function executeWorkspaceAccessibleBinary(workspace, binaryName, args, {
  cwd,
  stdin,
  stdout,
  stderr
}) {
  return await executePackageAccessibleBinary(workspace.anchoredLocator, binaryName, args, {
    project: workspace.project,
    cwd,
    stdin,
    stdout,
    stderr
  });
}

/***/ }),
/* 341 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getLibzipSync": () => /* binding */ getLibzipSync,
/* harmony export */   "getLibzipPromise": () => /* binding */ getLibzipPromise
/* harmony export */ });
/* harmony import */ var _makeInterface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(342);

let mod = null;
function getLibzipSync() {
  if (mod === null) mod = (0,_makeInterface__WEBPACK_IMPORTED_MODULE_0__.makeInterface)(__webpack_require__(343));
  return mod;
}
async function getLibzipPromise() {
  return getLibzipSync();
}

/***/ }),
/* 342 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Errors": () => /* binding */ Errors,
/* harmony export */   "makeInterface": () => /* binding */ makeInterface
/* harmony export */ });
const number64 = [`number`, `number`];
var Errors;

(function (Errors) {
  Errors[Errors["ZIP_ER_OK"] = 0] = "ZIP_ER_OK";
  Errors[Errors["ZIP_ER_MULTIDISK"] = 1] = "ZIP_ER_MULTIDISK";
  Errors[Errors["ZIP_ER_RENAME"] = 2] = "ZIP_ER_RENAME";
  Errors[Errors["ZIP_ER_CLOSE"] = 3] = "ZIP_ER_CLOSE";
  Errors[Errors["ZIP_ER_SEEK"] = 4] = "ZIP_ER_SEEK";
  Errors[Errors["ZIP_ER_READ"] = 5] = "ZIP_ER_READ";
  Errors[Errors["ZIP_ER_WRITE"] = 6] = "ZIP_ER_WRITE";
  Errors[Errors["ZIP_ER_CRC"] = 7] = "ZIP_ER_CRC";
  Errors[Errors["ZIP_ER_ZIPCLOSED"] = 8] = "ZIP_ER_ZIPCLOSED";
  Errors[Errors["ZIP_ER_NOENT"] = 9] = "ZIP_ER_NOENT";
  Errors[Errors["ZIP_ER_EXISTS"] = 10] = "ZIP_ER_EXISTS";
  Errors[Errors["ZIP_ER_OPEN"] = 11] = "ZIP_ER_OPEN";
  Errors[Errors["ZIP_ER_TMPOPEN"] = 12] = "ZIP_ER_TMPOPEN";
  Errors[Errors["ZIP_ER_ZLIB"] = 13] = "ZIP_ER_ZLIB";
  Errors[Errors["ZIP_ER_MEMORY"] = 14] = "ZIP_ER_MEMORY";
  Errors[Errors["ZIP_ER_CHANGED"] = 15] = "ZIP_ER_CHANGED";
  Errors[Errors["ZIP_ER_COMPNOTSUPP"] = 16] = "ZIP_ER_COMPNOTSUPP";
  Errors[Errors["ZIP_ER_EOF"] = 17] = "ZIP_ER_EOF";
  Errors[Errors["ZIP_ER_INVAL"] = 18] = "ZIP_ER_INVAL";
  Errors[Errors["ZIP_ER_NOZIP"] = 19] = "ZIP_ER_NOZIP";
  Errors[Errors["ZIP_ER_INTERNAL"] = 20] = "ZIP_ER_INTERNAL";
  Errors[Errors["ZIP_ER_INCONS"] = 21] = "ZIP_ER_INCONS";
  Errors[Errors["ZIP_ER_REMOVE"] = 22] = "ZIP_ER_REMOVE";
  Errors[Errors["ZIP_ER_DELETED"] = 23] = "ZIP_ER_DELETED";
  Errors[Errors["ZIP_ER_ENCRNOTSUPP"] = 24] = "ZIP_ER_ENCRNOTSUPP";
  Errors[Errors["ZIP_ER_RDONLY"] = 25] = "ZIP_ER_RDONLY";
  Errors[Errors["ZIP_ER_NOPASSWD"] = 26] = "ZIP_ER_NOPASSWD";
  Errors[Errors["ZIP_ER_WRONGPASSWD"] = 27] = "ZIP_ER_WRONGPASSWD";
  Errors[Errors["ZIP_ER_OPNOTSUPP"] = 28] = "ZIP_ER_OPNOTSUPP";
  Errors[Errors["ZIP_ER_INUSE"] = 29] = "ZIP_ER_INUSE";
  Errors[Errors["ZIP_ER_TELL"] = 30] = "ZIP_ER_TELL";
  Errors[Errors["ZIP_ER_COMPRESSED_DATA"] = 31] = "ZIP_ER_COMPRESSED_DATA";
})(Errors || (Errors = {}));

const makeInterface = libzip => ({
  // Those are getters because they can change after memory growth
  get HEAP8() {
    return libzip.HEAP8;
  },

  get HEAPU8() {
    return libzip.HEAPU8;
  },

  errors: Errors,
  SEEK_SET: 0,
  SEEK_CUR: 1,
  SEEK_END: 2,
  ZIP_CHECKCONS: 4,
  ZIP_CREATE: 1,
  ZIP_EXCL: 2,
  ZIP_TRUNCATE: 8,
  ZIP_RDONLY: 16,
  ZIP_FL_OVERWRITE: 8192,
  ZIP_FL_COMPRESSED: 4,
  ZIP_OPSYS_DOS: 0x00,
  ZIP_OPSYS_AMIGA: 0x01,
  ZIP_OPSYS_OPENVMS: 0x02,
  ZIP_OPSYS_UNIX: 0x03,
  ZIP_OPSYS_VM_CMS: 0x04,
  ZIP_OPSYS_ATARI_ST: 0x05,
  ZIP_OPSYS_OS_2: 0x06,
  ZIP_OPSYS_MACINTOSH: 0x07,
  ZIP_OPSYS_Z_SYSTEM: 0x08,
  ZIP_OPSYS_CPM: 0x09,
  ZIP_OPSYS_WINDOWS_NTFS: 0x0a,
  ZIP_OPSYS_MVS: 0x0b,
  ZIP_OPSYS_VSE: 0x0c,
  ZIP_OPSYS_ACORN_RISC: 0x0d,
  ZIP_OPSYS_VFAT: 0x0e,
  ZIP_OPSYS_ALTERNATE_MVS: 0x0f,
  ZIP_OPSYS_BEOS: 0x10,
  ZIP_OPSYS_TANDEM: 0x11,
  ZIP_OPSYS_OS_400: 0x12,
  ZIP_OPSYS_OS_X: 0x13,
  ZIP_CM_DEFAULT: -1,
  ZIP_CM_STORE: 0,
  ZIP_CM_DEFLATE: 8,
  uint08S: libzip._malloc(1),
  uint16S: libzip._malloc(2),
  uint32S: libzip._malloc(4),
  uint64S: libzip._malloc(8),
  malloc: libzip._malloc,
  free: libzip._free,
  getValue: libzip.getValue,
  open: libzip.cwrap(`zip_open`, `number`, [`string`, `number`, `number`]),
  openFromSource: libzip.cwrap(`zip_open_from_source`, `number`, [`number`, `number`, `number`]),
  close: libzip.cwrap(`zip_close`, `number`, [`number`]),
  discard: libzip.cwrap(`zip_discard`, null, [`number`]),
  getError: libzip.cwrap(`zip_get_error`, `number`, [`number`]),
  getName: libzip.cwrap(`zip_get_name`, `string`, [`number`, `number`, `number`]),
  getNumEntries: libzip.cwrap(`zip_get_num_entries`, `number`, [`number`, `number`]),
  delete: libzip.cwrap(`zip_delete`, `number`, [`number`, `number`]),
  stat: libzip.cwrap(`zip_stat`, `number`, [`number`, `string`, `number`, `number`]),
  statIndex: libzip.cwrap(`zip_stat_index`, `number`, [`number`, ...number64, `number`, `number`]),
  fopen: libzip.cwrap(`zip_fopen`, `number`, [`number`, `string`, `number`]),
  fopenIndex: libzip.cwrap(`zip_fopen_index`, `number`, [`number`, ...number64, `number`]),
  fread: libzip.cwrap(`zip_fread`, `number`, [`number`, `number`, `number`, `number`]),
  fclose: libzip.cwrap(`zip_fclose`, `number`, [`number`]),
  dir: {
    add: libzip.cwrap(`zip_dir_add`, `number`, [`number`, `string`])
  },
  file: {
    add: libzip.cwrap(`zip_file_add`, `number`, [`number`, `string`, `number`, `number`]),
    getError: libzip.cwrap(`zip_file_get_error`, `number`, [`number`]),
    getExternalAttributes: libzip.cwrap(`zip_file_get_external_attributes`, `number`, [`number`, ...number64, `number`, `number`, `number`]),
    setExternalAttributes: libzip.cwrap(`zip_file_set_external_attributes`, `number`, [`number`, ...number64, `number`, `number`, `number`]),
    setMtime: libzip.cwrap(`zip_file_set_mtime`, `number`, [`number`, ...number64, `number`, `number`]),
    setCompression: libzip.cwrap(`zip_set_file_compression`, `number`, [`number`, ...number64, `number`, `number`])
  },
  ext: {
    countSymlinks: libzip.cwrap(`zip_ext_count_symlinks`, `number`, [`number`])
  },
  error: {
    initWithCode: libzip.cwrap(`zip_error_init_with_code`, null, [`number`, `number`]),
    strerror: libzip.cwrap(`zip_error_strerror`, `string`, [`number`])
  },
  name: {
    locate: libzip.cwrap(`zip_name_locate`, `number`, [`number`, `string`, `number`])
  },
  source: {
    fromUnattachedBuffer: libzip.cwrap(`zip_source_buffer_create`, `number`, [`number`, `number`, `number`, `number`]),
    fromBuffer: libzip.cwrap(`zip_source_buffer`, `number`, [`number`, `number`, ...number64, `number`]),
    free: libzip.cwrap(`zip_source_free`, null, [`number`]),
    keep: libzip.cwrap(`zip_source_keep`, null, [`number`]),
    open: libzip.cwrap(`zip_source_open`, `number`, [`number`]),
    close: libzip.cwrap(`zip_source_close`, `number`, [`number`]),
    seek: libzip.cwrap(`zip_source_seek`, `number`, [`number`, ...number64, `number`]),
    tell: libzip.cwrap(`zip_source_tell`, `number`, [`number`]),
    read: libzip.cwrap(`zip_source_read`, `number`, [`number`, `number`, `number`]),
    error: libzip.cwrap(`zip_source_error`, `number`, [`number`]),
    setMtime: libzip.cwrap(`zip_source_set_mtime`, `number`, [`number`, `number`])
  },
  struct: {
    stat: libzip.cwrap(`zipstruct_stat`, `number`, []),
    statS: libzip.cwrap(`zipstruct_statS`, `number`, []),
    statName: libzip.cwrap(`zipstruct_stat_name`, `string`, [`number`]),
    statIndex: libzip.cwrap(`zipstruct_stat_index`, `number`, [`number`]),
    statSize: libzip.cwrap(`zipstruct_stat_size`, `number`, [`number`]),
    statCompSize: libzip.cwrap(`zipstruct_stat_comp_size`, `number`, [`number`]),
    statCompMethod: libzip.cwrap(`zipstruct_stat_comp_method`, `number`, [`number`]),
    statMtime: libzip.cwrap(`zipstruct_stat_mtime`, `number`, [`number`]),
    error: libzip.cwrap(`zipstruct_error`, `number`, []),
    errorS: libzip.cwrap(`zipstruct_errorS`, `number`, []),
    errorCodeZip: libzip.cwrap(`zipstruct_error_code_zip`, `number`, [`number`])
  }
});

/***/ }),
/* 343 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var frozenFs = Object.assign({}, __webpack_require__(8));
var Module = typeof Module !== "undefined" ? Module : {};
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}
var arguments_ = [];
var thisProgram = "./this.program";
var quit_ = function(status, toThrow) {
  throw toThrow;
};
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = true;
var scriptDirectory = "";
function locateFile(path) {
  if (Module["locateFile"]) {
    return Module["locateFile"](path, scriptDirectory);
  }
  return scriptDirectory + path;
}
var read_, readBinary;
var nodeFS;
var nodePath;
if (ENVIRONMENT_IS_NODE) {
  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = __webpack_require__(84).dirname(scriptDirectory) + "/";
  } else {
    scriptDirectory = __dirname + "/";
  }
  read_ = function shell_read(filename, binary) {
    var ret = tryParseAsDataURI(filename);
    if (ret) {
      return binary ? ret : ret.toString();
    }
    if (!nodeFS) nodeFS = frozenFs;
    if (!nodePath) nodePath = __webpack_require__(84);
    filename = nodePath["normalize"](filename);
    return nodeFS["readFileSync"](filename, binary ? null : "utf8");
  };
  readBinary = function readBinary(filename) {
    var ret = read_(filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };
  if (process["argv"].length > 1) {
    thisProgram = process["argv"][1].replace(/\\/g, "/");
  }
  arguments_ = process["argv"].slice(2);
  if (true) {
    module["exports"] = Module;
  }
  quit_ = function(status) {
    process["exit"](status);
  };
  Module["inspect"] = function() {
    return "[Emscripten Module object]";
  };
} else {
}
var out = Module["print"] || console.log.bind(console);
var err = Module["printErr"] || console.warn.bind(console);
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
moduleOverrides = null;
if (Module["arguments"]) arguments_ = Module["arguments"];
if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
if (Module["quit"]) quit_ = Module["quit"];
var STACK_ALIGN = 16;
function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN;
  return Math.ceil(size / factor) * factor;
}
var tempRet0 = 0;
var setTempRet0 = function(value) {
  tempRet0 = value;
};
var wasmBinary;
if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
var noExitRuntime;
if (Module["noExitRuntime"]) noExitRuntime = Module["noExitRuntime"];
if (typeof WebAssembly !== "object") {
  abort("no native wasm support detected");
}
function getValue(ptr, type, noSafe) {
  type = type || "i8";
  if (type.charAt(type.length - 1) === "*") type = "i32";
  switch (type) {
    case "i1":
      return HEAP8[ptr >> 0];
    case "i8":
      return HEAP8[ptr >> 0];
    case "i16":
      return HEAP16[ptr >> 1];
    case "i32":
      return HEAP32[ptr >> 2];
    case "i64":
      return HEAP32[ptr >> 2];
    case "float":
      return HEAPF32[ptr >> 2];
    case "double":
      return HEAPF64[ptr >> 3];
    default:
      abort("invalid type for getValue: " + type);
  }
  return null;
}
var wasmMemory;
var wasmTable = new WebAssembly.Table({
  initial: 31,
  maximum: 31,
  element: "anyfunc"
});
var ABORT = false;
var EXITSTATUS = 0;
function assert(condition, text) {
  if (!condition) {
    abort("Assertion failed: " + text);
  }
}
function getCFunc(ident) {
  var func = Module["_" + ident];
  assert(
    func,
    "Cannot call unknown function " + ident + ", make sure it is exported"
  );
  return func;
}
function ccall(ident, returnType, argTypes, args, opts) {
  var toC = {
    string: function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) {
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    array: function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };
  function convertReturnValue(ret) {
    if (returnType === "string") return UTF8ToString(ret);
    if (returnType === "boolean") return Boolean(ret);
    return ret;
  }
  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  return ret;
}
function cwrap(ident, returnType, argTypes, opts) {
  argTypes = argTypes || [];
  var numericArgs = argTypes.every(function(type) {
    return type === "number";
  });
  var numericRet = returnType !== "string";
  if (numericRet && numericArgs && !opts) {
    return getCFunc(ident);
  }
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  };
}
var UTF8Decoder =
  typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;
function UTF8ArrayToString(heap, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(heap.subarray(idx, endPtr));
  } else {
    var str = "";
    while (idx < endPtr) {
      var u0 = heap[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heap[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode(((u0 & 31) << 6) | u1);
        continue;
      }
      var u2 = heap[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));
      }
    }
  }
  return str;
}
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
}
function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) return 0;
  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1;
  for (var i = 0; i < str.length; ++i) {
    var u = str.charCodeAt(i);
    if (u >= 55296 && u <= 57343) {
      var u1 = str.charCodeAt(++i);
      u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);
    }
    if (u <= 127) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 2047) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 192 | (u >> 6);
      heap[outIdx++] = 128 | (u & 63);
    } else if (u <= 65535) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 224 | (u >> 12);
      heap[outIdx++] = 128 | ((u >> 6) & 63);
      heap[outIdx++] = 128 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 240 | (u >> 18);
      heap[outIdx++] = 128 | ((u >> 12) & 63);
      heap[outIdx++] = 128 | ((u >> 6) & 63);
      heap[outIdx++] = 128 | (u & 63);
    }
  }
  heap[outIdx] = 0;
  return outIdx - startIdx;
}
function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    var u = str.charCodeAt(i);
    if (u >= 55296 && u <= 57343)
      u = (65536 + ((u & 1023) << 10)) | (str.charCodeAt(++i) & 1023);
    if (u <= 127) ++len;
    else if (u <= 2047) len += 2;
    else if (u <= 65535) len += 3;
    else len += 4;
  }
  return len;
}
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}
function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}
var WASM_PAGE_SIZE = 65536;
function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}
var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module["HEAP8"] = HEAP8 = new Int8Array(buf);
  Module["HEAP16"] = HEAP16 = new Int16Array(buf);
  Module["HEAP32"] = HEAP32 = new Int32Array(buf);
  Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
  Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
  Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
  Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
  Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
}
var INITIAL_INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
if (Module["wasmMemory"]) {
  wasmMemory = Module["wasmMemory"];
} else {
  wasmMemory = new WebAssembly.Memory({
    initial: INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,
    maximum: 2147483648 / WASM_PAGE_SIZE
  });
}
if (wasmMemory) {
  buffer = wasmMemory.buffer;
}
INITIAL_INITIAL_MEMORY = buffer.byteLength;
updateGlobalBufferAndViews(buffer);
var __ATPRERUN__ = [];
var __ATINIT__ = [];
var __ATMAIN__ = [];
var __ATPOSTRUN__ = [];
var runtimeInitialized = false;
function preRun() {
  if (Module["preRun"]) {
    if (typeof Module["preRun"] == "function")
      Module["preRun"] = [Module["preRun"]];
    while (Module["preRun"].length) {
      addOnPreRun(Module["preRun"].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}
function initRuntime() {
  runtimeInitialized = true;
  if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
  TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}
function preMain() {
  FS.ignorePermissions = false;
  callRuntimeCallbacks(__ATMAIN__);
}
function postRun() {
  if (Module["postRun"]) {
    if (typeof Module["postRun"] == "function")
      Module["postRun"] = [Module["postRun"]];
    while (Module["postRun"].length) {
      addOnPostRun(Module["postRun"].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}
function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}
function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}
var Math_abs = Math.abs;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_min = Math.min;
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null;
function getUniqueRunDependency(id) {
  return id;
}
function addRunDependency(id) {
  runDependencies++;
  if (Module["monitorRunDependencies"]) {
    Module["monitorRunDependencies"](runDependencies);
  }
}
function removeRunDependency(id) {
  runDependencies--;
  if (Module["monitorRunDependencies"]) {
    Module["monitorRunDependencies"](runDependencies);
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback();
    }
  }
}
Module["preloadedImages"] = {};
Module["preloadedAudios"] = {};
function abort(what) {
  if (Module["onAbort"]) {
    Module["onAbort"](what);
  }
  what += "";
  err(what);
  ABORT = true;
  EXITSTATUS = 1;
  what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
  var e = new WebAssembly.RuntimeError(what);
  throw e;
}
function hasPrefix(str, prefix) {
  return String.prototype.startsWith
    ? str.startsWith(prefix)
    : str.indexOf(prefix) === 0;
}
var dataURIPrefix = "data:application/octet-stream;base64,";
function isDataURI(filename) {
  return hasPrefix(filename, dataURIPrefix);
}
var wasmBinaryFile =
  "data:application/octet-stream;base64,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AkEgaiQAC4sDAQF/IwBBMGsiAyQAIAMgADYCJCADIAE2AiAgAyACNwMYAkAgAygCJC0AKEEBcQRAIANCfzcDKAwBCwJAAkAgAygCJCgCIEEATQ0AIAMpAxhC////////////AFYNACADKQMYQgBYDQEgAygCIA0BCyADKAIkQQxqQRJBABAVIANCfzcDKAwBCyADKAIkLQA1QQFxBEAgA0J/NwMoDAELAn8jAEEQayIAIAMoAiQ2AgwgACgCDC0ANEEBcQsEQCADQgA3AygMAQsgAykDGFAEQCADQgA3AygMAQsgA0IANwMQA0AgAykDECADKQMYVARAIAMgAygCJCADKAIgIAMpAxCnaiADKQMYIAMpAxB9QQEQIiICNwMIIAJCAFMEQCADKAIkQQE6ADUgAykDEFAEQCADQn83AygMBAsgAyADKQMQNwMoDAMLIAMpAwhQBEAgAygCJEEBOgA0BSADIAMpAwggAykDEHw3AxAMAgsLCyADIAMpAxA3AygLIAMpAyghAiADQTBqJAAgAgs2AQF/IwBBEGsiASAANgIMAn4gASgCDC0AAEEBcQRAIAEoAgwpAwggASgCDCkDEH0MAQtCAAsLsgECAX8BfiMAQRBrIgEkACABIAA2AgQgASABKAIEQggQHzYCAAJAIAEoAgBFBEAgAUIANwMIDAELIAEgASgCAC0AAK0gASgCAC0AB61COIYgASgCAC0ABq1CMIZ8IAEoAgAtAAWtQiiGfCABKAIALQAErUIghnwgASgCAC0AA61CGIZ8IAEoAgAtAAKtQhCGfCABKAIALQABrUIIhnx8NwMICyABKQMIIQIgAUEQaiQAIAILqAEBAX8jAEEQayIBJAAgASAANgIIAkAgASgCCCgCIEEATQRAIAEoAghBDGpBEkEAEBUgAUF/NgIMDAELIAEoAggiACAAKAIgQX9qNgIgIAEoAggoAiBFBEAgASgCCEEAQgBBAhAiGiABKAIIKAIABEAgASgCCCgCABAyQQBIBEAgASgCCEEMakEUQQAQFQsLCyABQQA2AgwLIAEoAgwhACABQRBqJAAgAAvxAgICfwF+AkAgAkUNACAAIAJqIgNBf2ogAToAACAAIAE6AAAgAkEDSQ0AIANBfmogAToAACAAIAE6AAEgA0F9aiABOgAAIAAgAToAAiACQQdJDQAgA0F8aiAB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ECwQMwsgASgCDCgCVBAWIAEoAgxBADYCVAsgAUEQaiQAC/EBAQF/IwBBEGsiASAANgIMIAEoAgxBADYCACABKAIMQQA6AAQgASgCDEEAOgAFIAEoAgxBAToABiABKAIMQb8GOwEIIAEoAgxBCjsBCiABKAIMQQA7AQwgASgCDEF/NgIQIAEoAgxBADYCFCABKAIMQQA2AhggASgCDEIANwMgIAEoAgxCADcDKCABKAIMQQA2AjAgASgCDEEANgI0IAEoAgxBADYCOCABKAIMQQA2AjwgASgCDEEAOwFAIAEoAgxBgIDYjXg2AkQgASgCDEIANwNIIAEoAgxBADsBUCABKAIMQQA7AVIgASgCDEEANgJUC9oTAQF/IwBBsAFrIgMkACADIAA2AqgBIAMgATYCpAEgAyACNgKgASADQQA2ApABIAMgAygCpAEoAjBBABA7NgKUASADIAMoAqQBKAI4QQAQOzYCmAECQAJAAkACQCADKAKUAUECRgRAIAMoApgBQQFGDQELIAMoApQBQQFGBEAgAygCmAFBAkYNAQsgAygClAFBAkcNASADKAKYAUECRw0BCyADKAKkASIAIAAvAQxBgBByOwEMDAELIAMoAqQBIgAgAC8BDEH/7wNxOwEMIAMoApQBQQJGBEAgA0H14AEgAygCpAEoAjAgAygCqAFBCGoQxAE2ApABIAMoApABRQRAIANBfzYCrAEMAwsLAkAgAygCoAFBgAJxDQAgAygCmAFBAkcNACADQfXGASADKAKkASgCOCADKAKoAUEIahDEATYCSCADKAJIRQRAIAMoApABECQgA0F/NgKsAQwDCyADKAJIIAMoApABNgIAIAMgAygCSDYCkAELCwJAIAMoAqQBLwFSRQRAIAMoAqQBIgAgAC8BDEH+/wNxOwEMDAELIAMoAqQBIgAgAC8BDEEBcjsBDAsgAyADKAKkASADKAKgARCAAUEBcToAhgEgAyADKAKgAUGACnFBgApHBH8gAy0AhgEFQQELQQFxOgCHASADAn9BASADKAKkAS8BUkGBAkYNABpBASADKAKkAS8BUkGCAkYNABogAygCpAEvAVJBgwJGC0EBcToAhQEgAy0AhwFBAXEEQCADIANBIGpCHBAqNgIcIAMoAhxFBEAgAygCqAFBCGpBDkEAEBUgAygCkAEQJCADQX82AqwBDAILAkAgAygCoAFBgAJxBEACQCADKAKgAUGACHENACADKAKkASkDIEL/////D1YNACADKAKkASkDKEL/////D1gNAgsgAygCHCADKAKkASkDKBAuIAMoAhwgAygCpAEpAyAQLgwBCwJAAkAgAygCoAFBgAhxDQAgAygCpAEpAyBC/////w9WDQAgAygCpAEpAyhC/////w9WDQAgAygCpAEpA0hC/////w9YDQELIAMoAqQBKQMoQv////8PWgRAIAMoAhwgAygCpAEpAygQLgsgAygCpAEpAyBC/////w9aBEAgAygCHCADKAKkASkDIBAuCyADKAKkASkDSEL/////D1oEQCADKAIcIAMoAqQBKQNIEC4LCwsCfyMAQRBrIgAgAygCHDYCDCAAKAIMLQAAQQFxRQsEQCADKAKoAUEIakEUQQAQFSADKAIcEBcgAygCkAEQJCADQX82AqwBDAILIANBAQJ/IwBBEGsiACADKAIcNgIMAn4gACgCDC0AAEEBcQRAIAAoAgwpAxAMAQtCAAunQf//A3ELIANBIGpBgAYQUDYCjAEgAygCHBAXIAMoAowBIAMoApABNgIAIAMgAygCjAE2ApABCyADLQCFAUEBcQRAIAMgA0EVakIHECo2AhAgAygCEEUEQCADKAKoAUEIakEOQQAQFSADKAKQARAkIANBfzYCrAEMAgsgAygCEEECECAgAygCEEHP0wBBAhBAIAMoAhAgAygCpAEvAVJB/wFxEIoBIAMoAhAgAygCpAEoAhBB//8DcRAgAn8jAEEQayIAIAMoAhA2AgwgACgCDC0AAEEBcUULBEAgAygCqAFBCGpBFEEAEBUgAygCEBAXIAMoApABECQgA0F/NgKsAQwCCyADQYGyAkEHIANBFWpBgAYQUDYCDCADKAIQEBcgAygCDCADKAKQATYCACADIAMoAgw2ApABCyADIANB0ABqQi4QKiIANgJMIABFBEAgAygCqAFBCGpBDkEAEBUgAygCkAEQJCADQX82AqwBDAELIAMoAkxBxdMAQcrTACADKAKgAUGAAnEbQQQQQCADKAKgAUGAAnFFBEAgAygCTAJ/QS0gAy0AhgFBAXENABogAygCpAEvAQgLQf//A3EQIAsgAygCTAJ/QS0gAy0AhgFBAXENABogAygCpAEvAQoLQf//A3EQICADKAJMIAMoAqQBLwEMECACQCADLQCFAUEBcQRAIAMoAkxB4wAQIAwBCyADKAJMIAMoAqQBKAIQQf//A3EQIAsgAygCpAEoAhQgA0GeAWogA0GcAWoQwwEgAygCTCADLwGeARAgIAMoAkwgAy8BnAEQIAJAAkAgAy0AhQFBAXFFDQAgAygCpAEpAyhCFFoNACADKAJMQQAQIQwBCyADKAJMIAMoAqQBKAIYECELAkACQCADKAKgAUGAAnFBgAJHDQAgAygCpAEpAyBC/////w9UBEAgAygCpAEpAyhC/////w9UDQELIAMoAkxBfxAhIAMoAkxBfxAhDAELAkAgAygCpAEpAyBC/////w9UBEAgAygCTCADKAKkASkDIKcQIQwBCyADKAJMQX8QIQsCQCADKAKkASkDKEL/////D1QEQCADKAJMIAMoAqQBKQMopxAhDAELIAMoAkxBfxAhCwsgAygCTCADKAKkASgCMBBSQf//A3EQICADIAMoAqQBKAI0IAMoAqABEIIBQf//A3EgAygCkAFBgAYQggFB//8DcWo2AogBIAMoAkwgAygCiAFB//8DcRAgIAMoAqABQYACcUUEQCADKAJMIAMoAqQBKAI4EFJB//8DcRAgIAMoAkwgAygCpAEoAjxB//8DcRAgIAMoAkwgAygCpAEvAUAQICADKAJMIAMoAqQBKAJEECECQCADKAKkASkDSEL/////D1QEQCADKAJMIAMoAqQBKQNIpxAhDAELIAMoAkxBfxAhCwsCfyMAQRBrIgAgAygCTDYCDCAAKAIMLQAAQQFxRQsEQCADKAKoAUEIakEUQQAQFSADKAJMEBcgAygCkAEQJCADQX82AqwBDAELIAMoAqgBIANB0ABqAn4jAEEQayIAIAMoAkw2AgwCfiAAKAIMLQAAQQFxBEAgACgCDCkDEAwBC0IACwsQNkEASARAIAMoAkwQFyADKAKQARAkIANBfzYCrAEMAQsgAygCTBAXIAMoAqQBKAIwBEAgAygCqAEgAygCpAEoAjAQhgFBAEgEQCADKAKQARAkIANBfzYCrAEMAgsLIAMoApABBEAgAygCqAEgAygCkAFBgAYQgQFBAEgEQCADKAKQARAkIANBfzYCrAEMAgsLIAMoApABECQgAygCpAEoAjQEQCADKAKoASADKAKkASgCNCADKAKgARCBAUEASARAIANBfzYC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IAMoAoABKAIAIAMpA3CnQQR0aigCACADEPEBBEAgAygCfEEVQQAQFSADEFwgA0J/NwOIAQwDBSADKAKAASgCACADKQNwp0EEdGooAgAoAjQgAygCNBCFASEAIAMoAoABKAIAIAMpA3CnQQR0aigCACAANgI0IAMoAoABKAIAIAMpA3CnQQR0aigCAEEBOgAEIANBADYCNCADEFwgAyADKQNwQgF8NwNwDAILAAsLIAMCfiADKQNgIAMpA2h9Qv///////////wBUBEAgAykDYCADKQNofQwBC0L///////////8ACzcDiAELIAMpA4gBIQQgA0GQAWokACAEC6YBAQF/IwBBIGsiAyQAIAMgADYCGCADIAE2AhQgAyACNgIQIAMgAygCEBD6ASIANgIMAkAgAEUEQCADQQA2AhwMAQsgAygCDCADKAIYNgIAIAMoAgwgAygCFDYCBCADKAIUQRBxBEAgAygCDCIAIAAoAhRBAnI2AhQgAygCDCIAIAAoAhhBAnI2AhgLIAMgAygCDDYCHAsgAygCHCEAIANBIGokACAAC9UBAQF/IwBBIGsiBCQAIAQgADYCGCAEIAE3AxAgBCACNgIMIAQgAzYCCAJAAkAgBCkDEEL///////////8AVwRAIAQpAxBCgICAgICAgICAf1kNAQsgBCgCCEEEQT0QFSAEQX82AhwMAQsCfyAEKQMQIQEgBCgCDCEAIAQoAhgiAigCTEF/TARAIAIgASAAEJYBDAELIAIgASAAEJYBC0EASARAIAQoAghBBEG0nAEoAgAQFSAEQX82AhwMAQsgBEEANgIcCyAEKAIcIQAgBEEgaiQAIAALJwACf0EAQQAgABAFIgAgAEEbRhsiAEUNABpBtJwBIAA2AgBBAAsaC14BAX8jAEEQayIDJAAgAyABQcCAgAJxBH8gAyACQQRqNgIMIAIoAgAFQQALNgIAIAAgAUGAgAJyIAMQESIAQYFgTwRAQbScAUEAIABrNgIAQX8hAAsgA0EQaiQAIAALVQEBfyMAQRBrIgEkACABIAA2AgwCQAJAIAEoAgwoAiRBAUYNACABKAIMKAIkQQJGDQAMAQsgASgCDEEAQgBBChAiGiABKAIMQQA2AiQLIAFBEGokAAszAQF/An8gABAGIgFBYUYEQCAAEBIhAQsgAUGBYE8LBH9BtJwBQQAgAWs2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IEUNACABKAIIKAIkDQELIAFBATYCDAwBCyABIAEoAggoAhw2AgQCQAJAIAEoAgRFDQAgASgCBCgCACABKAIIRw0AIAEoAgQoAgRBKkYNASABKAIEKAIEQTlGDQEgASgCBCgCBEHFAEYNASABKAIEKAIEQckARg0BIAEoAgQoAgRB2wBGDQEgASgCBCgCBEHnAEYNASABKAIEKAIEQfEARg0BIAEoAgQoAgRBmgVGDQELIAFBATYCDAwBCyABQQA2AgwLIAEoAgwL0gQBAX8jAEEgayIDIAA2AhwgAyABNgIYIAMgAjYCFCADIAMoAhxB3BZqIAMoAhRBAnRqKAIANgIQIAMgAygCFEEBdDYCDANAAkAgAygCDCADKAIcKALQKEoNAAJAIAMoAgwgAygCHCgC0ChODQAgAygCGCADKAIcIAMoAgxBAnRqQeAWaigCAEECdGovAQAgAygCGCADKAIcQdwWaiADKAIMQQJ0aigCAEECdGovAQBOBEAgAygCGCADKAIcIAMoAgxBAnRqQeAWaigCAEECdGovAQAgAygCGCADKAIcQdwWaiADKAIMQQJ0aigCAEECdGovAQBHDQEgAygCHCADKAIMQQJ0akHgFmooAgAgAygCHEHYKGpqLQAAIAMoAhxB3BZqIAMoAgxBAnRqKAIAIAMoAhxB2Chqai0AAEoNAQsgAyADKAIMQQFqNgIMCyADKAIYIAMoAhBBAnRqLwEAIAMoAhggAygCHEHcFmogAygCDEECdGooAgBBAnRqLwEASA0AAkAgAygCGCADKAIQQQJ0ai8BACADKAIYIAMoAhxB3BZqIAMoAgxBAnRqKAIAQQJ0ai8BAEcNACADKAIQIAMoAhxB2Chqai0AACADKAIcQdwWaiADKAIMQQJ0aigCACADKAIcQdgoamotAABKDQAMAQsgAygCHEHcFmogAygCFEECdGogAygCHEHcFmogAygCDEECdGooAgA2AgAgAyADKAIMNgIUIAMgAygCDEEBdDYCDAwBCwsgAygCHEHcFmogAygCFEECdGogAygCEDYCAAvnCAEDfyMAQTBrIgIkACACIAA2AiwgAiABNgIoIAIgAigCKCgCADYCJCACIAIoAigoAggoAgA2AiAgAiACKAIoKAIIKAIMNgIcIAJBfzYCECACKAIsQQA2AtAoIAIoAixBvQQ2AtQoIAJBADYCGANAIAIoAhggAigCHE5FBEACQCACKAIkIAIoAhhBAnRqLwEABEAgAiACKAIYIgE2AhAgAigCLEHcFmohAyACKAIsIgQoAtAoQQFqIQAgBCAANgLQKCAAQQJ0IANqIAE2AgAgAigCGCACKAIsQdgoampBADoAAAwBCyACKAIkIAIoAhhBAnRqQQA7AQILIAIgAigCGEEBajYCGAwBCwsDQCACKAIsKALQKEECSARAAkAgAigCEEECSARAIAIgAigCEEEBaiIANgIQDAELQQAhAAsgAigCLEHcFmohAyACKAIsIgQoAtAoQQFqIQEgBCABNgLQKCABQQJ0IANqIAA2AgAgAiAANgIMIAIoAiQgAigCDEECdGpBATsBACACKAIMIAIoAixB2ChqakEAOgAAIAIoAiwiACAAKAKoLUF/ajYCqC0gAigCIARAIAIoAiwiACAAKAKsLSACKAIgIAIoAgxBAnRqLwECazYCrC0LDAELCyACKAIoIAIoAhA2AgQgAiACKAIsKALQKEECbTYCGANAIAIoAhhBAUhFBEAgAigCLCACKAIkIAIoAhgQdSACIAIoAhhBf2o2AhgMAQsLIAIgAigCHDYCDANAIAIgAigCLCgC4BY2AhggAigCLEHcFmohASACKAIsIgMoAtAoIQAgAyAAQX9qNgLQKCACKAIsIABBAnQgAWooAgA2AuAWIAIoAiwgAigCJEEBEHUgAiACKAIsKALgFjYCFCACKAIYIQEgAigCLEHcFmohAyACKAIsIgQoAtQoQX9qIQAgBCAANgLUKCAAQQJ0IANqIAE2AgAgAigCFCEBIAIoAixB3BZqIQMgAigCLCIEKALUKEF/aiEAIAQgADYC1CggAEECdCADaiABNgIAIAIoAiQgAigCDEECdGogAigCJCACKAIYQQJ0ai8BACACKAIkIAIoAhRBAnRqLwEAajsBACACKAIMIAIoAixB2ChqagJ/IAIoAhggAigCLEHYKGpqLQAAIAIoAhQgAigCLEHYKGpqLQAATgRAIAIoAhggAigCLEHYKGpqLQAADAELIAIoAhQgAigCLEHYKGpqLQAAC0EBajoAACACKAIkIAIoAhRBAnRqIAIoAgwiADsBAiACKAIkIAIoAhhBAnRqIAA7AQIgAiACKAIMIgBBAWo2AgwgAigCLCAANgLgFiACKAIs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AykDKCEBIANBMGokACABC3cBAX8jAEEQayICIAA2AgggAiABNgIEAkACQAJAIAIoAggpAyhC/////w9aDQAgAigCCCkDIEL/////D1oNACACKAIEQYAEcUUNASACKAIIKQNIQv////8PVA0BCyACQQE6AA8MAQsgAkEAOgAPCyACLQAPQQFxC9kCAQF/IwBBIGsiAyQAIAMgADYCGCADIAE2AhQgAyACNgIQIAMgA0EMakIEECo2AggCQCADKAIIRQRAIANBfzYCHAwBCwNAIAMoAhQEQCADKAIUKAIEIAMoAhBxQYAGcQRAIAMoAghCABAtGiADKAIIIAMoAhQvAQgQICADKAIIIAMoAhQvAQoQIAJ/IwBBEGsiACADKAIINgIMIAAoAgwtAABBAXFFCwRAIAMoAhhBCGpBFEEAEBUgAygCCBAXIANBfzYCHAwECyADKAIYIANBDGpCBBA2QQBIBEAgAygCCBAXIANBfzYCHAwECyADKAIULwEKQQBKBEAgAygCGCADKAIUKAIMIAMoAhQvAQqtEDZBAEgEQCADKAIIEBcgA0F/NgIcDAULCwsgAyADKAIUKAIANgIUDAELCyADKAIIEBcgA0EANgIcCyADKAIcIQAgA0EgaiQAIAALaAEBfyMAQRBrIgIgADYCDCACIAE2AgggAkEAOwEGA0AgAigCDARAIAIoAgwoAgQgAigCCHFBgAZxBEAgAiACKAIMLwEKIAIvAQZBBGpqOwEGCyACIAIoAgwoAgA2AgwMAQsLIAIvAQYL8AEBAX8jAEEQayIBJAAgASAANgIMIAEgASgCDDYCCCABQQA2AgQDQCABKAIMBEACQAJAIAEoAgwvAQhB9cYBRg0AIAEoAgwvAQhB9eABRg0AIAEoAgwvAQhBgbICRg0AIAEoAgwvAQhBAUcNAQsgASABKAIMKAIANgIAIAEoAgggASgCDEYEQCABIAEoAgA2AggLIAEoAgxBADYCACABKAIMECQgASgCBARAIAEoAgQgASgCADYCAAsgASABKAIANgIMDAILIAEgASgCDDYCBCABIAEoAgwoAgA2AgwMAQsLIAEoAgghACABQRBqJAAgAAuzBAEBfyMAQUBqIgUkACAFIAA2AjggBSABOwE2IAUgAjYCMCAFIAM2AiwgBSAENgIoIAUgBSgCOCAFLwE2rRAqIgA2AiQC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ACgCDCgCBDYCAAsLIAIoAgwEQCACKAIMIAIoAgQ2AgALIAJBEGokAAuVAQEBfyMAQRBrIgEkACABIAA2AggCQAJ/IwBBEGsiACABKAIINgIMIAAoAgwpAxhCgIAQg1ALBEAgASgCCCgCAARAIAEgASgCCCgCABCUAUEBcToADwwCCyABQQE6AA8MAQsgASABKAIIQQBCAEESECI+AgQgASABKAIEQQBHOgAPCyABLQAPQQFxIQAgAUEQaiQAIAALfwEBfyMAQSBrIgMkACADIAA2AhggAyABNwMQIANBADYCDCADIAI2AggCQCADKQMQQv///////////wBWBEAgAygCCEEEQT0QFSADQX82AhwMAQsgAyADKAIYIAMpAxAgAygCDCADKAIIEGc2AhwLIAMoAhwhACADQSBqJAAgAAt9ACACQQFGBEAgASAAKAIIIAAoAgRrrH0hAQsCQCAAKAIUIAAoAhxLBEAgAEEAQQAgACgCJBEBABogACgCFEUNAQsgAEEANgIcIABCADcDECAAIAEgAiAAKAIoERAAQgBTDQAgAEIANwIEIAAgACgCAEFvcTYCAEEADwtBfwviAgECfyMAQSBrIgMkAAJ/AkACQEH0lwEgASwAABCYAUUEQEG0nAFBHDYCAAwBC0GYCRAZIgINAQtBAAwBCyACQQBBkAEQMyABQSsQmAFFBEAgAkEIQQQgAS0AAEHyAEYbNgIACwJAIAEtAABB4QBHBEAgAigCACEBDAELIABBA0EAEAQiAUGACHFFBEAgAyABQYAIcjYCECAAQQQgA0EQahAEGgsgAiACKAIAQYABciIBNgIACyACQf8BOgBLIAJBgAg2AjAgAiAANgI8IAIgAkGYAWo2AiwCQCABQQhxDQAgAyADQRhqNgIAIABBk6gBIAMQDg0AIAJBCjoASwsgAkEaNgIoIAJBGzYCJCACQRw2AiAgAkEdNgIMQdygASgCAEUEQCACQX82AkwLIAJBsKEBKAIANgI4QbChASgCACIABEAgACACNgI0C0GwoQEgAjYCACACCyEAIANBIGokACAACxoAIAAgARCFAiIAQQAgAC0AACABQf8BcUYbCxgAIAAoAkxBf0wEQCAAEJoBDwsgABCaAQtgAgJ/AX4gACgCKCEBQQEhAiAAQgAgAC0AAEGAAXEEf0ECQQEgACgCFCAAKAIc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KAIYKQMwWgRAIAIoAhhBCGpBEkEAEBUgAkF/NgIcDAELIAIoAhgoAhhBAnEEQCACKAIYQQhqQRlBABAVIAJBfzYCHAwBCyACIAIoAhggAikDEEEAIAIoAhhBCGoQTyIANgIMIABFBEAgAkF/NgIcDAELIAIoAhgoAlAgAigCDCACKAIYQQhqEFlBAXFFBEAgAkF/NgIcDAELIAIoAhggAikDEBCgAgRAIAJBfzYCHAwBCyACKAIYKAJAIAIpAxCnQQR0akEBOgAMIAJBADYCHAsgAigCHCEAIAJBIGokACAAC5gCAAJAAkAgAUEUSw0AAkACQAJAAkACQAJAAkACQCABQXdqDgoAAQIJAwQFBgkHCAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACQRYRBAALDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC0oBA38gACgCACwAAEFQakEKSQRAA0AgACgCACIBLAAAIQMgACABQQFqNgIAIAMgAkEKbGpBUGohAiABLAABQVBqQQpJDQALCyACC38CAX8BfiAAvSIDQjSIp0H/D3EiAkH/D0cEfCACRQRAIAEgAEQAAAAAAAAAAGEEf0EABSAARAAAAAAAAPBDoiABEKQBIQAgASgCAEFAags2AgAgAA8LIAEgAkGCeGo2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLEgAgAEUEQEEADwsgACABELQCC+UBAQJ/IAJBAEchAwJAAkACQCACRQ0AIABBA3FFDQAgAUH/AXEhBANAIAAtAAAgBEYNAiAAQQFqIQAgAkF/aiICQQBHIQMgAkUNASAAQQNxDQALCyADRQ0BCwJAIAAtAAAgAUH/AXFGDQAgAkEESQ0AIAFB/wFxQYGChAhsIQMDQCAAKAIAIANzIgRBf3MgBEH//ft3anFBgIGChHhxDQEgAEEEaiEAIAJB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HAvkAQEBfyMAQSBrIgMkACADIAA6ABsgAyABNgIUIAMgAjYCECADQcgAEBkiADYCDAJAIABFBEAgAygCEEEBQbScASgCABAVIANBADYCHAwBCyADKAIMIAMoAhA2AgAgAygCDCADLQAbQQFxOgAEIAMoAgwgAygCFDYCCAJAIAMoAgwoAghBAU4EQCADKAIMKAIIQQlMDQELIAMoAgxBCTYCCAsgAygCDEEAOgAMIAMoAgxBADYCMCADKAIMQQA2AjQgAygCDEEANgI4IAMgAygCDDYCHAsgAygCHCEAIANBIGokACAAC+MIAQF/IwBBQGoiAiAANgI4IAIgATYCNCACIAIoAjgoAnw2AjAgAiACKAI4KAI4IAIoAjgoAmxqNgIsIAIgAigCOCgCeDYCICACIAIoAjgoApABNgIcIAICfyACKAI4KAJsIAIoAjgoAixBhgJrSwRAIAIoAjgoAmwgAigCOCgCLEGGAmtrDAELQQALNgIYIAIgAigCOCgCQDYCFCACIAIoAjgoAjQ2AhAgAiACKAI4KAI4IAIoAjgoAmxqQYICajYCDCACIAIoAiwgAigCIEEBa2otAAA6AAsgAiACKAIsIAIoAiBqLQAAOgAKIAIoAjgoAnggAigCOCgCjAFPBEAgAiACKAIwQQJ2NgIwCyACKAIcIAIoAjgoAnRLBEAgAiACKAI4KAJ0NgIcCwNAAkAgAiACKAI4KAI4IAIoAjRqNgIoAkAgAigCKCACKAIgai0AACACLQAKRw0AIAIoAiggAigCIEEBa2otAAAgAi0AC0cNACACKAIoLQAAIAIoAiwtAABHDQAgAiACKAIoIgBBAWo2AiggAC0AASACKAIsLQABRwRADAELIAIgAigCLEECajYCLCACIAIoAihBAWo2AigDQCACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AigCf0EAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AihBACAALQABIAFHDQAaIAIgAigCLCIAQQFqNgIsIAAtAAEhASACIAIoAigiAEEBajYCKEEAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AihBACAALQABIAFHDQAaIAIgAigCLCIAQQFqNgIsIAAtAAEhASACIAIoAigiAEEBajYCKEEAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACKAIsIAIoAgxJC0EBcQ0ACyACQYICIAIoAgwgAigCLGtrNgIkIAIgAigCDEH+fWo2AiwgAigCJCACKAIgSgRAIAIoAjggAigCNDYCcCACIAIoAiQ2AiAgAigCJCACKAIcTg0CIAIgAigCLCACKAIgQQFrai0AADoACyACIAIoAiwgAigCIGotAAA6AAoLCyACIAIoAhQgAigCNCACKAIQcUEBdGovAQAiATYCNEEAIQAgASACKAIYSwR/IAIgAigCMEF/aiIANgIwIABBAEcFQQALQQFxDQELCwJAIAIoAiAgAigCOCgCdE0EQCACIAIoAiA2AjwMAQsgAiACKAI4KAJ0NgI8CyACKAI8C5gQAQF/IwBBMGsiAiQAIAIgADYCKCACIAE2AiQgAgJ/IAIoAigoAgxBBWsgAigCKCgCLEsEQCACKAIoKAIsDAELIAIoAigoAgxBBWsLNgIgIAJBADYCECACIAIoAigoAgAoAgQ2AgwDQAJAIAJB//8DNgIcIAIgAigCKCgCvC1BKmpBA3U2AhQgAigCKCgCACgCECACKAIUSQ0AIAIgAigCKCgCACgCECACKAIUazYCFCACIAIoAigoAmwgAigCKCgCXGs2AhggAigCHCACKAIYIAIoAigoAgAoAgRqSwRAIAIgAigCGCACKAIoKAIAKAIEajYCHAsgAigCHCACKAIUSwRAIAIgAigCFDYCHAsCQCACKAIcIAIoAiBPDQACQCACKAIcRQRAIAIoAiRBBEcNAQsgAigCJEUNACACKAIcIAIoAhggAigCKCgCACgCBGpGDQELDAELQQAhACACIAIoAiRBBEYEfyACKAIcIAIoAhggAigCKCgCACgCBGpGBUEAC0EBcUVFNgIQIAIoAihBAEEAIAIoAhAQVyACKAIoKAIIIAIoAigoAhRBBGtqIAIoAhw6AAAgAigCKCgCCCACKAIoKAIUQQNraiACKAIcQQh2OgAAIAIoAigoAgggAigCKCgCFEECa2ogAigCHEF/czoAACACKAIoKAIIIAIoAigoAhRBAWtqIAIoAhxBf3NBCHY6AAAgAigCKCgCABAdIAIoAhgEQCACKAIYIAIoAhxLBEAgAiACKAIcNgIYCyACKAIoKAIAKAIMIAIoAigoAjggAigCKCgCXGogAigCGBAaGiACKAIoKAIAIgAgAigCGCAAKAIMajYCDCACKAIoKAIAIgAgACgCECACKAIYazYCECACKAIoKAIAIgAgAigCGCAAKAIUajYCFCACKAIoIgAgAigCGCAAKAJcajYCXCACIAIoAhwgAigCGGs2AhwLIAIoAhwEQCACKAIoKAIAIAIoAigoAgAoAgwgAigCHBBzGiACKAIoKAIAIgAgAigCHCAAKAIMajYCDCACKAIoKAIAIgAgACgCECACKAIcazYCECACKAIoKAIAIgAgAigCHCAAKAIUajYCFAsgAigCEEUNAQsLIAIgAigCDCACKAIoKAIAKAIEazYCDCACKAIMBEACQCACKAIMIAIoAigoAixPBEAgAigCKEECNgKwLSACKAIoKAI4IAIoAigoAgAoAgAgAigCKCgCLGsgAigCKCgCLBAaGiACKAIoIAIoAigoAiw2AmwMAQsgAigCKCgCPCACKAIoKAJsayACKAIMTQRAIAIoAigiACAAKAJsIAIoAigoAixrNgJsIAIoAigoAjggAigCKCgCOCACKAIoKAIsaiACKAIoKAJsEBoaIAIoAigoArAtQQJJBEAgAigCKCIAIAAoArAtQQFqNgKwLQsLIAIoAigoAjggAigCKCgCbGogAigCKCgCACgCACACKAIMayACKAIMEBoaIAIoAigiACACKAIMIAAoAmxqNgJsCyACKAIoIAIoAigoAmw2AlwgAigCKCIBAn8gAigCDCACKAIoKAIsIAIoAigoArQta0sEQCACKAIoKAIsIAIoAigoArQtawwBCyACKAIMCyABKAK0LWo2ArQtCyACKAIoKALALSACKAIoKAJsSQRAIAIoAiggAigCKCgCbDYCwC0LAkAgAigCEARAIAJBAzYCLAwBCwJAIAIoAiRFDQAgAigCJEEERg0AIAIoAigoAgAoAgQNACACKAIoKAJsIAIoAigoAlxHDQAgAkEBNgIsDAELIAIgAigCKCgCPCACKAIoKAJsa0EBazYCFAJAIAIoAigoAgAoAgQgAigCFE0NACACKAIoKAJcIAIoAigoAixIDQAgAigCKCIAIAAoAlwgAigCKCgCLGs2AlwgAigCKCIAIAAoAmwgAigCKCgCLGs2AmwgAigCKCgCOCACKAIoKAI4IAIoAigoAixqIAIoAigoAmwQGhogAigCKCgCsC1BAkkEQCACKAIoIgAgACgCsC1BAWo2ArAtCyACIAIoAigoAiwgAigCFGo2AhQLIAIoAhQgAigCKCgCACgCBEsEQCACIAIoAigoAgAoAgQ2AhQLIAIoAhQEQCACKAIoKAIAIAIoAigoAjggAigCKCgCbGogAigCFBBzGiACKAIoIgAgAigCFCAAKAJsajYCbAsgAigCKCgCwC0gAigCKCgCbEkEQCACKAIoIAIoAigoAmw2AsAtCyACIAIoAigoArwtQSpqQQN1NgIUIAICf0H//wMgAigCKCgCDCACKAIUa0H//wNLDQAaIAIoAigoAgwgAigCFGsLNgIUIAICfyACKAIUIAIoAigoAixLBEAgAigCKCgCLAwBCyACKAIUCzYCICACIAIoAigoAmwgAigCKCgCXGs2AhgCQCACKAIYIAIoAiBJBEAgAigCGEUEQCACKAIkQQRHDQILIAIoAiRFDQEgAigCKCgCACgCBA0BIAIoAhggAigCFEsNAQsgAgJ/IAIoAhggAigCFEsEQCACKAIUDAELIAIoAhgLNgIcIAICf0EAIAIoAiRBBEcNABpBACACKAIoKAIAKAIEDQAaIAIoAhwgAigCGEYLQQFxRUU2AhAgAigCKCACKAIoKAI4IAIoAigoAlxqIAIoAhwgAigCEBBXIAIoAigiACACKAIcIAAoAlxqNgJcIAIoAigoAgAQHQsgAkECQQAgAigCEBs2AiwLIAIoAiwhACACQTBqJAAgAAuyAgEBfyMAQRBrIgEkACABIAA2AggCQCABKAIIEHQEQCABQX42AgwMAQsgASABKAIIKAIcKAIENgIEIAEoAggoAhwoAggEQCABKAIIKAIoIAEoAggoAhwoAgggASgCCCgCJBEEAAsgASgCCCgCHCgCRARAIAEoAggoAiggASgCCCgCHCgCRCABKAIIKAIkEQQACyABKAIIKAIcKAJABEAgASgCCCgCKCAB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A0hCGnxBABAoQQBIBEAgAigCKEEIaiACKAIoKAIAEBggAkF/NgIsDAELIAIgAigCKCgCAEIEIAJBGGogAigCKEEIahBBIgA2AhQgAEUEQCACQX82AiwMAQsgAiACKAIUEB47ARIgAiACKAIUEB47ARAgAigCFBBIQQFxRQRAIAIoAhQQFyACKAIoQQhqQRRBABAVIAJBfzYCLAwBCyACKAIUEBcgAi8BEEEASgRAIAIoAigoAgAgAi8BEq1BARAoQQBIBEAgAigCKEEIakEEQbScASgCABAVIAJBfzYCLAwCCyACQQAgAigCKCgCACACLwEQQQAgAigCKEEIahBgNgIIIAIoAghFBEAgAkF/NgIsDAILIAIoAgggAi8BEEGAAiACQQxqIAIoAihBCGoQhAFBAXFFBEAgAigCCBAWIAJBfzYCLAwCCyACKAIIEBYgAigCDARAIAIgAigCDBCDATYCDCACKAIcKAIAKAI0IAIoAgwQhQEhACACKAIcKAIAIAA2AjQLCyACKAIcKAIAQQE6AAQCQCACKAIcKAIERQ0AIAIoAhwoAgQtAARBAXENACACKAIcKAIEIAIoAhwoAgAoAjQ2AjQgAigCHCgCBEEBOgAECyACQQA2AiwLIAIoAiwhACACQTBqJAAgAAsHACAAKAIAC4wBAQF/IwBBIGsiAiQAIAIgADYCGCACIAE2AhQgAkEANgIQAkAgAigCFEUEQCACQQA2AhwMAQsgAiACKAIUEBk2AgwgAigCDEUEQCACKAIQQQ5BABAVIAJBADYCHAwBCyACKAIMIAIoAhggAigCFBAaGiACIAIoAgw2AhwLIAIoAhwhACACQSBqJAAgAAsYAEGonAFCADcCAEGwnAFBADYCAEGonAELiAEBAX8jAEEgayIDJAAgAyAANgIUIAMgATYCECADIAI3AwgCQAJAIAMoAhQoAiRBAUYEQCADKQMIQv///////////wBYDQELIAMoAhRBDGpBEkEAEBUgA0J/NwMYDAELIAMgAygCFCADKAIQIAMpAwhBCxAiNwMYCyADKQMYIQIgA0EgaiQAIAILcwEBfyMAQSBrIgEkACABIAA2AhggAUIINwMQIAEgASgCGCkDECABKQMQfDcDCAJAIAEpAwggASgCGCkDEFQEQCABKAIYQQA6AAAgAUF/NgIcDAELIAEgASgCGCAB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IAIgADYCSCACIAE2AkQgAkEIaiIAEDwCQCACKAJIIAAQOQRAIwBBEGsiACACKAJINgIMIAIgACgCDEEMajYCBCMAQRBrIgAgAigCBDYCDAJAIAAoAgwoAgBBBUcNACMAQRBrIgAgAigCBDYCDCAAKAIMKAIEQSxHDQAgAkEANgJMDAILIAIoAkQgAigCBBBEIAJBfzYCTAwBCyACQQE2AkwLIAIoAkwhACACQdAAaiQAIAAL6gEBAX8jAEEwayIDJAAgAyAANgIoIAMgATYCJCADIAI2AiAjAEEQayIAIANBCGoiATYCDCAAKAIMQQA2AgAgACgCDEEANgIEIAAoAgxBADYCCCADIAMoAiggARD7ASIANgIYAkAgAEUEQCADKAIgIANBCGoiABCTASAAEDggA0EANgIsDAELIAMgAygCGCADKAIkIANBCGoQkgEiADYCHCAARQRAIAMoAhgQHCADKAIgIANBCGoiABCTASAAEDggA0EANgIsDAELIANBCGoQOCADIAMoAhw2AiwLIAMoAiwhACADQTBqJAAgAAvIAgEBfyMAQRBrIgEkACABIAA2AgggAUHYABAZNgIEAkAgASgCBEUEQCABKAIIQQ5BABAVIAFBADYCDAwBCyABKAIIEIEDIQAgASgCBCAANgJQIABFBEAgASgCBBAWIAFBADYCDAwBCyABKAIEQQA2AgAgASgCBEEANgIEIwBBEGsiACABKAIEQQhqNgIMIAAoAgxBADYCACAAKAIMQQA2AgQgACgCDEEANgIIIAEoAgRBADYCGCABKAIEQQA2AhQgASgCBEEANgIcIAEoAgRBADYCJCABKAIEQQA2AiAgASgCBEEAOgAoIAEoAgRCADcDOCABKAIEQgA3AzAgASgCBEEANgJAIAEoAgRBADYCSCABKAIEQQA2AkQgASgCBEEANgJMIAEoAgRBADYCVCABIAEoAgQ2AgwLIAEoAgwhACABQRBqJAAgAAuBAQEBfyMAQSBrIgIkACACIAA2AhggAkIANwMQIAJCfzcDCCACIAE2AgQCQAJAIAIoAhgEQCACKQMIQn9ZDQELIAIoAgRBEkEAEBUgAkEANgIcDAELIAIgAigCGCACKQMQIAIpAwggAigCBBD/ATYCHAsgAigCHCEAIAJBIGokACAAC80BAQJ/IwBBIGsiASQAIAEgADYCGCAB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CyAAIAFBf2oiAWoiAi0AAEEvRw0ACyACC6kBAQN/AkAgAC0AACICRQ0AA0AgAS0AACIERQRAIAIhAwwCCwJAIAIgBEYNACACQSByIAIgAkG/f2pBGkkbIAEtAAAiAkEgciACIAJBv39qQRpJG0YNACAALQAAIQMMAgsgAUEBaiEBIAAtAAEhAiAAQQFqIQAgAg0ACwsgA0H/AXEiAEEgciAAIABBv39qQRpJGyABLQAAIgBBIHIgACAAQb9/akEaSRtrC+gDAQN/IwBBsAFrIgEkACABIAA2AqgBIAEoAqgBEDgCQAJAIAEoAqgBKAIAQQBOBEAgASgCqAEoAgBBoA4oAgBIDQELIAEgASgCqAEoAgA2AhAgAUEgakG8lwEgAUEQahBvIAFBADYCpAEgASABQSBqNgKgAQwBCyABIAEoAqgBKAIAQQJ0QaANaigCADYCpAECQAJAAkACQCABKAKoASgCAEECdEGwDmooAgBBf2oOAgABAgsgASABKAKoASgCBEGQmgEoAgAQpAI2AqABDAILIwBBEGsiACABKAKoASgCBDYCDCABQQAgACgCDGtBAnRB2NQAaigCADYCoAEMAQsgAUEANgKgAQsLAkAgASgCoAFFBEAgASABKAKkATYCrAEMAQsgASABKAKgARAsAn8gASgCpAEEQCABKAKkARAsQQJqDAELQQALakEBahAZIgA2AhwgAEUEQCABQdgNKAIANgKsAQwBCyABKAIcIQACfyABKAKkAQRAIAEoAqQBDAELQdSXAQshAkHVlwFB1JcBIAEoAqQBGyEDIAEgASgCoAE2AgggASADNgIEIAEgAjYCACAAQc2XASABEG8gASgCqAEgASgCHDYCCCABIAEoAhw2AqwBCyABKAKsASEAIAFBsAFqJAAgAAtxAQN/AkACQANAIAAgAkHQiAFqLQAARwRAQdcAIQMgAkEBaiICQdcARw0BDAILCyACIgMNAEGwiQEhAAwBC0GwiQEhAgNAIAItAAAhBCACQQFqIgAhAiAEDQAgACECIANBf2oiAw0ACwsgASgCFBogAAszAQF/IAAoAhQiAyABIAIgACgCECADayIBIAEgAksbIgEQGhogACAAKAIUIAFqNgIUIAILigEBAn8jAEGgAWsiAyQAIANBCGpBuIcBQZABEBoaIAMgADYCNCADIAA2AhwgA0F+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QQhxBEAgACABQSByNgIAQX8PCyAAQgA3AgQgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCEEEACwYAQaShAQsGAEGgoQELBgBBmKEBC9kDAgJ/An4jAEEgayICJAACQCABQv///////////wCDIgVCgICAgICAwP9DfCAFQoCAgICAgMCAvH98VARAIAFCBIYgAEI8iIQhBCAAQv//////////D4MiAEKBgICAgICAgAhaBEAgBEKBgICAgICAgMAAfCEEDAILIARCgICAgICAgIBAfSEEIABCgICAgICAgIAIhUIAUg0BIARCAYMgBHwhBAwBCyAAUCAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQQMAQtCgICAgICAgPj/ACEEIAVC////////v//DAFYNAEIAIQQgBUIwiKciA0GR9wBJDQAgAkEQaiAAIAFC////////P4NCgICAgICAwACEIgQgA0H/iH9qELMCIAIgACAEQYH4ACADaxCyAiACKQMIQgSGIAIpAwAiAEI8iIQhBCACKQMQIAIpAxiEQgBSrSAAQv//////////D4OEIgBCgYCAgICAgIAIWgRAIARCAXwhBAwBCyAAQoCAgICAgICACIVCAFINACAEQgGDIAR8IQQLIAJBIGokACAEIAFCgICAgICAgICAf4OEvwtQAQF+AkAgA0HAAHEEQCACIANBQGqtiCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcDCAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAuLAgACQCAABH8gAUH/AE0NAQJAQZCaASgCACgCAEUEQCABQYB/cUGAvwNGDQMMAQsgAUH/D00EQCAAIAFBP3FBgAFyOgABIAAgAUEGdkHAAXI6AABBAg8LIAFBgLADT0EAIAFBgEBxQYDAA0cbRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMPCyABQYCAfGpB//8/TQRAIAAgAUE/cUGAAXI6AAMgACABQRJ2QfABcjoAACAAIAFBBnZBP3FBgAFyOgACIAAgAUEMdkE/cUGAAXI6AAFBBA8LC0G0nAFBGTYCAEF/BUEBCw8LIAAgAToAAEEBC74CAQF/IwBBwMAAayIDJAAgAyAANgK4QCADIAE2ArRAIAMgAjcDqEACQCADKAK0QBBJQQBIBEAgAygCuEBBCGogAygCtEAQGCADQX82ArxADAELIANBADYCDCADQgA3AxADQAJAIAMgAygCtEAgA0EgakKAwAAQLyICNwMYIAJCAFcNACADKAK4QCADQSBqIAMpAxgQNkEASARAIANBfzYCDAUgAykDGEKAwABSDQIgAygCuEAoAlRFDQIgAykDqEBCAFcNAiADIAMpAxggAykDEHw3AxAgAygCuEAoAlQgAykDELkgAykDqEC5oxBYDAILCwsgAykDGEIAUwRAIAMoArhAQQhqIAMoArRAEBggA0F/NgIMCyADKAK0QBAyGiADIAMoAgw2ArxACyADKAK8QCEAIANBwMAAaiQAIAALqgEBAX8jAEEwayIDJAAgAyAANgIoIAMgATYCJCADIAI3AxggAyADKAIoKAIAEDUiAjcDEAJAIAJCAFMEQCADQX82AiwMAQsgAyADKAIoIAMoAiQgAykDGBCQAyICNwMAIAJCAFMEQCADQX82AiwMAQsgAyADKAIoKAIAEDUiAjcDCCACQgBTBEAgA0F/NgIsDAELIANBADYCLAsgAygCLCEAIANBMGokACAAC/4BAQF/IwBBoMAAayICJAAgAiAANgKYQCACIAE3A5BAIAIgAikDkEC6OQMAAkADQCACKQOQQEIAVgRAIAICfkKAwAAgAikDkEBCgMAAVg0AGiACKQOQQAs+AgwgAigCmEAoAgAgAkEQaiACKAIMrSACKAKYQEEIahBhQQBIBEAgAkF/NgKcQAwDCyACKAKYQCACQRBqIAIoAgytEDZBAEgEQCACQX82ApxADAMFIAIgAikDkEAgAjUCDH03A5BAIAIoAphAKAJUIAIrAwAgAikDkEC6oSACKwMAoxBYDAILAAsLIAJBADYCnEALIAIoApxAIQAgAkGgwABqJAAgAAvnEQIBfwF+IwBBoAFrIgMkACADIAA2ApgBIAMgATYClAEgAyACNgKQAQJAIAMoApQBIANBOGoQOUEASARAIAMoApgBQQhqIAMoApQBEBggA0F/NgKcAQwBCyADKQM4QsAAg1AEQCADIAMpAzhCwACENwM4IANBADsBaAsCQAJAIAMoApABKAIQQX9HBEAgAygCkAEoAhBBfkcNAQsgAy8BaEUNACADKAKQASADLwFoNgIQDAELAkACQCADKAKQASgCEA0AIAMpAzhCBINQDQAgAyADKQM4QgiENwM4IAMgAykDUDcDWAwBCyADIAMpAzhC9////w+DNwM4CwsgAykDOEKAAYNQBEAgAyADKQM4QoABhDcDOCADQQA7AWoLIANBgAI2AiQCQCADKQM4QgSDUARAIAMgAygCJEGACHI2AiQgA0J/NwNwDAELIAMoApABIAMpA1A3AyggAyADKQNQNwNwAkAgAykDOEIIg1AEQAJAAkACQAJAAkACfwJAIAMoApABKAIQQX9HBEAgAygCkAEoAhBBfkcNAQtBCAwBCyADKAKQASgCEAtB//8DcQ4NAgMDAwMDAwMBAwMDAAMLIANClMLk8w83AxAMAwsgA0KDg7D/DzcDEAwCCyADQv////8PNwMQDAELIANCADcDEAsgAykDUCADKQMQVgRAIAMgAygCJEGACHI2AiQLDAELIAMoApABIAMpA1g3AyALCyADIAMoApgBKAIAEDUiBDcDiAEgBEIAUwRAIAMoApgBQQhqIAMoApgBKAIAEBggA0F/NgKcAQwBCyADKAKQASIAIAAvAQxB9/8DcTsBDCADIAMoApgBIAMoApABIAMoAiQQXiIANgIoIABBAEgEQCADQX82ApwBDAELIAMgAy8BaAJ/AkAgAygCkAEoAhBBf0cEQCADKAKQASgCEEF+Rw0BC0EIDAELIAMoApABKAIQC0H//wNxRzoAIiADIAMtACJBAXEEfyADLwFoQQBHBUEAC0EBcToAISADIAMvAWgEfyADLQAhBUEBC0EBcToAICADIAMtACJBAXEEfyADKAKQASgCEEEARwVBAAtBAXE6AB8gAwJ/QQEgAy0AIkEBcQ0AGkEBIAMoApABKAIAQYABcQ0AGiADKAKQAS8BUiADLwFqRwtBAXE6AB4gAyADLQAeQQFxBH8gAy8BakEARwVBAAtBAXE6AB0gAyADLQAeQQFxBH8gAygCkAEvAVJBAEcFQQALQQFxOgAcIAMgAygClAE2AjQjAEEQayIAIAMoAjQ2AgwgACgCDCIAIAAoAjBBAWo2AjAgAy0AHUEBcQRAIAMgAy8BakEAEHciADYCDCAARQRAIAMoApgBQQhqQRhBABAVIAMoAjQQHCADQX82ApwBDAILIAMgAygCmAEgAygCNCADLwFqQQAgAygCmAEoAhwgAygCDBEGACIANgIwIABFBEAgAygCNBAcIANBfzYCnAEMAgsgAygCNBAcIAMgAygCMDYCNAsgAy0AIUEBcQRAIAMgAygCmAEgAygCNCADLwFoEKsBIgA2AjAgAEUEQCADKAI0EBwgA0F/NgKcAQwCCyADKAI0EBwgAyADKAIwNgI0CyADLQAgQQFxBEAgAyADKAKYASADKAI0QQAQqgEiADYCMCAARQRAIAMoAjQQHCADQX82ApwBDAILIAMoAjQQHCADIAMoAjA2AjQLIAMtAB9BAXEEQCADIAMoApgBIAMoAjQgAygCkAEoAhAgAygCkAEvAVAQwgIiADYCMCAARQRAIAMoAjQQHCADQX82ApwBDAILIAMoAjQQHCADIAMoAjA2AjQLIAMtABxBAXEEQCADQQA2AgQCQCADKAKQASgCVARAIAMgAygCkAEoAlQ2AgQMAQsgAygCmAEoAhwEQCADIAMoApgBKAIcNgIECwsgAyADKAKQAS8BUkEBEHciADYCCCAARQRAIAMoApgBQQhqQRhBABAVIAMoAjQQHCADQX82ApwBDAILIAMgAygCmAEgAygCNCADKAKQAS8BUkEBIAMoAgQgAygCCBEGACIANgIwIABFBEAgAygCNBAcIANBfzYCnAEMAgsgAygCNBAcIAMgAygCMDYCNAsgAyADKAKYASgCABA1IgQ3A4ABIARCAFMEQCADKAKYAUEIaiADKAKYASgCABAYIANBfzYCnAEMAQsgAyADKAKYASADKAI0IAMpA3AQtQI2AiwgAygCNCADQThqEDlBAEgEQCADKAKYAUEIaiADKAI0EBggA0F/NgIsCyADIAMoAjQQuwIiADoAIyAAQRh0QRh1QQBIBEAgAygCmAFBCGogAygCNBAYIANBfzYCLAsgAygCNBAcIAMoAixBAEgEQCADQX82ApwBDAELIAMgAygCmAEoAgAQNSIENwN4IARCAFMEQCADKAKYAUEIaiADKAKYASgCABAYIANBfzYCnAEMAQsgAygCmAEoAgAgAykDiAEQqAFBAEgEQCADKAKYAUEIaiADKAKYASgCABAYIANBfzYCnAEMAQsgAykDOELkAINC5ABSBEAgAygCmAFBCGpBFEEAEBUgA0F/NgKcAQwBCyADKAKQASgCAEEgcUUEQAJAIAMpAzhCEINCAFIEQCADKAKQASADKAJgNgIUDAELIAMoApABQRRqEAEaCwsgAygCkAEgAy8BaDYCECADKAKQASADKAJkNgIYIAMoApABIAMpA1A3AyggAygCkAEgAykDeCADKQOAAX03AyAgAygCkAEgAygCkAEvAQxB+f8DcSADLQAjQQF0cjsBDCADKAKQASADKAIkQYAIcUEARxCKAyADIAMoApgBIAMoApABIAMoAiQQXiIANgIsIABBAEgEQCADQX82ApwBDAELIAMoAiggAygCLEcEQCADKAKYAUEIakEUQQAQFSADQX82ApwBDAELIAMoApgBKAIAIAMpA3gQqAFBAEgEQCADKAKYAUEIaiADKAKYASgCABAYIANBfzYCnAEMAQsgA0EANgKcAQsgAygCnAEhACADQaABaiQAIAALrwIBAX8jAEEgayICIAA2AhwgAiABNgIYIAJBADYCFCACQgA3AwACQCACKAIcLQAoQQFxRQRAIAIoAhwoAhggAigCHCgCFEYNAQsgAkEBNgIUCyACQgA3AwgDQCACKQMIIAIoAhwpAzBUBEACQAJAIAIoAhwoAkAgAikDCKdBBHRqKAIIDQAgAigCHCgCQCACKQMIp0EEdGotAAxBAXENACACKAIcKAJAIAIpAwinQQR0aigCBEUNASACKAIcKAJAIAIpAwinQQR0aigCBCgCAEUNAQsgAkEBNgIUCyACKAIcKAJAIAIpAwinQQR0ai0ADEEBcUUEQCACIAIpAwBCAXw3AwALIAIgAikDCEIBfDcDCAwBCwsgAigCGARAIAIoAhggAikDADcDAAsgAigCFAuMEAMCfwF+AXwjAEHgAGsiASQAIAEgADYCWAJAIAEoAlhFBEAgAUF/NgJcDAELIAEgASgCWCABQUBrELkCNgIkIAEpA0BQBEACQCABKAJYKAIEQQhxRQRAIAEoAiRFDQELIAEoAlgoAgAQhAJBAEgEQAJAAn8jAEEQayICIAEoAlgoAgA2AgwjAEEQayIAIAIoAgxBDGo2AgwgACgCDCgCAEEWRgsEQCMAQRBrIgIgASgC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NgI8IAEoAlAgASgCODYCQCABKAJYIAEoAjAQ1gIgASABKAJYKAIMNgJIIAEgASgCWCgCEDYCQCABIAEoAlgoAgA2AkwgASABKAJYKAIENgJEIAEgASgCUCgCPDYCPCABIAEoAlAoAkA2AjggASgCUCgCBEG//gBGBEAgASgCUEF/NgLINwsMDQsgASgCUEEANgLINwNAAkAgASABKAJQKAJQIAEoAjxBASABKAJQKAJYdEEBa3FBAnRqKAEANgEgIAEtACEgASgCOE0NACABKAJERQ0NIAEgASgCREF/ajYCRCABIAEoAkwiAEEBajYCTCABIAEoAjwgAC0AACABKAI4dGo2AjwgASABKAI4QQhqNgI4DAELCwJAIAEtACBFDQAgAS0AIEHwAXENACABIAEoASA2ARgDQAJAIAEgASgCUCgCUCABLwEaIAEoAjxBASABLQAZIAEtABhqdEEBa3EgAS0AGXZqQQJ0aigBADYBICABLQAZIAEtACFqIAEoAjhNDQAgASgCREUNDiABIAEoAkRBf2o2AkQgASABKAJMIgBBAWo2AkwgASABKAI8IAAtAAAgASgCOHRqNgI8IAEgASgCOEEIajYCOAwBCwsgASABKAI8IAEtABl2NgI8IAEgASgCOCABLQAZazYCOCABKAJQIgAgAS0AGSAAKALIN2o2Asg3CyABIAEoAjwgAS0AIXY2AjwgASABKAI4IAEtACFrNgI4IAEoAlAiACABLQAhIAAoAsg3ajYCyDcgASgCUCABLwEiNgJEIAEtACBFBEAgASgCUEHN/gA2AgQMDQsgAS0AIEEgcQRAIAEoAlBBfzYCyDcgASgCUEG//gA2AgQMDQsgAS0AIEHAAHEEQCABKAJYQYfxADYCGCABKAJQQdH+ADYCBAwNCyABKAJQIAEtACBBD3E2AkwgASgCUEHJ/gA2AgQLIAEoAlAoAkwEQANAIAEoAjggASgCUCgCTEkEQCABKAJERQ0NIAEgASgCREF/ajYCRCABIAEoAkwiAEEBajYCTCABIAEoAjwgAC0AACABKAI4dGo2AjwgASABKAI4QQhqNgI4DAELCyABKAJQIgAgACgCRCABKAI8QQEgASgCUCgCTHRBAWtxajYCRCABIAEoAjwgASgCUCgCTHY2AjwgASABKAI4IAEoAlAoAkxrNgI4IAEoAlAiACAB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KAIMSQRAIAIgAigCUCIAQQFqNgJQIAIgAigCLCAALQAAIAIoAih0ajYCLCACIAIoAihBCGo2AiggAigCKCACKAIMSQRAIAIgAigCUCIAQQFqNgJQIAIgAigCLCAALQAAIAIoAih0ajYCLCACIAIoAihBCGo2AigLCyACIAIoAgQgAigCLEEBIAIoAgx0QQFrcWo2AgQgAiACKAIsIAIoAgx2NgIsIAIgAigCKCACKAIMazYCKCACIAIoAkggAigCRGs2AgwCQCACKAIEIAIoAgxLBEAgAiACKAIEIAIoAgxrNgIMIAIoAgwgAigCOEsEQCACKAJUKALENwRAIAIoAlxBsO0ANgIYIAIoAlRB0f4ANgIEDAoLCyACIAIoAjA2AgACQCACKAI0RQRAIAIgAigCACACKAI8IAIoAgxrajYCACACKAIMIAIoAghJBEAgAiACKAIIIAIoAgxrNgIIA0AgAiACKAIAIgBBAWo2AgAgAC0AACEAIAIgAigCSCIBQQFqNgJIIAEgADoAACACIAIoAgxBf2oiADYCDCAADQALIAIgAigCSCACKAIEazYCAAsMAQsCQCACKAI0IAIoAgxJBEAgAiACKAIAIAIoAjwgAigCNGogAigCDGtqNgIAIAIgAigCDCACKAI0azYCDCACKAIMIAIoAghJBEAgAiACKAIIIAIoAgxrNgIIA0AgAiACKAIAIgBBAWo2AgAgAC0AACEAIAIgAigCSCIBQQFqNgJIIAEgADoAACACIAIoAgxBf2oiADYCDCAADQALIAIgAigCMDYCACACKAI0IAIoAghJBEAgAiACKAI0NgIMIAIgAigCCCACKAIMazYCCANAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIMQX9qIgA2AgwgAA0ACyACIAIoAkggAigCBGs2AgALCwwBCyACIAIoAgAgAigCNCACKAIMa2o2AgAgAigCDCACKAIISQRAIAIgAigCCCACKAIMazYCCANAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIMQX9qIgA2AgwgAA0ACyACIAIoAkggAigCBGs2AgALCwsDQCACKAIIQQJNRQRAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIAIgBBAWo2AgAgAC0AACEAIAIgAigCSCIBQQFqNgJIIAEgADoAACACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAAIAIgAigCCEEDazYCCAwBCwsMAQsgAiACKAJIIAIoAgRrNgIAA0AgAiACKAIAIgBBAWo2AgAgAC0AACEAIAIgAigCSCIBQQFqNgJIIAEgADoAACACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIIQQNrNgIIIAIoAghBAksNAAsLIAIoAggEQCACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAAIAIoAghBAUsEQCACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAACwsMAgsgAigCDEHAAHFFBEAgAkEQaiACKAIgIAIvARIgAigCLEEBIAIoAgx0QQFrcWpBAnRqKAEANgEADAELCyACKAJcQc7tADYCGCACKAJUQdH+ADYCBAwECwwCCyACKAIMQcAAcUUEQCACQRBqIAIoAiQgAi8BEiACKAIsQQEgAigCDHRBAWtxakECdGooAQA2AQAMAQsLIAIoAgxBIHEEQCACKAJUQb/+ADYCBAwCCyACKAJcQeTtADYCGCACKAJUQdH+ADYCBAwBC0EAIQAgAigCUCACKAJMSQR/IAIoAkggAigCQEkFQQALQQFxDQELCyACIAIoAihBA3Y2AgggAiACKAJQIAIoAghrNgJQIAIgAigCKCACKAIIQQN0azYCKCACIAIoAixBASACKAIodEEBa3E2AiwgAigCXCACKAJQNgIAIAIoAlwgAigCSDYCDCACKAJcAn8gAigCUCACKAJMSQRAIAIoAkwgAigCUGtBBWoMAQtBBSACKAJQIAIoAkxraws2AgQgAigCXAJ/IAIoAkggAigCQEkEQCACKAJAIAIoAkhrQYECagwBC0GBAiACKAJIIAIoAkBraws2AhAgAigCVCACKAIsNgI8IAIoAlQgAigCKDYCQAvBEAECfyMAQSBrIgIk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LSAAKAKgLUEBdGogAi8BEDsBACACLQATIQEgAigCKCIAKAKYLSEDIAAgACgCoC0iAEEBajYCoC0gACADaiABOgAAIAIgAi8BEEF/ajsBECACKAIoIAItABNBgNkAai0AAEECdGpBmAlqIgAgAC8BAEEBajsBACACKAIoQYgTagJ/IAIvARBBgAJIBEAgAi8BEC0AgFUMAQsgAi8BEEEHdUGAAmotAIBVC0ECdGoiACAALwEAQQFqOwEAIAIgAigCKCgCoC0gAigCKCgCnC1BAWtGNgIgIAIoAigiACAAKAJ0IAIoAigoAmBrNgJ0IAIoAigiACACKAIoKAJgIAAoAmxqNgJsIAIoAihBADYCYAwBCyACIAIoAigiACgCOCAAKAJsai0AADoADyACKAIoIgAoAqQtIAAoAqAtQQF0akEAOwEAIAItAA8hASACKAIoIgAoApgtIQMgACAAKAKgLSIAQQFqNgKgLSAAIANqIAE6AAAgAigCKCACLQAPQQJ0aiIAIAAvAZQBQQFqOwGUASACIAIoAigoAqAtIAIoAigoApwtQQFrRjYCICACKAIoIgAgACgCdEF/ajYCdCACKAIoIgAgACgCbEEBajYCbAsgAigCIARAIAIoAigCfyACKAIoKAJcQQBOBEAgAigCKCgCOCACKAIoKAJcagwBC0EACyACKAIoKAJsIAIoAigoAlxrQQAQKSACKAIoIAIoAigoAmw2AlwgAigCKCgCABAdIAIoAigoAgAoAhBFBEAgAkEANgIsDAQLCwwBCwsgAigCKEEANgK0LSACKAIkQQRGBEAgAigCKAJ/IAIoAigoAlxBAE4EQCACKAIoKAI4IAIoAigoAlxqDAELQQALIAIoAigoAmwgAigCKCgCXGtBARApIAIoAiggAigCKCgCbDYCXCACKAIoKAIAEB0gAigCKCgCACgCEEUEQCACQQI2AiwMAgsgAkEDNgIsDAELIAIoAigoAqAtBEAgAigCKAJ/IAIoAigoAlxBAE4EQCACKAIoKAI4IAIoAigoAlxqDAELQQALIAIoAigoAmwgAigCKCgCXGtBABApIAIoAiggAigCKCgCbDYCXCACKAIoKAIAEB0gAigCKCgCACgCEEUEQCACQQA2AiwMAgsLIAJBATYCLAsgAigCLCEAIAJBMGokACAAC8AFAQJ/IwBBIGsiAiQA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AgQgAkEANgIQA0AgAigCEEEPSkUEQCACKAI8QbwWaiACKAIQQQF0akEAOwEAIAIgAigCEEEBajYCEAwBCwsgAigCNCACKAI8QdwWaiACKAI8KALUKEECdGooAgBBAnRqQQA7AQIgAiACKAI8KALUKEEBajYCHANAIAIoAhxBvQRIBEAgAiACKAI8QdwWaiACKAIcQQJ0aigCADYCGCACIAIoAjQgAigCNCACKAIYQQJ0ai8BAkECdGovAQJBAWo2AhAgAigCECACKAIgSgRAIAIgAigCIDYCECACIAIoAgRBAWo2AgQLIAIoAjQgAigCGEECdGogAigCEDsBAiACKAIYIAIoAjBMBEAgAigCPCACKAIQQQF0akG8FmoiACAALwEAQQFqOwEAIAJBADYCDCACKAIYIAIoAiROBEAgAiACKAIoIAIoAhggAigCJGtBAnRqKAIANgIMCyACIAIoAjQgAigCGEECdGovAQA7AQogAigCPCIAIAAoAqgtIAIvAQogAigCECACKAIMamxqNgKoLSACKAIsBEAgAigCPCIAIAAoAqwtIAIvAQogAigCLCACKAIYQQJ0ai8BAiACKAIMamxqNgKsLQsLIAIgAigCHEEBajYCHAwBCwsCQCACKAIERQ0AA0AgAiACKAIgQQFrNgIQA0AgAigCPEG8FmogAigCEEEBdGovAQBFBEAgAiACKAIQQX9qNgIQDAELCyACKAI8IAIoAhBBAXRqQbwWaiIAIAAvAQBBf2o7AQAgAigCPCACKAIQQQF0akG+FmoiACAALwEAQQJqOwEAIAIoAjwgAigCIEEBdGpBvBZqIgAgAC8BAEF/ajsBACACIAIoAgRBAms2AgQgAigCBEEASg0ACyACIAIoAiA2AhADQCACKAIQRQ0BIAIgAigCPEG8FmogAigCEEEBdGovAQA2AhgDQCACKAIYBEAgAigCPEHcFmohACACIAIoAhxBf2oiATYCHCACIAFBAnQgAGooAgA2AhQgAigCFCACKAIwSg0BIAIoAjQgAigCFEECdGovAQIgAigCEEcEQCACKAI8IgAgACgCqC0gAigCNCACKAIUQQJ0ai8BACACKAIQIAIoAjQgAigCFEECdGovAQJrbGo2AqgtIAIoAjQgAigCFEECdGogAigCEDsBAgsgAiACKAIYQX9qNgIYDAELCyACIAIoAhBBf2o2AhAMAAALAAsLpQsBAX8jAEFAaiIEJAAgBCAANgI8IAQgATYCOCAEIAI2AjQgBCADNgIwIARBBTYCKAJAIAQoAjwoArwtQRAgBCgCKGtKBEAgBCAEKAI4QYECazYCJCAEKAI8IgAgAC8BuC0gBCgCJEH//wNxIAQoAjwoArwtdHI7AbgtIAQoAjwvAbgtQf8BcSEBIAQoAjwoAgghAiAEKAI8IgMoAhQhACADIABBAWo2AhQgACACaiABOgAAIAQoAjwvAbgtQQh1IQEgBCgCPCgCCCECIAQoAjwiAygCFCEAIAMgAEEBajYCFCAAIAJqIAE6AAAgBCgCPCAEKAIkQf//A3FBECAEKAI8KAK8LWt1OwG4LSAEKAI8IgAgACgCvC0gBCgCKEEQa2o2ArwtDAELIAQoAjwiACAALwG4LSAEKAI4QYECa0H//wNxIAQoAjwoArwtdHI7AbgtIAQoAjwiACAEKAIoIAAoArwtajYCvC0LIARBBTYCIAJAIAQoAjwoArwtQRAgBCgCIGtKBEAgBCAEKAI0QQFrNgIcIAQoAjwiACAALwG4LSAEKAIcQf//A3EgBCgCPCgCvC10cjsBuC0gBCgCPC8BuC1B/wFxIQEgBCgCPCgCCCECIAQoAjwiAygCFCEAIAMgAEEBajYCFCAAIAJqIAE6AAAgBCgCPC8BuC1BCHUhASAEKAI8KAIIIQIgBCgCPCIDKAIUIQAgAyAAQQFqNgIUIAAgAmogAToAACAEKAI8IAQoAhxB//8DcUEQIAQoAjwoArwta3U7AbgtIAQoAjwiACAAKAK8LSAEKAIgQRBrajYCvC0MAQsgBCgCPCIAIAAvAbgtIAQoAjRBAWtB//8DcSAEKAI8KAK8LXRyOwG4LSAEKAI8IgAgBCgCICAAKAK8LWo2ArwtCyAEQQQ2AhgCQCAEKAI8KAK8LUEQIAQoAhhrSgRAIAQgBCgCMEEEazYCFCAEKAI8IgAgAC8BuC0gBCgCFEH//wNxIAQoAjwoArwtdHI7AbgtIAQoAjwvAbgtQf8BcSEBIAQoAjwoAgghAiAEKAI8IgMoAhQhACADIABBAWo2AhQgACACaiABOgAAIAQoAjwvAbgtQQh1IQEgBCgCPCgCCCECIAQoAjwiAygCFCEAIAMgAEEBajYCFCAAIAJqIAE6AAAgBCgCPCAEKAIUQf//A3FBECAEKAI8KAK8LWt1OwG4LSAEKAI8IgAgACgCvC0gBCgCGEEQa2o2ArwtDAELIAQoAjwiACAALwG4LSAEKAIwQQRrQf//A3EgBCgCPCgCvC10cjsBuC0gBCgCPCIAIAQoAhggACgCvC1qNgK8LQsgBEEANgIsA0AgBCgCLCAEKAIwTkUEQCAEQQM2AhACQCAEKAI8KAK8LUEQIAQoAhBrSgRAIAQgBCgCPEH8FGogBCgCLC0AkGhBAnRqLwECNgIMIAQoAjwiACAALwG4LSAEKAIMQf//A3EgBCgCPCgCvC10cjsBuC0gBCgCPC8BuC1B/wFxIQEgBCgCPCgCCCECIAQoAjwiAygCFCEAIAMgAEEBajYCFCAAIAJqIAE6AAAgBCgCPC8BuC1BCHUhASAEKAI8KAIIIQIgBCgCPCIDKAIUIQAgAyAAQQFqNgIUIAAgAmogAToAACAEKAI8IAQoAgxB//8DcUEQIAQoAjwoArwta3U7AbgtIAQoAjwiACAAKAK8LSAEKAIQQRBrajYCvC0MAQsgBCgCPCIAIAAvAbgtIAQoAjxB/BRqIAQoAiwtAJBoQQJ0ai8BAiAEKAI8KAK8LXRyOwG4LSAEKAI8IgAgBCgCECAAKAK8LWo2ArwtCyAEIAQoAixBAWo2AiwMAQsLIAQoAjwgBCgCPEGUAWogBCgCOEEBaxCzASAEKAI8IAQoAjxBiBNqIAQoAjRBAWsQswEgBEFAayQAC8YBAQF/IwBBEGsiASQAIAEgADYCDCABKAIMIAEoAgxBlAFqIAEoAgwoApwWELQBIAEoAgwgASgCDEGIE2ogASgCDCgCqBYQtAEgASgCDCABKAIMQbAWahB2IAFBEjYCCANAAkAgASgCCEEDSA0AIAEoAgxB/BRqIAEoAggtAJBoQQJ0ai8BAg0AIAEgASgCCEF/ajYCCAwBCwsgASgCDCIAIAAoAqgtIAEoAghBA2xBEWpqNgKoLSABKAIIIQAgAUEQaiQAIAALgwIBAX8jAEEQayIBIAA2AgggAUH/gP+ffzYCBCABQQA2AgACQANAIAEoAgBBH0wEQAJAIAEoAgRBAXFFDQAgASgCCEGUAWogASgCAEECdGovAQBFDQAgAUEANgIMDAMLIAEgASgCAEEBajYCACABIAEoAgRBAXY2AgQMAQsLAkACQCABKAIILwG4AQ0AIAEoAggvAbwBDQAgASgCCC8ByAFFDQELIAFBATYCDAwBCyABQSA2AgADQCABKAIAQYACSARAIAEoAghBlAFqIAEoAgBBAnRqLwEABEAgAUEBNgIMDAMFIAEgASgCAEEBajYCAAwCCwALCyABQQA2AgwLIAEoAgwLjgUBBH8jAEEgayIBJAAgASAANgIcIAFBAzYCGAJAIAEoAhwoArwtQRAgASgCGGtKBEAgAUECNgIUIAEoAhwiACAALwG4LSABKAIUQf//A3EgASgCHCgCvC10cjsBuC0gASgCHC8BuC1B/wFxIQIgASgCHCgCCCEDIAEoAhwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAI6AAAgASgCHC8BuC1BCHUhAiABKAIcKAIIIQMgASgCHCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAjoAACABKAIcIAEoAhRB//8DcUEQIAEoAhwoArwta3U7AbgtIAEoAhwiACAAKAK8LSABKAIYQRBrajYCvC0MAQsgASgCHCIAIAAvAbgtQQIgASgCHCgCvC10cjsBuC0gASgCHCIAIAEoAhggACgCvC1qNgK8LQsgAUHC4wAvAQA2AhACQCABKAIcKAK8LUEQIAEoAhBrSgRAIAFBwOMALwEANgIMIAEoAhwiACAALwG4LSABKAIMQf//A3EgASgCHCgCvC10cjsBuC0gASgCHC8BuC1B/wFxIQIgASgCHCgCCCEDIAEoAhwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAI6AAAgASgCHC8BuC1BCHUhAiABKAIcKAIIIQMgASgCHCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAjoAACABKAIcIAEoAgxB//8DcUEQIAEoAhwoArwta3U7AbgtIAEoAhwiACAAKAK8LSABKAIQQRBrajYCvC0MAQsgASgCHCIAIAAvAbgtQcDjAC8BACABKAIcKAK8LXRyOwG4LSABKAIcIgAgASgCECAAKAK8LWo2ArwtCyABKAIcELcBIAFBIGokAAsjAQF/IwBBEGsiASQAIAEgADYCDCABKAIMELcBIAFBEGokAAuWAQEBfyMAQRBrIgEkACABIAA2AgwgASgCDCABKAIMQZQBajYCmBYgASgCDEGA2wA2AqAWIAEoAgwgASgCDEGIE2o2AqQWIAEoAgxBlNsANgKsFiABKAIMIAEoAgxB/BRqNgKwFiABKAIMQajbADYCuBYgASgCDEEAOwG4LSABKAIMQQA2ArwtIAEoAgwQuQEgAUEQaiQAC9cNAQF/IwBBIGsiAyAANgIYIAMgATYCFCADIAI2AhAgAyADKAIYQRB2NgIMIAMgAygCGEH//wNxNgIYAkAgAygCEEEBRgRAIAMgAygCFC0AACADKAIYajYCGCADKAIYQfH/A08EQCADIAMoAhhB8f8DazYCGAsgAyADKAIYIAMoAgxqNgIMIAMoAgxB8f8DTwRAIAMgAygCDEHx/wNrNgIMCyADIAMoAhggAygCDEEQdHI2AhwMAQsgAygCFEUEQCADQQE2AhwMAQsgAygCEEEQSQRAA0AgAyADKAIQIgBBf2o2AhAgAARAIAMgAygCFCIAQQFqNgIUIAMgAC0AACADKAIYajYCGCADIAMoAhggAygCDGo2AgwMAQsLIAMoAhhB8f8DTwRAIAMgAygCGEHx/wNrNgIYCyADIAMoAgxB8f8DcDYCDCADIAMoAhggAygCDEEQdHI2AhwMAQsDQCADKAIQQbArSUUEQCADIAMoAhBBsCtrNgIQIANB2wI2AggDQCADIAMoAhQtAAAgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AASADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQACIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAMgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ABCADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAFIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAYgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AByADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAIIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAkgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ACiADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQALIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAwgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ADSADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAOIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAA8gAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFEEQajYCFCADIAMoAghBf2oiADYCCCAADQALIAMgAygCGEHx/wNwNgIYIAMgAygCDEHx/wNwNgIMDAELCyADKAIQBEADQCADKAIQQRBJRQRAIAMgAygCEEEQazYCECADIAMoAhQtAAAgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AASADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQACIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAMgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ABCADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAFIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAYgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AByADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAIIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAkgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ACiADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQALIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAwgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ADSADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAOIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAA8gAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFEEQajYCFAwBCwsDQCADIAMoAhAiAEF/ajYCECAABEAgAyADKAIUIgBBAWo2AhQgAyAALQAAIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDAwBCwsgAyADKAIYQfH/A3A2AhggAyADKAIMQfH/A3A2AgwLIAMgAygC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KAIEDAELIAMoAgwoAgALQYAEEF4iADYCECAAQQBIBEAgA0J/NwO4AQwDCyADKAIQBEAgA0EBOgAXCyADIAMpAxhCAXw3AxgMAQsLIAMgAygCtAEoAgAQNSICNwMgIAJCAFMEQCADKAK0AUEIaiADKAK0ASgCABAYIANCfzcDuAEMAQsgAyADKQMgIAMpA6ABfTcDmAECQCADKQOgAUL/////D1gEQCADKQOoAUL//wNYDQELIANBAToAFwsgAyADQTBqQuIAECoiADYCLCAARQRAIAMoArQBQQhqQQ5BABAVIANCfzcDuAEMAQsgAy0AF0EBcQRAIAMoAixBttMAQQQQQCADKAIsQiwQLiADKAIsQS0QICADKAIsQS0QICADKAIsQQAQISADKAIsQQAQISADKAIsIAMpA6gBEC4gAygCLCADKQOoARAuIAMoAiwgAykDmAEQLiADKAIsIAMpA6ABEC4gAygCLEG70wBBBBBAIAMoAixBABAhIAMoAiwgAykDoAEgAykDmAF8EC4gAygCLEEBECELIAMoAixBwNMAQQQQQCADKAIsQQAQISADKAIsAn5C//8DIAMpA6gBQv//A1oNABogAykDqAELp0H//wNxECAgAygCLAJ+Qv//AyADKQOoAUL//wNaDQAaIAMpA6gBC6dB//8DcRAgIAMoAiwCf0F/IAMpA5gBQv////8PWg0AGiADKQOYAacLECEgAygCLAJ/QX8gAykDoAFC/////w9aDQAaIAMpA6ABpwsQISADAn8gAygCtAEtAChBAXEEQCADKAK0ASgCJAwBCyADKAK0ASgCIAs2ApQBIAMoAiwCfyADKAKUAQRAIAMoApQBLwEEDAELQQALQf//A3EQIAJ/IwBBEGsiACADKAIsNgIMIAAoAgwtAABBAXFFCwRAIAMoArQBQQhqQRRBABAVIAMoAiwQFyADQn83A7gBDAELIAMoArQBAn8jAEEQayIAIAMoAiw2AgwgACgCDCgCBAsCfiMAQRBrIgAgAygCLDYCDAJ+IAAoAgwtAABBAXEEQCAAKAIMKQMQDAELQgALCxA2QQBIBEAgAygCLBAXIANCfzcDuAEMAQsgAygCLBAXIAMoApQBBEAgAygCtAEgAygClAEoAgAgAygClAEvAQStEDZBAEgEQCADQn83A7gBDAILCyADIAMpA5gBNwO4AQsgAykDuAEhAiADQcABaiQAIAILBwAgACgCIAsIAEEBQTgQewsDAAELC/KNAScAQYAIC5QFTm8gZXJyb3IATXVsdGktZGlzayB6aXAgYXJjaGl2ZXMgbm90IHN1cHBvcnRlZABSZW5hbWluZyB0ZW1wb3JhcnkgZmlsZSBmYWlsZWQAQ2xvc2luZyB6aXAgYXJjaGl2ZSBmYWlsZWQAU2VlayBlcnJvcgBSZWFkIGVycm9yAFdyaXRlIGVycm9yAENSQyBlcnJvcgBDb250YWluaW5nIHppcCBhcmNoaXZlIHdhcyBjbG9zZWQATm8gc3VjaCBmaWxlAEZpbGUgYWxyZWFkeSBleGlzdHMAQ2FuJ3Qgb3BlbiBmaWxlAEZhaWx1cmUgdG8gY3JlYXRlIHRlbXBvcmFyeSBmaWxlAFpsaWIgZXJyb3IATWFsbG9jIGZhaWx1cmUARW50cnkgaGFzIGJlZW4gY2hhbmdlZABDb21wcmVzc2lvbiBtZXRob2Qgbm90IHN1cHBvcnRlZABQcmVtYXR1cmUgZW5kIG9mIGZpbGUASW52YWxpZCBhcmd1bWVudABOb3QgYSB6aXAgYXJjaGl2ZQBJbnRlcm5hbCBlcnJvcgBaaXAgYXJjaGl2ZSBpbmNvbnNpc3RlbnQAQ2FuJ3QgcmVtb3ZlIGZpbGUARW50cnkgaGFzIGJlZW4gZGVsZXRlZABFbmNyeXB0aW9uIG1ldGhvZCBub3Qgc3VwcG9ydGVkAFJlYWQtb25seSBhcmNoaXZlAE5vIHBhc3N3b3JkIHByb3ZpZGVkAFdyb25nIHBhc3N3b3JkIHByb3ZpZGVkAE9wZXJhdGlvbiBub3Qgc3VwcG9ydGVkAFJlc291cmNlIHN0aWxsIGluIHVzZQBUZWxsIGVycm9yAENvbXByZXNzZWQgZGF0YSBpbnZhbGlkAEGhDQuAAQQAAAkEAAAvBAAATgQAAGkEAAB0BAAAfwQAAIsEAACVBAAAtwQAAMQEAADYBAAA6AQAAAkFAAAUBQAAIwUAADoFAABbBQAAcQUAAIIFAACUBQAAowUAALwFAADOBQAA5QUAAAUGAAAXBgAALAYAAEQGAABcBgAAcgYAAH0GAAAgAEG4DgsRAQAAAAEAAAABAAAAAQAAAAEAQdwOCwkBAAAAAQAAAAIAQYgPCwEBAEGoDwsB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CAAaAAgAmgAIAFoACADaAAgAOgAIALoACAB6AAgA+gAIAAYACACGAAgARgAIAMYACAAmAAgApgAIAGYACADmAAgAFgAIAJYACABWAAgA1gAIADYACAC2AAgAdgAIAPYACAAOAAgAjgAIAE4ACADOAAgALgAIAK4ACABuAAgA7gAIAB4ACACeAAgAXgAIAN4ACAA+AAgAvgAIAH4ACAD+AAgAAQAIAIEACABBAAgAwQAIACEACAChAAgAYQAIAOEACAARAAgAkQAIAFEACADRAAgAMQAIALEACABxAAgA8QAIAAkACACJAAgASQAIAMkACAApAAgAqQAIAGkACADpAAgAGQAIAJkACABZAAgA2QAIADkACAC5AAgAeQAIAPkACAAFAAgAhQAIAEUACADFAAgAJQAIAKUACABlAAgA5QAIABUACACVAAgAVQAIANUACAA1AAgAtQAIAHUACAD1AAgADQAIAI0ACABNAAgAzQAIAC0ACACtAAgAbQAIAO0ACAAdAAgAnQAIAF0ACADdAAgAPQAIAL0ACAB9AAgA/QAIABMACQATAQkAkwAJAJMBCQBTAAkAUwEJANMACQDTAQkAMwAJADMBCQCzAAkAswEJAHMACQBzAQkA8wAJAPMBCQALAAkACwEJAIsACQCLAQkASwAJAEsBCQDLAAkAywEJACsACQArAQkAqwAJAKsBCQBrAAkAawEJAOsACQDrAQkAGwAJABsBCQCbAAkAmwEJAFsACQBbAQkA2wAJANsBCQA7AAkAOwEJALsACQC7AQkAewAJAHsBCQD7AAkA+wEJAAcACQAHAQkAhwAJAIcBCQBHAAkARwEJAMcACQDHAQkAJwAJACcBCQCnAAkApwEJAGcACQBnAQkA5wAJAOcBCQAXAAkAFwEJAJcACQCXAQkAVwAJAFcBCQDXAAkA1wEJADcACQA3AQkAtwAJALcBCQB3AAkAdwEJAPcACQD3AQkADwAJAA8BCQCPAAkAjwEJAE8ACQBPAQkAzwAJAM8BCQAvAAkALwEJAK8ACQCvAQkAbwAJAG8BCQDvAAkA7wEJAB8ACQAfAQkAnwAJAJ8BCQBfAAkAXwEJAN8ACQDfAQkAPwAJAD8BCQC/AAkAvwEJAH8ACQB/AQkA/wAJAP8BCQAAAAcAQAAHACAABwBgAAcAEAAHAFAABwAwAAcAcAAHAAgA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cnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATm8gZXJyb3IgaW5mb3JtYXRpb24AAFVua25vd24gZXJyb3IgJWQAJXMlcyVzAAA6IAAvcHJvYy9zZWxmL2ZkLwAvZGV2L3VyYW5kb20AcndhACVzLlhYWFhYWAByK2IAcmIAUEsFBgBBkJgBC04KAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAALAAAADAAAAA0AAAAOAAAADwAAABAAAAARAAAAAQAAAAgAAAAQTAAAMEwAQZCaAQsCgFAAQciaAQsJHwAAAGRNAAADAEHkmgELjAEt9FFYz4yxwEb2tcspMQPHBFtwMLRd/SB4f4ua2FkpUGhIiaunVgNs/7fNiD/Ud7QrpaNw8brkqPxBg/3Zb+GKei8tdJYHHw0JXgN2LHD3QKUsp29XQaiqdN+gWGQDSsfEPFOur18YBBWx420ohqsMpL9D8OlQgTlXFlI3/////////////////////w==";
if (!isDataURI(wasmBinaryFile)) {
  wasmBinaryFile = locateFile(wasmBinaryFile);
}
function getBinary() {
  try {
    if (wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    var binary = tryParseAsDataURI(wasmBinaryFile);
    if (binary) {
      return binary;
    }
    if (readBinary) {
      return readBinary(wasmBinaryFile);
    } else {
      throw "sync fetching of the wasm failed: you can preload it to Module['wasmBinary'] manually, or emcc.py will do that for you when generating HTML (but not JS)";
    }
  } catch (err) {
    abort(err);
  }
}
function createWasm() {
  var info = { a: asmLibraryArg };
  function receiveInstance(instance, module) {
    var exports = instance.exports;
    Module["asm"] = exports;
    removeRunDependency("wasm-instantiate");
  }
  addRunDependency("wasm-instantiate");
  function instantiateSync() {
    var instance;
    var module;
    var binary;
    try {
      binary = getBinary();
      module = new WebAssembly.Module(binary);
      instance = new WebAssembly.Instance(module, info);
    } catch (e) {
      var str = e.toString();
      err("failed to compile wasm module: " + str);
      if (
        str.indexOf("imported Memory") >= 0 ||
        str.indexOf("memory import") >= 0
      ) {
        err(
          "Memory size incompatibility issues may be due to changing INITIAL_MEMORY at runtime to something too large. Use ALLOW_MEMORY_GROWTH to allow any size memory (and also make sure not to set INITIAL_MEMORY at runtime to something smaller than it was at compile time)."
        );
      }
      throw e;
    }
    receiveInstance(instance, module);
  }
  if (Module["instantiateWasm"]) {
    try {
      var exports = Module["instantiateWasm"](info, receiveInstance);
      return exports;
    } catch (e) {
      err("Module.instantiateWasm callback failed with error: " + e);
      return false;
    }
  }
  instantiateSync();
  return Module["asm"];
}
var tempDouble;
var tempI64;
__ATINIT__.push({
  func: function() {
    ___wasm_call_ctors();
  }
});
function callRuntimeCallbacks(callbacks) {
  while (callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == "function") {
      callback(Module);
      continue;
    }
    var func = callback.func;
    if (typeof func === "number") {
      if (callback.arg === undefined) {
        wasmTable.get(func)();
      } else {
        wasmTable.get(func)(callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}
function demangle(func) {
  return func;
}
function demangleAll(text) {
  var regex = /\b_Z[\w\d_]+/g;
  return text.replace(regex, function(x) {
    var y = demangle(x);
    return x === y ? x : y + " [" + x + "]";
  });
}
function jsStackTrace() {
  var error = new Error();
  if (!error.stack) {
    try {
      throw new Error();
    } catch (e) {
      error = e;
    }
    if (!error.stack) {
      return "(no stack trace available)";
    }
  }
  return error.stack.toString();
}
function stackTrace() {
  var js = jsStackTrace();
  if (Module["extraStackTrace"]) js += "\n" + Module["extraStackTrace"]();
  return demangleAll(js);
}
function _gmtime_r(time, tmPtr) {
  var date = new Date(HEAP32[time >> 2] * 1e3);
  HEAP32[tmPtr >> 2] = date.getUTCSeconds();
  HEAP32[(tmPtr + 4) >> 2] = date.getUTCMinutes();
  HEAP32[(tmPtr + 8) >> 2] = date.getUTCHours();
  HEAP32[(tmPtr + 12) >> 2] = date.getUTCDate();
  HEAP32[(tmPtr + 16) >> 2] = date.getUTCMonth();
  HEAP32[(tmPtr + 20) >> 2] = date.getUTCFullYear() - 1900;
  HEAP32[(tmPtr + 24) >> 2] = date.getUTCDay();
  HEAP32[(tmPtr + 36) >> 2] = 0;
  HEAP32[(tmPtr + 32) >> 2] = 0;
  var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
  var yday = ((date.getTime() - start) / (1e3 * 60 * 60 * 24)) | 0;
  HEAP32[(tmPtr + 28) >> 2] = yday;
  if (!_gmtime_r.GMTString) _gmtime_r.GMTString = allocateUTF8("GMT");
  HEAP32[(tmPtr + 40) >> 2] = _gmtime_r.GMTString;
  return tmPtr;
}
function ___gmtime_r(a0, a1) {
  return _gmtime_r(a0, a1);
}
var PATH = {
  splitPath: function(filename) {
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    return splitPathRe.exec(filename).slice(1);
  },
  normalizeArray: function(parts, allowAboveRoot) {
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
      var last = parts[i];
      if (last === ".") {
        parts.splice(i, 1);
      } else if (last === "..") {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
    }
    if (allowAboveRoot) {
      for (; up; up--) {
        parts.unshift("..");
      }
    }
    return parts;
  },
  normalize: function(path) {
    var isAbsolute = path.charAt(0) === "/",
      trailingSlash = path.substr(-1) === "/";
    path = PATH.normalizeArray(
      path.split("/").filter(function(p) {
        return !!p;
      }),
      !isAbsolute
    ).join("/");
    if (!path && !isAbsolute) {
      path = ".";
    }
    if (path && trailingSlash) {
      path += "/";
    }
    return (isAbsolute ? "/" : "") + path;
  },
  dirname: function(path) {
    var result = PATH.splitPath(path),
      root = result[0],
      dir = result[1];
    if (!root && !dir) {
      return ".";
    }
    if (dir) {
      dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
  },
  basename: function(path) {
    if (path === "/") return "/";
    path = PATH.normalize(path);
    path = path.replace(/\/$/, "");
    var lastSlash = path.lastIndexOf("/");
    if (lastSlash === -1) return path;
    return path.substr(lastSlash + 1);
  },
  extname: function(path) {
    return PATH.splitPath(path)[3];
  },
  join: function() {
    var paths = Array.prototype.slice.call(arguments, 0);
    return PATH.normalize(paths.join("/"));
  },
  join2: function(l, r) {
    return PATH.normalize(l + "/" + r);
  }
};
function setErrNo(value) {
  HEAP32[___errno_location() >> 2] = value;
  return value;
}
var PATH_FS = {
  resolve: function() {
    var resolvedPath = "",
      resolvedAbsolute = false;
    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = i >= 0 ? arguments[i] : FS.cwd();
      if (typeof path !== "string") {
        throw new TypeError("Arguments to path.resolve must be strings");
      } else if (!path) {
        return "";
      }
      resolvedPath = path + "/" + resolvedPath;
      resolvedAbsolute = path.charAt(0) === "/";
    }
    resolvedPath = PATH.normalizeArray(
      resolvedPath.split("/").filter(function(p) {
        return !!p;
      }),
      !resolvedAbsolute
    ).join("/");
    return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
  },
  relative: function(from, to) {
    from = PATH_FS.resolve(from).substr(1);
    to = PATH_FS.resolve(to).substr(1);
    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== "") break;
      }
      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== "") break;
      }
      if (start > end) return [];
      return arr.slice(start, end - start + 1);
    }
    var fromParts = trim(from.split("/"));
    var toParts = trim(to.split("/"));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }
    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push("..");
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join("/");
  }
};
var TTY = {
  ttys: [],
  init: function() {},
  shutdown: function() {},
  register: function(dev, ops) {
    TTY.ttys[dev] = { input: [], output: [], ops: ops };
    FS.registerDevice(dev, TTY.stream_ops);
  },
  stream_ops: {
    open: function(stream) {
      var tty = TTY.ttys[stream.node.rdev];
      if (!tty) {
        throw new FS.ErrnoError(43);
      }
      stream.tty = tty;
      stream.seekable = false;
    },
    close: function(stream) {
      stream.tty.ops.flush(stream.tty);
    },
    flush: function(stream) {
      stream.tty.ops.flush(stream.tty);
    },
    read: function(stream, buffer, offset, length, pos) {
      if (!stream.tty || !stream.tty.ops.get_char) {
        throw new FS.ErrnoError(60);
      }
      var bytesRead = 0;
      for (var i = 0; i < length; i++) {
        var result;
        try {
          result = stream.tty.ops.get_char(stream.tty);
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (result === undefined && bytesRead === 0) {
          throw new FS.ErrnoError(6);
        }
        if (result === null || result === undefined) break;
        bytesRead++;
        buffer[offset + i] = result;
      }
      if (bytesRead) {
        stream.node.timestamp = Date.now();
      }
      return bytesRead;
    },
    write: function(stream, buffer, offset, length, pos) {
      if (!stream.tty || !stream.tty.ops.put_char) {
        throw new FS.ErrnoError(60);
      }
      try {
        for (var i = 0; i < length; i++) {
          stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
        }
      } catch (e) {
        throw new FS.ErrnoError(29);
      }
      if (length) {
        stream.node.timestamp = Date.now();
      }
      return i;
    }
  },
  default_tty_ops: {
    get_char: function(tty) {
      if (!tty.input.length) {
        var result = null;
        if (ENVIRONMENT_IS_NODE) {
          var BUFSIZE = 256;
          var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
          var bytesRead = 0;
          try {
            bytesRead = nodeFS.readSync(
              process.stdin.fd,
              buf,
              0,
              BUFSIZE,
              null
            );
          } catch (e) {
            if (e.toString().indexOf("EOF") != -1) bytesRead = 0;
            else throw e;
          }
          if (bytesRead > 0) {
            result = buf.slice(0, bytesRead).toString("utf-8");
          } else {
            result = null;
          }
        } else if (
          typeof window != "undefined" &&
          typeof window.prompt == "function"
        ) {
          result = window.prompt("Input: ");
          if (result !== null) {
            result += "\n";
          }
        } else if (typeof readline == "function") {
          result = readline();
          if (result !== null) {
            result += "\n";
          }
        }
        if (!result) {
          return null;
        }
        tty.input = intArrayFromString(result, true);
      }
      return tty.input.shift();
    },
    put_char: function(tty, val) {
      if (val === null || val === 10) {
        out(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      } else {
        if (val != 0) tty.output.push(val);
      }
    },
    flush: function(tty) {
      if (tty.output && tty.output.length > 0) {
        out(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      }
    }
  },
  default_tty1_ops: {
    put_char: function(tty, val) {
      if (val === null || val === 10) {
        err(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      } else {
        if (val != 0) tty.output.push(val);
      }
    },
    flush: function(tty) {
      if (tty.output && tty.output.length > 0) {
        err(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      }
    }
  }
};
var MEMFS = {
  ops_table: null,
  mount: function(mount) {
    return MEMFS.createNode(null, "/", 16384 | 511, 0);
  },
  createNode: function(parent, name, mode, dev) {
    if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
      throw new FS.ErrnoError(63);
    }
    if (!MEMFS.ops_table) {
      MEMFS.ops_table = {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: { llseek: MEMFS.stream_ops.llseek }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
    }
    var node = FS.createNode(parent, name, mode, dev);
    if (FS.isDir(node.mode)) {
      node.node_ops = MEMFS.ops_table.dir.node;
      node.stream_ops = MEMFS.ops_table.dir.stream;
      node.contents = {};
    } else if (FS.isFile(node.mode)) {
      node.node_ops = MEMFS.ops_table.file.node;
      node.stream_ops = MEMFS.ops_table.file.stream;
      node.usedBytes = 0;
      node.contents = null;
    } else if (FS.isLink(node.mode)) {
      node.node_ops = MEMFS.ops_table.link.node;
      node.stream_ops = MEMFS.ops_table.link.stream;
    } else if (FS.isChrdev(node.mode)) {
      node.node_ops = MEMFS.ops_table.chrdev.node;
      node.stream_ops = MEMFS.ops_table.chrdev.stream;
    }
    node.timestamp = Date.now();
    if (parent) {
      parent.contents[name] = node;
    }
    return node;
  },
  getFileDataAsRegularArray: function(node) {
    if (node.contents && node.contents.subarray) {
      var arr = [];
      for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
      return arr;
    }
    return node.contents;
  },
  getFileDataAsTypedArray: function(node) {
    if (!node.contents) return new Uint8Array(0);
    if (node.contents.subarray)
      return node.contents.subarray(0, node.usedBytes);
    return new Uint8Array(node.contents);
  },
  expandFileStorage: function(node, newCapacity) {
    var prevCapacity = node.contents ? node.contents.length : 0;
    if (prevCapacity >= newCapacity) return;
    var CAPACITY_DOUBLING_MAX = 1024 * 1024;
    newCapacity = Math.max(
      newCapacity,
      (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) >>> 0
    );
    if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
    var oldContents = node.contents;
    node.contents = new Uint8Array(newCapacity);
    if (node.usedBytes > 0)
      node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    return;
  },
  resizeFileStorage: function(node, newSize) {
    if (node.usedBytes == newSize) return;
    if (newSize == 0) {
      node.contents = null;
      node.usedBytes = 0;
      return;
    }
    if (!node.contents || node.contents.subarray) {
      var oldContents = node.contents;
      node.contents = new Uint8Array(newSize);
      if (oldContents) {
        node.contents.set(
          oldContents.subarray(0, Math.min(newSize, node.usedBytes))
        );
      }
      node.usedBytes = newSize;
      return;
    }
    if (!node.contents) node.contents = [];
    if (node.contents.length > newSize) node.contents.length = newSize;
    else while (node.contents.length < newSize) node.contents.push(0);
    node.usedBytes = newSize;
  },
  node_ops: {
    getattr: function(node) {
      var attr = {};
      attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
      attr.ino = node.id;
      attr.mode = node.mode;
      attr.nlink = 1;
      attr.uid = 0;
      attr.gid = 0;
      attr.rdev = node.rdev;
      if (FS.isDir(node.mode)) {
        attr.size = 4096;
      } else if (FS.isFile(node.mode)) {
        attr.size = node.usedBytes;
      } else if (FS.isLink(node.mode)) {
        attr.size = node.link.length;
      } else {
        attr.size = 0;
      }
      attr.atime = new Date(node.timestamp);
      attr.mtime = new Date(node.timestamp);
      attr.ctime = new Date(node.timestamp);
      attr.blksize = 4096;
      attr.blocks = Math.ceil(attr.size / attr.blksize);
      return attr;
    },
    setattr: function(node, attr) {
      if (attr.mode !== undefined) {
        node.mode = attr.mode;
      }
      if (attr.timestamp !== undefined) {
        node.timestamp = attr.timestamp;
      }
      if (attr.size !== undefined) {
        MEMFS.resizeFileStorage(node, attr.size);
      }
    },
    lookup: function(parent, name) {
      throw FS.genericErrors[44];
    },
    mknod: function(parent, name, mode, dev) {
      return MEMFS.createNode(parent, name, mode, dev);
    },
    rename: function(old_node, new_dir, new_name) {
      if (FS.isDir(old_node.mode)) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {}
        if (new_node) {
          for (var i in new_node.contents) {
            throw new FS.ErrnoError(55);
          }
        }
      }
      delete old_node.parent.contents[old_node.name];
      old_node.name = new_name;
      new_dir.contents[new_name] = old_node;
      old_node.parent = new_dir;
    },
    unlink: function(parent, name) {
      delete parent.contents[name];
    },
    rmdir: function(parent, name) {
      var node = FS.lookupNode(parent, name);
      for (var i in node.contents) {
        throw new FS.ErrnoError(55);
      }
      delete parent.contents[name];
    },
    readdir: function(node) {
      var entries = [".", ".."];
      for (var key in node.contents) {
        if (!node.contents.hasOwnProperty(key)) {
          continue;
        }
        entries.push(key);
      }
      return entries;
    },
    symlink: function(parent, newname, oldpath) {
      var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
      node.link = oldpath;
      return node;
    },
    readlink: function(node) {
      if (!FS.isLink(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      return node.link;
    }
  },
  stream_ops: {
    read: function(stream, buffer, offset, length, position) {
      var contents = stream.node.contents;
      if (position >= stream.node.usedBytes) return 0;
      var size = Math.min(stream.node.usedBytes - position, length);
      if (size > 8 && contents.subarray) {
        buffer.set(contents.subarray(position, position + size), offset);
      } else {
        for (var i = 0; i < size; i++)
          buffer[offset + i] = contents[position + i];
      }
      return size;
    },
    write: function(stream, buffer, offset, length, position, canOwn) {
      if (buffer.buffer === HEAP8.buffer) {
        canOwn = false;
      }
      if (!length) return 0;
      var node = stream.node;
      node.timestamp = Date.now();
      if (buffer.subarray && (!node.contents || node.contents.subarray)) {
        if (canOwn) {
          node.contents = buffer.subarray(offset, offset + length);
          node.usedBytes = length;
          return length;
        } else if (node.usedBytes === 0 && position === 0) {
          node.contents = buffer.slice(offset, offset + length);
          node.usedBytes = length;
          return length;
        } else if (position + length <= node.usedBytes) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
          return length;
        }
      }
      MEMFS.expandFileStorage(node, position + length);
      if (node.contents.subarray && buffer.subarray) {
        node.contents.set(buffer.subarray(offset, offset + length), position);
      } else {
        for (var i = 0; i < length; i++) {
          node.contents[position + i] = buffer[offset + i];
        }
      }
      node.usedBytes = Math.max(node.usedBytes, position + length);
      return length;
    },
    llseek: function(stream, offset, whence) {
      var position = offset;
      if (whence === 1) {
        position += stream.position;
      } else if (whence === 2) {
        if (FS.isFile(stream.node.mode)) {
          position += stream.node.usedBytes;
        }
      }
      if (position < 0) {
        throw new FS.ErrnoError(28);
      }
      return position;
    },
    allocate: function(stream, offset, length) {
      MEMFS.expandFileStorage(stream.node, offset + length);
      stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
    },
    mmap: function(stream, address, length, position, prot, flags) {
      assert(address === 0);
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      var ptr;
      var allocated;
      var contents = stream.node.contents;
      if (!(flags & 2) && contents.buffer === buffer) {
        allocated = false;
        ptr = contents.byteOffset;
      } else {
        if (position > 0 || position + length < contents.length) {
          if (contents.subarray) {
            contents = contents.subarray(position, position + length);
          } else {
            contents = Array.prototype.slice.call(
              contents,
              position,
              position + length
            );
          }
        }
        allocated = true;
        ptr = FS.mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        HEAP8.set(contents, ptr);
      }
      return { ptr: ptr, allocated: allocated };
    },
    msync: function(stream, buffer, offset, length, mmapFlags) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (mmapFlags & 2) {
        return 0;
      }
      var bytesWritten = MEMFS.stream_ops.write(
        stream,
        buffer,
        0,
        length,
        offset,
        false
      );
      return 0;
    }
  }
};
var ERRNO_CODES = {
  EPERM: 63,
  ENOENT: 44,
  ESRCH: 71,
  EINTR: 27,
  EIO: 29,
  ENXIO: 60,
  E2BIG: 1,
  ENOEXEC: 45,
  EBADF: 8,
  ECHILD: 12,
  EAGAIN: 6,
  EWOULDBLOCK: 6,
  ENOMEM: 48,
  EACCES: 2,
  EFAULT: 21,
  ENOTBLK: 105,
  EBUSY: 10,
  EEXIST: 20,
  EXDEV: 75,
  ENODEV: 43,
  ENOTDIR: 54,
  EISDIR: 31,
  EINVAL: 28,
  ENFILE: 41,
  EMFILE: 33,
  ENOTTY: 59,
  ETXTBSY: 74,
  EFBIG: 22,
  ENOSPC: 51,
  ESPIPE: 70,
  EROFS: 69,
  EMLINK: 34,
  EPIPE: 64,
  EDOM: 18,
  ERANGE: 68,
  ENOMSG: 49,
  EIDRM: 24,
  ECHRNG: 106,
  EL2NSYNC: 156,
  EL3HLT: 107,
  EL3RST: 108,
  ELNRNG: 109,
  EUNATCH: 110,
  ENOCSI: 111,
  EL2HLT: 112,
  EDEADLK: 16,
  ENOLCK: 46,
  EBADE: 113,
  EBADR: 114,
  EXFULL: 115,
  ENOANO: 104,
  EBADRQC: 103,
  EBADSLT: 102,
  EDEADLOCK: 16,
  EBFONT: 101,
  ENOSTR: 100,
  ENODATA: 116,
  ETIME: 117,
  ENOSR: 118,
  ENONET: 119,
  ENOPKG: 120,
  EREMOTE: 121,
  ENOLINK: 47,
  EADV: 122,
  ESRMNT: 123,
  ECOMM: 124,
  EPROTO: 65,
  EMULTIHOP: 36,
  EDOTDOT: 125,
  EBADMSG: 9,
  ENOTUNIQ: 126,
  EBADFD: 127,
  EREMCHG: 128,
  ELIBACC: 129,
  ELIBBAD: 130,
  ELIBSCN: 131,
  ELIBMAX: 132,
  ELIBEXEC: 133,
  ENOSYS: 52,
  ENOTEMPTY: 55,
  ENAMETOOLONG: 37,
  ELOOP: 32,
  EOPNOTSUPP: 138,
  EPFNOSUPPORT: 139,
  ECONNRESET: 15,
  ENOBUFS: 42,
  EAFNOSUPPORT: 5,
  EPROTOTYPE: 67,
  ENOTSOCK: 57,
  ENOPROTOOPT: 50,
  ESHUTDOWN: 140,
  ECONNREFUSED: 14,
  EADDRINUSE: 3,
  ECONNABORTED: 13,
  ENETUNREACH: 40,
  ENETDOWN: 38,
  ETIMEDOUT: 73,
  EHOSTDOWN: 142,
  EHOSTUNREACH: 23,
  EINPROGRESS: 26,
  EALREADY: 7,
  EDESTADDRREQ: 17,
  EMSGSIZE: 35,
  EPROTONOSUPPORT: 66,
  ESOCKTNOSUPPORT: 137,
  EADDRNOTAVAIL: 4,
  ENETRESET: 39,
  EISCONN: 30,
  ENOTCONN: 53,
  ETOOMANYREFS: 141,
  EUSERS: 136,
  EDQUOT: 19,
  ESTALE: 72,
  ENOTSUP: 138,
  ENOMEDIUM: 148,
  EILSEQ: 25,
  EOVERFLOW: 61,
  ECANCELED: 11,
  ENOTRECOVERABLE: 56,
  EOWNERDEAD: 62,
  ESTRPIPE: 135
};
var NODEFS = {
  isWindows: false,
  staticInit: function() {
    NODEFS.isWindows = !!process.platform.match(/^win/);
    var flags = { fs: fs.constants };
    if (flags["fs"]) {
      flags = flags["fs"];
    }
    NODEFS.flagsForNodeMap = {
      1024: flags["O_APPEND"],
      64: flags["O_CREAT"],
      128: flags["O_EXCL"],
      0: flags["O_RDONLY"],
      2: flags["O_RDWR"],
      4096: flags["O_SYNC"],
      512: flags["O_TRUNC"],
      1: flags["O_WRONLY"]
    };
  },
  bufferFrom: function(arrayBuffer) {
    return Buffer["alloc"] ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);
  },
  convertNodeCode: function(e) {
    var code = e.code;
    return ERRNO_CODES[code];
  },
  mount: function(mount) {
    return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
  },
  createNode: function(parent, name, mode, dev) {
    if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
      throw new FS.ErrnoError(28);
    }
    var node = FS.createNode(parent, name, mode);
    node.node_ops = NODEFS.node_ops;
    node.stream_ops = NODEFS.stream_ops;
    return node;
  },
  getMode: function(path) {
    var stat;
    try {
      stat = fs.lstatSync(path);
      if (NODEFS.isWindows) {
        stat.mode = stat.mode | ((stat.mode & 292) >> 2);
      }
    } catch (e) {
      if (!e.code) throw e;
      throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
    }
    return stat.mode;
  },
  realPath: function(node) {
    var parts = [];
    while (node.parent !== node) {
      parts.push(node.name);
      node = node.parent;
    }
    parts.push(node.mount.opts.root);
    parts.reverse();
    return PATH.join.apply(null, parts);
  },
  flagsForNode: function(flags) {
    flags &= ~2097152;
    flags &= ~2048;
    flags &= ~32768;
    flags &= ~524288;
    var newFlags = 0;
    for (var k in NODEFS.flagsForNodeMap) {
      if (flags & k) {
        newFlags |= NODEFS.flagsForNodeMap[k];
        flags ^= k;
      }
    }
    if (!flags) {
      return newFlags;
    } else {
      throw new FS.ErrnoError(28);
    }
  },
  node_ops: {
    getattr: function(node) {
      var path = NODEFS.realPath(node);
      var stat;
      try {
        stat = fs.lstatSync(path);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      if (NODEFS.isWindows && !stat.blksize) {
        stat.blksize = 4096;
      }
      if (NODEFS.isWindows && !stat.blocks) {
        stat.blocks = ((stat.size + stat.blksize - 1) / stat.blksize) | 0;
      }
      return {
        dev: stat.dev,
        ino: stat.ino,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr: function(node, attr) {
      var path = NODEFS.realPath(node);
      try {
        if (attr.mode !== undefined) {
          fs.chmodSync(path, attr.mode);
          node.mode = attr.mode;
        }
        if (attr.timestamp !== undefined) {
          var date = new Date(attr.timestamp);
          fs.utimesSync(path, date, date);
        }
        if (attr.size !== undefined) {
          fs.truncateSync(path, attr.size);
        }
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    lookup: function(parent, name) {
      var path = PATH.join2(NODEFS.realPath(parent), name);
      var mode = NODEFS.getMode(path);
      return NODEFS.createNode(parent, name, mode);
    },
    mknod: function(parent, name, mode, dev) {
      var node = NODEFS.createNode(parent, name, mode, dev);
      var path = NODEFS.realPath(node);
      try {
        if (FS.isDir(node.mode)) {
          fs.mkdirSync(path, node.mode);
        } else {
          fs.writeFileSync(path, "", { mode: node.mode });
        }
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      return node;
    },
    rename: function(oldNode, newDir, newName) {
      var oldPath = NODEFS.realPath(oldNode);
      var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
      try {
        fs.renameSync(oldPath, newPath);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      oldNode.name = newName;
    },
    unlink: function(parent, name) {
      var path = PATH.join2(NODEFS.realPath(parent), name);
      try {
        fs.unlinkSync(path);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    rmdir: function(parent, name) {
      var path = PATH.join2(NODEFS.realPath(parent), name);
      try {
        fs.rmdirSync(path);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    readdir: function(node) {
      var path = NODEFS.realPath(node);
      try {
        return fs.readdirSync(path);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    symlink: function(parent, newName, oldPath) {
      var newPath = PATH.join2(NODEFS.realPath(parent), newName);
      try {
        fs.symlinkSync(oldPath, newPath);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    readlink: function(node) {
      var path = NODEFS.realPath(node);
      try {
        path = fs.readlinkSync(path);
        path = NODEJS_PATH.relative(
          NODEJS_PATH.resolve(node.mount.opts.root),
          path
        );
        return path;
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    }
  },
  stream_ops: {
    open: function(stream) {
      var path = NODEFS.realPath(stream.node);
      try {
        if (FS.isFile(stream.node.mode)) {
          stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
        }
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    close: function(stream) {
      try {
        if (FS.isFile(stream.node.mode) && stream.nfd) {
          fs.closeSync(stream.nfd);
        }
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    read: function(stream, buffer, offset, length, position) {
      if (length === 0) return 0;
      try {
        return fs.readSync(
          stream.nfd,
          NODEFS.bufferFrom(buffer.buffer),
          offset,
          length,
          position
        );
      } catch (e) {
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    write: function(stream, buffer, offset, length, position) {
      try {
        return fs.writeSync(
          stream.nfd,
          NODEFS.bufferFrom(buffer.buffer),
          offset,
          length,
          position
        );
      } catch (e) {
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    llseek: function(stream, offset, whence) {
      var position = offset;
      if (whence === 1) {
        position += stream.position;
      } else if (whence === 2) {
        if (FS.isFile(stream.node.mode)) {
          try {
            var stat = fs.fstatSync(stream.nfd);
            position += stat.size;
          } catch (e) {
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        }
      }
      if (position < 0) {
        throw new FS.ErrnoError(28);
      }
      return position;
    },
    mmap: function(stream, address, length, position, prot, flags) {
      assert(address === 0);
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      var ptr = FS.mmapAlloc(length);
      NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
      return { ptr: ptr, allocated: true };
    },
    msync: function(stream, buffer, offset, length, mmapFlags) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (mmapFlags & 2) {
        return 0;
      }
      var bytesWritten = NODEFS.stream_ops.write(
        stream,
        buffer,
        0,
        length,
        offset,
        false
      );
      return 0;
    }
  }
};
var NODERAWFS = {
  lookupPath: function(path) {
    return { path: path, node: { mode: NODEFS.getMode(path) } };
  },
  createStandardStreams: function() {
    FS.streams[0] = {
      fd: 0,
      nfd: 0,
      position: 0,
      path: "",
      flags: 0,
      tty: true,
      seekable: false
    };
    for (var i = 1; i < 3; i++) {
      FS.streams[i] = {
        fd: i,
        nfd: i,
        position: 0,
        path: "",
        flags: 577,
        tty: true,
        seekable: false
      };
    }
  },
  cwd: function() {
    return process.cwd();
  },
  chdir: function() {
    process.chdir.apply(void 0, arguments);
  },
  mknod: function(path, mode) {
    if (FS.isDir(path)) {
      fs.mkdirSync(path, mode);
    } else {
      fs.writeFileSync(path, "", { mode: mode });
    }
  },
  mkdir: function() {
    fs.mkdirSync.apply(void 0, arguments);
  },
  symlink: function() {
    fs.symlinkSync.apply(void 0, arguments);
  },
  rename: function() {
    fs.renameSync.apply(void 0, arguments);
  },
  rmdir: function() {
    fs.rmdirSync.apply(void 0, arguments);
  },
  readdir: function() {
    fs.readdirSync.apply(void 0, arguments);
  },
  unlink: function() {
    fs.unlinkSync.apply(void 0, arguments);
  },
  readlink: function() {
    return fs.readlinkSync.apply(void 0, arguments);
  },
  stat: function() {
    return fs.statSync.apply(void 0, arguments);
  },
  lstat: function() {
    return fs.lstatSync.apply(void 0, arguments);
  },
  chmod: function() {
    fs.chmodSync.apply(void 0, arguments);
  },
  fchmod: function() {
    fs.fchmodSync.apply(void 0, arguments);
  },
  chown: function() {
    fs.chownSync.apply(void 0, arguments);
  },
  fchown: function() {
    fs.fchownSync.apply(void 0, arguments);
  },
  truncate: function() {
    fs.truncateSync.apply(void 0, arguments);
  },
  ftruncate: function() {
    fs.ftruncateSync.apply(void 0, arguments);
  },
  utime: function() {
    fs.utimesSync.apply(void 0, arguments);
  },
  open: function(path, flags, mode, suggestFD) {
    if (typeof flags === "string") {
      flags = VFS.modeStringToFlags(flags);
    }
    var nfd = fs.openSync(path, NODEFS.flagsForNode(flags), mode);
    var fd = suggestFD != null ? suggestFD : FS.nextfd(nfd);
    var stream = {
      fd: fd,
      nfd: nfd,
      position: 0,
      path: path,
      flags: flags,
      seekable: true
    };
    FS.streams[fd] = stream;
    return stream;
  },
  close: function(stream) {
    if (!stream.stream_ops) {
      fs.closeSync(stream.nfd);
    }
    FS.closeStream(stream.fd);
  },
  llseek: function(stream, offset, whence) {
    if (stream.stream_ops) {
      return VFS.llseek(stream, offset, whence);
    }
    var position = offset;
    if (whence === 1) {
      position += stream.position;
    } else if (whence === 2) {
      position += fs.fstatSync(stream.nfd).size;
    } else if (whence !== 0) {
      throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
    }
    if (position < 0) {
      throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
    }
    stream.position = position;
    return position;
  },
  read: function(stream, buffer, offset, length, position) {
    if (stream.stream_ops) {
      return VFS.read(stream, buffer, offset, length, position);
    }
    var seeking = typeof position !== "undefined";
    if (!seeking && stream.seekable) position = stream.position;
    var bytesRead = fs.readSync(
      stream.nfd,
      NODEFS.bufferFrom(buffer.buffer),
      offset,
      length,
      position
    );
    if (!seeking) stream.position += bytesRead;
    return bytesRead;
  },
  write: function(stream, buffer, offset, length, position) {
    if (stream.stream_ops) {
      return VFS.write(stream, buffer, offset, length, position);
    }
    if (stream.flags & +"1024") {
      FS.llseek(stream, 0, +"2");
    }
    var seeking = typeof position !== "undefined";
    if (!seeking && stream.seekable) position = stream.position;
    var bytesWritten = fs.writeSync(
      stream.nfd,
      NODEFS.bufferFrom(buffer.buffer),
      offset,
      length,
      position
    );
    if (!seeking) stream.position += bytesWritten;
    return bytesWritten;
  },
  allocate: function() {
    throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
  },
  mmap: function() {
    throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
  },
  msync: function() {
    return 0;
  },
  munmap: function() {
    return 0;
  },
  ioctl: function() {
    throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
  }
};
var FS = {
  root: null,
  mounts: [],
  devices: {},
  streams: [],
  nextInode: 1,
  nameTable: null,
  currentPath: "/",
  initialized: false,
  ignorePermissions: true,
  trackingDelegate: {},
  tracking: { openFlags: { READ: 1, WRITE: 2 } },
  ErrnoError: null,
  genericErrors: {},
  filesystems: null,
  syncFSRequests: 0,
  handleFSError: function(e) {
    if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace();
    return setErrNo(e.errno);
  },
  lookupPath: function(path, opts) {
    path = PATH_FS.resolve(FS.cwd(), path);
    opts = opts || {};
    if (!path) return { path: "", node: null };
    var defaults = { follow_mount: true, recurse_count: 0 };
    for (var key in defaults) {
      if (opts[key] === undefined) {
        opts[key] = defaults[key];
      }
    }
    if (opts.recurse_count > 8) {
      throw new FS.ErrnoError(32);
    }
    var parts = PATH.normalizeArray(
      path.split("/").filter(function(p) {
        return !!p;
      }),
      false
    );
    var current = FS.root;
    var current_path = "/";
    for (var i = 0; i < parts.length; i++) {
      var islast = i === parts.length - 1;
      if (islast && opts.parent) {
        break;
      }
      current = FS.lookupNode(current, parts[i]);
      current_path = PATH.join2(current_path, parts[i]);
      if (FS.isMountpoint(current)) {
        if (!islast || (islast && opts.follow_mount)) {
          current = current.mounted.root;
        }
      }
      if (!islast || opts.follow) {
        var count = 0;
        while (FS.isLink(current.mode)) {
          var link = FS.readlink(current_path);
          current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
          var lookup = FS.lookupPath(current_path, {
            recurse_count: opts.recurse_count
          });
          current = lookup.node;
          if (count++ > 40) {
            throw new FS.ErrnoError(32);
          }
        }
      }
    }
    return { path: current_path, node: current };
  },
  getPath: function(node) {
    var path;
    while (true) {
      if (FS.isRoot(node)) {
        var mount = node.mount.mountpoint;
        if (!path) return mount;
        return mount[mount.length - 1] !== "/"
          ? mount + "/" + path
          : mount + path;
      }
      path = path ? node.name + "/" + path : node.name;
      node = node.parent;
    }
  },
  hashName: function(parentid, name) {
    var hash = 0;
    for (var i = 0; i < name.length; i++) {
      hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
    }
    return ((parentid + hash) >>> 0) % FS.nameTable.length;
  },
  hashAddNode: function(node) {
    var hash = FS.hashName(node.parent.id, node.name);
    node.name_next = FS.nameTable[hash];
    FS.nameTable[hash] = node;
  },
  hashRemoveNode: function(node) {
    var hash = FS.hashName(node.parent.id, node.name);
    if (FS.nameTable[hash] === node) {
      FS.nameTable[hash] = node.name_next;
    } else {
      var current = FS.nameTable[hash];
      while (current) {
        if (current.name_next === node) {
          current.name_next = node.name_next;
          break;
        }
        current = current.name_next;
      }
    }
  },
  lookupNode: function(parent, name) {
    var errCode = FS.mayLookup(parent);
    if (errCode) {
      throw new FS.ErrnoError(errCode, parent);
    }
    var hash = FS.hashName(parent.id, name);
    for (var node = FS.nameTable[hash]; node; node = node.name_next) {
      var nodeName = node.name;
      if (node.parent.id === parent.id && nodeName === name) {
        return node;
      }
    }
    return FS.lookup(parent, name);
  },
  createNode: function(parent, name, mode, rdev) {
    var node = new FS.FSNode(parent, name, mode, rdev);
    FS.hashAddNode(node);
    return node;
  },
  destroyNode: function(node) {
    FS.hashRemoveNode(node);
  },
  isRoot: function(node) {
    return node === node.parent;
  },
  isMountpoint: function(node) {
    return !!node.mounted;
  },
  isFile: function(mode) {
    return (mode & 61440) === 32768;
  },
  isDir: function(mode) {
    return (mode & 61440) === 16384;
  },
  isLink: function(mode) {
    return (mode & 61440) === 40960;
  },
  isChrdev: function(mode) {
    return (mode & 61440) === 8192;
  },
  isBlkdev: function(mode) {
    return (mode & 61440) === 24576;
  },
  isFIFO: function(mode) {
    return (mode & 61440) === 4096;
  },
  isSocket: function(mode) {
    return (mode & 49152) === 49152;
  },
  flagModes: {
    r: 0,
    rs: 1052672,
    "r+": 2,
    w: 577,
    wx: 705,
    xw: 705,
    "w+": 578,
    "wx+": 706,
    "xw+": 706,
    a: 1089,
    ax: 1217,
    xa: 1217,
    "a+": 1090,
    "ax+": 1218,
    "xa+": 1218
  },
  modeStringToFlags: function(str) {
    var flags = FS.flagModes[str];
    if (typeof flags === "undefined") {
      throw new Error("Unknown file open mode: " + str);
    }
    return flags;
  },
  flagsToPermissionString: function(flag) {
    var perms = ["r", "w", "rw"][flag & 3];
    if (flag & 512) {
      perms += "w";
    }
    return perms;
  },
  nodePermissions: function(node, perms) {
    if (FS.ignorePermissions) {
      return 0;
    }
    if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
      return 2;
    } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
      return 2;
    } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
      return 2;
    }
    return 0;
  },
  mayLookup: function(dir) {
    var errCode = FS.nodePermissions(dir, "x");
    if (errCode) return errCode;
    if (!dir.node_ops.lookup) return 2;
    return 0;
  },
  mayCreate: function(dir, name) {
    try {
      var node = FS.lookupNode(dir, name);
      return 20;
    } catch (e) {}
    return FS.nodePermissions(dir, "wx");
  },
  mayDelete: function(dir, name, isdir) {
    var node;
    try {
      node = FS.lookupNode(dir, name);
    } catch (e) {
      return e.errno;
    }
    var errCode = FS.nodePermissions(dir, "wx");
    if (errCode) {
      return errCode;
    }
    if (isdir) {
      if (!FS.isDir(node.mode)) {
        return 54;
      }
      if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
        return 10;
      }
    } else {
      if (FS.isDir(node.mode)) {
        return 31;
      }
    }
    return 0;
  },
  mayOpen: function(node, flags) {
    if (!node) {
      return 44;
    }
    if (FS.isLink(node.mode)) {
      return 32;
    } else if (FS.isDir(node.mode)) {
      if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
        return 31;
      }
    }
    return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
  },
  MAX_OPEN_FDS: 4096,
  nextfd: function(fd_start, fd_end) {
    fd_start = fd_start || 0;
    fd_end = fd_end || FS.MAX_OPEN_FDS;
    for (var fd = fd_start; fd <= fd_end; fd++) {
      if (!FS.streams[fd]) {
        return fd;
      }
    }
    throw new FS.ErrnoError(33);
  },
  getStream: function(fd) {
    return FS.streams[fd];
  },
  createStream: function(stream, fd_start, fd_end) {
    if (!FS.FSStream) {
      FS.FSStream = function() {};
      FS.FSStream.prototype = {
        object: {
          get: function() {
            return this.node;
          },
          set: function(val) {
            this.node = val;
          }
        },
        isRead: {
          get: function() {
            return (this.flags & 2097155) !== 1;
          }
        },
        isWrite: {
          get: function() {
            return (this.flags & 2097155) !== 0;
          }
        },
        isAppend: {
          get: function() {
            return this.flags & 1024;
          }
        }
      };
    }
    var newStream = new FS.FSStream();
    for (var p in stream) {
      newStream[p] = stream[p];
    }
    stream = newStream;
    var fd = FS.nextfd(fd_start, fd_end);
    stream.fd = fd;
    FS.streams[fd] = stream;
    return stream;
  },
  closeStream: function(fd) {
    FS.streams[fd] = null;
  },
  chrdev_stream_ops: {
    open: function(stream) {
      var device = FS.getDevice(stream.node.rdev);
      stream.stream_ops = device.stream_ops;
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
    },
    llseek: function() {
      throw new FS.ErrnoError(70);
    }
  },
  major: function(dev) {
    return dev >> 8;
  },
  minor: function(dev) {
    return dev & 255;
  },
  makedev: function(ma, mi) {
    return (ma << 8) | mi;
  },
  registerDevice: function(dev, ops) {
    FS.devices[dev] = { stream_ops: ops };
  },
  getDevice: function(dev) {
    return FS.devices[dev];
  },
  getMounts: function(mount) {
    var mounts = [];
    var check = [mount];
    while (check.length) {
      var m = check.pop();
      mounts.push(m);
      check.push.apply(check, m.mounts);
    }
    return mounts;
  },
  syncfs: function(populate, callback) {
    if (typeof populate === "function") {
      callback = populate;
      populate = false;
    }
    FS.syncFSRequests++;
    if (FS.syncFSRequests > 1) {
      err(
        "warning: " +
          FS.syncFSRequests +
          " FS.syncfs operations in flight at once, probably just doing extra work"
      );
    }
    var mounts = FS.getMounts(FS.root.mount);
    var completed = 0;
    function doCallback(errCode) {
      FS.syncFSRequests--;
      return callback(errCode);
    }
    function done(errCode) {
      if (errCode) {
        if (!done.errored) {
          done.errored = true;
          return doCallback(errCode);
        }
        return;
      }
      if (++completed >= mounts.length) {
        doCallback(null);
      }
    }
    mounts.forEach(function(mount) {
      if (!mount.type.syncfs) {
        return done(null);
      }
      mount.type.syncfs(mount, populate, done);
    });
  },
  mount: function(type, opts, mountpoint) {
    var root = mountpoint === "/";
    var pseudo = !mountpoint;
    var node;
    if (root && FS.root) {
      throw new FS.ErrnoError(10);
    } else if (!root && !pseudo) {
      var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
      mountpoint = lookup.path;
      node = lookup.node;
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      if (!FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
    }
    var mount = { type: type, opts: opts, mountpoint: mountpoint, mounts: [] };
    var mountRoot = type.mount(mount);
    mountRoot.mount = mount;
    mount.root = mountRoot;
    if (root) {
      FS.root = mountRoot;
    } else if (node) {
      node.mounted = mount;
      if (node.mount) {
        node.mount.mounts.push(mount);
      }
    }
    return mountRoot;
  },
  unmount: function(mountpoint) {
    var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
    if (!FS.isMountpoint(lookup.node)) {
      throw new FS.ErrnoError(28);
    }
    var node = lookup.node;
    var mount = node.mounted;
    var mounts = FS.getMounts(mount);
    Object.keys(FS.nameTable).forEach(function(hash) {
      var current = FS.nameTable[hash];
      while (current) {
        var next = current.name_next;
        if (mounts.indexOf(current.mount) !== -1) {
          FS.destroyNode(current);
        }
        current = next;
      }
    });
    node.mounted = null;
    var idx = node.mount.mounts.indexOf(mount);
    node.mount.mounts.splice(idx, 1);
  },
  lookup: function(parent, name) {
    return parent.node_ops.lookup(parent, name);
  },
  mknod: function(path, mode, dev) {
    var lookup = FS.lookupPath(path, { parent: true });
    var parent = lookup.node;
    var name = PATH.basename(path);
    if (!name || name === "." || name === "..") {
      throw new FS.ErrnoError(28);
    }
    var errCode = FS.mayCreate(parent, name);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.mknod) {
      throw new FS.ErrnoError(63);
    }
    return parent.node_ops.mknod(parent, name, mode, dev);
  },
  create: function(path, mode) {
    mode = mode !== undefined ? mode : 438;
    mode &= 4095;
    mode |= 32768;
    return FS.mknod(path, mode, 0);
  },
  mkdir: function(path, mode) {
    mode = mode !== undefined ? mode : 511;
    mode &= 511 | 512;
    mode |= 16384;
    return FS.mknod(path, mode, 0);
  },
  mkdirTree: function(path, mode) {
    var dirs = path.split("/");
    var d = "";
    for (var i = 0; i < dirs.length; ++i) {
      if (!dirs[i]) continue;
      d += "/" + dirs[i];
      try {
        FS.mkdir(d, mode);
      } catch (e) {
        if (e.errno != 20) throw e;
      }
    }
  },
  mkdev: function(path, mode, dev) {
    if (typeof dev === "undefined") {
      dev = mode;
      mode = 438;
    }
    mode |= 8192;
    return FS.mknod(path, mode, dev);
  },
  symlink: function(oldpath, newpath) {
    if (!PATH_FS.resolve(oldpath)) {
      throw new FS.ErrnoError(44);
    }
    var lookup = FS.lookupPath(newpath, { parent: true });
    var parent = lookup.node;
    if (!parent) {
      throw new FS.ErrnoError(44);
    }
    var newname = PATH.basename(newpath);
    var errCode = FS.mayCreate(parent, newname);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.symlink) {
      throw new FS.ErrnoError(63);
    }
    return parent.node_ops.symlink(parent, newname, oldpath);
  },
  rename: function(old_path, new_path) {
    var old_dirname = PATH.dirname(old_path);
    var new_dirname = PATH.dirname(new_path);
    var old_name = PATH.basename(old_path);
    var new_name = PATH.basename(new_path);
    var lookup, old_dir, new_dir;
    lookup = FS.lookupPath(old_path, { parent: true });
    old_dir = lookup.node;
    lookup = FS.lookupPath(new_path, { parent: true });
    new_dir = lookup.node;
    if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
    if (old_dir.mount !== new_dir.mount) {
      throw new FS.ErrnoError(75);
    }
    var old_node = FS.lookupNode(old_dir, old_name);
    var relative = PATH_FS.relative(old_path, new_dirname);
    if (relative.charAt(0) !== ".") {
      throw new FS.ErrnoError(28);
    }
    relative = PATH_FS.relative(new_path, old_dirname);
    if (relative.charAt(0) !== ".") {
      throw new FS.ErrnoError(55);
    }
    var new_node;
    try {
      new_node = FS.lookupNode(new_dir, new_name);
    } catch (e) {}
    if (old_node === new_node) {
      return;
    }
    var isdir = FS.isDir(old_node.mode);
    var errCode = FS.mayDelete(old_dir, old_name, isdir);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    errCode = new_node
      ? FS.mayDelete(new_dir, new_name, isdir)
      : FS.mayCreate(new_dir, new_name);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!old_dir.node_ops.rename) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
      throw new FS.ErrnoError(10);
    }
    if (new_dir !== old_dir) {
      errCode = FS.nodePermissions(old_dir, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
    }
    try {
      if (FS.trackingDelegate["willMovePath"]) {
        FS.trackingDelegate["willMovePath"](old_path, new_path);
      }
    } catch (e) {
      err(
        "FS.trackingDelegate['willMovePath']('" +
          old_path +
          "', '" +
          new_path +
          "') threw an exception: " +
          e.message
      );
    }
    FS.hashRemoveNode(old_node);
    try {
      old_dir.node_ops.rename(old_node, new_dir, new_name);
    } catch (e) {
      throw e;
    } finally {
      FS.hashAddNode(old_node);
    }
    try {
      if (FS.trackingDelegate["onMovePath"])
        FS.trackingDelegate["onMovePath"](old_path, new_path);
    } catch (e) {
      err(
        "FS.trackingDelegate['onMovePath']('" +
          old_path +
          "', '" +
          new_path +
          "') threw an exception: " +
          e.message
      );
    }
  },
  rmdir: function(path) {
    var lookup = FS.lookupPath(path, { parent: true });
    var parent = lookup.node;
    var name = PATH.basename(path);
    var node = FS.lookupNode(parent, name);
    var errCode = FS.mayDelete(parent, name, true);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.rmdir) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isMountpoint(node)) {
      throw new FS.ErrnoError(10);
    }
    try {
      if (FS.trackingDelegate["willDeletePath"]) {
        FS.trackingDelegate["willDeletePath"](path);
      }
    } catch (e) {
      err(
        "FS.trackingDelegate['willDeletePath']('" +
          path +
          "') threw an exception: " +
          e.message
      );
    }
    parent.node_ops.rmdir(parent, name);
    FS.destroyNode(node);
    try {
      if (FS.trackingDelegate["onDeletePath"])
        FS.trackingDelegate["onDeletePath"](path);
    } catch (e) {
      err(
        "FS.trackingDelegate['onDeletePath']('" +
          path +
          "') threw an exception: " +
          e.message
      );
    }
  },
  readdir: function(path) {
    var lookup = FS.lookupPath(path, { follow: true });
    var node = lookup.node;
    if (!node.node_ops.readdir) {
      throw new FS.ErrnoError(54);
    }
    return node.node_ops.readdir(node);
  },
  unlink: function(path) {
    var lookup = FS.lookupPath(path, { parent: true });
    var parent = lookup.node;
    var name = PATH.basename(path);
    var node = FS.lookupNode(parent, name);
    var errCode = FS.mayDelete(parent, name, false);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.unlink) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isMountpoint(node)) {
      throw new FS.ErrnoError(10);
    }
    try {
      if (FS.trackingDelegate["willDeletePath"]) {
        FS.trackingDelegate["willDeletePath"](path);
      }
    } catch (e) {
      err(
        "FS.trackingDelegate['willDeletePath']('" +
          path +
          "') threw an exception: " +
          e.message
      );
    }
    parent.node_ops.unlink(parent, name);
    FS.destroyNode(node);
    try {
      if (FS.trackingDelegate["onDeletePath"])
        FS.trackingDelegate["onDeletePath"](path);
    } catch (e) {
      err(
        "FS.trackingDelegate['onDeletePath']('" +
          path +
          "') threw an exception: " +
          e.message
      );
    }
  },
  readlink: function(path) {
    var lookup = FS.lookupPath(path);
    var link = lookup.node;
    if (!link) {
      throw new FS.ErrnoError(44);
    }
    if (!link.node_ops.readlink) {
      throw new FS.ErrnoError(28);
    }
    return PATH_FS.resolve(
      FS.getPath(link.parent),
      link.node_ops.readlink(link)
    );
  },
  stat: function(path, dontFollow) {
    var lookup = FS.lookupPath(path, { follow: !dontFollow });
    var node = lookup.node;
    if (!node) {
      throw new FS.ErrnoError(44);
    }
    if (!node.node_ops.getattr) {
      throw new FS.ErrnoError(63);
    }
    return node.node_ops.getattr(node);
  },
  lstat: function(path) {
    return FS.stat(path, true);
  },
  chmod: function(path, mode, dontFollow) {
    var node;
    if (typeof path === "string") {
      var lookup = FS.lookupPath(path, { follow: !dontFollow });
      node = lookup.node;
    } else {
      node = path;
    }
    if (!node.node_ops.setattr) {
      throw new FS.ErrnoError(63);
    }
    node.node_ops.setattr(node, {
      mode: (mode & 4095) | (node.mode & ~4095),
      timestamp: Date.now()
    });
  },
  lchmod: function(path, mode) {
    FS.chmod(path, mode, true);
  },
  fchmod: function(fd, mode) {
    var stream = FS.getStream(fd);
    if (!stream) {
      throw new FS.ErrnoError(8);
    }
    FS.chmod(stream.node, mode);
  },
  chown: function(path, uid, gid, dontFollow) {
    var node;
    if (typeof path === "string") {
      var lookup = FS.lookupPath(path, { follow: !dontFollow });
      node = lookup.node;
    } else {
      node = path;
    }
    if (!node.node_ops.setattr) {
      throw new FS.ErrnoError(63);
    }
    node.node_ops.setattr(node, { timestamp: Date.now() });
  },
  lchown: function(path, uid, gid) {
    FS.chown(path, uid, gid, true);
  },
  fchown: function(fd, uid, gid) {
    var stream = FS.getStream(fd);
    if (!stream) {
      throw new FS.ErrnoError(8);
    }
    FS.chown(stream.node, uid, gid);
  },
  truncate: function(path, len) {
    if (len < 0) {
      throw new FS.ErrnoError(28);
    }
    var node;
    if (typeof path === "string") {
      var lookup = FS.lookupPath(path, { follow: true });
      node = lookup.node;
    } else {
      node = path;
    }
    if (!node.node_ops.setattr) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isDir(node.mode)) {
      throw new FS.ErrnoError(31);
    }
    if (!FS.isFile(node.mode)) {
      throw new FS.ErrnoError(28);
    }
    var errCode = FS.nodePermissions(node, "w");
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
  },
  ftruncate: function(fd, len) {
    var stream = FS.getStream(fd);
    if (!stream) {
      throw new FS.ErrnoError(8);
    }
    if ((stream.flags & 2097155) === 0) {
      throw new FS.ErrnoError(28);
    }
    FS.truncate(stream.node, len);
  },
  utime: function(path, atime, mtime) {
    var lookup = FS.lookupPath(path, { follow: true });
    var node = lookup.node;
    node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
  },
  open: function(path, flags, mode, fd_start, fd_end) {
    if (path === "") {
      throw new FS.ErrnoError(44);
    }
    flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
    mode = typeof mode === "undefined" ? 438 : mode;
    if (flags & 64) {
      mode = (mode & 4095) | 32768;
    } else {
      mode = 0;
    }
    var node;
    if (typeof path === "object") {
      node = path;
    } else {
      path = PATH.normalize(path);
      try {
        var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
        node = lookup.node;
      } catch (e) {}
    }
    var created = false;
    if (flags & 64) {
      if (node) {
        if (flags & 128) {
          throw new FS.ErrnoError(20);
        }
      } else {
        node = FS.mknod(path, mode, 0);
        created = true;
      }
    }
    if (!node) {
      throw new FS.ErrnoError(44);
    }
    if (FS.isChrdev(node.mode)) {
      flags &= ~512;
    }
    if (flags & 65536 && !FS.isDir(node.mode)) {
      throw new FS.ErrnoError(54);
    }
    if (!created) {
      var errCode = FS.mayOpen(node, flags);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
    }
    if (flags & 512) {
      FS.truncate(node, 0);
    }
    flags &= ~(128 | 512 | 131072);
    var stream = FS.createStream(
      {
        node: node,
        path: FS.getPath(node),
        flags: flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      },
      fd_start,
      fd_end
    );
    if (stream.stream_ops.open) {
      stream.stream_ops.open(stream);
    }
    if (Module["logReadFiles"] && !(flags & 1)) {
      if (!FS.readFiles) FS.readFiles = {};
      if (!(path in FS.readFiles)) {
        FS.readFiles[path] = 1;
        err("FS.trackingDelegate error on read file: " + path);
      }
    }
    try {
      if (FS.trackingDelegate["onOpenFile"]) {
        var trackingFlags = 0;
        if ((flags & 2097155) !== 1) {
          trackingFlags |= FS.tracking.openFlags.READ;
        }
        if ((flags & 2097155) !== 0) {
          trackingFlags |= FS.tracking.openFlags.WRITE;
        }
        FS.trackingDelegate["onOpenFile"](path, trackingFlags);
      }
    } catch (e) {
      err(
        "FS.trackingDelegate['onOpenFile']('" +
          path +
          "', flags) threw an exception: " +
          e.message
      );
    }
    return stream;
  },
  close: function(stream) {
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if (stream.getdents) stream.getdents = null;
    try {
      if (stream.stream_ops.close) {
        stream.stream_ops.close(stream);
      }
    } catch (e) {
      throw e;
    } finally {
      FS.closeStream(stream.fd);
    }
    stream.fd = null;
  },
  isClosed: function(stream) {
    return stream.fd === null;
  },
  llseek: function(stream, offset, whence) {
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if (!stream.seekable || !stream.stream_ops.llseek) {
      throw new FS.ErrnoError(70);
    }
    if (whence != 0 && whence != 1 && whence != 2) {
      throw new FS.ErrnoError(28);
    }
    stream.position = stream.stream_ops.llseek(stream, offset, whence);
    stream.ungotten = [];
    return stream.position;
  },
  read: function(stream, buffer, offset, length, position) {
    if (length < 0 || position < 0) {
      throw new FS.ErrnoError(28);
    }
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if ((stream.flags & 2097155) === 1) {
      throw new FS.ErrnoError(8);
    }
    if (FS.isDir(stream.node.mode)) {
      throw new FS.ErrnoError(31);
    }
    if (!stream.stream_ops.read) {
      throw new FS.ErrnoError(28);
    }
    var seeking = typeof position !== "undefined";
    if (!seeking) {
      position = stream.position;
    } else if (!stream.seekable) {
      throw new FS.ErrnoError(70);
    }
    var bytesRead = stream.stream_ops.read(
      stream,
      buffer,
      offset,
      length,
      position
    );
    if (!seeking) stream.position += bytesRead;
    return bytesRead;
  },
  write: function(stream, buffer, offset, length, position, canOwn) {
    if (length < 0 || position < 0) {
      throw new FS.ErrnoError(28);
    }
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if ((stream.flags & 2097155) === 0) {
      throw new FS.ErrnoError(8);
    }
    if (FS.isDir(stream.node.mode)) {
      throw new FS.ErrnoError(31);
    }
    if (!stream.stream_ops.write) {
      throw new FS.ErrnoError(28);
    }
    if (stream.seekable && stream.flags & 1024) {
      FS.llseek(stream, 0, 2);
    }
    var seeking = typeof position !== "undefined";
    if (!seeking) {
      position = stream.position;
    } else if (!stream.seekable) {
      throw new FS.ErrnoError(70);
    }
    var bytesWritten = stream.stream_ops.write(
      stream,
      buffer,
      offset,
      length,
      position,
      canOwn
    );
    if (!seeking) stream.position += bytesWritten;
    try {
      if (stream.path && FS.trackingDelegate["onWriteToFile"])
        FS.trackingDelegate["onWriteToFile"](stream.path);
    } catch (e) {
      err(
        "FS.trackingDelegate['onWriteToFile']('" +
          stream.path +
          "') threw an exception: " +
          e.message
      );
    }
    return bytesWritten;
  },
  allocate: function(stream, offset, length) {
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if (offset < 0 || length <= 0) {
      throw new FS.ErrnoError(28);
    }
    if ((stream.flags & 2097155) === 0) {
      throw new FS.ErrnoError(8);
    }
    if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
      throw new FS.ErrnoError(43);
    }
    if (!stream.stream_ops.allocate) {
      throw new FS.ErrnoError(138);
    }
    stream.stream_ops.allocate(stream, offset, length);
  },
  mmap: function(stream, address, length, position, prot, flags) {
    if (
      (prot & 2) !== 0 &&
      (flags & 2) === 0 &&
      (stream.flags & 2097155) !== 2
    ) {
      throw new FS.ErrnoError(2);
    }
    if ((stream.flags & 2097155) === 1) {
      throw new FS.ErrnoError(2);
    }
    if (!stream.stream_ops.mmap) {
      throw new FS.ErrnoError(43);
    }
    return stream.stream_ops.mmap(
      stream,
      address,
      length,
      position,
      prot,
      flags
    );
  },
  msync: function(stream, buffer, offset, length, mmapFlags) {
    if (!stream || !stream.stream_ops.msync) {
      return 0;
    }
    return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
  },
  munmap: function(stream) {
    return 0;
  },
  ioctl: function(stream, cmd, arg) {
    if (!stream.stream_ops.ioctl) {
      throw new FS.ErrnoError(59);
    }
    return stream.stream_ops.ioctl(stream, cmd, arg);
  },
  readFile: function(path, opts) {
    opts = opts || {};
    opts.flags = opts.flags || "r";
    opts.encoding = opts.encoding || "binary";
    if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
      throw new Error('Invalid encoding type "' + opts.encoding + '"');
    }
    var ret;
    var stream = FS.open(path, opts.flags);
    var stat = FS.stat(path);
    var length = stat.size;
    var buf = new Uint8Array(length);
    FS.read(stream, buf, 0, length, 0);
    if (opts.encoding === "utf8") {
      ret = UTF8ArrayToString(buf, 0);
    } else if (opts.encoding === "binary") {
      ret = buf;
    }
    FS.close(stream);
    return ret;
  },
  writeFile: function(path, data, opts) {
    opts = opts || {};
    opts.flags = opts.flags || "w";
    var stream = FS.open(path, opts.flags, opts.mode);
    if (typeof data === "string") {
      var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
      var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
      FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
    } else if (ArrayBuffer.isView(data)) {
      FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
    } else {
      throw new Error("Unsupported data type");
    }
    FS.close(stream);
  },
  cwd: function() {
    return FS.currentPath;
  },
  chdir: function(path) {
    var lookup = FS.lookupPath(path, { follow: true });
    if (lookup.node === null) {
      throw new FS.ErrnoError(44);
    }
    if (!FS.isDir(lookup.node.mode)) {
      throw new FS.ErrnoError(54);
    }
    var errCode = FS.nodePermissions(lookup.node, "x");
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    FS.currentPath = lookup.path;
  },
  createDefaultDirectories: function() {
    FS.mkdir("/tmp");
    FS.mkdir("/home");
    FS.mkdir("/home/web_user");
  },
  createDefaultDevices: function() {
    FS.mkdir("/dev");
    FS.registerDevice(FS.makedev(1, 3), {
      read: function() {
        return 0;
      },
      write: function(stream, buffer, offset, length, pos) {
        return length;
      }
    });
    FS.mkdev("/dev/null", FS.makedev(1, 3));
    TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
    TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
    FS.mkdev("/dev/tty", FS.makedev(5, 0));
    FS.mkdev("/dev/tty1", FS.makedev(6, 0));
    var random_device;
    if (
      typeof crypto === "object" &&
      typeof crypto["getRandomValues"] === "function"
    ) {
      var randomBuffer = new Uint8Array(1);
      random_device = function() {
        crypto.getRandomValues(randomBuffer);
        return randomBuffer[0];
      };
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = __webpack_require__(72);
        random_device = function() {
          return crypto_module["randomBytes"](1)[0];
        };
      } catch (e) {}
    } else {
    }
    if (!random_device) {
      random_device = function() {
        abort("random_device");
      };
    }
    FS.createDevice("/dev", "random", random_device);
    FS.createDevice("/dev", "urandom", random_device);
    FS.mkdir("/dev/shm");
    FS.mkdir("/dev/shm/tmp");
  },
  createSpecialDirectories: function() {
    FS.mkdir("/proc");
    FS.mkdir("/proc/self");
    FS.mkdir("/proc/self/fd");
    FS.mount(
      {
        mount: function() {
          var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
          node.node_ops = {
            lookup: function(parent, name) {
              var fd = +name;
              var stream = FS.getStream(fd);
              if (!stream) throw new FS.ErrnoError(8);
              var ret = {
                parent: null,
                mount: { mountpoint: "fake" },
                node_ops: {
                  readlink: function() {
                    return stream.path;
                  }
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      },
      {},
      "/proc/self/fd"
    );
  },
  createStandardStreams: function() {
    if (Module["stdin"]) {
      FS.createDevice("/dev", "stdin", Module["stdin"]);
    } else {
      FS.symlink("/dev/tty", "/dev/stdin");
    }
    if (Module["stdout"]) {
      FS.createDevice("/dev", "stdout", null, Module["stdout"]);
    } else {
      FS.symlink("/dev/tty", "/dev/stdout");
    }
    if (Module["stderr"]) {
      FS.createDevice("/dev", "stderr", null, Module["stderr"]);
    } else {
      FS.symlink("/dev/tty1", "/dev/stderr");
    }
    var stdin = FS.open("/dev/stdin", "r");
    var stdout = FS.open("/dev/stdout", "w");
    var stderr = FS.open("/dev/stderr", "w");
  },
  ensureErrnoError: function() {
    if (FS.ErrnoError) return;
    FS.ErrnoError = function ErrnoError(errno, node) {
      this.node = node;
      this.setErrno = function(errno) {
        this.errno = errno;
      };
      this.setErrno(errno);
      this.message = "FS error";
    };
    FS.ErrnoError.prototype = new Error();
    FS.ErrnoError.prototype.constructor = FS.ErrnoError;
    [44].forEach(function(code) {
      FS.genericErrors[code] = new FS.ErrnoError(code);
      FS.genericErrors[code].stack = "<generic error, no stack>";
    });
  },
  staticInit: function() {
    FS.ensureErrnoError();
    FS.nameTable = new Array(4096);
    FS.mount(MEMFS, {}, "/");
    FS.createDefaultDirectories();
    FS.createDefaultDevices();
    FS.createSpecialDirectories();
    FS.filesystems = { MEMFS: MEMFS, NODEFS: NODEFS };
  },
  init: function(input, output, error) {
    FS.init.initialized = true;
    FS.ensureErrnoError();
    Module["stdin"] = input || Module["stdin"];
    Module["stdout"] = output || Module["stdout"];
    Module["stderr"] = error || Module["stderr"];
    FS.createStandardStreams();
  },
  quit: function() {
    FS.init.initialized = false;
    var fflush = Module["_fflush"];
    if (fflush) fflush(0);
    for (var i = 0; i < FS.streams.length; i++) {
      var stream = FS.streams[i];
      if (!stream) {
        continue;
      }
      FS.close(stream);
    }
  },
  getMode: function(canRead, canWrite) {
    var mode = 0;
    if (canRead) mode |= 292 | 73;
    if (canWrite) mode |= 146;
    return mode;
  },
  joinPath: function(parts, forceRelative) {
    var path = PATH.join.apply(null, parts);
    if (forceRelative && path[0] == "/") path = path.substr(1);
    return path;
  },
  absolutePath: function(relative, base) {
    return PATH_FS.resolve(base, relative);
  },
  standardizePath: function(path) {
    return PATH.normalize(path);
  },
  findObject: function(path, dontResolveLastLink) {
    var ret = FS.analyzePath(path, dontResolveLastLink);
    if (ret.exists) {
      return ret.object;
    } else {
      setErrNo(ret.error);
      return null;
    }
  },
  analyzePath: function(path, dontResolveLastLink) {
    try {
      var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
      path = lookup.path;
    } catch (e) {}
    var ret = {
      isRoot: false,
      exists: false,
      error: 0,
      name: null,
      path: null,
      object: null,
      parentExists: false,
      parentPath: null,
      parentObject: null
    };
    try {
      var lookup = FS.lookupPath(path, { parent: true });
      ret.parentExists = true;
      ret.parentPath = lookup.path;
      ret.parentObject = lookup.node;
      ret.name = PATH.basename(path);
      lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
      ret.exists = true;
      ret.path = lookup.path;
      ret.object = lookup.node;
      ret.name = lookup.node.name;
      ret.isRoot = lookup.path === "/";
    } catch (e) {
      ret.error = e.errno;
    }
    return ret;
  },
  createFolder: function(parent, name, canRead, canWrite) {
    var path = PATH.join2(
      typeof parent === "string" ? parent : FS.getPath(parent),
      name
    );
    var mode = FS.getMode(canRead, canWrite);
    return FS.mkdir(path, mode);
  },
  createPath: function(parent, path, canRead, canWrite) {
    parent = typeof parent === "string" ? parent : FS.getPath(parent);
    var parts = path.split("/").reverse();
    while (parts.length) {
      var part = parts.pop();
      if (!part) continue;
      var current = PATH.join2(parent, part);
      try {
        FS.mkdir(current);
      } catch (e) {}
      parent = current;
    }
    return current;
  },
  createFile: function(parent, name, properties, canRead, canWrite) {
    var path = PATH.join2(
      typeof parent === "string" ? parent : FS.getPath(parent),
      name
    );
    var mode = FS.getMode(canRead, canWrite);
    return FS.create(path, mode);
  },
  createDataFile: function(parent, name, data, canRead, canWrite, canOwn) {
    var path = name
      ? PATH.join2(
          typeof parent === "string" ? parent : FS.getPath(parent),
          name
        )
      : parent;
    var mode = FS.getMode(canRead, canWrite);
    var node = FS.create(path, mode);
    if (data) {
      if (typeof data === "string") {
        var arr = new Array(data.length);
        for (var i = 0, len = data.length; i < len; ++i)
          arr[i] = data.charCodeAt(i);
        data = arr;
      }
      FS.chmod(node, mode | 146);
      var stream = FS.open(node, "w");
      FS.write(stream, data, 0, data.length, 0, canOwn);
      FS.close(stream);
      FS.chmod(node, mode);
    }
    return node;
  },
  createDevice: function(parent, name, input, output) {
    var path = PATH.join2(
      typeof parent === "string" ? parent : FS.getPath(parent),
      name
    );
    var mode = FS.getMode(!!input, !!output);
    if (!FS.createDevice.major) FS.createDevice.major = 64;
    var dev = FS.makedev(FS.createDevice.major++, 0);
    FS.registerDevice(dev, {
      open: function(stream) {
        stream.seekable = false;
      },
      close: function(stream) {
        if (output && output.buffer && output.buffer.length) {
          output(10);
        }
      },
      read: function(stream, buffer, offset, length, pos) {
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = input();
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === undefined && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === undefined) break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function(stream, buffer, offset, length, pos) {
        for (var i = 0; i < length; i++) {
          try {
            output(buffer[offset + i]);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    });
    return FS.mkdev(path, mode, dev);
  },
  createLink: function(parent, name, target, canRead, canWrite) {
    var path = PATH.join2(
      typeof parent === "string" ? parent : FS.getPath(parent),
      name
    );
    return FS.symlink(target, path);
  },
  forceLoadFile: function(obj) {
    if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
    var success = true;
    if (typeof XMLHttpRequest !== "undefined") {
      throw new Error(
        "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
      );
    } else if (read_) {
      try {
        obj.contents = intArrayFromString(read_(obj.url), true);
        obj.usedBytes = obj.contents.length;
      } catch (e) {
        success = false;
      }
    } else {
      throw new Error("Cannot load without read() or XMLHttpRequest.");
    }
    if (!success) setErrNo(29);
    return success;
  },
  createLazyFile: function(parent, name, url, canRead, canWrite) {
    function LazyUint8Array() {
      this.lengthKnown = false;
      this.chunks = [];
    }
    LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
      if (idx > this.length - 1 || idx < 0) {
        return undefined;
      }
      var chunkOffset = idx % this.chunkSize;
      var chunkNum = (idx / this.chunkSize) | 0;
      return this.getter(chunkNum)[chunkOffset];
    };
    LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(
      getter
    ) {
      this.getter = getter;
    };
    LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
      var xhr = new XMLHttpRequest();
      xhr.open("HEAD", url, false);
      xhr.send(null);
      if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))
        throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
      var datalength = Number(xhr.getResponseHeader("Content-length"));
      var header;
      var hasByteServing =
        (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
      var usesGzip =
        (header = xhr.getResponseHeader("Content-Encoding")) &&
        header === "gzip";
      var chunkSize = 1024 * 1024;
      if (!hasByteServing) chunkSize = datalength;
      var doXHR = function(from, to) {
        if (from > to)
          throw new Error(
            "invalid range (" + from + ", " + to + ") or no bytes requested!"
          );
        if (to > datalength - 1)
          throw new Error(
            "only " + datalength + " bytes available! programmer error!"
          );
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, false);
        if (datalength !== chunkSize)
          xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
        if (typeof Uint8Array != "undefined") xhr.responseType = "arraybuffer";
        if (xhr.overrideMimeType) {
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }
        xhr.send(null);
        if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        if (xhr.response !== undefined) {
          return new Uint8Array(xhr.response || []);
        } else {
          return intArrayFromString(xhr.responseText || "", true);
        }
      };
      var lazyArray = this;
      lazyArray.setDataGetter(function(chunkNum) {
        var start = chunkNum * chunkSize;
        var end = (chunkNum + 1) * chunkSize - 1;
        end = Math.min(end, datalength - 1);
        if (typeof lazyArray.chunks[chunkNum] === "undefined") {
          lazyArray.chunks[chunkNum] = doXHR(start, end);
        }
        if (typeof lazyArray.chunks[chunkNum] === "undefined")
          throw new Error("doXHR failed!");
        return lazyArray.chunks[chunkNum];
      });
      if (usesGzip || !datalength) {
        chunkSize = datalength = 1;
        datalength = this.getter(0).length;
        chunkSize = datalength;
        out(
          "LazyFiles on gzip forces download of the whole file when length is accessed"
        );
      }
      this._length = datalength;
      this._chunkSize = chunkSize;
      this.lengthKnown = true;
    };
    if (typeof XMLHttpRequest !== "undefined") {
      if (!ENVIRONMENT_IS_WORKER)
        throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
      var lazyArray = new LazyUint8Array();
      Object.defineProperties(lazyArray, {
        length: {
          get: function() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._length;
          }
        },
        chunkSize: {
          get: function() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._chunkSize;
          }
        }
      });
      var properties = { isDevice: false, contents: lazyArray };
    } else {
      var properties = { isDevice: false, url: url };
    }
    var node = FS.createFile(parent, name, properties, canRead, canWrite);
    if (properties.contents) {
      node.contents = properties.contents;
    } else if (properties.url) {
      node.contents = null;
      node.url = properties.url;
    }
    Object.defineProperties(node, {
      usedBytes: {
        get: function() {
          return this.contents.length;
        }
      }
    });
    var stream_ops = {};
    var keys = Object.keys(node.stream_ops);
    keys.forEach(function(key) {
      var fn = node.stream_ops[key];
      stream_ops[key] = function forceLoadLazyFile() {
        if (!FS.forceLoadFile(node)) {
          throw new FS.ErrnoError(29);
        }
        return fn.apply(null, arguments);
      };
    });
    stream_ops.read = function stream_ops_read(
      stream,
      buffer,
      offset,
      length,
      position
    ) {
      if (!FS.forceLoadFile(node)) {
        throw new FS.ErrnoError(29);
      }
      var contents = stream.node.contents;
      if (position >= contents.length) return 0;
      var size = Math.min(contents.length - position, length);
      if (contents.slice) {
        for (var i = 0; i < size; i++) {
          buffer[offset + i] = contents[position + i];
        }
      } else {
        for (var i = 0; i < size; i++) {
          buffer[offset + i] = contents.get(position + i);
        }
      }
      return size;
    };
    node.stream_ops = stream_ops;
    return node;
  },
  createPreloadedFile: function(
    parent,
    name,
    url,
    canRead,
    canWrite,
    onload,
    onerror,
    dontCreateFile,
    canOwn,
    preFinish
  ) {
    Browser.init();
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency("cp " + fullname);
    function processData(byteArray) {
      function finish(byteArray) {
        if (preFinish) preFinish();
        if (!dontCreateFile) {
          FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
        }
        if (onload) onload();
        removeRunDependency(dep);
      }
      var handled = false;
      Module["preloadPlugins"].forEach(function(plugin) {
        if (handled) return;
        if (plugin["canHandle"](fullname)) {
          plugin["handle"](byteArray, fullname, finish, function() {
            if (onerror) onerror();
            removeRunDependency(dep);
          });
          handled = true;
        }
      });
      if (!handled) finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      Browser.asyncLoad(
        url,
        function(byteArray) {
          processData(byteArray);
        },
        onerror
      );
    } else {
      processData(url);
    }
  },
  indexedDB: function() {
    return (
      window.indexedDB ||
      window.mozIndexedDB ||
      window.webkitIndexedDB ||
      window.msIndexedDB
    );
  },
  DB_NAME: function() {
    return "EM_FS_" + window.location.pathname;
  },
  DB_VERSION: 20,
  DB_STORE_NAME: "FILE_DATA",
  saveFilesToDB: function(paths, onload, onerror) {
    onload = onload || function() {};
    onerror = onerror || function() {};
    var indexedDB = FS.indexedDB();
    try {
      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
    } catch (e) {
      return onerror(e);
    }
    openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
      out("creating db");
      var db = openRequest.result;
      db.createObjectStore(FS.DB_STORE_NAME);
    };
    openRequest.onsuccess = function openRequest_onsuccess() {
      var db = openRequest.result;
      var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
      var files = transaction.objectStore(FS.DB_STORE_NAME);
      var ok = 0,
        fail = 0,
        total = paths.length;
      function finish() {
        if (fail == 0) onload();
        else onerror();
      }
      paths.forEach(function(path) {
        var putRequest = files.put(FS.analyzePath(path).object.contents, path);
        putRequest.onsuccess = function putRequest_onsuccess() {
          ok++;
          if (ok + fail == total) finish();
        };
        putRequest.onerror = function putRequest_onerror() {
          fail++;
          if (ok + fail == total) finish();
        };
      });
      transaction.onerror = onerror;
    };
    openRequest.onerror = onerror;
  },
  loadFilesFromDB: function(paths, onload, onerror) {
    onload = onload || function() {};
    onerror = onerror || function() {};
    var indexedDB = FS.indexedDB();
    try {
      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
    } catch (e) {
      return onerror(e);
    }
    openRequest.onupgradeneeded = onerror;
    openRequest.onsuccess = function openRequest_onsuccess() {
      var db = openRequest.result;
      try {
        var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
      } catch (e) {
        onerror(e);
        return;
      }
      var files = transaction.objectStore(FS.DB_STORE_NAME);
      var ok = 0,
        fail = 0,
        total = paths.length;
      function finish() {
        if (fail == 0) onload();
        else onerror();
      }
      paths.forEach(function(path) {
        var getRequest = files.get(path);
        getRequest.onsuccess = function getRequest_onsuccess() {
          if (FS.analyzePath(path).exists) {
            FS.unlink(path);
          }
          FS.createDataFile(
            PATH.dirname(path),
            PATH.basename(path),
            getRequest.result,
            true,
            true,
            true
          );
          ok++;
          if (ok + fail == total) finish();
        };
        getRequest.onerror = function getRequest_onerror() {
          fail++;
          if (ok + fail == total) finish();
        };
      });
      transaction.onerror = onerror;
    };
    openRequest.onerror = onerror;
  },
  mmapAlloc: function(size) {
    var alignedSize = alignMemory(size, 16384);
    var ptr = _malloc(alignedSize);
    while (size < alignedSize) HEAP8[ptr + size++] = 0;
    return ptr;
  }
};
var SYSCALLS = {
  mappings: {},
  DEFAULT_POLLMASK: 5,
  umask: 511,
  calculateAt: function(dirfd, path) {
    if (path[0] !== "/") {
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = FS.getStream(dirfd);
        if (!dirstream) throw new FS.ErrnoError(8);
        dir = dirstream.path;
      }
      path = PATH.join2(dir, path);
    }
    return path;
  },
  doStat: function(func, path, buf) {
    try {
      var stat = func(path);
    } catch (e) {
      if (
        e &&
        e.node &&
        PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))
      ) {
        return -54;
      }
      throw e;
    }
    HEAP32[buf >> 2] = stat.dev;
    HEAP32[(buf + 4) >> 2] = 0;
    HEAP32[(buf + 8) >> 2] = stat.ino;
    HEAP32[(buf + 12) >> 2] = stat.mode;
    HEAP32[(buf + 16) >> 2] = stat.nlink;
    HEAP32[(buf + 20) >> 2] = stat.uid;
    HEAP32[(buf + 24) >> 2] = stat.gid;
    HEAP32[(buf + 28) >> 2] = stat.rdev;
    HEAP32[(buf + 32) >> 2] = 0;
    (tempI64 = [
      stat.size >>> 0,
      ((tempDouble = stat.size),
      +Math_abs(tempDouble) >= 1
        ? tempDouble > 0
          ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>>
            0
          : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
            0
        : 0)
    ]),
      (HEAP32[(buf + 40) >> 2] = tempI64[0]),
      (HEAP32[(buf + 44) >> 2] = tempI64[1]);
    HEAP32[(buf + 48) >> 2] = 4096;
    HEAP32[(buf + 52) >> 2] = stat.blocks;
    HEAP32[(buf + 56) >> 2] = (stat.atime.getTime() / 1e3) | 0;
    HEAP32[(buf + 60) >> 2] = 0;
    HEAP32[(buf + 64) >> 2] = (stat.mtime.getTime() / 1e3) | 0;
    HEAP32[(buf + 68) >> 2] = 0;
    HEAP32[(buf + 72) >> 2] = (stat.ctime.getTime() / 1e3) | 0;
    HEAP32[(buf + 76) >> 2] = 0;
    (tempI64 = [
      stat.ino >>> 0,
      ((tempDouble = stat.ino),
      +Math_abs(tempDouble) >= 1
        ? tempDouble > 0
          ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>>
            0
          : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
            0
        : 0)
    ]),
      (HEAP32[(buf + 80) >> 2] = tempI64[0]),
      (HEAP32[(buf + 84) >> 2] = tempI64[1]);
    return 0;
  },
  doMsync: function(addr, stream, len, flags, offset) {
    var buffer = HEAPU8.slice(addr, addr + len);
    FS.msync(stream, buffer, offset, len, flags);
  },
  doMkdir: function(path, mode) {
    path = PATH.normalize(path);
    if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
    FS.mkdir(path, mode, 0);
    return 0;
  },
  doMknod: function(path, mode, dev) {
    switch (mode & 61440) {
      case 32768:
      case 8192:
      case 24576:
      case 4096:
      case 49152:
        break;
      default:
        return -28;
    }
    FS.mknod(path, mode, dev);
    return 0;
  },
  doReadlink: function(path, buf, bufsize) {
    if (bufsize <= 0) return -28;
    var ret = FS.readlink(path);
    var len = Math.min(bufsize, lengthBytesUTF8(ret));
    var endChar = HEAP8[buf + len];
    stringToUTF8(ret, buf, bufsize + 1);
    HEAP8[buf + len] = endChar;
    return len;
  },
  doAccess: function(path, amode) {
    if (amode & ~7) {
      return -28;
    }
    var node;
    var lookup = FS.lookupPath(path, { follow: true });
    node = lookup.node;
    if (!node) {
      return -44;
    }
    var perms = "";
    if (amode & 4) perms += "r";
    if (amode & 2) perms += "w";
    if (amode & 1) perms += "x";
    if (perms && FS.nodePermissions(node, perms)) {
      return -2;
    }
    return 0;
  },
  doDup: function(path, flags, suggestFD) {
    var suggest = FS.getStream(suggestFD);
    if (suggest) FS.close(suggest);
    return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
  },
  doReadv: function(stream, iov, iovcnt, offset) {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAP32[(iov + i * 8) >> 2];
      var len = HEAP32[(iov + (i * 8 + 4)) >> 2];
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0) return -1;
      ret += curr;
      if (curr < len) break;
    }
    return ret;
  },
  doWritev: function(stream, iov, iovcnt, offset) {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAP32[(iov + i * 8) >> 2];
      var len = HEAP32[(iov + (i * 8 + 4)) >> 2];
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0) return -1;
      ret += curr;
    }
    return ret;
  },
  varargs: undefined,
  get: function() {
    SYSCALLS.varargs += 4;
    var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];
    return ret;
  },
  getStr: function(ptr) {
    var ret = UTF8ToString(ptr);
    return ret;
  },
  getStreamFromFD: function(fd) {
    var stream = FS.getStream(fd);
    if (!stream) throw new FS.ErrnoError(8);
    return stream;
  },
  get64: function(low, high) {
    return low;
  }
};
function ___sys_chmod(path, mode) {
  try {
    path = SYSCALLS.getStr(path);
    FS.chmod(path, mode);
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    switch (cmd) {
      case 0: {
        var arg = SYSCALLS.get();
        if (arg < 0) {
          return -28;
        }
        var newStream;
        newStream = FS.open(stream.path, stream.flags, 0, arg);
        return newStream.fd;
      }
      case 1:
      case 2:
        return 0;
      case 3:
        return stream.flags;
      case 4: {
        var arg = SYSCALLS.get();
        stream.flags |= arg;
        return 0;
      }
      case 12: {
        var arg = SYSCALLS.get();
        var offset = 0;
        HEAP16[(arg + offset) >> 1] = 2;
        return 0;
      }
      case 13:
      case 14:
        return 0;
      case 16:
      case 8:
        return -28;
      case 9:
        setErrNo(28);
        return -1;
      default: {
        return -28;
      }
    }
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_fstat64(fd, buf) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    return SYSCALLS.doStat(FS.stat, stream.path, buf);
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_ioctl(fd, op, varargs) {
  SYSCALLS.varargs = varargs;
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    switch (op) {
      case 21509:
      case 21505: {
        if (!stream.tty) return -59;
        return 0;
      }
      case 21510:
      case 21511:
      case 21512:
      case 21506:
      case 21507:
      case 21508: {
        if (!stream.tty) return -59;
        return 0;
      }
      case 21519: {
        if (!stream.tty) return -59;
        var argp = SYSCALLS.get();
        HEAP32[argp >> 2] = 0;
        return 0;
      }
      case 21520: {
        if (!stream.tty) return -59;
        return -28;
      }
      case 21531: {
        var argp = SYSCALLS.get();
        return FS.ioctl(stream, op, argp);
      }
      case 21523: {
        if (!stream.tty) return -59;
        return 0;
      }
      case 21524: {
        if (!stream.tty) return -59;
        return 0;
      }
      default:
        abort("bad ioctl syscall " + op);
    }
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_open(path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {
    var pathname = SYSCALLS.getStr(path);
    var mode = SYSCALLS.get();
    var stream = FS.open(pathname, flags, mode);
    return stream.fd;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_read(fd, buf, count) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    return FS.read(stream, HEAP8, buf, count);
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_rename(old_path, new_path) {
  try {
    old_path = SYSCALLS.getStr(old_path);
    new_path = SYSCALLS.getStr(new_path);
    FS.rename(old_path, new_path);
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_rmdir(path) {
  try {
    path = SYSCALLS.getStr(path);
    FS.rmdir(path);
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_stat64(path, buf) {
  try {
    path = SYSCALLS.getStr(path);
    return SYSCALLS.doStat(FS.stat, path, buf);
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_unlink(path) {
  try {
    path = SYSCALLS.getStr(path);
    FS.unlink(path);
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function _emscripten_memcpy_big(dest, src, num) {
  HEAPU8.copyWithin(dest, src, src + num);
}
function _emscripten_get_heap_size() {
  return HEAPU8.length;
}
function emscripten_realloc_buffer(size) {
  try {
    wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16);
    updateGlobalBufferAndViews(wasmMemory.buffer);
    return 1;
  } catch (e) {}
}
function _emscripten_resize_heap(requestedSize) {
  requestedSize = requestedSize >>> 0;
  var oldSize = _emscripten_get_heap_size();
  var maxHeapSize = 2147483648;
  if (requestedSize > maxHeapSize) {
    return false;
  }
  var minHeapSize = 16777216;
  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
    var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
    var newSize = Math.min(
      maxHeapSize,
      alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), 65536)
    );
    var replacement = emscripten_realloc_buffer(newSize);
    if (replacement) {
      return true;
    }
  }
  return false;
}
function _fd_close(fd) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    FS.close(stream);
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
function _fd_fdstat_get(fd, pbuf) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    var type = stream.tty
      ? 2
      : FS.isDir(stream.mode)
      ? 3
      : FS.isLink(stream.mode)
      ? 7
      : 4;
    HEAP8[pbuf >> 0] = type;
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
function _fd_read(fd, iov, iovcnt, pnum) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    var num = SYSCALLS.doReadv(stream, iov, iovcnt);
    HEAP32[pnum >> 2] = num;
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    var HIGH_OFFSET = 4294967296;
    var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
    var DOUBLE_LIMIT = 9007199254740992;
    if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
      return -61;
    }
    FS.llseek(stream, offset, whence);
    (tempI64 = [
      stream.position >>> 0,
      ((tempDouble = stream.position),
      +Math_abs(tempDouble) >= 1
        ? tempDouble > 0
          ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>>
            0
          : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
            0
        : 0)
    ]),
      (HEAP32[newOffset >> 2] = tempI64[0]),
      (HEAP32[(newOffset + 4) >> 2] = tempI64[1]);
    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
function _fd_write(fd, iov, iovcnt, pnum) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    var num = SYSCALLS.doWritev(stream, iov, iovcnt);
    HEAP32[pnum >> 2] = num;
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
function _setTempRet0($i) {
  setTempRet0($i | 0);
}
function _time(ptr) {
  var ret = (Date.now() / 1e3) | 0;
  if (ptr) {
    HEAP32[ptr >> 2] = ret;
  }
  return ret;
}
function _tzset() {
  if (_tzset.called) return;
  _tzset.called = true;
  HEAP32[__get_timezone() >> 2] = new Date().getTimezoneOffset() * 60;
  var currentYear = new Date().getFullYear();
  var winter = new Date(currentYear, 0, 1);
  var summer = new Date(currentYear, 6, 1);
  HEAP32[__get_daylight() >> 2] = Number(
    winter.getTimezoneOffset() != summer.getTimezoneOffset()
  );
  function extractZone(date) {
    var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
    return match ? match[1] : "GMT";
  }
  var winterName = extractZone(winter);
  var summerName = extractZone(summer);
  var winterNamePtr = allocateUTF8(winterName);
  var summerNamePtr = allocateUTF8(summerName);
  if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {
    HEAP32[__get_tzname() >> 2] = winterNamePtr;
    HEAP32[(__get_tzname() + 4) >> 2] = summerNamePtr;
  } else {
    HEAP32[__get_tzname() >> 2] = summerNamePtr;
    HEAP32[(__get_tzname() + 4) >> 2] = winterNamePtr;
  }
}
function _timegm(tmPtr) {
  _tzset();
  var time = Date.UTC(
    HEAP32[(tmPtr + 20) >> 2] + 1900,
    HEAP32[(tmPtr + 16) >> 2],
    HEAP32[(tmPtr + 12) >> 2],
    HEAP32[(tmPtr + 8) >> 2],
    HEAP32[(tmPtr + 4) >> 2],
    HEAP32[tmPtr >> 2],
    0
  );
  var date = new Date(time);
  HEAP32[(tmPtr + 24) >> 2] = date.getUTCDay();
  var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
  var yday = ((date.getTime() - start) / (1e3 * 60 * 60 * 24)) | 0;
  HEAP32[(tmPtr + 28) >> 2] = yday;
  return (date.getTime() / 1e3) | 0;
}
var FSNode = function(parent, name, mode, rdev) {
  if (!parent) {
    parent = this;
  }
  this.parent = parent;
  this.mount = parent.mount;
  this.mounted = null;
  this.id = FS.nextInode++;
  this.name = name;
  this.mode = mode;
  this.node_ops = {};
  this.stream_ops = {};
  this.rdev = rdev;
};
var readMode = 292 | 73;
var writeMode = 146;
Object.defineProperties(FSNode.prototype, {
  read: {
    get: function() {
      return (this.mode & readMode) === readMode;
    },
    set: function(val) {
      val ? (this.mode |= readMode) : (this.mode &= ~readMode);
    }
  },
  write: {
    get: function() {
      return (this.mode & writeMode) === writeMode;
    },
    set: function(val) {
      val ? (this.mode |= writeMode) : (this.mode &= ~writeMode);
    }
  },
  isFolder: {
    get: function() {
      return FS.isDir(this.mode);
    }
  },
  isDevice: {
    get: function() {
      return FS.isChrdev(this.mode);
    }
  }
});
FS.FSNode = FSNode;
FS.staticInit();
if (ENVIRONMENT_IS_NODE) {
  var fs = frozenFs;
  var NODEJS_PATH = __webpack_require__(84);
  NODEFS.staticInit();
}
if (ENVIRONMENT_IS_NODE) {
  var _wrapNodeError = function(func) {
    return function() {
      try {
        return func.apply(this, arguments);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(ERRNO_CODES[e.code]);
      }
    };
  };
  var VFS = Object.assign({}, FS);
  for (var _key in NODERAWFS) FS[_key] = _wrapNodeError(NODERAWFS[_key]);
} else {
  throw new Error(
    "NODERAWFS is currently only supported on Node.js environment."
  );
}
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}
var decodeBase64 =
  typeof atob === "function"
    ? atob
    : function(input) {
        var keyStr =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        do {
          enc1 = keyStr.indexOf(input.charAt(i++));
          enc2 = keyStr.indexOf(input.charAt(i++));
          enc3 = keyStr.indexOf(input.charAt(i++));
          enc4 = keyStr.indexOf(input.charAt(i++));
          chr1 = (enc1 << 2) | (enc2 >> 4);
          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
          chr3 = ((enc3 & 3) << 6) | enc4;
          output = output + String.fromCharCode(chr1);
          if (enc3 !== 64) {
            output = output + String.fromCharCode(chr2);
          }
          if (enc4 !== 64) {
            output = output + String.fromCharCode(chr3);
          }
        } while (i < input.length);
        return output;
      };
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE === "boolean" && ENVIRONMENT_IS_NODE) {
    var buf;
    try {
      buf = Buffer.from(s, "base64");
    } catch (_) {
      buf = new Buffer(s, "base64");
    }
    return new Uint8Array(buf["buffer"], buf["byteOffset"], buf["byteLength"]);
  }
  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0; i < decoded.length; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error("Converting base64 string to bytes failed.");
  }
}
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }
  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}
var asmLibraryArg = {
  m: ___gmtime_r,
  b: wasmTable,
  r: ___sys_chmod,
  g: ___sys_fcntl64,
  l: ___sys_fstat64,
  q: ___sys_ioctl,
  t: ___sys_open,
  s: ___sys_read,
  j: ___sys_rename,
  u: ___sys_rmdir,
  e: ___sys_stat64,
  i: ___sys_unlink,
  v: _emscripten_memcpy_big,
  w: _emscripten_resize_heap,
  h: _fd_close,
  k: _fd_fdstat_get,
  p: _fd_read,
  n: _fd_seek,
  f: _fd_write,
  a: wasmMemory,
  c: _setTempRet0,
  d: _time,
  o: _timegm
};
var asm = createWasm();
var ___wasm_call_ctors = (Module["___wasm_call_ctors"] = asm["x"]);
var _zipstruct_stat = (Module["_zipstruct_stat"] = asm["y"]);
var _zipstruct_statS = (Module["_zipstruct_statS"] = asm["z"]);
var _zipstruct_stat_name = (Module["_zipstruct_stat_name"] = asm["A"]);
var _zipstruct_stat_index = (Module["_zipstruct_stat_index"] = asm["B"]);
var _zipstruct_stat_size = (Module["_zipstruct_stat_size"] = asm["C"]);
var _zipstruct_stat_mtime = (Module["_zipstruct_stat_mtime"] = asm["D"]);
var _zipstruct_error = (Module["_zipstruct_error"] = asm["E"]);
var _zipstruct_errorS = (Module["_zipstruct_errorS"] = asm["F"]);
var _zipstruct_error_code_zip = (Module["_zipstruct_error_code_zip"] =
  asm["G"]);
var _zipstruct_stat_comp_size = (Module["_zipstruct_stat_comp_size"] =
  asm["H"]);
var _zipstruct_stat_comp_method = (Module["_zipstruct_stat_comp_method"] =
  asm["I"]);
var _zip_close = (Module["_zip_close"] = asm["J"]);
var _zip_delete = (Module["_zip_delete"] = asm["K"]);
var _zip_dir_add = (Module["_zip_dir_add"] = asm["L"]);
var _zip_discard = (Module["_zip_discard"] = asm["M"]);
var _zip_error_init_with_code = (Module["_zip_error_init_with_code"] =
  asm["N"]);
var _zip_get_error = (Module["_zip_get_error"] = asm["O"]);
var _zip_file_get_error = (Module["_zip_file_get_error"] = asm["P"]);
var _zip_error_strerror = (Module["_zip_error_strerror"] = asm["Q"]);
var _zip_fclose = (Module["_zip_fclose"] = asm["R"]);
var _zip_file_add = (Module["_zip_file_add"] = asm["S"]);
var _zip_file_get_external_attributes = (Module[
  "_zip_file_get_external_attributes"
] = asm["T"]);
var _zip_file_set_external_attributes = (Module[
  "_zip_file_set_external_attributes"
] = asm["U"]);
var _zip_file_set_mtime = (Module["_zip_file_set_mtime"] = asm["V"]);
var _zip_fopen = (Module["_zip_fopen"] = asm["W"]);
var _zip_fopen_index = (Module["_zip_fopen_index"] = asm["X"]);
var _zip_fread = (Module["_zip_fread"] = asm["Y"]);
var _zip_get_name = (Module["_zip_get_name"] = asm["Z"]);
var _zip_get_num_entries = (Module["_zip_get_num_entries"] = asm["_"]);
var _zip_name_locate = (Module["_zip_name_locate"] = asm["$"]);
var _zip_open = (Module["_zip_open"] = asm["aa"]);
var _zip_open_from_source = (Module["_zip_open_from_source"] = asm["ba"]);
var _zip_set_file_compression = (Module["_zip_set_file_compression"] =
  asm["ca"]);
var _zip_source_buffer = (Module["_zip_source_buffer"] = asm["da"]);
var _zip_source_buffer_create = (Module["_zip_source_buffer_create"] =
  asm["ea"]);
var _zip_source_close = (Module["_zip_source_close"] = asm["fa"]);
var _zip_source_error = (Module["_zip_source_error"] = asm["ga"]);
var _zip_source_free = (Module["_zip_source_free"] = asm["ha"]);
var _zip_source_keep = (Module["_zip_source_keep"] = asm["ia"]);
var _zip_source_open = (Module["_zip_source_open"] = asm["ja"]);
var _zip_source_read = (Module["_zip_source_read"] = asm["ka"]);
var _zip_source_seek = (Module["_zip_source_seek"] = asm["la"]);
var _zip_source_set_mtime = (Module["_zip_source_set_mtime"] = asm["ma"]);
var _zip_source_tell = (Module["_zip_source_tell"] = asm["na"]);
var _zip_stat = (Module["_zip_stat"] = asm["oa"]);
var _zip_stat_index = (Module["_zip_stat_index"] = asm["pa"]);
var _zip_ext_count_symlinks = (Module["_zip_ext_count_symlinks"] = asm["qa"]);
var ___errno_location = (Module["___errno_location"] = asm["ra"]);
var __get_tzname = (Module["__get_tzname"] = asm["sa"]);
var __get_daylight = (Module["__get_daylight"] = asm["ta"]);
var __get_timezone = (Module["__get_timezone"] = asm["ua"]);
var stackSave = (Module["stackSave"] = asm["va"]);
var stackRestore = (Module["stackRestore"] = asm["wa"]);
var stackAlloc = (Module["stackAlloc"] = asm["xa"]);
var _malloc = (Module["_malloc"] = asm["ya"]);
var _free = (Module["_free"] = asm["za"]);
Module["cwrap"] = cwrap;
Module["getValue"] = getValue;
var calledRun;
dependenciesFulfilled = function runCaller() {
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller;
};
function run(args) {
  args = args || arguments_;
  if (runDependencies > 0) {
    return;
  }
  preRun();
  if (runDependencies > 0) return;
  function doRun() {
    if (calledRun) return;
    calledRun = true;
    Module["calledRun"] = true;
    if (ABORT) return;
    initRuntime();
    preMain();
    if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
    postRun();
  }
  if (Module["setStatus"]) {
    Module["setStatus"]("Running...");
    setTimeout(function() {
      setTimeout(function() {
        Module["setStatus"]("");
      }, 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module["run"] = run;
if (Module["preInit"]) {
  if (typeof Module["preInit"] == "function")
    Module["preInit"] = [Module["preInit"]];
  while (Module["preInit"].length > 0) {
    Module["preInit"].pop()();
  }
}
noExitRuntime = true;
run();


/***/ }),
/* 344 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "globUtils": () => /* reexport module object */ _globUtils__WEBPACK_IMPORTED_MODULE_4__,
/* harmony export */   "ShellError": () => /* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_3__.ShellError,
/* harmony export */   "execute": () => /* binding */ execute
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(165);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(182);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(345);
/* harmony import */ var _globUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(346);
/* harmony import */ var _pipe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(347);









var StreamType;

(function (StreamType) {
  StreamType[StreamType["Readable"] = 1] = "Readable";
  StreamType[StreamType["Writable"] = 2] = "Writable";
})(StreamType || (StreamType = {}));

function getFileDescriptorStream(fd, type, state) {
  const stream = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough({
    autoDestroy: true
  });

  switch (fd) {
    case _pipe__WEBPACK_IMPORTED_MODULE_5__.Pipe.STDIN:
      {
        if ((type & StreamType.Readable) === StreamType.Readable) state.stdin.pipe(stream, {
          end: false
        });

        if ((type & StreamType.Writable) === StreamType.Writable && state.stdin instanceof stream__WEBPACK_IMPORTED_MODULE_2__.Writable) {
          stream.pipe(state.stdin, {
            end: false
          });
        }
      }
      break;

    case _pipe__WEBPACK_IMPORTED_MODULE_5__.Pipe.STDOUT:
      {
        if ((type & StreamType.Readable) === StreamType.Readable) state.stdout.pipe(stream, {
          end: false
        });

        if ((type & StreamType.Writable) === StreamType.Writable) {
          stream.pipe(state.stdout, {
            end: false
          });
        }
      }
      break;

    case _pipe__WEBPACK_IMPORTED_MODULE_5__.Pipe.STDERR:
      {
        if ((type & StreamType.Readable) === StreamType.Readable) state.stderr.pipe(stream, {
          end: false
        });

        if ((type & StreamType.Writable) === StreamType.Writable) {
          stream.pipe(state.stderr, {
            end: false
          });
        }
      }
      break;

    default:
      {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.ShellError(`Bad file descriptor: "${fd}"`);
      }
  }

  return stream;
}

function cloneState(state, mergeWith = {}) {
  const newState = { ...state,
    ...mergeWith
  };
  newState.environment = { ...state.environment,
    ...mergeWith.environment
  };
  newState.variables = { ...state.variables,
    ...mergeWith.variables
  };
  return newState;
}

const BUILTINS = new Map([[`cd`, async ([target = (0,os__WEBPACK_IMPORTED_MODULE_1__.homedir)(), ...rest], opts, state) => {
  const resolvedTarget = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(state.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(target));
  const stat = await opts.baseFs.statPromise(resolvedTarget);

  if (!stat.isDirectory()) {
    state.stderr.write(`cd: not a directory\n`);
    return 1;
  } else {
    state.cwd = resolvedTarget;
    return 0;
  }
}], [`pwd`, async (args, opts, state) => {
  state.stdout.write(`${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.fromPortablePath(state.cwd)}\n`);
  return 0;
}], [`:`, async (args, opts, state) => {
  return 0;
}], [`true`, async (args, opts, state) => {
  return 0;
}], [`false`, async (args, opts, state) => {
  return 1;
}], [`exit`, async ([code, ...rest], opts, state) => {
  return state.exitCode = parseInt(code !== null && code !== void 0 ? code : state.variables[`?`], 10);
}], [`echo`, async (args, opts, state) => {
  state.stdout.write(`${args.join(` `)}\n`);
  return 0;
}], [`__ysh_run_procedure`, async (args, opts, state) => {
  const procedure = state.procedures[args[0]];
  const exitCode = await (0,_pipe__WEBPACK_IMPORTED_MODULE_5__.start)(procedure, {
    stdin: new _pipe__WEBPACK_IMPORTED_MODULE_5__.ProtectedStream(state.stdin),
    stdout: new _pipe__WEBPACK_IMPORTED_MODULE_5__.ProtectedStream(state.stdout),
    stderr: new _pipe__WEBPACK_IMPORTED_MODULE_5__.ProtectedStream(state.stderr)
  }).run();
  return exitCode;
}], [`__ysh_set_redirects`, async (args, opts, state) => {
  let stdin = state.stdin;
  let stdout = state.stdout;
  const stderr = state.stderr;
  const inputs = [];
  const outputs = [];
  let t = 0;

  while (args[t] !== `--`) {
    const type = args[t++];
    const count = Number(args[t++]);
    const last = t + count;

    for (let u = t; u < last; ++t, ++u) {
      switch (type) {
        case `<`:
          {
            inputs.push(() => {
              return opts.baseFs.createReadStream(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(state.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(args[u])));
            });
          }
          break;

        case `<<<`:
          {
            inputs.push(() => {
              const input = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
              process.nextTick(() => {
                input.write(`${args[u]}\n`);
                input.end();
              });
              return input;
            });
          }
          break;

        case `<&`:
          {
            inputs.push(() => getFileDescriptorStream(Number(args[u]), StreamType.Readable, state));
          }
          break;

        case `>`:
          {
            outputs.push(opts.baseFs.createWriteStream(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(state.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(args[u]))));
          }
          break;

        case `>>`:
          {
            outputs.push(opts.baseFs.createWriteStream(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(state.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(args[u])), {
              flags: `a`
            }));
          }
          break;

        case `>&`:
          {
            outputs.push(getFileDescriptorStream(Number(args[u]), StreamType.Writable, state));
          }
          break;

        default:
          {
            throw new Error(`Assertion failed: Unsupported redirection type: "${type}"`);
          }
      }
    }
  }

  if (inputs.length > 0) {
    const pipe = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
    stdin = pipe;

    const bindInput = n => {
      if (n === inputs.length) {
        pipe.end();
      } else {
        const input = inputs[n]();
        input.pipe(pipe, {
          end: false
        });
        input.on(`end`, () => {
          bindInput(n + 1);
        });
      }
    };

    bindInput(0);
  }

  if (outputs.length > 0) {
    const pipe = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
    stdout = pipe;

    for (const output of outputs) {
      pipe.pipe(output);
    }
  }

  const exitCode = await (0,_pipe__WEBPACK_IMPORTED_MODULE_5__.start)(makeCommandAction(args.slice(t + 1), opts, state), {
    stdin: new _pipe__WEBPACK_IMPORTED_MODULE_5__.ProtectedStream(stdin),
    stdout: new _pipe__WEBPACK_IMPORTED_MODULE_5__.ProtectedStream(stdout),
    stderr: new _pipe__WEBPACK_IMPORTED_MODULE_5__.ProtectedStream(stderr)
  }).run(); // Close all the outputs (since the shell never closes the output stream)

  await Promise.all(outputs.map(output => {
    // Wait until the output got flushed to the disk
    return new Promise(resolve => {
      output.on(`close`, () => {
        resolve();
      });
      output.end();
    });
  }));
  return exitCode;
}]]);

async function executeBufferedSubshell(ast, opts, state) {
  const chunks = [];
  const stdout = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
  stdout.on(`data`, chunk => chunks.push(chunk));
  await executeShellLine(ast, opts, cloneState(state, {
    stdout
  }));
  return Buffer.concat(chunks).toString().replace(/[\r\n]+$/, ``);
}

async function applyEnvVariables(environmentSegments, opts, state) {
  const envPromises = environmentSegments.map(async envSegment => {
    const interpolatedArgs = await interpolateArguments(envSegment.args, opts, state);
    return {
      name: envSegment.name,
      value: interpolatedArgs.join(` `)
    };
  });
  const interpolatedEnvs = await Promise.all(envPromises);
  return interpolatedEnvs.reduce((envs, env) => {
    envs[env.name] = env.value;
    return envs;
  }, {});
}

function split(raw) {
  return raw.match(/[^ \r\n\t]+/g) || [];
}

async function evaluateVariable(segment, opts, state, push, pushAndClose = push) {
  switch (segment.name) {
    case `$`:
      {
        push(String(process.pid));
      }
      break;

    case `#`:
      {
        push(String(opts.args.length));
      }
      break;

    case `@`:
      {
        if (segment.quoted) {
          for (const raw of opts.args) {
            pushAndClose(raw);
          }
        } else {
          for (const raw of opts.args) {
            const parts = split(raw);

            for (let t = 0; t < parts.length - 1; ++t) pushAndClose(parts[t]);

            push(parts[parts.length - 1]);
          }
        }
      }
      break;

    case `*`:
      {
        const raw = opts.args.join(` `);

        if (segment.quoted) {
          push(raw);
        } else {
          for (const part of split(raw)) {
            pushAndClose(part);
          }
        }
      }
      break;

    case `PPID`:
      {
        push(String(process.ppid));
      }
      break;

    case `RANDOM`:
      {
        push(String(Math.floor(Math.random() * 32768)));
      }
      break;

    default:
      {
        const argIndex = parseInt(segment.name, 10);

        if (Number.isFinite(argIndex)) {
          if (argIndex >= 0 && argIndex < opts.args.length) {
            push(opts.args[argIndex]);
          } else if (segment.defaultValue) {
            push((await interpolateArguments(segment.defaultValue, opts, state)).join(` `));
          } else {
            throw new _errors__WEBPACK_IMPORTED_MODULE_3__.ShellError(`Unbound argument #${argIndex}`);
          }
        } else {
          if (Object.prototype.hasOwnProperty.call(state.variables, segment.name)) {
            push(state.variables[segment.name]);
          } else if (Object.prototype.hasOwnProperty.call(state.environment, segment.name)) {
            push(state.environment[segment.name]);
          } else if (segment.defaultValue) {
            push((await interpolateArguments(segment.defaultValue, opts, state)).join(` `));
          } else {
            throw new _errors__WEBPACK_IMPORTED_MODULE_3__.ShellError(`Unbound variable "${segment.name}"`);
          }
        }
      }
      break;
  }
}

const operators = {
  addition: (left, right) => left + right,
  subtraction: (left, right) => left - right,
  multiplication: (left, right) => left * right,
  division: (left, right) => Math.trunc(left / right)
};

async function evaluateArithmetic(arithmetic, opts, state) {
  if (arithmetic.type === `number`) {
    if (!Number.isInteger(arithmetic.value)) {
      // ZSH allows non-integers, while bash throws at the parser level (unrecoverable)
      throw new Error(`Invalid number: "${arithmetic.value}", only integers are allowed`);
    } else {
      return arithmetic.value;
    }
  } else if (arithmetic.type === `variable`) {
    const parts = [];
    await evaluateVariable({ ...arithmetic,
      quoted: true
    }, opts, state, result => parts.push(result));
    const number = Number(parts.join(` `));

    if (Number.isNaN(number)) {
      return evaluateArithmetic({
        type: `variable`,
        name: parts.join(` `)
      }, opts, state);
    } else {
      return evaluateArithmetic({
        type: `number`,
        value: number
      }, opts, state);
    }
  } else {
    return operators[arithmetic.type](await evaluateArithmetic(arithmetic.left, opts, state), await evaluateArithmetic(arithmetic.right, opts, state));
  }
}

async function interpolateArguments(commandArgs, opts, state) {
  const redirections = new Map();
  const interpolated = [];
  let interpolatedSegments = [];

  const push = segment => {
    interpolatedSegments.push(segment);
  };

  const close = () => {
    if (interpolatedSegments.length > 0) interpolated.push(interpolatedSegments.join(``));
    interpolatedSegments = [];
  };

  const pushAndClose = segment => {
    push(segment);
    close();
  };

  const redirect = (type, target) => {
    let targets = redirections.get(type);
    if (typeof targets === `undefined`) redirections.set(type, targets = []);
    targets.push(target);
  };

  for (const commandArg of commandArgs) {
    let isGlob = false;

    switch (commandArg.type) {
      case `redirection`:
        {
          const interpolatedArgs = await interpolateArguments(commandArg.args, opts, state);

          for (const interpolatedArg of interpolatedArgs) {
            redirect(commandArg.subtype, interpolatedArg);
          }
        }
        break;

      case `argument`:
        {
          for (const segment of commandArg.segments) {
            switch (segment.type) {
              case `text`:
                {
                  push(segment.text);
                }
                break;

              case `glob`:
                {
                  push(segment.pattern);
                  isGlob = true;
                }
                break;

              case `shell`:
                {
                  const raw = await executeBufferedSubshell(segment.shell, opts, state);

                  if (segment.quoted) {
                    push(raw);
                  } else {
                    const parts = split(raw);

                    for (let t = 0; t < parts.length - 1; ++t) pushAndClose(parts[t]);

                    push(parts[parts.length - 1]);
                  }
                }
                break;

              case `variable`:
                {
                  await evaluateVariable(segment, opts, state, push, pushAndClose);
                }
                break;

              case `arithmetic`:
                {
                  push(String(await evaluateArithmetic(segment.arithmetic, opts, state)));
                }
                break;
            }
          }
        }
        break;
    }

    close();

    if (isGlob) {
      const pattern = interpolated.pop();
      if (typeof pattern === `undefined`) throw new Error(`Assertion failed: Expected a glob pattern to have been set`);
      const matches = await opts.glob.match(pattern, {
        cwd: state.cwd,
        baseFs: opts.baseFs
      });

      if (matches.length === 0) {
        const braceExpansionNotice = _globUtils__WEBPACK_IMPORTED_MODULE_4__.isBraceExpansion(pattern) ? `. Note: Brace expansion of arbitrary strings isn't currently supported. For more details, please read this issue: https://github.com/yarnpkg/berry/issues/22` : ``;
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.ShellError(`No matches found: "${pattern}"${braceExpansionNotice}`);
      }

      for (const match of matches.sort()) {
        pushAndClose(match);
      }
    }
  }

  if (redirections.size > 0) {
    const redirectionArgs = [];

    for (const [subtype, targets] of redirections.entries()) redirectionArgs.splice(redirectionArgs.length, 0, subtype, String(targets.length), ...targets);

    interpolated.splice(0, 0, `__ysh_set_redirects`, ...redirectionArgs, `--`);
  }

  return interpolated;
}
/**
 * Executes a command chain. A command chain is a list of commands linked
 * together thanks to the use of either of the `|` or `|&` operators:
 *
 * $ cat hello | grep world | grep -v foobar
 */


function makeCommandAction(args, opts, state) {
  if (!opts.builtins.has(args[0])) args = [`command`, ...args];
  const nativeCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.fromPortablePath(state.cwd);
  let env = state.environment;
  if (typeof env.PWD !== `undefined`) env = { ...env,
    PWD: nativeCwd
  };
  const [name, ...rest] = args;

  if (name === `command`) {
    return (0,_pipe__WEBPACK_IMPORTED_MODULE_5__.makeProcess)(rest[0], rest.slice(1), opts, {
      cwd: nativeCwd,
      env
    });
  }

  const builtin = opts.builtins.get(name);
  if (typeof builtin === `undefined`) throw new Error(`Assertion failed: A builtin should exist for "${name}"`);
  return (0,_pipe__WEBPACK_IMPORTED_MODULE_5__.makeBuiltin)(async ({
    stdin,
    stdout,
    stderr
  }) => {
    state.stdin = stdin;
    state.stdout = stdout;
    state.stderr = stderr;
    return await builtin(rest, opts, state);
  });
}

function makeSubshellAction(ast, opts, state) {
  return stdio => {
    const stdin = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
    const promise = executeShellLine(ast, opts, cloneState(state, {
      stdin
    }));
    return {
      stdin,
      promise
    };
  };
}

function makeGroupAction(ast, opts, state) {
  return stdio => {
    const stdin = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
    const promise = executeShellLine(ast, opts, state);
    return {
      stdin,
      promise
    };
  };
}

function makeActionFromProcedure(procedure, args, opts, activeState) {
  if (args.length === 0) {
    return procedure;
  } else {
    let key;

    do {
      key = String(Math.random());
    } while (Object.prototype.hasOwnProperty.call(activeState.procedures, key));

    activeState.procedures = { ...activeState.procedures
    };
    activeState.procedures[key] = procedure;
    return makeCommandAction([...args, `__ysh_run_procedure`, key], opts, activeState);
  }
}

async function executeCommandChain(node, opts, state) {
  let current = node;
  let pipeType = null;
  let execution = null;

  while (current) {
    // Only the final segment is allowed to modify the shell state; all the
    // other ones are isolated
    const activeState = current.then ? { ...state
    } : state;
    let action;

    switch (current.type) {
      case `command`:
        {
          const args = await interpolateArguments(current.args, opts, state);
          const environment = await applyEnvVariables(current.envs, opts, state);
          action = current.envs.length ? makeCommandAction(args, opts, cloneState(activeState, {
            environment
          })) : makeCommandAction(args, opts, activeState);
        }
        break;

      case `subshell`:
        {
          const args = await interpolateArguments(current.args, opts, state); // We don't interpolate the subshell because it will be recursively
          // interpolated within its own context

          const procedure = makeSubshellAction(current.subshell, opts, activeState);
          action = makeActionFromProcedure(procedure, args, opts, activeState);
        }
        break;

      case `group`:
        {
          const args = await interpolateArguments(current.args, opts, state);
          const procedure = makeGroupAction(current.group, opts, activeState);
          action = makeActionFromProcedure(procedure, args, opts, activeState);
        }
        break;

      case `envs`:
        {
          const environment = await applyEnvVariables(current.envs, opts, state);
          activeState.environment = { ...activeState.environment,
            ...environment
          };
          action = makeCommandAction([`true`], opts, activeState);
        }
        break;
    }

    if (typeof action === `undefined`) throw new Error(`Assertion failed: An action should have been generated`);

    if (pipeType === null) {
      // If we're processing the left-most segment of the command, we start a
      // new execution pipeline
      execution = (0,_pipe__WEBPACK_IMPORTED_MODULE_5__.start)(action, {
        stdin: new _pipe__WEBPACK_IMPORTED_MODULE_5__.ProtectedStream(activeState.stdin),
        stdout: new _pipe__WEBPACK_IMPORTED_MODULE_5__.ProtectedStream(activeState.stdout),
        stderr: new _pipe__WEBPACK_IMPORTED_MODULE_5__.ProtectedStream(activeState.stderr)
      });
    } else {
      if (execution === null) throw new Error(`Assertion failed: The execution pipeline should have been setup`); // Otherwise, depending on the exaxct pipe type, we either pipe stdout
      // only or stdout and stderr

      switch (pipeType) {
        case `|`:
          {
            execution = execution.pipeTo(action, _pipe__WEBPACK_IMPORTED_MODULE_5__.Pipe.STDOUT);
          }
          break;

        case `|&`:
          {
            execution = execution.pipeTo(action, _pipe__WEBPACK_IMPORTED_MODULE_5__.Pipe.STDOUT | _pipe__WEBPACK_IMPORTED_MODULE_5__.Pipe.STDERR);
          }
          break;
      }
    }

    if (current.then) {
      pipeType = current.then.type;
      current = current.then.chain;
    } else {
      current = null;
    }
  }

  if (execution === null) throw new Error(`Assertion failed: The execution pipeline should have been setup`);
  return await execution.run();
}
/**
 * Execute a command line. A command line is a list of command shells linked
 * together thanks to the use of either of the `||` or `&&` operators.
 */


async function executeCommandLine(node, opts, state) {
  let code;

  const setCode = newCode => {
    code = newCode; // We must update $?, which always contains the exit code from
    // the right-most command

    state.variables[`?`] = String(newCode);
  };

  const executeChain = async chain => {
    try {
      return await executeCommandChain(chain, opts, state);
    } catch (error) {
      if (!(error instanceof _errors__WEBPACK_IMPORTED_MODULE_3__.ShellError)) throw error;
      state.stderr.write(`${error.message}\n`);
      return 1;
    }
  };

  setCode(await executeChain(node.chain)); // We use a loop because we must make sure that we respect
  // the left associativity of lists, as per the bash spec.
  // (e.g. `inexistent && echo yes || echo no` must be
  // the same as `{inexistent && echo yes} || echo no`)

  while (node.then) {
    // If the execution aborted (usually through "exit"), we must bailout
    if (state.exitCode !== null) return state.exitCode;

    switch (node.then.type) {
      case `&&`:
        {
          if (code === 0) {
            setCode(await executeChain(node.then.line.chain));
          }
        }
        break;

      case `||`:
        {
          if (code !== 0) {
            setCode(await executeChain(node.then.line.chain));
          }
        }
        break;

      default:
        {
          throw new Error(`Assertion failed: Unsupported command type: "${node.then.type}"`);
        }
        break;
    }

    node = node.then.line;
  }

  return code;
}

async function executeShellLine(node, opts, state) {
  let rightMostExitCode = 0;

  for (const command of node) {
    rightMostExitCode = await executeCommandLine(command, opts, state); // If the execution aborted (usually through "exit"), we must bailout

    if (state.exitCode !== null) return state.exitCode; // We must update $?, which always contains the exit code from
    // the right-most command

    state.variables[`?`] = String(rightMostExitCode);
  }

  return rightMostExitCode;
}

function locateArgsVariableInSegment(segment) {
  switch (segment.type) {
    case `variable`:
      {
        return segment.name === `@` || segment.name === `#` || segment.name === `*` || Number.isFinite(parseInt(segment.name, 10)) || `defaultValue` in segment && !!segment.defaultValue && segment.defaultValue.some(arg => locateArgsVariableInArgument(arg));
      }
      break;

    case `arithmetic`:
      {
        return locateArgsVariableInArithmetic(segment.arithmetic);
      }
      break;

    case `shell`:
      {
        return locateArgsVariable(segment.shell);
      }
      break;

    default:
      {
        return false;
      }
      break;
  }
}

function locateArgsVariableInArgument(arg) {
  switch (arg.type) {
    case `redirection`:
      {
        return arg.args.some(arg => locateArgsVariableInArgument(arg));
      }
      break;

    case `argument`:
      {
        return arg.segments.some(segment => locateArgsVariableInSegment(segment));
      }
      break;

    default:
      throw new Error(`Assertion failed: Unsupported argument type: "${arg.type}"`);
  }
}

function locateArgsVariableInArithmetic(arg) {
  switch (arg.type) {
    case `variable`:
      {
        return locateArgsVariableInSegment(arg);
      }
      break;

    case `number`:
      {
        return false;
      }
      break;

    default:
      return locateArgsVariableInArithmetic(arg.left) || locateArgsVariableInArithmetic(arg.right);
  }
}

function locateArgsVariable(node) {
  return node.some(command => {
    while (command) {
      let chain = command.chain;

      while (chain) {
        let hasArgs;

        switch (chain.type) {
          case `subshell`:
            {
              hasArgs = locateArgsVariable(chain.subshell);
            }
            break;

          case `command`:
            {
              hasArgs = chain.envs.some(env => env.args.some(arg => {
                return locateArgsVariableInArgument(arg);
              })) || chain.args.some(arg => {
                return locateArgsVariableInArgument(arg);
              });
            }
            break;
        }

        if (hasArgs) return true;
        if (!chain.then) break;
        chain = chain.then.chain;
      }

      if (!command.then) break;
      command = command.then.line;
    }

    return false;
  });
}

async function execute(command, args = [], {
  baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.NodeFS(),
  builtins = {},
  cwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(process.cwd()),
  env = process.env,
  stdin = process.stdin,
  stdout = process.stdout,
  stderr = process.stderr,
  variables = {},
  glob = _globUtils__WEBPACK_IMPORTED_MODULE_4__
} = {}) {
  const normalizedEnv = {};

  for (const [key, value] of Object.entries(env)) if (typeof value !== `undefined`) normalizedEnv[key] = value;

  const normalizedBuiltins = new Map(BUILTINS);

  for (const [key, builtin] of Object.entries(builtins)) normalizedBuiltins.set(key, builtin); // This is meant to be the equivalent of /dev/null


  if (stdin === null) {
    stdin = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
    stdin.end();
  }

  const ast = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseShell)(command, glob); // If the shell line doesn't use the args, inject it at the end of the
  // right-most command

  if (!locateArgsVariable(ast) && ast.length > 0 && args.length > 0) {
    let command = ast[ast.length - 1];

    while (command.then) command = command.then.line;

    let chain = command.chain;

    while (chain.then) chain = chain.then.chain;

    if (chain.type === `command`) {
      chain.args = chain.args.concat(args.map(arg => {
        return {
          type: `argument`,
          segments: [{
            type: `text`,
            text: arg
          }]
        };
      }));
    }
  }

  return await executeShellLine(ast, {
    args,
    baseFs,
    builtins: normalizedBuiltins,
    initialStdin: stdin,
    initialStdout: stdout,
    initialStderr: stderr,
    glob
  }, {
    cwd,
    environment: normalizedEnv,
    exitCode: null,
    procedures: {},
    stdin,
    stdout,
    stderr,
    variables: Object.assign({}, variables, {
      [`?`]: 0
    })
  });
}

/***/ }),
/* 345 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShellError": () => /* binding */ ShellError
/* harmony export */ });
/**
 * A recoverable shell error.
 */
class ShellError extends Error {
  constructor(message) {
    super(message);
    this.name = `ShellError`;
  }

}

/***/ }),
/* 346 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "micromatchOptions": () => /* binding */ micromatchOptions,
/* harmony export */   "fastGlobOptions": () => /* binding */ fastGlobOptions,
/* harmony export */   "isGlobPattern": () => /* binding */ isGlobPattern,
/* harmony export */   "match": () => /* binding */ match,
/* harmony export */   "isBraceExpansion": () => /* binding */ isBraceExpansion
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(174);
/* harmony import */ var fast_glob__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);
/* harmony import */ var fast_glob__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_glob__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_2__);




const micromatchOptions = {
  // This is required because we don't want ")/*" to be a valid shell glob pattern.
  strictBrackets: true
};
const fastGlobOptions = {
  onlyDirectories: false,
  onlyFiles: false
};
/**
 * Decides whether a string is a glob pattern, using micromatch.
 *
 * Required because `fastGlob.isDynamicPattern` doesn't have the `strictBrackets` option.
 */

function isGlobPattern(pattern) {
  // The scanner extracts globs from a pattern, but doesn't throw errors
  if (!micromatch__WEBPACK_IMPORTED_MODULE_2___default().scan(pattern, micromatchOptions).isGlob) return false; // The parser is the one that throws errors

  try {
    micromatch__WEBPACK_IMPORTED_MODULE_2___default().parse(pattern, micromatchOptions);
  } catch (_a) {
    return false;
  }

  return true;
}
function match(pattern, {
  cwd,
  baseFs
}) {
  return fast_glob__WEBPACK_IMPORTED_MODULE_0___default()(pattern, { ...fastGlobOptions,
    cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(cwd),
    fs: (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.extendFs)((fs__WEBPACK_IMPORTED_MODULE_1___default()), new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.PosixFS(baseFs))
  });
}
function isBraceExpansion(pattern) {
  return micromatch__WEBPACK_IMPORTED_MODULE_2___default().scan(pattern, micromatchOptions).isBrace;
}

/***/ }),
/* 347 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Pipe": () => /* binding */ Pipe,
/* harmony export */   "makeProcess": () => /* binding */ makeProcess,
/* harmony export */   "makeBuiltin": () => /* binding */ makeBuiltin,
/* harmony export */   "ProtectedStream": () => /* binding */ ProtectedStream,
/* harmony export */   "Handle": () => /* binding */ Handle,
/* harmony export */   "start": () => /* binding */ start
/* harmony export */ });
/* harmony import */ var cross_spawn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(348);
/* harmony import */ var cross_spawn__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cross_spawn__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_1__);


var Pipe;

(function (Pipe) {
  Pipe[Pipe["STDIN"] = 0] = "STDIN";
  Pipe[Pipe["STDOUT"] = 1] = "STDOUT";
  Pipe[Pipe["STDERR"] = 2] = "STDERR";
})(Pipe || (Pipe = {}));

function sigintHandler() {} // We don't want SIGINT to kill our process; we want it to kill the
// innermost process, whose end will cause our own to exit.
// Rather than attaching one SIGINT handler for each process, we
// attach a single one and use a refcount to detect once it's no
// longer needed.


let sigintRefCount = 0;
function makeProcess(name, args, opts, spawnOpts) {
  return stdio => {
    const stdin = stdio[0] instanceof stream__WEBPACK_IMPORTED_MODULE_1__.Transform ? `pipe` : stdio[0];
    const stdout = stdio[1] instanceof stream__WEBPACK_IMPORTED_MODULE_1__.Transform ? `pipe` : stdio[1];
    const stderr = stdio[2] instanceof stream__WEBPACK_IMPORTED_MODULE_1__.Transform ? `pipe` : stdio[2];
    const child = cross_spawn__WEBPACK_IMPORTED_MODULE_0___default()(name, args, { ...spawnOpts,
      stdio: [stdin, stdout, stderr]
    });
    if (sigintRefCount++ === 0) process.on(`SIGINT`, sigintHandler);
    if (stdio[0] instanceof stream__WEBPACK_IMPORTED_MODULE_1__.Transform) stdio[0].pipe(child.stdin);
    if (stdio[1] instanceof stream__WEBPACK_IMPORTED_MODULE_1__.Transform) child.stdout.pipe(stdio[1], {
      end: false
    });
    if (stdio[2] instanceof stream__WEBPACK_IMPORTED_MODULE_1__.Transform) child.stderr.pipe(stdio[2], {
      end: false
    });
    return {
      stdin: child.stdin,
      promise: new Promise(resolve => {
        child.on(`error`, error => {
          if (--sigintRefCount === 0) process.off(`SIGINT`, sigintHandler); // @ts-expect-error

          switch (error.code) {
            case `ENOENT`:
              {
                stdio[2].write(`command not found: ${name}\n`);
                resolve(127);
              }
              break;

            case `EACCES`:
              {
                stdio[2].write(`permission denied: ${name}\n`);
                resolve(128);
              }
              break;

            default:
              {
                stdio[2].write(`uncaught error: ${error.message}\n`);
                resolve(1);
              }
              break;
          }
        });
        child.on(`exit`, code => {
          if (--sigintRefCount === 0) process.off(`SIGINT`, sigintHandler);

          if (code !== null) {
            resolve(code);
          } else {
            resolve(129);
          }
        });
      })
    };
  };
}
function makeBuiltin(builtin) {
  return stdio => {
    const stdin = stdio[0] === `pipe` ? new stream__WEBPACK_IMPORTED_MODULE_1__.PassThrough() : stdio[0];
    return {
      stdin,
      promise: Promise.resolve().then(() => builtin({
        stdin,
        stdout: stdio[1],
        stderr: stdio[2]
      }))
    };
  };
}
class ProtectedStream {
  constructor(stream) {
    this.stream = stream;
  }

  close() {// Ignore close request
  }

  get() {
    return this.stream;
  }

}

class PipeStream {
  constructor() {
    this.stream = null;
  }

  close() {
    if (this.stream === null) {
      throw new Error(`Assertion failed: No stream attached`);
    } else {
      this.stream.end();
    }
  }

  attach(stream) {
    this.stream = stream;
  }

  get() {
    if (this.stream === null) {
      throw new Error(`Assertion failed: No stream attached`);
    } else {
      return this.stream;
    }
  }

}

class Handle {
  constructor(ancestor, implementation) {
    this.stdin = null;
    this.stdout = null;
    this.stderr = null;
    this.pipe = null;
    this.ancestor = ancestor;
    this.implementation = implementation;
  }

  static start(implementation, {
    stdin,
    stdout,
    stderr
  }) {
    const chain = new Handle(null, implementation);
    chain.stdin = stdin;
    chain.stdout = stdout;
    chain.stderr = stderr;
    return chain;
  }

  pipeTo(implementation, source = Pipe.STDOUT) {
    const next = new Handle(this, implementation);
    const pipe = new PipeStream();
    next.pipe = pipe;
    next.stdout = this.stdout;
    next.stderr = this.stderr;
    if ((source & Pipe.STDOUT) === Pipe.STDOUT) this.stdout = pipe;else if (this.ancestor !== null) this.stderr = this.ancestor.stdout;
    if ((source & Pipe.STDERR) === Pipe.STDERR) this.stderr = pipe;else if (this.ancestor !== null) this.stderr = this.ancestor.stderr;
    return next;
  }

  async exec() {
    const stdio = [`ignore`, `ignore`, `ignore`];

    if (this.pipe) {
      stdio[0] = `pipe`;
    } else {
      if (this.stdin === null) {
        throw new Error(`Assertion failed: No input stream registered`);
      } else {
        stdio[0] = this.stdin.get();
      }
    }

    let stdoutLock;

    if (this.stdout === null) {
      throw new Error(`Assertion failed: No output stream registered`);
    } else {
      stdoutLock = this.stdout;
      stdio[1] = stdoutLock.get();
    }

    let stderrLock;

    if (this.stderr === null) {
      throw new Error(`Assertion failed: No error stream registered`);
    } else {
      stderrLock = this.stderr;
      stdio[2] = stderrLock.get();
    }

    const child = this.implementation(stdio);
    if (this.pipe) this.pipe.attach(child.stdin);
    return await child.promise.then(code => {
      stdoutLock.close();
      stderrLock.close();
      return code;
    });
  }

  async run() {
    const promises = [];

    for (let handle = this; handle; handle = handle.ancestor) promises.push(handle.exec());

    const exitCodes = await Promise.all(promises);
    return exitCodes[0];
  }

}
function start(p, opts) {
  return Handle.start(p, opts);
}

/***/ }),
/* 348 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const cp = __webpack_require__(4);
const parse = __webpack_require__(349);
const enoent = __webpack_require__(360);

function spawn(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);

    // Spawn the child process
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);

    // Hook into child process "exit" event to emit an error if the command
    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    enoent.hookChildProcess(spawned, parsed);

    return spawned;
}

function spawnSync(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);

    // Spawn the child process
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);

    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);

    return result;
}

module.exports = spawn;
module.exports.spawn = spawn;
module.exports.sync = spawnSync;

module.exports._parse = parse;
module.exports._enoent = enoent;


/***/ }),
/* 349 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(84);
const resolveCommand = __webpack_require__(350);
const escape = __webpack_require__(356);
const readShebang = __webpack_require__(357);

const isWin = process.platform === 'win32';
const isExecutableRegExp = /\.(?:com|exe)$/i;
const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;

function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);

    const shebang = parsed.file && readShebang(parsed.file);

    if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;

        return resolveCommand(parsed);
    }

    return parsed.file;
}

function parseNonShell(parsed) {
    if (!isWin) {
        return parsed;
    }

    // Detect & add support for shebangs
    const commandFile = detectShebang(parsed);

    // We don't need a shell if the command filename is an executable
    const needsShell = !isExecutableRegExp.test(commandFile);

    // If a shell is required, use cmd.exe and take care of escaping everything correctly
    // Note that `forceShell` is an hidden option used only in tests
    if (parsed.options.forceShell || needsShell) {
        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
        // we need to double escape them
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);

        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
        // This is necessary otherwise it will always fail with ENOENT in those cases
        parsed.command = path.normalize(parsed.command);

        // Escape command & arguments
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));

        const shellCommand = [parsed.command].concat(parsed.args).join(' ');

        parsed.args = ['/d', '/s', '/c', `"${shellCommand}"`];
        parsed.command = process.env.comspec || 'cmd.exe';
        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
    }

    return parsed;
}

function parse(command, args, options) {
    // Normalize arguments, similar to nodejs
    if (args && !Array.isArray(args)) {
        options = args;
        args = null;
    }

    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
    options = Object.assign({}, options); // Clone object to avoid changing the original

    // Build our parsed object
    const parsed = {
        command,
        args,
        options,
        file: undefined,
        original: {
            command,
            args,
        },
    };

    // Delegate further parsing to shell or non-shell
    return options.shell ? parsed : parseNonShell(parsed);
}

module.exports = parse;


/***/ }),
/* 350 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(84);
const which = __webpack_require__(351);
const getPathKey = __webpack_require__(355);

function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    // Worker threads do not have process.chdir()
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;

    // If a custom `cwd` was specified, we need to change the process cwd
    // because `which` will do stat calls but does not support a custom cwd
    if (shouldSwitchCwd) {
        try {
            process.chdir(parsed.options.cwd);
        } catch (err) {
            /* Empty */
        }
    }

    let resolved;

    try {
        resolved = which.sync(parsed.command, {
            path: env[getPathKey({ env })],
            pathExt: withoutPathExt ? path.delimiter : undefined,
        });
    } catch (e) {
        /* Empty */
    } finally {
        if (shouldSwitchCwd) {
            process.chdir(cwd);
        }
    }

    // If we successfully resolved, ensure that an absolute path is returned
    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
    if (resolved) {
        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
    }

    return resolved;
}

function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}

module.exports = resolveCommand;


/***/ }),
/* 351 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isWindows = process.platform === 'win32' ||
    process.env.OSTYPE === 'cygwin' ||
    process.env.OSTYPE === 'msys'

const path = __webpack_require__(84)
const COLON = isWindows ? ';' : ':'
const isexe = __webpack_require__(352)

const getNotFoundError = (cmd) =>
  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })

const getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? ['']
    : (
      [
        // windows always checks the cwd first
        ...(isWindows ? [process.cwd()] : []),
        ...(opt.path || process.env.PATH ||
          /* istanbul ignore next: very unusual */ '').split(colon),
      ]
    )
  const pathExtExe = isWindows
    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
    : ''
  const pathExt = isWindows ? pathExtExe.split(colon) : ['']

  if (isWindows) {
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
      pathExt.unshift('')
  }

  return {
    pathEnv,
    pathExt,
    pathExtExe,
  }
}

const which = (cmd, opt, cb) => {
  if (typeof opt === 'function') {
    cb = opt
    opt = {}
  }
  if (!opt)
    opt = {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  const step = i => new Promise((resolve, reject) => {
    if (i === pathEnv.length)
      return opt.all && found.length ? resolve(found)
        : reject(getNotFoundError(cmd))

    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    resolve(subStep(p, i, 0))
  })

  const subStep = (p, i, ii) => new Promise((resolve, reject) => {
    if (ii === pathExt.length)
      return resolve(step(i + 1))
    const ext = pathExt[ii]
    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is) {
        if (opt.all)
          found.push(p + ext)
        else
          return resolve(p + ext)
      }
      return resolve(subStep(p, i, ii + 1))
    })
  })

  return cb ? step(0).then(res => cb(null, res), cb) : step(0)
}

const whichSync = (cmd, opt) => {
  opt = opt || {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  for (let i = 0; i < pathEnv.length; i ++) {
    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    for (let j = 0; j < pathExt.length; j ++) {
      const cur = p + pathExt[j]
      try {
        const is = isexe.sync(cur, { pathExt: pathExtExe })
        if (is) {
          if (opt.all)
            found.push(cur)
          else
            return cur
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length)
    return found

  if (opt.nothrow)
    return null

  throw getNotFoundError(cmd)
}

module.exports = which
which.sync = whichSync


/***/ }),
/* 352 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(8)
var core
if (process.platform === 'win32' || global.TESTING_WINDOWS) {
  core = __webpack_require__(353)
} else {
  core = __webpack_require__(354)
}

module.exports = isexe
isexe.sync = sync

function isexe (path, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  if (!cb) {
    if (typeof Promise !== 'function') {
      throw new TypeError('callback not provided')
    }

    return new Promise(function (resolve, reject) {
      isexe(path, options || {}, function (er, is) {
        if (er) {
          reject(er)
        } else {
          resolve(is)
        }
      })
    })
  }

  core(path, options || {}, function (er, is) {
    // ignore EACCES because that just means we aren't allowed to run it
    if (er) {
      if (er.code === 'EACCES' || options && options.ignoreErrors) {
        er = null
        is = false
      }
    }
    cb(er, is)
  })
}

function sync (path, options) {
  // my kingdom for a filtered catch
  try {
    return core.sync(path, options || {})
  } catch (er) {
    if (options && options.ignoreErrors || er.code === 'EACCES') {
      return false
    } else {
      throw er
    }
  }
}


/***/ }),
/* 353 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(8)

function checkPathExt (path, options) {
  var pathext = options.pathExt !== undefined ?
    options.pathExt : process.env.PATHEXT

  if (!pathext) {
    return true
  }

  pathext = pathext.split(';')
  if (pathext.indexOf('') !== -1) {
    return true
  }
  for (var i = 0; i < pathext.length; i++) {
    var p = pathext[i].toLowerCase()
    if (p && path.substr(-p.length).toLowerCase() === p) {
      return true
    }
  }
  return false
}

function checkStat (stat, path, options) {
  if (!stat.isSymbolicLink() && !stat.isFile()) {
    return false
  }
  return checkPathExt(path, options)
}

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, path, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), path, options)
}


/***/ }),
/* 354 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(8)

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), options)
}

function checkStat (stat, options) {
  return stat.isFile() && checkMode(stat, options)
}

function checkMode (stat, options) {
  var mod = stat.mode
  var uid = stat.uid
  var gid = stat.gid

  var myUid = options.uid !== undefined ?
    options.uid : process.getuid && process.getuid()
  var myGid = options.gid !== undefined ?
    options.gid : process.getgid && process.getgid()

  var u = parseInt('100', 8)
  var g = parseInt('010', 8)
  var o = parseInt('001', 8)
  var ug = u | g

  var ret = (mod & o) ||
    (mod & g) && gid === myGid ||
    (mod & u) && uid === myUid ||
    (mod & ug) && myUid === 0

  return ret
}


/***/ }),
/* 355 */
/***/ ((module) => {

"use strict";


const pathKey = (options = {}) => {
	const environment = options.env || process.env;
	const platform = options.platform || process.platform;

	if (platform !== 'win32') {
		return 'PATH';
	}

	return Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';
};

module.exports = pathKey;
// TODO: Remove this for the next major release
module.exports.default = pathKey;


/***/ }),
/* 356 */
/***/ ((module) => {

"use strict";


// See http://www.robvanderwoude.com/escapechars.php
const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;

function escapeCommand(arg) {
    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');

    return arg;
}

function escapeArgument(arg, doubleEscapeMetaChars) {
    // Convert to string
    arg = `${arg}`;

    // Algorithm below is based on https://qntm.org/cmd

    // Sequence of backslashes followed by a double quote:
    // double up all the backslashes and escape the double quote
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');

    // Sequence of backslashes followed by the end of the string
    // (which will become a double quote later):
    // double up all the backslashes
    arg = arg.replace(/(\\*)$/, '$1$1');

    // All other backslashes occur literally

    // Quote the whole thing:
    arg = `"${arg}"`;

    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');

    // Double escape meta chars if necessary
    if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, '^$1');
    }

    return arg;
}

module.exports.command = escapeCommand;
module.exports.argument = escapeArgument;


/***/ }),
/* 357 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(8);
const shebangCommand = __webpack_require__(358);

function readShebang(command) {
    // Read the first 150 bytes from the file
    const size = 150;
    const buffer = Buffer.alloc(size);

    let fd;

    try {
        fd = fs.openSync(command, 'r');
        fs.readSync(fd, buffer, 0, size, 0);
        fs.closeSync(fd);
    } catch (e) { /* Empty */ }

    // Attempt to extract shebang (null is returned if not a shebang)
    return shebangCommand(buffer.toString());
}

module.exports = readShebang;


/***/ }),
/* 358 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const shebangRegex = __webpack_require__(359);

module.exports = (string = '') => {
	const match = string.match(shebangRegex);

	if (!match) {
		return null;
	}

	const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
	const binary = path.split('/').pop();

	if (binary === 'env') {
		return argument;
	}

	return argument ? `${binary} ${argument}` : binary;
};


/***/ }),
/* 359 */
/***/ ((module) => {

"use strict";

module.exports = /^#!(.*)/;


/***/ }),
/* 360 */
/***/ ((module) => {

"use strict";


const isWin = process.platform === 'win32';

function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: 'ENOENT',
        errno: 'ENOENT',
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args,
    });
}

function hookChildProcess(cp, parsed) {
    if (!isWin) {
        return;
    }

    const originalEmit = cp.emit;

    cp.emit = function (name, arg1) {
        // If emitting "exit" event and exit code is 1, we need to check if
        // the command exists and emit an "error" instead
        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
        if (name === 'exit') {
            const err = verifyENOENT(arg1, parsed, 'spawn');

            if (err) {
                return originalEmit.call(cp, 'error', err);
            }
        }

        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
    };
}

function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawn');
    }

    return null;
}

function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawnSync');
    }

    return null;
}

module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError,
};


/***/ }),
/* 361 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeBinjumperSync = exports.makeBinjumper = exports.getBinjumper = void 0;
const path_1 = __webpack_require__(84);
const fs_1 = __webpack_require__(8);
const util_1 = __webpack_require__(90);
const binjumper_1 = __webpack_require__(362);
Object.defineProperty(exports, "getBinjumper", ({ enumerable: true, get: function () { return binjumper_1.getBinjumper; } }));
async function makeBinjumper(opts) {
    const writeFilePromise = util_1.promisify(fs_1.writeFile);
    const mkdirPromise = util_1.promisify(fs_1.mkdir);
    await mkdirPromise(opts.dir, { recursive: true });
    if (process.platform === 'win32') {
        await Promise.all([
            writeFilePromise(path_1.join(opts.dir, `${opts.name}.exe`), binjumper_1.getBinjumper()),
            writeFilePromise(path_1.join(opts.dir, `${opts.name}.exe.info`), [opts.target, ...(opts.args || [])].join('\n')),
        ]);
    }
    await writeFilePromise(path_1.join(opts.dir, opts.name), `#!/bin/sh\nexec "${opts.target}" ${(opts.args || [])
        .map((arg) => `'${arg.replace(/'/g, `'"'"'`)}'`)
        .join(' ')} "$@"\n`, { mode: 0o755 });
}
exports.makeBinjumper = makeBinjumper;
function makeBinjumperSync(opts) {
    fs_1.mkdirSync(opts.dir, { recursive: true });
    if (process.platform === 'win32') {
        fs_1.writeFileSync(path_1.join(opts.dir, `${opts.name}.exe`), binjumper_1.getBinjumper());
        fs_1.writeFileSync(path_1.join(opts.dir, `${opts.name}.exe.info`), [opts.target, ...(opts.args || [])].join('\n'));
    }
    fs_1.writeFileSync(path_1.join(opts.dir, opts.name), `#!/bin/sh\nexec "${opts.target}" ${(opts.args || [])
        .map((arg) => `'${arg.replace(/'/g, `'"'"'`)}'`)
        .join(' ')} "$@"\n`, { mode: 0o755 });
}
exports.makeBinjumperSync = makeBinjumperSync;


/***/ }),
/* 362 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBinjumper = void 0;
const zlib_1 = __webpack_require__(164);
let decompressedJumper = null;
function getBinjumper() {
    if (!decompressedJumper) {
        decompressedJumper = zlib_1.gunzipSync(Buffer.from('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', 'base64'));
    }
    return decompressedJumper;
}
exports.getBinjumper = getBinjumper;


/***/ }),
/* 363 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toString = __webpack_require__(306),
    upperFirst = __webpack_require__(364);

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

module.exports = capitalize;


/***/ }),
/* 364 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createCaseFirst = __webpack_require__(365);

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

module.exports = upperFirst;


/***/ }),
/* 365 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castSlice = __webpack_require__(366),
    hasUnicode = __webpack_require__(368),
    stringToArray = __webpack_require__(369),
    toString = __webpack_require__(306);

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

module.exports = createCaseFirst;


/***/ }),
/* 366 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSlice = __webpack_require__(367);

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;


/***/ }),
/* 367 */
/***/ ((module) => {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),
/* 368 */
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


/***/ }),
/* 369 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var asciiToArray = __webpack_require__(370),
    hasUnicode = __webpack_require__(368),
    unicodeToArray = __webpack_require__(371);

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;


/***/ }),
/* 370 */
/***/ ((module) => {

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;


/***/ }),
/* 371 */
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;


/***/ }),
/* 372 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YarnVersion": () => /* binding */ YarnVersion
/* harmony export */ });
const YarnVersion =  true ? "2.3.3-git.20201126.af64950d" : 0;

/***/ }),
/* 373 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EndStrategy": () => /* binding */ EndStrategy,
/* harmony export */   "pipevp": () => /* binding */ pipevp,
/* harmony export */   "execvp": () => /* binding */ execvp
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(162);
/* harmony import */ var cross_spawn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(348);
/* harmony import */ var cross_spawn__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cross_spawn__WEBPACK_IMPORTED_MODULE_0__);


var EndStrategy;

(function (EndStrategy) {
  EndStrategy[EndStrategy["Never"] = 0] = "Never";
  EndStrategy[EndStrategy["ErrorCode"] = 1] = "ErrorCode";
  EndStrategy[EndStrategy["Always"] = 2] = "Always";
})(EndStrategy || (EndStrategy = {}));

function hasFd(stream) {
  // @ts-expect-error: Not sure how to typecheck this field
  return stream !== null && typeof stream.fd === `number`;
}

function sigintHandler() {} // We don't want SIGINT to kill our process; we want it to kill the
// innermost process, whose end will cause our own to exit.
// Rather than attaching one SIGINT handler for each process, we
// attach a single one and use a refcount to detect once it's no
// longer needed.


let sigintRefCount = 0;
async function pipevp(fileName, args, {
  cwd,
  env = process.env,
  strict = false,
  stdin = null,
  stdout,
  stderr,
  end = EndStrategy.Always
}) {
  const stdio = [`pipe`, `pipe`, `pipe`];
  if (stdin === null) stdio[0] = `ignore`;else if (hasFd(stdin)) stdio[0] = stdin;
  if (hasFd(stdout)) stdio[1] = stdout;
  if (hasFd(stderr)) stdio[2] = stderr;
  if (sigintRefCount++ === 0) process.on(`SIGINT`, sigintHandler);
  const child = cross_spawn__WEBPACK_IMPORTED_MODULE_0___default()(fileName, args, {
    cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.fromPortablePath(cwd),
    env: { ...env,
      PWD: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.fromPortablePath(cwd)
    },
    stdio
  });
  if (!hasFd(stdin) && stdin !== null) stdin.pipe(child.stdin);
  if (!hasFd(stdout)) child.stdout.pipe(stdout, {
    end: false
  });
  if (!hasFd(stderr)) child.stderr.pipe(stderr, {
    end: false
  });

  const closeStreams = () => {
    for (const stream of new Set([stdout, stderr])) {
      if (!hasFd(stream)) {
        stream.end();
      }
    }
  };

  return new Promise((resolve, reject) => {
    child.on(`error`, error => {
      if (--sigintRefCount === 0) process.off(`SIGINT`, sigintHandler);
      if (end === EndStrategy.Always || end === EndStrategy.ErrorCode) closeStreams();
      reject(error);
    });
    child.on(`close`, (code, sig) => {
      if (--sigintRefCount === 0) process.off(`SIGINT`, sigintHandler);
      if (end === EndStrategy.Always || end === EndStrategy.ErrorCode && code > 0) closeStreams();

      if (code === 0 || !strict) {
        resolve({
          code: getExitCode(code, sig)
        });
      } else if (code !== null) {
        reject(new Error(`Child "${fileName}" exited with exit code ${code}`));
      } else {
        reject(new Error(`Child "${fileName}" exited with signal ${sig}`));
      }
    });
  });
}
async function execvp(fileName, args, {
  cwd,
  env = process.env,
  encoding = `utf8`,
  strict = false
}) {
  const stdio = [`ignore`, `pipe`, `pipe`];
  const stdoutChunks = [];
  const stderrChunks = [];
  const nativeCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.fromPortablePath(cwd);
  if (typeof env.PWD !== `undefined`) env = { ...env,
    PWD: nativeCwd
  };
  const subprocess = cross_spawn__WEBPACK_IMPORTED_MODULE_0___default()(fileName, args, {
    cwd: nativeCwd,
    env,
    stdio
  });
  subprocess.stdout.on(`data`, chunk => {
    stdoutChunks.push(chunk);
  });
  subprocess.stderr.on(`data`, chunk => {
    stderrChunks.push(chunk);
  });
  return await new Promise((resolve, reject) => {
    subprocess.on(`error`, reject);
    subprocess.on(`close`, (code, signal) => {
      const stdout = encoding === `buffer` ? Buffer.concat(stdoutChunks) : Buffer.concat(stdoutChunks).toString(encoding);
      const stderr = encoding === `buffer` ? Buffer.concat(stderrChunks) : Buffer.concat(stderrChunks).toString(encoding);

      if (code === 0 || !strict) {
        resolve({
          code: getExitCode(code, signal),
          stdout,
          stderr
        });
      } else {
        reject(Object.assign(new Error(`Child "${fileName}" exited with exit code ${code}\n\n${stderr}`), {
          code: getExitCode(code, signal),
          stdout,
          stderr
        }));
      }
    });
  });
}
const signalToCodeMap = new Map([[`SIGINT`, 2], [`SIGQUIT`, 3], [`SIGKILL`, 9], [`SIGTERM`, 15]]);

function getExitCode(code, signal) {
  const signalCode = signalToCodeMap.get(signal);

  if (typeof signalCode !== `undefined`) {
    return 128 + signalCode;
  } else {
    return code !== null && code !== void 0 ? code : 1;
  }
}

/***/ }),
/* 374 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "formatName": () => /* binding */ formatName,
/* harmony export */   "formatNameWithHyperlink": () => /* binding */ formatNameWithHyperlink,
/* harmony export */   "StreamReport": () => /* binding */ StreamReport
/* harmony export */ });
/* harmony import */ var _arcanis_slice_ansi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(375);
/* harmony import */ var _arcanis_slice_ansi__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_arcanis_slice_ansi__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(180);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(233);
/* harmony import */ var _formatUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);




const PROGRESS_FRAMES = [``, ``, ``, ``, ``, ``, ``, ``, ``, ``];
const PROGRESS_INTERVAL = 80;
const BASE_FORGETTABLE_NAMES = new Set([_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.FETCH_NOT_CACHED, _MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.UNUSED_CACHE_ENTRY]);
const BASE_FORGETTABLE_BUFFER_SIZE = 5;
const GROUP = process.env.GITHUB_ACTIONS ? {
  start: what => `::group::${what}\n`,
  end: what => `::endgroup::\n`
} : process.env.TRAVIS ? {
  start: what => `travis_fold:start:${what}\n`,
  end: what => `travis_fold:end:${what}\n`
} : process.env.GITLAB_CI ? {
  start: what => `section_start:${Math.floor(Date.now() / 1000)}:${what.toLowerCase().replace(/\W+/g, `_`)}\r\x1b[0K${what}\n`,
  end: what => `section_end:${Math.floor(Date.now() / 1000)}:${what.toLowerCase().replace(/\W+/g, `_`)}\r\x1b[0K`
} : null;
const now = new Date(); // We only want to support environments that will out-of-the-box accept the
// characters we want to use. Others can enforce the style from the project
// configuration.

const supportsEmojis = [`iTerm.app`, `Apple_Terminal`].includes(process.env.TERM_PROGRAM) || !!process.env.WT_SESSION;

const makeRecord = obj => obj;

const PROGRESS_STYLES = makeRecord({
  patrick: {
    date: [17, 3],
    chars: [``, ``],
    size: 40
  },
  simba: {
    date: [19, 7],
    chars: [``, ``],
    size: 40
  },
  jack: {
    date: [31, 10],
    chars: [``, ``],
    size: 40
  },
  hogsfather: {
    date: [31, 12],
    chars: [``, ``],
    size: 40
  },
  default: {
    chars: [`=`, `-`],
    size: 80
  }
});
const defaultStyle = supportsEmojis && Object.keys(PROGRESS_STYLES).find(name => {
  const style = PROGRESS_STYLES[name];
  if (style.date && (style.date[0] !== now.getDate() || style.date[1] !== now.getMonth() + 1)) return false;
  return true;
}) || `default`;
function formatName(name, {
  configuration,
  json
}) {
  const num = name === null ? 0 : name;
  const label = (0,_MessageName__WEBPACK_IMPORTED_MODULE_1__.stringifyMessageName)(num);

  if (!json && name === null) {
    return _formatUtils__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, label, `grey`);
  } else {
    return label;
  }
}
function formatNameWithHyperlink(name, {
  configuration,
  json
}) {
  const code = formatName(name, {
    configuration,
    json
  }); // Only print hyperlinks if allowed per configuration

  if (!configuration.get(`enableHyperlinks`)) return code; // Don't print hyperlinks for the generic messages

  if (name === null || name === _MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.UNNAMED) return code;
  const desc = _MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName[name];
  const href = `https://yarnpkg.com/advanced/error-codes#${code}---${desc}`.toLowerCase(); // We use BELL as ST because it seems that iTerm doesn't properly support
  // the \x1b\\ sequence described in the reference document
  // https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda#the-escape-sequence

  return `\u001b]8;;${href}\u0007${code}\u001b]8;;\u0007`;
}
class StreamReport extends _Report__WEBPACK_IMPORTED_MODULE_3__.Report {
  constructor({
    configuration,
    stdout,
    json = false,
    includeFooter = true,
    includeLogs = !json,
    includeInfos = includeLogs,
    includeWarnings = includeLogs,
    forgettableBufferSize = BASE_FORGETTABLE_BUFFER_SIZE,
    forgettableNames = new Set()
  }) {
    super();
    this.uncommitted = new Set();
    this.cacheHitCount = 0;
    this.cacheMissCount = 0;
    this.warningCount = 0;
    this.errorCount = 0;
    this.startTime = Date.now();
    this.indent = 0;
    this.progress = new Map();
    this.progressTime = 0;
    this.progressFrame = 0;
    this.progressTimeout = null;
    this.forgettableLines = [];
    _formatUtils__WEBPACK_IMPORTED_MODULE_2__.addLogFilterSupport(this, {
      configuration
    });
    this.configuration = configuration;
    this.forgettableBufferSize = forgettableBufferSize;
    this.forgettableNames = new Set([...forgettableNames, ...BASE_FORGETTABLE_NAMES]);
    this.includeFooter = includeFooter;
    this.includeInfos = includeInfos;
    this.includeWarnings = includeWarnings;
    this.json = json;
    this.stdout = stdout;
    const styleName = this.configuration.get(`progressBarStyle`) || defaultStyle;
    if (!Object.prototype.hasOwnProperty.call(PROGRESS_STYLES, styleName)) throw new Error(`Assertion failed: Invalid progress bar style`);
    this.progressStyle = PROGRESS_STYLES[styleName];
    const PAD_LEFT = ` YN0000:  `.length;
    const maxWidth = Math.max(0, Math.min(process.stdout.columns - PAD_LEFT, 80));
    this.progressMaxScaledSize = Math.floor(this.progressStyle.size * maxWidth / 80);
  }

  static async start(opts, cb) {
    const report = new this(opts);
    const emitWarning = process.emitWarning;

    process.emitWarning = (message, name) => {
      if (typeof message !== `string`) {
        const error = message;
        message = error.message;
        name = name !== null && name !== void 0 ? name : error.name;
      }

      const fullMessage = typeof name !== `undefined` ? `${name}: ${message}` : message;
      report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.UNNAMED, fullMessage);
    };

    try {
      await cb(report);
    } catch (error) {
      report.reportExceptionOnce(error);
    } finally {
      await report.finalize();
      process.emitWarning = emitWarning;
    }

    return report;
  }

  hasErrors() {
    return this.errorCount > 0;
  }

  exitCode() {
    return this.hasErrors() ? 1 : 0;
  }

  reportCacheHit(locator) {
    this.cacheHitCount += 1;
  }

  reportCacheMiss(locator, message) {
    this.cacheMissCount += 1;

    if (typeof message !== `undefined` && !this.configuration.get(`preferAggregateCacheInfo`)) {
      this.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.FETCH_NOT_CACHED, message);
    }
  }

  startTimerSync(what, opts, cb) {
    const realOpts = typeof opts === `function` ? {} : opts;
    const realCb = typeof opts === `function` ? opts : cb;
    const mark = {
      committed: false,
      action: () => {
        this.reportInfo(null, ` ${what}`);
        this.indent += 1;

        if (GROUP !== null) {
          this.stdout.write(GROUP.start(what));
        }
      }
    };

    if (realOpts.skipIfEmpty) {
      this.uncommitted.add(mark);
    } else {
      mark.action();
      mark.committed = true;
    }

    const before = Date.now();

    try {
      return realCb();
    } catch (error) {
      this.reportExceptionOnce(error);
      throw error;
    } finally {
      const after = Date.now();
      this.uncommitted.delete(mark);

      if (mark.committed) {
        this.indent -= 1;
        if (GROUP !== null) this.stdout.write(GROUP.end(what));

        if (this.configuration.get(`enableTimers`) && after - before > 200) {
          this.reportInfo(null, ` Completed in ${_formatUtils__WEBPACK_IMPORTED_MODULE_2__.pretty(this.configuration, after - before, _formatUtils__WEBPACK_IMPORTED_MODULE_2__.Type.DURATION)}`);
        } else {
          this.reportInfo(null, ` Completed`);
        }
      }
    }
  }

  async startTimerPromise(what, opts, cb) {
    const realOpts = typeof opts === `function` ? {} : opts;
    const realCb = typeof opts === `function` ? opts : cb;
    const mark = {
      committed: false,
      action: () => {
        this.reportInfo(null, ` ${what}`);
        this.indent += 1;

        if (GROUP !== null) {
          this.stdout.write(GROUP.start(what));
        }
      }
    };

    if (realOpts.skipIfEmpty) {
      this.uncommitted.add(mark);
    } else {
      mark.action();
      mark.committed = true;
    }

    const before = Date.now();

    try {
      return await realCb();
    } catch (error) {
      this.reportExceptionOnce(error);
      throw error;
    } finally {
      const after = Date.now();
      this.uncommitted.delete(mark);

      if (mark.committed) {
        this.indent -= 1;
        if (GROUP !== null) this.stdout.write(GROUP.end(what));

        if (this.configuration.get(`enableTimers`) && after - before > 200) {
          this.reportInfo(null, ` Completed in ${_formatUtils__WEBPACK_IMPORTED_MODULE_2__.pretty(this.configuration, after - before, _formatUtils__WEBPACK_IMPORTED_MODULE_2__.Type.DURATION)}`);
        } else {
          this.reportInfo(null, ` Completed`);
        }
      }
    }
  }

  async startCacheReport(cb) {
    const cacheInfo = this.configuration.get(`preferAggregateCacheInfo`) ? {
      cacheHitCount: this.cacheHitCount,
      cacheMissCount: this.cacheMissCount
    } : null;

    try {
      return await cb();
    } catch (error) {
      this.reportExceptionOnce(error);
      throw error;
    } finally {
      if (cacheInfo !== null) {
        this.reportCacheChanges(cacheInfo);
      }
    }
  }

  reportSeparator() {
    if (this.indent === 0) {
      this.writeLineWithForgettableReset(``);
    } else {
      this.reportInfo(null, ``);
    }
  }

  reportInfo(name, text) {
    if (!this.includeInfos) return;
    this.commit();
    const message = `${_formatUtils__WEBPACK_IMPORTED_MODULE_2__.pretty(this.configuration, ``, `blueBright`)} ${this.formatNameWithHyperlink(name)}: ${this.formatIndent()}${text}`;

    if (!this.json) {
      if (this.forgettableNames.has(name)) {
        this.forgettableLines.push(message);

        if (this.forgettableLines.length > this.forgettableBufferSize) {
          while (this.forgettableLines.length > this.forgettableBufferSize) this.forgettableLines.shift();

          this.writeLines(this.forgettableLines, {
            truncate: true
          });
        } else {
          this.writeLine(message, {
            truncate: true
          });
        }
      } else {
        this.writeLineWithForgettableReset(message);
      }
    } else {
      this.reportJson({
        type: `info`,
        name,
        displayName: this.formatName(name),
        indent: this.formatIndent(),
        data: text
      });
    }
  }

  reportWarning(name, text) {
    this.warningCount += 1;
    if (!this.includeWarnings) return;
    this.commit();

    if (!this.json) {
      this.writeLineWithForgettableReset(`${_formatUtils__WEBPACK_IMPORTED_MODULE_2__.pretty(this.configuration, ``, `yellowBright`)} ${this.formatNameWithHyperlink(name)}: ${this.formatIndent()}${text}`);
    } else {
      this.reportJson({
        type: `warning`,
        name,
        displayName: this.formatName(name),
        indent: this.formatIndent(),
        data: text
      });
    }
  }

  reportError(name, text) {
    this.errorCount += 1;
    this.commit();

    if (!this.json) {
      this.writeLineWithForgettableReset(`${_formatUtils__WEBPACK_IMPORTED_MODULE_2__.pretty(this.configuration, ``, `redBright`)} ${this.formatNameWithHyperlink(name)}: ${this.formatIndent()}${text}`, {
        truncate: false
      });
    } else {
      this.reportJson({
        type: `error`,
        name,
        displayName: this.formatName(name),
        indent: this.formatIndent(),
        data: text
      });
    }
  }

  reportProgress(progressIt) {
    let stopped = false;
    const promise = Promise.resolve().then(async () => {
      const progressDefinition = {
        progress: 0,
        title: undefined
      };
      this.progress.set(progressIt, {
        definition: progressDefinition,
        lastScaledSize: -1
      });
      this.refreshProgress(-1);

      for await (const {
        progress,
        title
      } of progressIt) {
        if (stopped) continue;
        if (progressDefinition.progress === progress && progressDefinition.title === title) continue;
        progressDefinition.progress = progress;
        progressDefinition.title = title;
        this.refreshProgress();
      }

      stop();
    });

    const stop = () => {
      if (stopped) return;
      stopped = true;
      this.progress.delete(progressIt);
      this.refreshProgress(+1);
    };

    return { ...promise,
      stop
    };
  }

  reportJson(data) {
    if (this.json) {
      this.writeLineWithForgettableReset(`${JSON.stringify(data)}`);
    }
  }

  async finalize() {
    if (!this.includeFooter) return;
    let installStatus = ``;
    if (this.errorCount > 0) installStatus = `Failed with errors`;else if (this.warningCount > 0) installStatus = `Done with warnings`;else installStatus = `Done`;
    const timing = _formatUtils__WEBPACK_IMPORTED_MODULE_2__.pretty(this.configuration, Date.now() - this.startTime, _formatUtils__WEBPACK_IMPORTED_MODULE_2__.Type.DURATION);
    const message = this.configuration.get(`enableTimers`) ? `${installStatus} in ${timing}` : installStatus;

    if (this.errorCount > 0) {
      this.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.UNNAMED, message);
    } else if (this.warningCount > 0) {
      this.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.UNNAMED, message);
    } else {
      this.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.UNNAMED, message);
    }
  }

  writeLine(str, {
    truncate
  } = {}) {
    this.clearProgress({
      clear: true
    });
    this.stdout.write(`${this.truncate(str, {
      truncate
    })}\n`);
    this.writeProgress();
  }

  writeLineWithForgettableReset(str, {
    truncate
  } = {}) {
    this.forgettableLines = [];
    this.writeLine(str, {
      truncate
    });
  }

  writeLines(lines, {
    truncate
  } = {}) {
    this.clearProgress({
      delta: lines.length
    });

    for (const line of lines) this.stdout.write(`${this.truncate(line, {
      truncate
    })}\n`);

    this.writeProgress();
  }

  reportCacheChanges({
    cacheHitCount,
    cacheMissCount
  }) {
    const cacheHitDelta = this.cacheHitCount - cacheHitCount;
    const cacheMissDelta = this.cacheMissCount - cacheMissCount;
    if (cacheHitDelta === 0 && cacheMissDelta === 0) return;
    let fetchStatus = ``;
    if (this.cacheHitCount > 1) fetchStatus += `${this.cacheHitCount} packages were already cached`;else if (this.cacheHitCount === 1) fetchStatus += ` - one package was already cached`;else fetchStatus += `No packages were cached`;

    if (this.cacheHitCount > 0) {
      if (this.cacheMissCount > 1) {
        fetchStatus += `, ${this.cacheMissCount} had to be fetched`;
      } else if (this.cacheMissCount === 1) {
        fetchStatus += `, one had to be fetched`;
      }
    } else {
      if (this.cacheMissCount > 1) {
        fetchStatus += ` - ${this.cacheMissCount} packages had to be fetched`;
      } else if (this.cacheMissCount === 1) {
        fetchStatus += ` - one package had to be fetched`;
      }
    }

    this.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.FETCH_NOT_CACHED, fetchStatus);
  }

  commit() {
    const marks = this.uncommitted;
    this.uncommitted = new Set();

    for (const mark of marks) {
      mark.committed = true;
      mark.action();
    }
  }

  clearProgress({
    delta = 0,
    clear = false
  }) {
    if (!this.configuration.get(`enableProgressBars`) || this.json) return;

    if (this.progress.size + delta > 0) {
      this.stdout.write(`\x1b[${this.progress.size + delta}A`);

      if (delta > 0 || clear) {
        this.stdout.write(`\x1b[0J`);
      }
    }
  }

  writeProgress() {
    if (!this.configuration.get(`enableProgressBars`) || this.json) return;
    if (this.progressTimeout !== null) clearTimeout(this.progressTimeout);
    this.progressTimeout = null;
    if (this.progress.size === 0) return;
    const now = Date.now();

    if (now - this.progressTime > PROGRESS_INTERVAL) {
      this.progressFrame = (this.progressFrame + 1) % PROGRESS_FRAMES.length;
      this.progressTime = now;
    }

    const spinner = PROGRESS_FRAMES[this.progressFrame];

    for (const progress of this.progress.values()) {
      const ok = this.progressStyle.chars[0].repeat(progress.lastScaledSize);
      const ko = this.progressStyle.chars[1].repeat(this.progressMaxScaledSize - progress.lastScaledSize);
      this.stdout.write(`${_formatUtils__WEBPACK_IMPORTED_MODULE_2__.pretty(this.configuration, ``, `blueBright`)} ${this.formatName(null)}: ${spinner} ${ok}${ko}\n`);
    }

    this.progressTimeout = setTimeout(() => {
      this.refreshProgress();
    }, PROGRESS_INTERVAL);
  }

  refreshProgress(delta = 0) {
    let needsUpdate = false;

    if (this.progress.size === 0) {
      needsUpdate = true;
    } else {
      for (const progress of this.progress.values()) {
        const refreshedScaledSize = Math.trunc(this.progressMaxScaledSize * progress.definition.progress);
        const previousScaledSize = progress.lastScaledSize;
        progress.lastScaledSize = refreshedScaledSize;

        if (refreshedScaledSize !== previousScaledSize) {
          needsUpdate = true;
          break;
        }
      }
    }

    if (needsUpdate) {
      this.clearProgress({
        delta
      });
      this.writeProgress();
    }
  }

  truncate(str, {
    truncate
  } = {}) {
    if (!this.configuration.get(`enableProgressBars`)) truncate = false;
    if (typeof truncate === `undefined`) truncate = this.configuration.get(`preferTruncatedLines`); // The -1 is to account for terminals that would wrap after
    // the last column rather before the first overwrite

    if (truncate) str = _arcanis_slice_ansi__WEBPACK_IMPORTED_MODULE_0___default()(str, 0, process.stdout.columns - 1);
    return str;
  }

  formatName(name) {
    return formatName(name, {
      configuration: this.configuration,
      json: this.json
    });
  }

  formatNameWithHyperlink(name) {
    return formatNameWithHyperlink(name, {
      configuration: this.configuration,
      json: this.json
    });
  }

  formatIndent() {
    return ` `.repeat(this.indent);
  }

}

/***/ }),
/* 375 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const GraphemeSplitter = __webpack_require__(376);

const ANSI_SEQUENCE = /^(.*?)(\x1b\[[^m]+m|\x1b\]8;;.*?(\x1b\\|\u0007))/;
const splitter = new GraphemeSplitter();

module.exports = (orig, at = 0, until = orig.length) => {
  // Because to do this we'd need to know the printable length of the string,
  // which would require to do two passes (or would complexify the main one)
  if (at < 0 || until < 0)
    throw new RangeError(`Negative indices aren't supported by this implementation`);

  const length = until - at;

  let output = ``;

  let skipped = 0;
  let visible = 0;

  while (orig.length > 0) {
    const lookup = orig.match(ANSI_SEQUENCE) || [orig, orig, undefined];
    let graphemes = splitter.splitGraphemes(lookup[1]);

    const skipping = Math.min(at - skipped, graphemes.length);
    graphemes = graphemes.slice(skipping);

    const displaying = Math.min(length - visible, graphemes.length);
    output += graphemes.slice(0, displaying).join(``);

    skipped += skipping;
    visible += displaying;

    if (typeof lookup[2] !== `undefined`)
      output += lookup[2];

    orig = orig.slice(lookup[0].length);
  }

  return output;
};


/***/ }),
/* 376 */
/***/ ((module) => {

/*
Breaks a Javascript string into individual user-perceived "characters" 
called extended grapheme clusters by implementing the Unicode UAX-29 standard, version 10.0.0

Usage:
var splitter = new GraphemeSplitter();
//returns an array of strings, one string for each grapheme cluster
var graphemes = splitter.splitGraphemes(string); 

*/
function GraphemeSplitter(){
	var CR = 0,
		LF = 1,
		Control = 2,
		Extend = 3,
		Regional_Indicator = 4,
		SpacingMark = 5,
		L = 6,
		V = 7,
		T = 8,
		LV = 9,
		LVT = 10,
		Other = 11,
		Prepend = 12,
		E_Base = 13,
		E_Modifier = 14,
		ZWJ = 15,
		Glue_After_Zwj = 16,
		E_Base_GAZ = 17;
		
	// BreakTypes
	var NotBreak = 0,
		BreakStart = 1,
		Break = 2,
		BreakLastRegional = 3,
		BreakPenultimateRegional = 4;
		
	function isSurrogate(str, pos) {
		return  0xd800 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 0xdbff && 
				0xdc00 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 0xdfff;
	}
		
	// Private function, gets a Unicode code point from a JavaScript UTF-16 string
	// handling surrogate pairs appropriately
	function codePointAt(str, idx){
		if(idx === undefined){
			idx = 0;
		}
		var code = str.charCodeAt(idx);

		// if a high surrogate
		if (0xD800 <= code && code <= 0xDBFF && 
			idx < str.length - 1){
			var hi = code;
			var low = str.charCodeAt(idx + 1);
			if (0xDC00 <= low && low <= 0xDFFF){
				return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
			}
			return hi;
		}
		
		// if a low surrogate
		if (0xDC00 <= code && code <= 0xDFFF &&
			idx >= 1){
			var hi = str.charCodeAt(idx - 1);
			var low = code;
			if (0xD800 <= hi && hi <= 0xDBFF){
				return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
			}
			return low;
		}
		
		//just return the char if an unmatched surrogate half or a 
		//single-char codepoint
		return code;
	}
	
	// Private function, returns whether a break is allowed between the 
	// two given grapheme breaking classes
	function shouldBreak(start, mid, end){
		var all = [start].concat(mid).concat([end]);
		var previous = all[all.length - 2]
		var next = end
		
		// Lookahead termintor for:
		// GB10. (E_Base | EBG) Extend* ?	E_Modifier
		var eModifierIndex = all.lastIndexOf(E_Modifier)
		if(eModifierIndex > 1 &&
			all.slice(1, eModifierIndex).every(function(c){return c == Extend}) &&
			[Extend, E_Base, E_Base_GAZ].indexOf(start) == -1){
			return Break
		}

		// Lookahead termintor for:
		// GB12. ^ (RI RI)* RI	?	RI
		// GB13. [^RI] (RI RI)* RI	?	RI
		var rIIndex = all.lastIndexOf(Regional_Indicator)
		if(rIIndex > 0 &&
			all.slice(1, rIIndex).every(function(c){return c == Regional_Indicator}) &&
			[Prepend, Regional_Indicator].indexOf(previous) == -1) { 
			if(all.filter(function(c){return c == Regional_Indicator}).length % 2 == 1) {
				return BreakLastRegional
			}
			else {
				return BreakPenultimateRegional
			}
		}
		
		// GB3. CR X LF
		if(previous == CR && next == LF){
			return NotBreak;
		}
		// GB4. (Control|CR|LF) 
		else if(previous == Control || previous == CR || previous == LF){
			if(next == E_Modifier && mid.every(function(c){return c == Extend})){
				return Break
			}
			else {
				return BreakStart
			}
		}
		// GB5.  (Control|CR|LF)
		else if(next == Control || next == CR || next == LF){
			return BreakStart;
		}
		// GB6. L X (L|V|LV|LVT)
		else if(previous == L && 
			(next == L || next == V || next == LV || next == LVT)){
			return NotBreak;
		}
		// GB7. (LV|V) X (V|T)
		else if((previous == LV || previous == V) && 
			(next == V || next == T)){
			return NotBreak;
		}
		// GB8. (LVT|T) X (T)
		else if((previous == LVT || previous == T) && 
			next == T){
			return NotBreak;
		}
		// GB9. X (Extend|ZWJ)
		else if (next == Extend || next == ZWJ){
			return NotBreak;
		}
		// GB9a. X SpacingMark
		else if(next == SpacingMark){
			return NotBreak;
		}
		// GB9b. Prepend X
		else if (previous == Prepend){
			return NotBreak;
		}
		
		// GB10. (E_Base | EBG) Extend* ?	E_Modifier
		var previousNonExtendIndex = all.indexOf(Extend) != -1 ? all.lastIndexOf(Extend) - 1 : all.length - 2;
		if([E_Base, E_Base_GAZ].indexOf(all[previousNonExtendIndex]) != -1 &&
			all.slice(previousNonExtendIndex + 1, -1).every(function(c){return c == Extend}) &&
			next == E_Modifier){
			return NotBreak;
		}
		
		// GB11. ZWJ ? (Glue_After_Zwj | EBG)
		if(previous == ZWJ && [Glue_After_Zwj, E_Base_GAZ].indexOf(next) != -1) {
			return NotBreak;
		}

		// GB12. ^ (RI RI)* RI ? RI
		// GB13. [^RI] (RI RI)* RI ? RI
		if(mid.indexOf(Regional_Indicator) != -1) { 
			return Break;
		}
		if(previous == Regional_Indicator && next == Regional_Indicator) {
			return NotBreak;
		}

		// GB999. Any ? Any
		return BreakStart;
	}
	
	// Returns the next grapheme break in the string after the given index
	this.nextBreak = function(string, index){
		if(index === undefined){
			index = 0;
		}
		if(index < 0){
			return 0;
		}
		if(index >= string.length - 1){
			return string.length;
		}
		var prev = getGraphemeBreakProperty(codePointAt(string, index));
		var mid = []
		for (var i = index + 1; i < string.length; i++) {
			// check for already processed low surrogates
			if(isSurrogate(string, i - 1)){
				continue;
			}
		
			var next = getGraphemeBreakProperty(codePointAt(string, i));
			if(shouldBreak(prev, mid, next)){
				return i;
			}
			
			mid.push(next);
		}
		return string.length;
	};
	
	// Breaks the given string into an array of grapheme cluster strings
	this.splitGraphemes = function(str){
		var res = [];
		var index = 0;
		var brk;
		while((brk = this.nextBreak(str, index)) < str.length){
			res.push(str.slice(index, brk));
			index = brk;
		}
		if(index < str.length){
			res.push(str.slice(index));
		}
		return res;
	};

	// Returns the iterator of grapheme clusters there are in the given string
	this.iterateGraphemes = function(str) {
		var index = 0;
		var res = {
			next: (function() {
				var value;
				var brk;
				if ((brk = this.nextBreak(str, index)) < str.length) {
					value = str.slice(index, brk);
					index = brk;
					return { value: value, done: false };
				}
				if (index < str.length) {
					value = str.slice(index);
					index = str.length;
					return { value: value, done: false };
				}
				return { value: undefined, done: true };
			}).bind(this)
		};
		// ES2015 @@iterator method (iterable) for spread syntax and for...of statement
		if (typeof Symbol !== 'undefined' && Symbol.iterator) {
			res[Symbol.iterator] = function() {return res};
		}
		return res;
	};

	// Returns the number of grapheme clusters there are in the given string
	this.countGraphemes = function(str){
		var count = 0;
		var index = 0;
		var brk;
		while((brk = this.nextBreak(str, index)) < str.length){
			index = brk;
			count++;
		}
		if(index < str.length){
			count++;
		}
		return count;
	};
	
	//given a Unicode code point, determines this symbol's grapheme break property
	function getGraphemeBreakProperty(code){
		
		//grapheme break property for Unicode 10.0.0, 
		//taken from http://www.unicode.org/Public/10.0.0/ucd/auxiliary/GraphemeBreakProperty.txt
		//and adapted to JavaScript rules
		
		if(		
		(0x0600 <= code && code <= 0x0605) || // Cf   [6] ARABIC NUMBER SIGN..ARABIC NUMBER MARK ABOVE
		0x06DD == code || // Cf       ARABIC END OF AYAH
		0x070F == code || // Cf       SYRIAC ABBREVIATION MARK
		0x08E2 == code || // Cf       ARABIC DISPUTED END OF AYAH
		0x0D4E == code || // Lo       MALAYALAM LETTER DOT REPH
		0x110BD == code || // Cf       KAITHI NUMBER SIGN
		(0x111C2 <= code && code <= 0x111C3) || // Lo   [2] SHARADA SIGN JIHVAMULIYA..SHARADA SIGN UPADHMANIYA
		0x11A3A == code || // Lo       ZANABAZAR SQUARE CLUSTER-INITIAL LETTER RA
		(0x11A86 <= code && code <= 0x11A89) || // Lo   [4] SOYOMBO CLUSTER-INITIAL LETTER RA..SOYOMBO CLUSTER-INITIAL LETTER SA
		0x11D46 == code // Lo       MASARAM GONDI REPHA
		){
			return Prepend;
		}
		if(
		0x000D == code // Cc       <control-000D>
		){
			return CR;
		}
		
		if(
		0x000A == code // Cc       <control-000A>
		){
			return LF;
		}
		
		
		if(
		(0x0000 <= code && code <= 0x0009) || // Cc  [10] <control-0000>..<control-0009>
		(0x000B <= code && code <= 0x000C) || // Cc   [2] <control-000B>..<control-000C>
		(0x000E <= code && code <= 0x001F) || // Cc  [18] <control-000E>..<control-001F>
		(0x007F <= code && code <= 0x009F) || // Cc  [33] <control-007F>..<control-009F>
		0x00AD == code || // Cf       SOFT HYPHEN
		0x061C == code || // Cf       ARABIC LETTER MARK
	
		0x180E == code || // Cf       MONGOLIAN VOWEL SEPARATOR
		0x200B == code || // Cf       ZERO WIDTH SPACE
		(0x200E <= code && code <= 0x200F) || // Cf   [2] LEFT-TO-RIGHT MARK..RIGHT-TO-LEFT MARK
		0x2028 == code || // Zl       LINE SEPARATOR
		0x2029 == code || // Zp       PARAGRAPH SEPARATOR
		(0x202A <= code && code <= 0x202E) || // Cf   [5] LEFT-TO-RIGHT EMBEDDING..RIGHT-TO-LEFT OVERRIDE
		(0x2060 <= code && code <= 0x2064) || // Cf   [5] WORD JOINER..INVISIBLE PLUS
		0x2065 == code || // Cn       <reserved-2065>
		(0x2066 <= code && code <= 0x206F) || // Cf  [10] LEFT-TO-RIGHT ISOLATE..NOMINAL DIGIT SHAPES
		(0xD800 <= code && code <= 0xDFFF) || // Cs [2048] <surrogate-D800>..<surrogate-DFFF>
		0xFEFF == code || // Cf       ZERO WIDTH NO-BREAK SPACE
		(0xFFF0 <= code && code <= 0xFFF8) || // Cn   [9] <reserved-FFF0>..<reserved-FFF8>
		(0xFFF9 <= code && code <= 0xFFFB) || // Cf   [3] INTERLINEAR ANNOTATION ANCHOR..INTERLINEAR ANNOTATION TERMINATOR
		(0x1BCA0 <= code && code <= 0x1BCA3) || // Cf   [4] SHORTHAND FORMAT LETTER OVERLAP..SHORTHAND FORMAT UP STEP
		(0x1D173 <= code && code <= 0x1D17A) || // Cf   [8] MUSICAL SYMBOL BEGIN BEAM..MUSICAL SYMBOL END PHRASE
		0xE0000 == code || // Cn       <reserved-E0000>
		0xE0001 == code || // Cf       LANGUAGE TAG
		(0xE0002 <= code && code <= 0xE001F) || // Cn  [30] <reserved-E0002>..<reserved-E001F>
		(0xE0080 <= code && code <= 0xE00FF) || // Cn [128] <reserved-E0080>..<reserved-E00FF>
		(0xE01F0 <= code && code <= 0xE0FFF) // Cn [3600] <reserved-E01F0>..<reserved-E0FFF>
		){
			return Control;
		}
		
		
		if(
		(0x0300 <= code && code <= 0x036F) || // Mn [112] COMBINING GRAVE ACCENT..COMBINING LATIN SMALL LETTER X
		(0x0483 <= code && code <= 0x0487) || // Mn   [5] COMBINING CYRILLIC TITLO..COMBINING CYRILLIC POKRYTIE
		(0x0488 <= code && code <= 0x0489) || // Me   [2] COMBINING CYRILLIC HUNDRED THOUSANDS SIGN..COMBINING CYRILLIC MILLIONS SIGN
		(0x0591 <= code && code <= 0x05BD) || // Mn  [45] HEBREW ACCENT ETNAHTA..HEBREW POINT METEG
		0x05BF == code || // Mn       HEBREW POINT RAFE
		(0x05C1 <= code && code <= 0x05C2) || // Mn   [2] HEBREW POINT SHIN DOT..HEBREW POINT SIN DOT
		(0x05C4 <= code && code <= 0x05C5) || // Mn   [2] HEBREW MARK UPPER DOT..HEBREW MARK LOWER DOT
		0x05C7 == code || // Mn       HEBREW POINT QAMATS QATAN
		(0x0610 <= code && code <= 0x061A) || // Mn  [11] ARABIC SIGN SALLALLAHOU ALAYHE WASSALLAM..ARABIC SMALL KASRA
		(0x064B <= code && code <= 0x065F) || // Mn  [21] ARABIC FATHATAN..ARABIC WAVY HAMZA BELOW
		0x0670 == code || // Mn       ARABIC LETTER SUPERSCRIPT ALEF
		(0x06D6 <= code && code <= 0x06DC) || // Mn   [7] ARABIC SMALL HIGH LIGATURE SAD WITH LAM WITH ALEF MAKSURA..ARABIC SMALL HIGH SEEN
		(0x06DF <= code && code <= 0x06E4) || // Mn   [6] ARABIC SMALL HIGH ROUNDED ZERO..ARABIC SMALL HIGH MADDA
		(0x06E7 <= code && code <= 0x06E8) || // Mn   [2] ARABIC SMALL HIGH YEH..ARABIC SMALL HIGH NOON
		(0x06EA <= code && code <= 0x06ED) || // Mn   [4] ARABIC EMPTY CENTRE LOW STOP..ARABIC SMALL LOW MEEM
		0x0711 == code || // Mn       SYRIAC LETTER SUPERSCRIPT ALAPH
		(0x0730 <= code && code <= 0x074A) || // Mn  [27] SYRIAC PTHAHA ABOVE..SYRIAC BARREKH
		(0x07A6 <= code && code <= 0x07B0) || // Mn  [11] THAANA ABAFILI..THAANA SUKUN
		(0x07EB <= code && code <= 0x07F3) || // Mn   [9] NKO COMBINING SHORT HIGH TONE..NKO COMBINING DOUBLE DOT ABOVE
		(0x0816 <= code && code <= 0x0819) || // Mn   [4] SAMARITAN MARK IN..SAMARITAN MARK DAGESH
		(0x081B <= code && code <= 0x0823) || // Mn   [9] SAMARITAN MARK EPENTHETIC YUT..SAMARITAN VOWEL SIGN A
		(0x0825 <= code && code <= 0x0827) || // Mn   [3] SAMARITAN VOWEL SIGN SHORT A..SAMARITAN VOWEL SIGN U
		(0x0829 <= code && code <= 0x082D) || // Mn   [5] SAMARITAN VOWEL SIGN LONG I..SAMARITAN MARK NEQUDAA
		(0x0859 <= code && code <= 0x085B) || // Mn   [3] MANDAIC AFFRICATION MARK..MANDAIC GEMINATION MARK
		(0x08D4 <= code && code <= 0x08E1) || // Mn  [14] ARABIC SMALL HIGH WORD AR-RUB..ARABIC SMALL HIGH SIGN SAFHA
		(0x08E3 <= code && code <= 0x0902) || // Mn  [32] ARABIC TURNED DAMMA BELOW..DEVANAGARI SIGN ANUSVARA
		0x093A == code || // Mn       DEVANAGARI VOWEL SIGN OE
		0x093C == code || // Mn       DEVANAGARI SIGN NUKTA
		(0x0941 <= code && code <= 0x0948) || // Mn   [8] DEVANAGARI VOWEL SIGN U..DEVANAGARI VOWEL SIGN AI
		0x094D == code || // Mn       DEVANAGARI SIGN VIRAMA
		(0x0951 <= code && code <= 0x0957) || // Mn   [7] DEVANAGARI STRESS SIGN UDATTA..DEVANAGARI VOWEL SIGN UUE
		(0x0962 <= code && code <= 0x0963) || // Mn   [2] DEVANAGARI VOWEL SIGN VOCALIC L..DEVANAGARI VOWEL SIGN VOCALIC LL
		0x0981 == code || // Mn       BENGALI SIGN CANDRABINDU
		0x09BC == code || // Mn       BENGALI SIGN NUKTA
		0x09BE == code || // Mc       BENGALI VOWEL SIGN AA
		(0x09C1 <= code && code <= 0x09C4) || // Mn   [4] BENGALI VOWEL SIGN U..BENGALI VOWEL SIGN VOCALIC RR
		0x09CD == code || // Mn       BENGALI SIGN VIRAMA
		0x09D7 == code || // Mc       BENGALI AU LENGTH MARK
		(0x09E2 <= code && code <= 0x09E3) || // Mn   [2] BENGALI VOWEL SIGN VOCALIC L..BENGALI VOWEL SIGN VOCALIC LL
		(0x0A01 <= code && code <= 0x0A02) || // Mn   [2] GURMUKHI SIGN ADAK BINDI..GURMUKHI SIGN BINDI
		0x0A3C == code || // Mn       GURMUKHI SIGN NUKTA
		(0x0A41 <= code && code <= 0x0A42) || // Mn   [2] GURMUKHI VOWEL SIGN U..GURMUKHI VOWEL SIGN UU
		(0x0A47 <= code && code <= 0x0A48) || // Mn   [2] GURMUKHI VOWEL SIGN EE..GURMUKHI VOWEL SIGN AI
		(0x0A4B <= code && code <= 0x0A4D) || // Mn   [3] GURMUKHI VOWEL SIGN OO..GURMUKHI SIGN VIRAMA
		0x0A51 == code || // Mn       GURMUKHI SIGN UDAAT
		(0x0A70 <= code && code <= 0x0A71) || // Mn   [2] GURMUKHI TIPPI..GURMUKHI ADDAK
		0x0A75 == code || // Mn       GURMUKHI SIGN YAKASH
		(0x0A81 <= code && code <= 0x0A82) || // Mn   [2] GUJARATI SIGN CANDRABINDU..GUJARATI SIGN ANUSVARA
		0x0ABC == code || // Mn       GUJARATI SIGN NUKTA
		(0x0AC1 <= code && code <= 0x0AC5) || // Mn   [5] GUJARATI VOWEL SIGN U..GUJARATI VOWEL SIGN CANDRA E
		(0x0AC7 <= code && code <= 0x0AC8) || // Mn   [2] GUJARATI VOWEL SIGN E..GUJARATI VOWEL SIGN AI
		0x0ACD == code || // Mn       GUJARATI SIGN VIRAMA
		(0x0AE2 <= code && code <= 0x0AE3) || // Mn   [2] GUJARATI VOWEL SIGN VOCALIC L..GUJARATI VOWEL SIGN VOCALIC LL
		(0x0AFA <= code && code <= 0x0AFF) || // Mn   [6] GUJARATI SIGN SUKUN..GUJARATI SIGN TWO-CIRCLE NUKTA ABOVE
		0x0B01 == code || // Mn       ORIYA SIGN CANDRABINDU
		0x0B3C == code || // Mn       ORIYA SIGN NUKTA
		0x0B3E == code || // Mc       ORIYA VOWEL SIGN AA
		0x0B3F == code || // Mn       ORIYA VOWEL SIGN I
		(0x0B41 <= code && code <= 0x0B44) || // Mn   [4] ORIYA VOWEL SIGN U..ORIYA VOWEL SIGN VOCALIC RR
		0x0B4D == code || // Mn       ORIYA SIGN VIRAMA
		0x0B56 == code || // Mn       ORIYA AI LENGTH MARK
		0x0B57 == code || // Mc       ORIYA AU LENGTH MARK
		(0x0B62 <= code && code <= 0x0B63) || // Mn   [2] ORIYA VOWEL SIGN VOCALIC L..ORIYA VOWEL SIGN VOCALIC LL
		0x0B82 == code || // Mn       TAMIL SIGN ANUSVARA
		0x0BBE == code || // Mc       TAMIL VOWEL SIGN AA
		0x0BC0 == code || // Mn       TAMIL VOWEL SIGN II
		0x0BCD == code || // Mn       TAMIL SIGN VIRAMA
		0x0BD7 == code || // Mc       TAMIL AU LENGTH MARK
		0x0C00 == code || // Mn       TELUGU SIGN COMBINING CANDRABINDU ABOVE
		(0x0C3E <= code && code <= 0x0C40) || // Mn   [3] TELUGU VOWEL SIGN AA..TELUGU VOWEL SIGN II
		(0x0C46 <= code && code <= 0x0C48) || // Mn   [3] TELUGU VOWEL SIGN E..TELUGU VOWEL SIGN AI
		(0x0C4A <= code && code <= 0x0C4D) || // Mn   [4] TELUGU VOWEL SIGN O..TELUGU SIGN VIRAMA
		(0x0C55 <= code && code <= 0x0C56) || // Mn   [2] TELUGU LENGTH MARK..TELUGU AI LENGTH MARK
		(0x0C62 <= code && code <= 0x0C63) || // Mn   [2] TELUGU VOWEL SIGN VOCALIC L..TELUGU VOWEL SIGN VOCALIC LL
		0x0C81 == code || // Mn       KANNADA SIGN CANDRABINDU
		0x0CBC == code || // Mn       KANNADA SIGN NUKTA
		0x0CBF == code || // Mn       KANNADA VOWEL SIGN I
		0x0CC2 == code || // Mc       KANNADA VOWEL SIGN UU
		0x0CC6 == code || // Mn       KANNADA VOWEL SIGN E
		(0x0CCC <= code && code <= 0x0CCD) || // Mn   [2] KANNADA VOWEL SIGN AU..KANNADA SIGN VIRAMA
		(0x0CD5 <= code && code <= 0x0CD6) || // Mc   [2] KANNADA LENGTH MARK..KANNADA AI LENGTH MARK
		(0x0CE2 <= code && code <= 0x0CE3) || // Mn   [2] KANNADA VOWEL SIGN VOCALIC L..KANNADA VOWEL SIGN VOCALIC LL
		(0x0D00 <= code && code <= 0x0D01) || // Mn   [2] MALAYALAM SIGN COMBINING ANUSVARA ABOVE..MALAYALAM SIGN CANDRABINDU
		(0x0D3B <= code && code <= 0x0D3C) || // Mn   [2] MALAYALAM SIGN VERTICAL BAR VIRAMA..MALAYALAM SIGN CIRCULAR VIRAMA
		0x0D3E == code || // Mc       MALAYALAM VOWEL SIGN AA
		(0x0D41 <= code && code <= 0x0D44) || // Mn   [4] MALAYALAM VOWEL SIGN U..MALAYALAM VOWEL SIGN VOCALIC RR
		0x0D4D == code || // Mn       MALAYALAM SIGN VIRAMA
		0x0D57 == code || // Mc       MALAYALAM AU LENGTH MARK
		(0x0D62 <= code && code <= 0x0D63) || // Mn   [2] MALAYALAM VOWEL SIGN VOCALIC L..MALAYALAM VOWEL SIGN VOCALIC LL
		0x0DCA == code || // Mn       SINHALA SIGN AL-LAKUNA
		0x0DCF == code || // Mc       SINHALA VOWEL SIGN AELA-PILLA
		(0x0DD2 <= code && code <= 0x0DD4) || // Mn   [3] SINHALA VOWEL SIGN KETTI IS-PILLA..SINHALA VOWEL SIGN KETTI PAA-PILLA
		0x0DD6 == code || // Mn       SINHALA VOWEL SIGN DIGA PAA-PILLA
		0x0DDF == code || // Mc       SINHALA VOWEL SIGN GAYANUKITTA
		0x0E31 == code || // Mn       THAI CHARACTER MAI HAN-AKAT
		(0x0E34 <= code && code <= 0x0E3A) || // Mn   [7] THAI CHARACTER SARA I..THAI CHARACTER PHINTHU
		(0x0E47 <= code && code <= 0x0E4E) || // Mn   [8] THAI CHARACTER MAITAIKHU..THAI CHARACTER YAMAKKAN
		0x0EB1 == code || // Mn       LAO VOWEL SIGN MAI KAN
		(0x0EB4 <= code && code <= 0x0EB9) || // Mn   [6] LAO VOWEL SIGN I..LAO VOWEL SIGN UU
		(0x0EBB <= code && code <= 0x0EBC) || // Mn   [2] LAO VOWEL SIGN MAI KON..LAO SEMIVOWEL SIGN LO
		(0x0EC8 <= code && code <= 0x0ECD) || // Mn   [6] LAO TONE MAI EK..LAO NIGGAHITA
		(0x0F18 <= code && code <= 0x0F19) || // Mn   [2] TIBETAN ASTROLOGICAL SIGN -KHYUD PA..TIBETAN ASTROLOGICAL SIGN SDONG TSHUGS
		0x0F35 == code || // Mn       TIBETAN MARK NGAS BZUNG NYI ZLA
		0x0F37 == code || // Mn       TIBETAN MARK NGAS BZUNG SGOR RTAGS
		0x0F39 == code || // Mn       TIBETAN MARK TSA -PHRU
		(0x0F71 <= code && code <= 0x0F7E) || // Mn  [14] TIBETAN VOWEL SIGN AA..TIBETAN SIGN RJES SU NGA RO
		(0x0F80 <= code && code <= 0x0F84) || // Mn   [5] TIBETAN VOWEL SIGN REVERSED I..TIBETAN MARK HALANTA
		(0x0F86 <= code && code <= 0x0F87) || // Mn   [2] TIBETAN SIGN LCI RTAGS..TIBETAN SIGN YANG RTAGS
		(0x0F8D <= code && code <= 0x0F97) || // Mn  [11] TIBETAN SUBJOINED SIGN LCE TSA CAN..TIBETAN SUBJOINED LETTER JA
		(0x0F99 <= code && code <= 0x0FBC) || // Mn  [36] TIBETAN SUBJOINED LETTER NYA..TIBETAN SUBJOINED LETTER FIXED-FORM RA
		0x0FC6 == code || // Mn       TIBETAN SYMBOL PADMA GDAN
		(0x102D <= code && code <= 0x1030) || // Mn   [4] MYANMAR VOWEL SIGN I..MYANMAR VOWEL SIGN UU
		(0x1032 <= code && code <= 0x1037) || // Mn   [6] MYANMAR VOWEL SIGN AI..MYANMAR SIGN DOT BELOW
		(0x1039 <= code && code <= 0x103A) || // Mn   [2] MYANMAR SIGN VIRAMA..MYANMAR SIGN ASAT
		(0x103D <= code && code <= 0x103E) || // Mn   [2] MYANMAR CONSONANT SIGN MEDIAL WA..MYANMAR CONSONANT SIGN MEDIAL HA
		(0x1058 <= code && code <= 0x1059) || // Mn   [2] MYANMAR VOWEL SIGN VOCALIC L..MYANMAR VOWEL SIGN VOCALIC LL
		(0x105E <= code && code <= 0x1060) || // Mn   [3] MYANMAR CONSONANT SIGN MON MEDIAL NA..MYANMAR CONSONANT SIGN MON MEDIAL LA
		(0x1071 <= code && code <= 0x1074) || // Mn   [4] MYANMAR VOWEL SIGN GEBA KAREN I..MYANMAR VOWEL SIGN KAYAH EE
		0x1082 == code || // Mn       MYANMAR CONSONANT SIGN SHAN MEDIAL WA
		(0x1085 <= code && code <= 0x1086) || // Mn   [2] MYANMAR VOWEL SIGN SHAN E ABOVE..MYANMAR VOWEL SIGN SHAN FINAL Y
		0x108D == code || // Mn       MYANMAR SIGN SHAN COUNCIL EMPHATIC TONE
		0x109D == code || // Mn       MYANMAR VOWEL SIGN AITON AI
		(0x135D <= code && code <= 0x135F) || // Mn   [3] ETHIOPIC COMBINING GEMINATION AND VOWEL LENGTH MARK..ETHIOPIC COMBINING GEMINATION MARK
		(0x1712 <= code && code <= 0x1714) || // Mn   [3] TAGALOG VOWEL SIGN I..TAGALOG SIGN VIRAMA
		(0x1732 <= code && code <= 0x1734) || // Mn   [3] HANUNOO VOWEL SIGN I..HANUNOO SIGN PAMUDPOD
		(0x1752 <= code && code <= 0x1753) || // Mn   [2] BUHID VOWEL SIGN I..BUHID VOWEL SIGN U
		(0x1772 <= code && code <= 0x1773) || // Mn   [2] TAGBANWA VOWEL SIGN I..TAGBANWA VOWEL SIGN U
		(0x17B4 <= code && code <= 0x17B5) || // Mn   [2] KHMER VOWEL INHERENT AQ..KHMER VOWEL INHERENT AA
		(0x17B7 <= code && code <= 0x17BD) || // Mn   [7] KHMER VOWEL SIGN I..KHMER VOWEL SIGN UA
		0x17C6 == code || // Mn       KHMER SIGN NIKAHIT
		(0x17C9 <= code && code <= 0x17D3) || // Mn  [11] KHMER SIGN MUUSIKATOAN..KHMER SIGN BATHAMASAT
		0x17DD == code || // Mn       KHMER SIGN ATTHACAN
		(0x180B <= code && code <= 0x180D) || // Mn   [3] MONGOLIAN FREE VARIATION SELECTOR ONE..MONGOLIAN FREE VARIATION SELECTOR THREE
		(0x1885 <= code && code <= 0x1886) || // Mn   [2] MONGOLIAN LETTER ALI GALI BALUDA..MONGOLIAN LETTER ALI GALI THREE BALUDA
		0x18A9 == code || // Mn       MONGOLIAN LETTER ALI GALI DAGALGA
		(0x1920 <= code && code <= 0x1922) || // Mn   [3] LIMBU VOWEL SIGN A..LIMBU VOWEL SIGN U
		(0x1927 <= code && code <= 0x1928) || // Mn   [2] LIMBU VOWEL SIGN E..LIMBU VOWEL SIGN O
		0x1932 == code || // Mn       LIMBU SMALL LETTER ANUSVARA
		(0x1939 <= code && code <= 0x193B) || // Mn   [3] LIMBU SIGN MUKPHRENG..LIMBU SIGN SA-I
		(0x1A17 <= code && code <= 0x1A18) || // Mn   [2] BUGINESE VOWEL SIGN I..BUGINESE VOWEL SIGN U
		0x1A1B == code || // Mn       BUGINESE VOWEL SIGN AE
		0x1A56 == code || // Mn       TAI THAM CONSONANT SIGN MEDIAL LA
		(0x1A58 <= code && code <= 0x1A5E) || // Mn   [7] TAI THAM SIGN MAI KANG LAI..TAI THAM CONSONANT SIGN SA
		0x1A60 == code || // Mn       TAI THAM SIGN SAKOT
		0x1A62 == code || // Mn       TAI THAM VOWEL SIGN MAI SAT
		(0x1A65 <= code && code <= 0x1A6C) || // Mn   [8] TAI THAM VOWEL SIGN I..TAI THAM VOWEL SIGN OA BELOW
		(0x1A73 <= code && code <= 0x1A7C) || // Mn  [10] TAI THAM VOWEL SIGN OA ABOVE..TAI THAM SIGN KHUEN-LUE KARAN
		0x1A7F == code || // Mn       TAI THAM COMBINING CRYPTOGRAMMIC DOT
		(0x1AB0 <= code && code <= 0x1ABD) || // Mn  [14] COMBINING DOUBLED CIRCUMFLEX ACCENT..COMBINING PARENTHESES BELOW
		0x1ABE == code || // Me       COMBINING PARENTHESES OVERLAY
		(0x1B00 <= code && code <= 0x1B03) || // Mn   [4] BALINESE SIGN ULU RICEM..BALINESE SIGN SURANG
		0x1B34 == code || // Mn       BALINESE SIGN REREKAN
		(0x1B36 <= code && code <= 0x1B3A) || // Mn   [5] BALINESE VOWEL SIGN ULU..BALINESE VOWEL SIGN RA REPA
		0x1B3C == code || // Mn       BALINESE VOWEL SIGN LA LENGA
		0x1B42 == code || // Mn       BALINESE VOWEL SIGN PEPET
		(0x1B6B <= code && code <= 0x1B73) || // Mn   [9] BALINESE MUSICAL SYMBOL COMBINING TEGEH..BALINESE MUSICAL SYMBOL COMBINING GONG
		(0x1B80 <= code && code <= 0x1B81) || // Mn   [2] SUNDANESE SIGN PANYECEK..SUNDANESE SIGN PANGLAYAR
		(0x1BA2 <= code && code <= 0x1BA5) || // Mn   [4] SUNDANESE CONSONANT SIGN PANYAKRA..SUNDANESE VOWEL SIGN PANYUKU
		(0x1BA8 <= code && code <= 0x1BA9) || // Mn   [2] SUNDANESE VOWEL SIGN PAMEPET..SUNDANESE VOWEL SIGN PANEULEUNG
		(0x1BAB <= code && code <= 0x1BAD) || // Mn   [3] SUNDANESE SIGN VIRAMA..SUNDANESE CONSONANT SIGN PASANGAN WA
		0x1BE6 == code || // Mn       BATAK SIGN TOMPI
		(0x1BE8 <= code && code <= 0x1BE9) || // Mn   [2] BATAK VOWEL SIGN PAKPAK E..BATAK VOWEL SIGN EE
		0x1BED == code || // Mn       BATAK VOWEL SIGN KARO O
		(0x1BEF <= code && code <= 0x1BF1) || // Mn   [3] BATAK VOWEL SIGN U FOR SIMALUNGUN SA..BATAK CONSONANT SIGN H
		(0x1C2C <= code && code <= 0x1C33) || // Mn   [8] LEPCHA VOWEL SIGN E..LEPCHA CONSONANT SIGN T
		(0x1C36 <= code && code <= 0x1C37) || // Mn   [2] LEPCHA SIGN RAN..LEPCHA SIGN NUKTA
		(0x1CD0 <= code && code <= 0x1CD2) || // Mn   [3] VEDIC TONE KARSHANA..VEDIC TONE PRENKHA
		(0x1CD4 <= code && code <= 0x1CE0) || // Mn  [13] VEDIC SIGN YAJURVEDIC MIDLINE SVARITA..VEDIC TONE RIGVEDIC KASHMIRI INDEPENDENT SVARITA
		(0x1CE2 <= code && code <= 0x1CE8) || // Mn   [7] VEDIC SIGN VISARGA SVARITA..VEDIC SIGN VISARGA ANUDATTA WITH TAIL
		0x1CED == code || // Mn       VEDIC SIGN TIRYAK
		0x1CF4 == code || // Mn       VEDIC TONE CANDRA ABOVE
		(0x1CF8 <= code && code <= 0x1CF9) || // Mn   [2] VEDIC TONE RING ABOVE..VEDIC TONE DOUBLE RING ABOVE
		(0x1DC0 <= code && code <= 0x1DF9) || // Mn  [58] COMBINING DOTTED GRAVE ACCENT..COMBINING WIDE INVERTED BRIDGE BELOW
		(0x1DFB <= code && code <= 0x1DFF) || // Mn   [5] COMBINING DELETION MARK..COMBINING RIGHT ARROWHEAD AND DOWN ARROWHEAD BELOW
		0x200C == code || // Cf       ZERO WIDTH NON-JOINER
		(0x20D0 <= code && code <= 0x20DC) || // Mn  [13] COMBINING LEFT HARPOON ABOVE..COMBINING FOUR DOTS ABOVE
		(0x20DD <= code && code <= 0x20E0) || // Me   [4] COMBINING ENCLOSING CIRCLE..COMBINING ENCLOSING CIRCLE BACKSLASH
		0x20E1 == code || // Mn       COMBINING LEFT RIGHT ARROW ABOVE
		(0x20E2 <= code && code <= 0x20E4) || // Me   [3] COMBINING ENCLOSING SCREEN..COMBINING ENCLOSING UPWARD POINTING TRIANGLE
		(0x20E5 <= code && code <= 0x20F0) || // Mn  [12] COMBINING REVERSE SOLIDUS OVERLAY..COMBINING ASTERISK ABOVE
		(0x2CEF <= code && code <= 0x2CF1) || // Mn   [3] COPTIC COMBINING NI ABOVE..COPTIC COMBINING SPIRITUS LENIS
		0x2D7F == code || // Mn       TIFINAGH CONSONANT JOINER
		(0x2DE0 <= code && code <= 0x2DFF) || // Mn  [32] COMBINING CYRILLIC LETTER BE..COMBINING CYRILLIC LETTER IOTIFIED BIG YUS
		(0x302A <= code && code <= 0x302D) || // Mn   [4] IDEOGRAPHIC LEVEL TONE MARK..IDEOGRAPHIC ENTERING TONE MARK
		(0x302E <= code && code <= 0x302F) || // Mc   [2] HANGUL SINGLE DOT TONE MARK..HANGUL DOUBLE DOT TONE MARK
		(0x3099 <= code && code <= 0x309A) || // Mn   [2] COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK..COMBINING KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
		0xA66F == code || // Mn       COMBINING CYRILLIC VZMET
		(0xA670 <= code && code <= 0xA672) || // Me   [3] COMBINING CYRILLIC TEN MILLIONS SIGN..COMBINING CYRILLIC THOUSAND MILLIONS SIGN
		(0xA674 <= code && code <= 0xA67D) || // Mn  [10] COMBINING CYRILLIC LETTER UKRAINIAN IE..COMBINING CYRILLIC PAYEROK
		(0xA69E <= code && code <= 0xA69F) || // Mn   [2] COMBINING CYRILLIC LETTER EF..COMBINING CYRILLIC LETTER IOTIFIED E
		(0xA6F0 <= code && code <= 0xA6F1) || // Mn   [2] BAMUM COMBINING MARK KOQNDON..BAMUM COMBINING MARK TUKWENTIS
		0xA802 == code || // Mn       SYLOTI NAGRI SIGN DVISVARA
		0xA806 == code || // Mn       SYLOTI NAGRI SIGN HASANTA
		0xA80B == code || // Mn       SYLOTI NAGRI SIGN ANUSVARA
		(0xA825 <= code && code <= 0xA826) || // Mn   [2] SYLOTI NAGRI VOWEL SIGN U..SYLOTI NAGRI VOWEL SIGN E
		(0xA8C4 <= code && code <= 0xA8C5) || // Mn   [2] SAURASHTRA SIGN VIRAMA..SAURASHTRA SIGN CANDRABINDU
		(0xA8E0 <= code && code <= 0xA8F1) || // Mn  [18] COMBINING DEVANAGARI DIGIT ZERO..COMBINING DEVANAGARI SIGN AVAGRAHA
		(0xA926 <= code && code <= 0xA92D) || // Mn   [8] KAYAH LI VOWEL UE..KAYAH LI TONE CALYA PLOPHU
		(0xA947 <= code && code <= 0xA951) || // Mn  [11] REJANG VOWEL SIGN I..REJANG CONSONANT SIGN R
		(0xA980 <= code && code <= 0xA982) || // Mn   [3] JAVANESE SIGN PANYANGGA..JAVANESE SIGN LAYAR
		0xA9B3 == code || // Mn       JAVANESE SIGN CECAK TELU
		(0xA9B6 <= code && code <= 0xA9B9) || // Mn   [4] JAVANESE VOWEL SIGN WULU..JAVANESE VOWEL SIGN SUKU MENDUT
		0xA9BC == code || // Mn       JAVANESE VOWEL SIGN PEPET
		0xA9E5 == code || // Mn       MYANMAR SIGN SHAN SAW
		(0xAA29 <= code && code <= 0xAA2E) || // Mn   [6] CHAM VOWEL SIGN AA..CHAM VOWEL SIGN OE
		(0xAA31 <= code && code <= 0xAA32) || // Mn   [2] CHAM VOWEL SIGN AU..CHAM VOWEL SIGN UE
		(0xAA35 <= code && code <= 0xAA36) || // Mn   [2] CHAM CONSONANT SIGN LA..CHAM CONSONANT SIGN WA
		0xAA43 == code || // Mn       CHAM CONSONANT SIGN FINAL NG
		0xAA4C == code || // Mn       CHAM CONSONANT SIGN FINAL M
		0xAA7C == code || // Mn       MYANMAR SIGN TAI LAING TONE-2
		0xAAB0 == code || // Mn       TAI VIET MAI KANG
		(0xAAB2 <= code && code <= 0xAAB4) || // Mn   [3] TAI VIET VOWEL I..TAI VIET VOWEL U
		(0xAAB7 <= code && code <= 0xAAB8) || // Mn   [2] TAI VIET MAI KHIT..TAI VIET VOWEL IA
		(0xAABE <= code && code <= 0xAABF) || // Mn   [2] TAI VIET VOWEL AM..TAI VIET TONE MAI EK
		0xAAC1 == code || // Mn       TAI VIET TONE MAI THO
		(0xAAEC <= code && code <= 0xAAED) || // Mn   [2] MEETEI MAYEK VOWEL SIGN UU..MEETEI MAYEK VOWEL SIGN AAI
		0xAAF6 == code || // Mn       MEETEI MAYEK VIRAMA
		0xABE5 == code || // Mn       MEETEI MAYEK VOWEL SIGN ANAP
		0xABE8 == code || // Mn       MEETEI MAYEK VOWEL SIGN UNAP
		0xABED == code || // Mn       MEETEI MAYEK APUN IYEK
		0xFB1E == code || // Mn       HEBREW POINT JUDEO-SPANISH VARIKA
		(0xFE00 <= code && code <= 0xFE0F) || // Mn  [16] VARIATION SELECTOR-1..VARIATION SELECTOR-16
		(0xFE20 <= code && code <= 0xFE2F) || // Mn  [16] COMBINING LIGATURE LEFT HALF..COMBINING CYRILLIC TITLO RIGHT HALF
		(0xFF9E <= code && code <= 0xFF9F) || // Lm   [2] HALFWIDTH KATAKANA VOICED SOUND MARK..HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
		0x101FD == code || // Mn       PHAISTOS DISC SIGN COMBINING OBLIQUE STROKE
		0x102E0 == code || // Mn       COPTIC EPACT THOUSANDS MARK
		(0x10376 <= code && code <= 0x1037A) || // Mn   [5] COMBINING OLD PERMIC LETTER AN..COMBINING OLD PERMIC LETTER SII
		(0x10A01 <= code && code <= 0x10A03) || // Mn   [3] KHAROSHTHI VOWEL SIGN I..KHAROSHTHI VOWEL SIGN VOCALIC R
		(0x10A05 <= code && code <= 0x10A06) || // Mn   [2] KHAROSHTHI VOWEL SIGN E..KHAROSHTHI VOWEL SIGN O
		(0x10A0C <= code && code <= 0x10A0F) || // Mn   [4] KHAROSHTHI VOWEL LENGTH MARK..KHAROSHTHI SIGN VISARGA
		(0x10A38 <= code && code <= 0x10A3A) || // Mn   [3] KHAROSHTHI SIGN BAR ABOVE..KHAROSHTHI SIGN DOT BELOW
		0x10A3F == code || // Mn       KHAROSHTHI VIRAMA
		(0x10AE5 <= code && code <= 0x10AE6) || // Mn   [2] MANICHAEAN ABBREVIATION MARK ABOVE..MANICHAEAN ABBREVIATION MARK BELOW
		0x11001 == code || // Mn       BRAHMI SIGN ANUSVARA
		(0x11038 <= code && code <= 0x11046) || // Mn  [15] BRAHMI VOWEL SIGN AA..BRAHMI VIRAMA
		(0x1107F <= code && code <= 0x11081) || // Mn   [3] BRAHMI NUMBER JOINER..KAITHI SIGN ANUSVARA
		(0x110B3 <= code && code <= 0x110B6) || // Mn   [4] KAITHI VOWEL SIGN U..KAITHI VOWEL SIGN AI
		(0x110B9 <= code && code <= 0x110BA) || // Mn   [2] KAITHI SIGN VIRAMA..KAITHI SIGN NUKTA
		(0x11100 <= code && code <= 0x11102) || // Mn   [3] CHAKMA SIGN CANDRABINDU..CHAKMA SIGN VISARGA
		(0x11127 <= code && code <= 0x1112B) || // Mn   [5] CHAKMA VOWEL SIGN A..CHAKMA VOWEL SIGN UU
		(0x1112D <= code && code <= 0x11134) || // Mn   [8] CHAKMA VOWEL SIGN AI..CHAKMA MAAYYAA
		0x11173 == code || // Mn       MAHAJANI SIGN NUKTA
		(0x11180 <= code && code <= 0x11181) || // Mn   [2] SHARADA SIGN CANDRABINDU..SHARADA SIGN ANUSVARA
		(0x111B6 <= code && code <= 0x111BE) || // Mn   [9] SHARADA VOWEL SIGN U..SHARADA VOWEL SIGN O
		(0x111CA <= code && code <= 0x111CC) || // Mn   [3] SHARADA SIGN NUKTA..SHARADA EXTRA SHORT VOWEL MARK
		(0x1122F <= code && code <= 0x11231) || // Mn   [3] KHOJKI VOWEL SIGN U..KHOJKI VOWEL SIGN AI
		0x11234 == code || // Mn       KHOJKI SIGN ANUSVARA
		(0x11236 <= code && code <= 0x11237) || // Mn   [2] KHOJKI SIGN NUKTA..KHOJKI SIGN SHADDA
		0x1123E == code || // Mn       KHOJKI SIGN SUKUN
		0x112DF == code || // Mn       KHUDAWADI SIGN ANUSVARA
		(0x112E3 <= code && code <= 0x112EA) || // Mn   [8] KHUDAWADI VOWEL SIGN U..KHUDAWADI SIGN VIRAMA
		(0x11300 <= code && code <= 0x11301) || // Mn   [2] GRANTHA SIGN COMBINING ANUSVARA ABOVE..GRANTHA SIGN CANDRABINDU
		0x1133C == code || // Mn       GRANTHA SIGN NUKTA
		0x1133E == code || // Mc       GRANTHA VOWEL SIGN AA
		0x11340 == code || // Mn       GRANTHA VOWEL SIGN II
		0x11357 == code || // Mc       GRANTHA AU LENGTH MARK
		(0x11366 <= code && code <= 0x1136C) || // Mn   [7] COMBINING GRANTHA DIGIT ZERO..COMBINING GRANTHA DIGIT SIX
		(0x11370 <= code && code <= 0x11374) || // Mn   [5] COMBINING GRANTHA LETTER A..COMBINING GRANTHA LETTER PA
		(0x11438 <= code && code <= 0x1143F) || // Mn   [8] NEWA VOWEL SIGN U..NEWA VOWEL SIGN AI
		(0x11442 <= code && code <= 0x11444) || // Mn   [3] NEWA SIGN VIRAMA..NEWA SIGN ANUSVARA
		0x11446 == code || // Mn       NEWA SIGN NUKTA
		0x114B0 == code || // Mc       TIRHUTA VOWEL SIGN AA
		(0x114B3 <= code && code <= 0x114B8) || // Mn   [6] TIRHUTA VOWEL SIGN U..TIRHUTA VOWEL SIGN VOCALIC LL
		0x114BA == code || // Mn       TIRHUTA VOWEL SIGN SHORT E
		0x114BD == code || // Mc       TIRHUTA VOWEL SIGN SHORT O
		(0x114BF <= code && code <= 0x114C0) || // Mn   [2] TIRHUTA SIGN CANDRABINDU..TIRHUTA SIGN ANUSVARA
		(0x114C2 <= code && code <= 0x114C3) || // Mn   [2] TIRHUTA SIGN VIRAMA..TIRHUTA SIGN NUKTA
		0x115AF == code || // Mc       SIDDHAM VOWEL SIGN AA
		(0x115B2 <= code && code <= 0x115B5) || // Mn   [4] SIDDHAM VOWEL SIGN U..SIDDHAM VOWEL SIGN VOCALIC RR
		(0x115BC <= code && code <= 0x115BD) || // Mn   [2] SIDDHAM SIGN CANDRABINDU..SIDDHAM SIGN ANUSVARA
		(0x115BF <= code && code <= 0x115C0) || // Mn   [2] SIDDHAM SIGN VIRAMA..SIDDHAM SIGN NUKTA
		(0x115DC <= code && code <= 0x115DD) || // Mn   [2] SIDDHAM VOWEL SIGN ALTERNATE U..SIDDHAM VOWEL SIGN ALTERNATE UU
		(0x11633 <= code && code <= 0x1163A) || // Mn   [8] MODI VOWEL SIGN U..MODI VOWEL SIGN AI
		0x1163D == code || // Mn       MODI SIGN ANUSVARA
		(0x1163F <= code && code <= 0x11640) || // Mn   [2] MODI SIGN VIRAMA..MODI SIGN ARDHACANDRA
		0x116AB == code || // Mn       TAKRI SIGN ANUSVARA
		0x116AD == code || // Mn       TAKRI VOWEL SIGN AA
		(0x116B0 <= code && code <= 0x116B5) || // Mn   [6] TAKRI VOWEL SIGN U..TAKRI VOWEL SIGN AU
		0x116B7 == code || // Mn       TAKRI SIGN NUKTA
		(0x1171D <= code && code <= 0x1171F) || // Mn   [3] AHOM CONSONANT SIGN MEDIAL LA..AHOM CONSONANT SIGN MEDIAL LIGATING RA
		(0x11722 <= code && code <= 0x11725) || // Mn   [4] AHOM VOWEL SIGN I..AHOM VOWEL SIGN UU
		(0x11727 <= code && code <= 0x1172B) || // Mn   [5] AHOM VOWEL SIGN AW..AHOM SIGN KILLER
		(0x11A01 <= code && code <= 0x11A06) || // Mn   [6] ZANABAZAR SQUARE VOWEL SIGN I..ZANABAZAR SQUARE VOWEL SIGN O
		(0x11A09 <= code && code <= 0x11A0A) || // Mn   [2] ZANABAZAR SQUARE VOWEL SIGN REVERSED I..ZANABAZAR SQUARE VOWEL LENGTH MARK
		(0x11A33 <= code && code <= 0x11A38) || // Mn   [6] ZANABAZAR SQUARE FINAL CONSONANT MARK..ZANABAZAR SQUARE SIGN ANUSVARA
		(0x11A3B <= code && code <= 0x11A3E) || // Mn   [4] ZANABAZAR SQUARE CLUSTER-FINAL LETTER YA..ZANABAZAR SQUARE CLUSTER-FINAL LETTER VA
		0x11A47 == code || // Mn       ZANABAZAR SQUARE SUBJOINER
		(0x11A51 <= code && code <= 0x11A56) || // Mn   [6] SOYOMBO VOWEL SIGN I..SOYOMBO VOWEL SIGN OE
		(0x11A59 <= code && code <= 0x11A5B) || // Mn   [3] SOYOMBO VOWEL SIGN VOCALIC R..SOYOMBO VOWEL LENGTH MARK
		(0x11A8A <= code && code <= 0x11A96) || // Mn  [13] SOYOMBO FINAL CONSONANT SIGN G..SOYOMBO SIGN ANUSVARA
		(0x11A98 <= code && code <= 0x11A99) || // Mn   [2] SOYOMBO GEMINATION MARK..SOYOMBO SUBJOINER
		(0x11C30 <= code && code <= 0x11C36) || // Mn   [7] BHAIKSUKI VOWEL SIGN I..BHAIKSUKI VOWEL SIGN VOCALIC L
		(0x11C38 <= code && code <= 0x11C3D) || // Mn   [6] BHAIKSUKI VOWEL SIGN E..BHAIKSUKI SIGN ANUSVARA
		0x11C3F == code || // Mn       BHAIKSUKI SIGN VIRAMA
		(0x11C92 <= code && code <= 0x11CA7) || // Mn  [22] MARCHEN SUBJOINED LETTER KA..MARCHEN SUBJOINED LETTER ZA
		(0x11CAA <= code && code <= 0x11CB0) || // Mn   [7] MARCHEN SUBJOINED LETTER RA..MARCHEN VOWEL SIGN AA
		(0x11CB2 <= code && code <= 0x11CB3) || // Mn   [2] MARCHEN VOWEL SIGN U..MARCHEN VOWEL SIGN E
		(0x11CB5 <= code && code <= 0x11CB6) || // Mn   [2] MARCHEN SIGN ANUSVARA..MARCHEN SIGN CANDRABINDU
		(0x11D31 <= code && code <= 0x11D36) || // Mn   [6] MASARAM GONDI VOWEL SIGN AA..MASARAM GONDI VOWEL SIGN VOCALIC R
		0x11D3A == code || // Mn       MASARAM GONDI VOWEL SIGN E
		(0x11D3C <= code && code <= 0x11D3D) || // Mn   [2] MASARAM GONDI VOWEL SIGN AI..MASARAM GONDI VOWEL SIGN O
		(0x11D3F <= code && code <= 0x11D45) || // Mn   [7] MASARAM GONDI VOWEL SIGN AU..MASARAM GONDI VIRAMA
		0x11D47 == code || // Mn       MASARAM GONDI RA-KARA
		(0x16AF0 <= code && code <= 0x16AF4) || // Mn   [5] BASSA VAH COMBINING HIGH TONE..BASSA VAH COMBINING HIGH-LOW TONE
		(0x16B30 <= code && code <= 0x16B36) || // Mn   [7] PAHAWH HMONG MARK CIM TUB..PAHAWH HMONG MARK CIM TAUM
		(0x16F8F <= code && code <= 0x16F92) || // Mn   [4] MIAO TONE RIGHT..MIAO TONE BELOW
		(0x1BC9D <= code && code <= 0x1BC9E) || // Mn   [2] DUPLOYAN THICK LETTER SELECTOR..DUPLOYAN DOUBLE MARK
		0x1D165 == code || // Mc       MUSICAL SYMBOL COMBINING STEM
		(0x1D167 <= code && code <= 0x1D169) || // Mn   [3] MUSICAL SYMBOL COMBINING TREMOLO-1..MUSICAL SYMBOL COMBINING TREMOLO-3
		(0x1D16E <= code && code <= 0x1D172) || // Mc   [5] MUSICAL SYMBOL COMBINING FLAG-1..MUSICAL SYMBOL COMBINING FLAG-5
		(0x1D17B <= code && code <= 0x1D182) || // Mn   [8] MUSICAL SYMBOL COMBINING ACCENT..MUSICAL SYMBOL COMBINING LOURE
		(0x1D185 <= code && code <= 0x1D18B) || // Mn   [7] MUSICAL SYMBOL COMBINING DOIT..MUSICAL SYMBOL COMBINING TRIPLE TONGUE
		(0x1D1AA <= code && code <= 0x1D1AD) || // Mn   [4] MUSICAL SYMBOL COMBINING DOWN BOW..MUSICAL SYMBOL COMBINING SNAP PIZZICATO
		(0x1D242 <= code && code <= 0x1D244) || // Mn   [3] COMBINING GREEK MUSICAL TRISEME..COMBINING GREEK MUSICAL PENTASEME
		(0x1DA00 <= code && code <= 0x1DA36) || // Mn  [55] SIGNWRITING HEAD RIM..SIGNWRITING AIR SUCKING IN
		(0x1DA3B <= code && code <= 0x1DA6C) || // Mn  [50] SIGNWRITING MOUTH CLOSED NEUTRAL..SIGNWRITING EXCITEMENT
		0x1DA75 == code || // Mn       SIGNWRITING UPPER BODY TILTING FROM HIP JOINTS
		0x1DA84 == code || // Mn       SIGNWRITING LOCATION HEAD NECK
		(0x1DA9B <= code && code <= 0x1DA9F) || // Mn   [5] SIGNWRITING FILL MODIFIER-2..SIGNWRITING FILL MODIFIER-6
		(0x1DAA1 <= code && code <= 0x1DAAF) || // Mn  [15] SIGNWRITING ROTATION MODIFIER-2..SIGNWRITING ROTATION MODIFIER-16
		(0x1E000 <= code && code <= 0x1E006) || // Mn   [7] COMBINING GLAGOLITIC LETTER AZU..COMBINING GLAGOLITIC LETTER ZHIVETE
		(0x1E008 <= code && code <= 0x1E018) || // Mn  [17] COMBINING GLAGOLITIC LETTER ZEMLJA..COMBINING GLAGOLITIC LETTER HERU
		(0x1E01B <= code && code <= 0x1E021) || // Mn   [7] COMBINING GLAGOLITIC LETTER SHTA..COMBINING GLAGOLITIC LETTER YATI
		(0x1E023 <= code && code <= 0x1E024) || // Mn   [2] COMBINING GLAGOLITIC LETTER YU..COMBINING GLAGOLITIC LETTER SMALL YUS
		(0x1E026 <= code && code <= 0x1E02A) || // Mn   [5] COMBINING GLAGOLITIC LETTER YO..COMBINING GLAGOLITIC LETTER FITA
		(0x1E8D0 <= code && code <= 0x1E8D6) || // Mn   [7] MENDE KIKAKUI COMBINING NUMBER TEENS..MENDE KIKAKUI COMBINING NUMBER MILLIONS
		(0x1E944 <= code && code <= 0x1E94A) || // Mn   [7] ADLAM ALIF LENGTHENER..ADLAM NUKTA
		(0xE0020 <= code && code <= 0xE007F) || // Cf  [96] TAG SPACE..CANCEL TAG
		(0xE0100 <= code && code <= 0xE01EF) // Mn [240] VARIATION SELECTOR-17..VARIATION SELECTOR-256
		){
			return Extend;
		}
		
		
		if(
		(0x1F1E6 <= code && code <= 0x1F1FF) // So  [26] REGIONAL INDICATOR SYMBOL LETTER A..REGIONAL INDICATOR SYMBOL LETTER Z
		){
			return Regional_Indicator;
		}
		
		if(
		0x0903 == code || // Mc       DEVANAGARI SIGN VISARGA
		0x093B == code || // Mc       DEVANAGARI VOWEL SIGN OOE
		(0x093E <= code && code <= 0x0940) || // Mc   [3] DEVANAGARI VOWEL SIGN AA..DEVANAGARI VOWEL SIGN II
		(0x0949 <= code && code <= 0x094C) || // Mc   [4] DEVANAGARI VOWEL SIGN CANDRA O..DEVANAGARI VOWEL SIGN AU
		(0x094E <= code && code <= 0x094F) || // Mc   [2] DEVANAGARI VOWEL SIGN PRISHTHAMATRA E..DEVANAGARI VOWEL SIGN AW
		(0x0982 <= code && code <= 0x0983) || // Mc   [2] BENGALI SIGN ANUSVARA..BENGALI SIGN VISARGA
		(0x09BF <= code && code <= 0x09C0) || // Mc   [2] BENGALI VOWEL SIGN I..BENGALI VOWEL SIGN II
		(0x09C7 <= code && code <= 0x09C8) || // Mc   [2] BENGALI VOWEL SIGN E..BENGALI VOWEL SIGN AI
		(0x09CB <= code && code <= 0x09CC) || // Mc   [2] BENGALI VOWEL SIGN O..BENGALI VOWEL SIGN AU
		0x0A03 == code || // Mc       GURMUKHI SIGN VISARGA
		(0x0A3E <= code && code <= 0x0A40) || // Mc   [3] GURMUKHI VOWEL SIGN AA..GURMUKHI VOWEL SIGN II
		0x0A83 == code || // Mc       GUJARATI SIGN VISARGA
		(0x0ABE <= code && code <= 0x0AC0) || // Mc   [3] GUJARATI VOWEL SIGN AA..GUJARATI VOWEL SIGN II
		0x0AC9 == code || // Mc       GUJARATI VOWEL SIGN CANDRA O
		(0x0ACB <= code && code <= 0x0ACC) || // Mc   [2] GUJARATI VOWEL SIGN O..GUJARATI VOWEL SIGN AU
		(0x0B02 <= code && code <= 0x0B03) || // Mc   [2] ORIYA SIGN ANUSVARA..ORIYA SIGN VISARGA
		0x0B40 == code || // Mc       ORIYA VOWEL SIGN II
		(0x0B47 <= code && code <= 0x0B48) || // Mc   [2] ORIYA VOWEL SIGN E..ORIYA VOWEL SIGN AI
		(0x0B4B <= code && code <= 0x0B4C) || // Mc   [2] ORIYA VOWEL SIGN O..ORIYA VOWEL SIGN AU
		0x0BBF == code || // Mc       TAMIL VOWEL SIGN I
		(0x0BC1 <= code && code <= 0x0BC2) || // Mc   [2] TAMIL VOWEL SIGN U..TAMIL VOWEL SIGN UU
		(0x0BC6 <= code && code <= 0x0BC8) || // Mc   [3] TAMIL VOWEL SIGN E..TAMIL VOWEL SIGN AI
		(0x0BCA <= code && code <= 0x0BCC) || // Mc   [3] TAMIL VOWEL SIGN O..TAMIL VOWEL SIGN AU
		(0x0C01 <= code && code <= 0x0C03) || // Mc   [3] TELUGU SIGN CANDRABINDU..TELUGU SIGN VISARGA
		(0x0C41 <= code && code <= 0x0C44) || // Mc   [4] TELUGU VOWEL SIGN U..TELUGU VOWEL SIGN VOCALIC RR
		(0x0C82 <= code && code <= 0x0C83) || // Mc   [2] KANNADA SIGN ANUSVARA..KANNADA SIGN VISARGA
		0x0CBE == code || // Mc       KANNADA VOWEL SIGN AA
		(0x0CC0 <= code && code <= 0x0CC1) || // Mc   [2] KANNADA VOWEL SIGN II..KANNADA VOWEL SIGN U
		(0x0CC3 <= code && code <= 0x0CC4) || // Mc   [2] KANNADA VOWEL SIGN VOCALIC R..KANNADA VOWEL SIGN VOCALIC RR
		(0x0CC7 <= code && code <= 0x0CC8) || // Mc   [2] KANNADA VOWEL SIGN EE..KANNADA VOWEL SIGN AI
		(0x0CCA <= code && code <= 0x0CCB) || // Mc   [2] KANNADA VOWEL SIGN O..KANNADA VOWEL SIGN OO
		(0x0D02 <= code && code <= 0x0D03) || // Mc   [2] MALAYALAM SIGN ANUSVARA..MALAYALAM SIGN VISARGA
		(0x0D3F <= code && code <= 0x0D40) || // Mc   [2] MALAYALAM VOWEL SIGN I..MALAYALAM VOWEL SIGN II
		(0x0D46 <= code && code <= 0x0D48) || // Mc   [3] MALAYALAM VOWEL SIGN E..MALAYALAM VOWEL SIGN AI
		(0x0D4A <= code && code <= 0x0D4C) || // Mc   [3] MALAYALAM VOWEL SIGN O..MALAYALAM VOWEL SIGN AU
		(0x0D82 <= code && code <= 0x0D83) || // Mc   [2] SINHALA SIGN ANUSVARAYA..SINHALA SIGN VISARGAYA
		(0x0DD0 <= code && code <= 0x0DD1) || // Mc   [2] SINHALA VOWEL SIGN KETTI AEDA-PILLA..SINHALA VOWEL SIGN DIGA AEDA-PILLA
		(0x0DD8 <= code && code <= 0x0DDE) || // Mc   [7] SINHALA VOWEL SIGN GAETTA-PILLA..SINHALA VOWEL SIGN KOMBUVA HAA GAYANUKITTA
		(0x0DF2 <= code && code <= 0x0DF3) || // Mc   [2] SINHALA VOWEL SIGN DIGA GAETTA-PILLA..SINHALA VOWEL SIGN DIGA GAYANUKITTA
		0x0E33 == code || // Lo       THAI CHARACTER SARA AM
		0x0EB3 == code || // Lo       LAO VOWEL SIGN AM
		(0x0F3E <= code && code <= 0x0F3F) || // Mc   [2] TIBETAN SIGN YAR TSHES..TIBETAN SIGN MAR TSHES
		0x0F7F == code || // Mc       TIBETAN SIGN RNAM BCAD
		0x1031 == code || // Mc       MYANMAR VOWEL SIGN E
		(0x103B <= code && code <= 0x103C) || // Mc   [2] MYANMAR CONSONANT SIGN MEDIAL YA..MYANMAR CONSONANT SIGN MEDIAL RA
		(0x1056 <= code && code <= 0x1057) || // Mc   [2] MYANMAR VOWEL SIGN VOCALIC R..MYANMAR VOWEL SIGN VOCALIC RR
		0x1084 == code || // Mc       MYANMAR VOWEL SIGN SHAN E
		0x17B6 == code || // Mc       KHMER VOWEL SIGN AA
		(0x17BE <= code && code <= 0x17C5) || // Mc   [8] KHMER VOWEL SIGN OE..KHMER VOWEL SIGN AU
		(0x17C7 <= code && code <= 0x17C8) || // Mc   [2] KHMER SIGN REAHMUK..KHMER SIGN YUUKALEAPINTU
		(0x1923 <= code && code <= 0x1926) || // Mc   [4] LIMBU VOWEL SIGN EE..LIMBU VOWEL SIGN AU
		(0x1929 <= code && code <= 0x192B) || // Mc   [3] LIMBU SUBJOINED LETTER YA..LIMBU SUBJOINED LETTER WA
		(0x1930 <= code && code <= 0x1931) || // Mc   [2] LIMBU SMALL LETTER KA..LIMBU SMALL LETTER NGA
		(0x1933 <= code && code <= 0x1938) || // Mc   [6] LIMBU SMALL LETTER TA..LIMBU SMALL LETTER LA
		(0x1A19 <= code && code <= 0x1A1A) || // Mc   [2] BUGINESE VOWEL SIGN E..BUGINESE VOWEL SIGN O
		0x1A55 == code || // Mc       TAI THAM CONSONANT SIGN MEDIAL RA
		0x1A57 == code || // Mc       TAI THAM CONSONANT SIGN LA TANG LAI
		(0x1A6D <= code && code <= 0x1A72) || // Mc   [6] TAI THAM VOWEL SIGN OY..TAI THAM VOWEL SIGN THAM AI
		0x1B04 == code || // Mc       BALINESE SIGN BISAH
		0x1B35 == code || // Mc       BALINESE VOWEL SIGN TEDUNG
		0x1B3B == code || // Mc       BALINESE VOWEL SIGN RA REPA TEDUNG
		(0x1B3D <= code && code <= 0x1B41) || // Mc   [5] BALINESE VOWEL SIGN LA LENGA TEDUNG..BALINESE VOWEL SIGN TALING REPA TEDUNG
		(0x1B43 <= code && code <= 0x1B44) || // Mc   [2] BALINESE VOWEL SIGN PEPET TEDUNG..BALINESE ADEG ADEG
		0x1B82 == code || // Mc       SUNDANESE SIGN PANGWISAD
		0x1BA1 == code || // Mc       SUNDANESE CONSONANT SIGN PAMINGKAL
		(0x1BA6 <= code && code <= 0x1BA7) || // Mc   [2] SUNDANESE VOWEL SIGN PANAELAENG..SUNDANESE VOWEL SIGN PANOLONG
		0x1BAA == code || // Mc       SUNDANESE SIGN PAMAAEH
		0x1BE7 == code || // Mc       BATAK VOWEL SIGN E
		(0x1BEA <= code && code <= 0x1BEC) || // Mc   [3] BATAK VOWEL SIGN I..BATAK VOWEL SIGN O
		0x1BEE == code || // Mc       BATAK VOWEL SIGN U
		(0x1BF2 <= code && code <= 0x1BF3) || // Mc   [2] BATAK PANGOLAT..BATAK PANONGONAN
		(0x1C24 <= code && code <= 0x1C2B) || // Mc   [8] LEPCHA SUBJOINED LETTER YA..LEPCHA VOWEL SIGN UU
		(0x1C34 <= code && code <= 0x1C35) || // Mc   [2] LEPCHA CONSONANT SIGN NYIN-DO..LEPCHA CONSONANT SIGN KANG
		0x1CE1 == code || // Mc       VEDIC TONE ATHARVAVEDIC INDEPENDENT SVARITA
		(0x1CF2 <= code && code <= 0x1CF3) || // Mc   [2] VEDIC SIGN ARDHAVISARGA..VEDIC SIGN ROTATED ARDHAVISARGA
		0x1CF7 == code || // Mc       VEDIC SIGN ATIKRAMA
		(0xA823 <= code && code <= 0xA824) || // Mc   [2] SYLOTI NAGRI VOWEL SIGN A..SYLOTI NAGRI VOWEL SIGN I
		0xA827 == code || // Mc       SYLOTI NAGRI VOWEL SIGN OO
		(0xA880 <= code && code <= 0xA881) || // Mc   [2] SAURASHTRA SIGN ANUSVARA..SAURASHTRA SIGN VISARGA
		(0xA8B4 <= code && code <= 0xA8C3) || // Mc  [16] SAURASHTRA CONSONANT SIGN HAARU..SAURASHTRA VOWEL SIGN AU
		(0xA952 <= code && code <= 0xA953) || // Mc   [2] REJANG CONSONANT SIGN H..REJANG VIRAMA
		0xA983 == code || // Mc       JAVANESE SIGN WIGNYAN
		(0xA9B4 <= code && code <= 0xA9B5) || // Mc   [2] JAVANESE VOWEL SIGN TARUNG..JAVANESE VOWEL SIGN TOLONG
		(0xA9BA <= code && code <= 0xA9BB) || // Mc   [2] JAVANESE VOWEL SIGN TALING..JAVANESE VOWEL SIGN DIRGA MURE
		(0xA9BD <= code && code <= 0xA9C0) || // Mc   [4] JAVANESE CONSONANT SIGN KERET..JAVANESE PANGKON
		(0xAA2F <= code && code <= 0xAA30) || // Mc   [2] CHAM VOWEL SIGN O..CHAM VOWEL SIGN AI
		(0xAA33 <= code && code <= 0xAA34) || // Mc   [2] CHAM CONSONANT SIGN YA..CHAM CONSONANT SIGN RA
		0xAA4D == code || // Mc       CHAM CONSONANT SIGN FINAL H
		0xAAEB == code || // Mc       MEETEI MAYEK VOWEL SIGN II
		(0xAAEE <= code && code <= 0xAAEF) || // Mc   [2] MEETEI MAYEK VOWEL SIGN AU..MEETEI MAYEK VOWEL SIGN AAU
		0xAAF5 == code || // Mc       MEETEI MAYEK VOWEL SIGN VISARGA
		(0xABE3 <= code && code <= 0xABE4) || // Mc   [2] MEETEI MAYEK VOWEL SIGN ONAP..MEETEI MAYEK VOWEL SIGN INAP
		(0xABE6 <= code && code <= 0xABE7) || // Mc   [2] MEETEI MAYEK VOWEL SIGN YENAP..MEETEI MAYEK VOWEL SIGN SOUNAP
		(0xABE9 <= code && code <= 0xABEA) || // Mc   [2] MEETEI MAYEK VOWEL SIGN CHEINAP..MEETEI MAYEK VOWEL SIGN NUNG
		0xABEC == code || // Mc       MEETEI MAYEK LUM IYEK
		0x11000 == code || // Mc       BRAHMI SIGN CANDRABINDU
		0x11002 == code || // Mc       BRAHMI SIGN VISARGA
		0x11082 == code || // Mc       KAITHI SIGN VISARGA
		(0x110B0 <= code && code <= 0x110B2) || // Mc   [3] KAITHI VOWEL SIGN AA..KAITHI VOWEL SIGN II
		(0x110B7 <= code && code <= 0x110B8) || // Mc   [2] KAITHI VOWEL SIGN O..KAITHI VOWEL SIGN AU
		0x1112C == code || // Mc       CHAKMA VOWEL SIGN E
		0x11182 == code || // Mc       SHARADA SIGN VISARGA
		(0x111B3 <= code && code <= 0x111B5) || // Mc   [3] SHARADA VOWEL SIGN AA..SHARADA VOWEL SIGN II
		(0x111BF <= code && code <= 0x111C0) || // Mc   [2] SHARADA VOWEL SIGN AU..SHARADA SIGN VIRAMA
		(0x1122C <= code && code <= 0x1122E) || // Mc   [3] KHOJKI VOWEL SIGN AA..KHOJKI VOWEL SIGN II
		(0x11232 <= code && code <= 0x11233) || // Mc   [2] KHOJKI VOWEL SIGN O..KHOJKI VOWEL SIGN AU
		0x11235 == code || // Mc       KHOJKI SIGN VIRAMA
		(0x112E0 <= code && code <= 0x112E2) || // Mc   [3] KHUDAWADI VOWEL SIGN AA..KHUDAWADI VOWEL SIGN II
		(0x11302 <= code && code <= 0x11303) || // Mc   [2] GRANTHA SIGN ANUSVARA..GRANTHA SIGN VISARGA
		0x1133F == code || // Mc       GRANTHA VOWEL SIGN I
		(0x11341 <= code && code <= 0x11344) || // Mc   [4] GRANTHA VOWEL SIGN U..GRANTHA VOWEL SIGN VOCALIC RR
		(0x11347 <= code && code <= 0x11348) || // Mc   [2] GRANTHA VOWEL SIGN EE..GRANTHA VOWEL SIGN AI
		(0x1134B <= code && code <= 0x1134D) || // Mc   [3] GRANTHA VOWEL SIGN OO..GRANTHA SIGN VIRAMA
		(0x11362 <= code && code <= 0x11363) || // Mc   [2] GRANTHA VOWEL SIGN VOCALIC L..GRANTHA VOWEL SIGN VOCALIC LL
		(0x11435 <= code && code <= 0x11437) || // Mc   [3] NEWA VOWEL SIGN AA..NEWA VOWEL SIGN II
		(0x11440 <= code && code <= 0x11441) || // Mc   [2] NEWA VOWEL SIGN O..NEWA VOWEL SIGN AU
		0x11445 == code || // Mc       NEWA SIGN VISARGA
		(0x114B1 <= code && code <= 0x114B2) || // Mc   [2] TIRHUTA VOWEL SIGN I..TIRHUTA VOWEL SIGN II
		0x114B9 == code || // Mc       TIRHUTA VOWEL SIGN E
		(0x114BB <= code && code <= 0x114BC) || // Mc   [2] TIRHUTA VOWEL SIGN AI..TIRHUTA VOWEL SIGN O
		0x114BE == code || // Mc       TIRHUTA VOWEL SIGN AU
		0x114C1 == code || // Mc       TIRHUTA SIGN VISARGA
		(0x115B0 <= code && code <= 0x115B1) || // Mc   [2] SIDDHAM VOWEL SIGN I..SIDDHAM VOWEL SIGN II
		(0x115B8 <= code && code <= 0x115BB) || // Mc   [4] SIDDHAM VOWEL SIGN E..SIDDHAM VOWEL SIGN AU
		0x115BE == code || // Mc       SIDDHAM SIGN VISARGA
		(0x11630 <= code && code <= 0x11632) || // Mc   [3] MODI VOWEL SIGN AA..MODI VOWEL SIGN II
		(0x1163B <= code && code <= 0x1163C) || // Mc   [2] MODI VOWEL SIGN O..MODI VOWEL SIGN AU
		0x1163E == code || // Mc       MODI SIGN VISARGA
		0x116AC == code || // Mc       TAKRI SIGN VISARGA
		(0x116AE <= code && code <= 0x116AF) || // Mc   [2] TAKRI VOWEL SIGN I..TAKRI VOWEL SIGN II
		0x116B6 == code || // Mc       TAKRI SIGN VIRAMA
		(0x11720 <= code && code <= 0x11721) || // Mc   [2] AHOM VOWEL SIGN A..AHOM VOWEL SIGN AA
		0x11726 == code || // Mc       AHOM VOWEL SIGN E
		(0x11A07 <= code && code <= 0x11A08) || // Mc   [2] ZANABAZAR SQUARE VOWEL SIGN AI..ZANABAZAR SQUARE VOWEL SIGN AU
		0x11A39 == code || // Mc       ZANABAZAR SQUARE SIGN VISARGA
		(0x11A57 <= code && code <= 0x11A58) || // Mc   [2] SOYOMBO VOWEL SIGN AI..SOYOMBO VOWEL SIGN AU
		0x11A97 == code || // Mc       SOYOMBO SIGN VISARGA
		0x11C2F == code || // Mc       BHAIKSUKI VOWEL SIGN AA
		0x11C3E == code || // Mc       BHAIKSUKI SIGN VISARGA
		0x11CA9 == code || // Mc       MARCHEN SUBJOINED LETTER YA
		0x11CB1 == code || // Mc       MARCHEN VOWEL SIGN I
		0x11CB4 == code || // Mc       MARCHEN VOWEL SIGN O
		(0x16F51 <= code && code <= 0x16F7E) || // Mc  [46] MIAO SIGN ASPIRATION..MIAO VOWEL SIGN NG
		0x1D166 == code || // Mc       MUSICAL SYMBOL COMBINING SPRECHGESANG STEM
		0x1D16D == code // Mc       MUSICAL SYMBOL COMBINING AUGMENTATION DOT
		){
			return SpacingMark;
		}
		
		
		if(
		(0x1100 <= code && code <= 0x115F) || // Lo  [96] HANGUL CHOSEONG KIYEOK..HANGUL CHOSEONG FILLER
		(0xA960 <= code && code <= 0xA97C) // Lo  [29] HANGUL CHOSEONG TIKEUT-MIEUM..HANGUL CHOSEONG SSANGYEORINHIEUH
		){
			return L;
		}
		
		if(
		(0x1160 <= code && code <= 0x11A7) || // Lo  [72] HANGUL JUNGSEONG FILLER..HANGUL JUNGSEONG O-YAE
		(0xD7B0 <= code && code <= 0xD7C6) // Lo  [23] HANGUL JUNGSEONG O-YEO..HANGUL JUNGSEONG ARAEA-E
		){
			return V;
		}
		
		
		if(
		(0x11A8 <= code && code <= 0x11FF) || // Lo  [88] HANGUL JONGSEONG KIYEOK..HANGUL JONGSEONG SSANGNIEUN
		(0xD7CB <= code && code <= 0xD7FB) // Lo  [49] HANGUL JONGSEONG NIEUN-RIEUL..HANGUL JONGSEONG PHIEUPH-THIEUTH
		){
			return T;
		}
		
		if(
		0xAC00 == code || // Lo       HANGUL SYLLABLE GA
		0xAC1C == code || // Lo       HANGUL SYLLABLE GAE
		0xAC38 == code || // Lo       HANGUL SYLLABLE GYA
		0xAC54 == code || // Lo       HANGUL SYLLABLE GYAE
		0xAC70 == code || // Lo       HANGUL SYLLABLE GEO
		0xAC8C == code || // Lo       HANGUL SYLLABLE GE
		0xACA8 == code || // Lo       HANGUL SYLLABLE GYEO
		0xACC4 == code || // Lo       HANGUL SYLLABLE GYE
		0xACE0 == code || // Lo       HANGUL SYLLABLE GO
		0xACFC == code || // Lo       HANGUL SYLLABLE GWA
		0xAD18 == code || // Lo       HANGUL SYLLABLE GWAE
		0xAD34 == code || // Lo       HANGUL SYLLABLE GOE
		0xAD50 == code || // Lo       HANGUL SYLLABLE GYO
		0xAD6C == code || // Lo       HANGUL SYLLABLE GU
		0xAD88 == code || // Lo       HANGUL SYLLABLE GWEO
		0xADA4 == code || // Lo       HANGUL SYLLABLE GWE
		0xADC0 == code || // Lo       HANGUL SYLLABLE GWI
		0xADDC == code || // Lo       HANGUL SYLLABLE GYU
		0xADF8 == code || // Lo       HANGUL SYLLABLE GEU
		0xAE14 == code || // Lo       HANGUL SYLLABLE GYI
		0xAE30 == code || // Lo       HANGUL SYLLABLE GI
		0xAE4C == code || // Lo       HANGUL SYLLABLE GGA
		0xAE68 == code || // Lo       HANGUL SYLLABLE GGAE
		0xAE84 == code || // Lo       HANGUL SYLLABLE GGYA
		0xAEA0 == code || // Lo       HANGUL SYLLABLE GGYAE
		0xAEBC == code || // Lo       HANGUL SYLLABLE GGEO
		0xAED8 == code || // Lo       HANGUL SYLLABLE GGE
		0xAEF4 == code || // Lo       HANGUL SYLLABLE GGYEO
		0xAF10 == code || // Lo       HANGUL SYLLABLE GGYE
		0xAF2C == code || // Lo       HANGUL SYLLABLE GGO
		0xAF48 == code || // Lo       HANGUL SYLLABLE GGWA
		0xAF64 == code || // Lo       HANGUL SYLLABLE GGWAE
		0xAF80 == code || // Lo       HANGUL SYLLABLE GGOE
		0xAF9C == code || // Lo       HANGUL SYLLABLE GGYO
		0xAFB8 == code || // Lo       HANGUL SYLLABLE GGU
		0xAFD4 == code || // Lo       HANGUL SYLLABLE GGWEO
		0xAFF0 == code || // Lo       HANGUL SYLLABLE GGWE
		0xB00C == code || // Lo       HANGUL SYLLABLE GGWI
		0xB028 == code || // Lo       HANGUL SYLLABLE GGYU
		0xB044 == code || // Lo       HANGUL SYLLABLE GGEU
		0xB060 == code || // Lo       HANGUL SYLLABLE GGYI
		0xB07C == code || // Lo       HANGUL SYLLABLE GGI
		0xB098 == code || // Lo       HANGUL SYLLABLE NA
		0xB0B4 == code || // Lo       HANGUL SYLLABLE NAE
		0xB0D0 == code || // Lo       HANGUL SYLLABLE NYA
		0xB0EC == code || // Lo       HANGUL SYLLABLE NYAE
		0xB108 == code || // Lo       HANGUL SYLLABLE NEO
		0xB124 == code || // Lo       HANGUL SYLLABLE NE
		0xB140 == code || // Lo       HANGUL SYLLABLE NYEO
		0xB15C == code || // Lo       HANGUL SYLLABLE NYE
		0xB178 == code || // Lo       HANGUL SYLLABLE NO
		0xB194 == code || // Lo       HANGUL SYLLABLE NWA
		0xB1B0 == code || // Lo       HANGUL SYLLABLE NWAE
		0xB1CC == code || // Lo       HANGUL SYLLABLE NOE
		0xB1E8 == code || // Lo       HANGUL SYLLABLE NYO
		0xB204 == code || // Lo       HANGUL SYLLABLE NU
		0xB220 == code || // Lo       HANGUL SYLLABLE NWEO
		0xB23C == code || // Lo       HANGUL SYLLABLE NWE
		0xB258 == code || // Lo       HANGUL SYLLABLE NWI
		0xB274 == code || // Lo       HANGUL SYLLABLE NYU
		0xB290 == code || // Lo       HANGUL SYLLABLE NEU
		0xB2AC == code || // Lo       HANGUL SYLLABLE NYI
		0xB2C8 == code || // Lo       HANGUL SYLLABLE NI
		0xB2E4 == code || // Lo       HANGUL SYLLABLE DA
		0xB300 == code || // Lo       HANGUL SYLLABLE DAE
		0xB31C == code || // Lo       HANGUL SYLLABLE DYA
		0xB338 == code || // Lo       HANGUL SYLLABLE DYAE
		0xB354 == code || // Lo       HANGUL SYLLABLE DEO
		0xB370 == code || // Lo       HANGUL SYLLABLE DE
		0xB38C == code || // Lo       HANGUL SYLLABLE DYEO
		0xB3A8 == code || // Lo       HANGUL SYLLABLE DYE
		0xB3C4 == code || // Lo       HANGUL SYLLABLE DO
		0xB3E0 == code || // Lo       HANGUL SYLLABLE DWA
		0xB3FC == code || // Lo       HANGUL SYLLABLE DWAE
		0xB418 == code || // Lo       HANGUL SYLLABLE DOE
		0xB434 == code || // Lo       HANGUL SYLLABLE DYO
		0xB450 == code || // Lo       HANGUL SYLLABLE DU
		0xB46C == code || // Lo       HANGUL SYLLABLE DWEO
		0xB488 == code || // Lo       HANGUL SYLLABLE DWE
		0xB4A4 == code || // Lo       HANGUL SYLLABLE DWI
		0xB4C0 == code || // Lo       HANGUL SYLLABLE DYU
		0xB4DC == code || // Lo       HANGUL SYLLABLE DEU
		0xB4F8 == code || // Lo       HANGUL SYLLABLE DYI
		0xB514 == code || // Lo       HANGUL SYLLABLE DI
		0xB530 == code || // Lo       HANGUL SYLLABLE DDA
		0xB54C == code || // Lo       HANGUL SYLLABLE DDAE
		0xB568 == code || // Lo       HANGUL SYLLABLE DDYA
		0xB584 == code || // Lo       HANGUL SYLLABLE DDYAE
		0xB5A0 == code || // Lo       HANGUL SYLLABLE DDEO
		0xB5BC == code || // Lo       HANGUL SYLLABLE DDE
		0xB5D8 == code || // Lo       HANGUL SYLLABLE DDYEO
		0xB5F4 == code || // Lo       HANGUL SYLLABLE DDYE
		0xB610 == code || // Lo       HANGUL SYLLABLE DDO
		0xB62C == code || // Lo       HANGUL SYLLABLE DDWA
		0xB648 == code || // Lo       HANGUL SYLLABLE DDWAE
		0xB664 == code || // Lo       HANGUL SYLLABLE DDOE
		0xB680 == code || // Lo       HANGUL SYLLABLE DDYO
		0xB69C == code || // Lo       HANGUL SYLLABLE DDU
		0xB6B8 == code || // Lo       HANGUL SYLLABLE DDWEO
		0xB6D4 == code || // Lo       HANGUL SYLLABLE DDWE
		0xB6F0 == code || // Lo       HANGUL SYLLABLE DDWI
		0xB70C == code || // Lo       HANGUL SYLLABLE DDYU
		0xB728 == code || // Lo       HANGUL SYLLABLE DDEU
		0xB744 == code || // Lo       HANGUL SYLLABLE DDYI
		0xB760 == code || // Lo       HANGUL SYLLABLE DDI
		0xB77C == code || // Lo       HANGUL SYLLABLE RA
		0xB798 == code || // Lo       HANGUL SYLLABLE RAE
		0xB7B4 == code || // Lo       HANGUL SYLLABLE RYA
		0xB7D0 == code || // Lo       HANGUL SYLLABLE RYAE
		0xB7EC == code || // Lo       HANGUL SYLLABLE REO
		0xB808 == code || // Lo       HANGUL SYLLABLE RE
		0xB824 == code || // Lo       HANGUL SYLLABLE RYEO
		0xB840 == code || // Lo       HANGUL SYLLABLE RYE
		0xB85C == code || // Lo       HANGUL SYLLABLE RO
		0xB878 == code || // Lo       HANGUL SYLLABLE RWA
		0xB894 == code || // Lo       HANGUL SYLLABLE RWAE
		0xB8B0 == code || // Lo       HANGUL SYLLABLE ROE
		0xB8CC == code || // Lo       HANGUL SYLLABLE RYO
		0xB8E8 == code || // Lo       HANGUL SYLLABLE RU
		0xB904 == code || // Lo       HANGUL SYLLABLE RWEO
		0xB920 == code || // Lo       HANGUL SYLLABLE RWE
		0xB93C == code || // Lo       HANGUL SYLLABLE RWI
		0xB958 == code || // Lo       HANGUL SYLLABLE RYU
		0xB974 == code || // Lo       HANGUL SYLLABLE REU
		0xB990 == code || // Lo       HANGUL SYLLABLE RYI
		0xB9AC == code || // Lo       HANGUL SYLLABLE RI
		0xB9C8 == code || // Lo       HANGUL SYLLABLE MA
		0xB9E4 == code || // Lo       HANGUL SYLLABLE MAE
		0xBA00 == code || // Lo       HANGUL SYLLABLE MYA
		0xBA1C == code || // Lo       HANGUL SYLLABLE MYAE
		0xBA38 == code || // Lo       HANGUL SYLLABLE MEO
		0xBA54 == code || // Lo       HANGUL SYLLABLE ME
		0xBA70 == code || // Lo       HANGUL SYLLABLE MYEO
		0xBA8C == code || // Lo       HANGUL SYLLABLE MYE
		0xBAA8 == code || // Lo       HANGUL SYLLABLE MO
		0xBAC4 == code || // Lo       HANGUL SYLLABLE MWA
		0xBAE0 == code || // Lo       HANGUL SYLLABLE MWAE
		0xBAFC == code || // Lo       HANGUL SYLLABLE MOE
		0xBB18 == code || // Lo       HANGUL SYLLABLE MYO
		0xBB34 == code || // Lo       HANGUL SYLLABLE MU
		0xBB50 == code || // Lo       HANGUL SYLLABLE MWEO
		0xBB6C == code || // Lo       HANGUL SYLLABLE MWE
		0xBB88 == code || // Lo       HANGUL SYLLABLE MWI
		0xBBA4 == code || // Lo       HANGUL SYLLABLE MYU
		0xBBC0 == code || // Lo       HANGUL SYLLABLE MEU
		0xBBDC == code || // Lo       HANGUL SYLLABLE MYI
		0xBBF8 == code || // Lo       HANGUL SYLLABLE MI
		0xBC14 == code || // Lo       HANGUL SYLLABLE BA
		0xBC30 == code || // Lo       HANGUL SYLLABLE BAE
		0xBC4C == code || // Lo       HANGUL SYLLABLE BYA
		0xBC68 == code || // Lo       HANGUL SYLLABLE BYAE
		0xBC84 == code || // Lo       HANGUL SYLLABLE BEO
		0xBCA0 == code || // Lo       HANGUL SYLLABLE BE
		0xBCBC == code || // Lo       HANGUL SYLLABLE BYEO
		0xBCD8 == code || // Lo       HANGUL SYLLABLE BYE
		0xBCF4 == code || // Lo       HANGUL SYLLABLE BO
		0xBD10 == code || // Lo       HANGUL SYLLABLE BWA
		0xBD2C == code || // Lo       HANGUL SYLLABLE BWAE
		0xBD48 == code || // Lo       HANGUL SYLLABLE BOE
		0xBD64 == code || // Lo       HANGUL SYLLABLE BYO
		0xBD80 == code || // Lo       HANGUL SYLLABLE BU
		0xBD9C == code || // Lo       HANGUL SYLLABLE BWEO
		0xBDB8 == code || // Lo       HANGUL SYLLABLE BWE
		0xBDD4 == code || // Lo       HANGUL SYLLABLE BWI
		0xBDF0 == code || // Lo       HANGUL SYLLABLE BYU
		0xBE0C == code || // Lo       HANGUL SYLLABLE BEU
		0xBE28 == code || // Lo       HANGUL SYLLABLE BYI
		0xBE44 == code || // Lo       HANGUL SYLLABLE BI
		0xBE60 == code || // Lo       HANGUL SYLLABLE BBA
		0xBE7C == code || // Lo       HANGUL SYLLABLE BBAE
		0xBE98 == code || // Lo       HANGUL SYLLABLE BBYA
		0xBEB4 == code || // Lo       HANGUL SYLLABLE BBYAE
		0xBED0 == code || // Lo       HANGUL SYLLABLE BBEO
		0xBEEC == code || // Lo       HANGUL SYLLABLE BBE
		0xBF08 == code || // Lo       HANGUL SYLLABLE BBYEO
		0xBF24 == code || // Lo       HANGUL SYLLABLE BBYE
		0xBF40 == code || // Lo       HANGUL SYLLABLE BBO
		0xBF5C == code || // Lo       HANGUL SYLLABLE BBWA
		0xBF78 == code || // Lo       HANGUL SYLLABLE BBWAE
		0xBF94 == code || // Lo       HANGUL SYLLABLE BBOE
		0xBFB0 == code || // Lo       HANGUL SYLLABLE BBYO
		0xBFCC == code || // Lo       HANGUL SYLLABLE BBU
		0xBFE8 == code || // Lo       HANGUL SYLLABLE BBWEO
		0xC004 == code || // Lo       HANGUL SYLLABLE BBWE
		0xC020 == code || // Lo       HANGUL SYLLABLE BBWI
		0xC03C == code || // Lo       HANGUL SYLLABLE BBYU
		0xC058 == code || // Lo       HANGUL SYLLABLE BBEU
		0xC074 == code || // Lo       HANGUL SYLLABLE BBYI
		0xC090 == code || // Lo       HANGUL SYLLABLE BBI
		0xC0AC == code || // Lo       HANGUL SYLLABLE SA
		0xC0C8 == code || // Lo       HANGUL SYLLABLE SAE
		0xC0E4 == code || // Lo       HANGUL SYLLABLE SYA
		0xC100 == code || // Lo       HANGUL SYLLABLE SYAE
		0xC11C == code || // Lo       HANGUL SYLLABLE SEO
		0xC138 == code || // Lo       HANGUL SYLLABLE SE
		0xC154 == code || // Lo       HANGUL SYLLABLE SYEO
		0xC170 == code || // Lo       HANGUL SYLLABLE SYE
		0xC18C == code || // Lo       HANGUL SYLLABLE SO
		0xC1A8 == code || // Lo       HANGUL SYLLABLE SWA
		0xC1C4 == code || // Lo       HANGUL SYLLABLE SWAE
		0xC1E0 == code || // Lo       HANGUL SYLLABLE SOE
		0xC1FC == code || // Lo       HANGUL SYLLABLE SYO
		0xC218 == code || // Lo       HANGUL SYLLABLE SU
		0xC234 == code || // Lo       HANGUL SYLLABLE SWEO
		0xC250 == code || // Lo       HANGUL SYLLABLE SWE
		0xC26C == code || // Lo       HANGUL SYLLABLE SWI
		0xC288 == code || // Lo       HANGUL SYLLABLE SYU
		0xC2A4 == code || // Lo       HANGUL SYLLABLE SEU
		0xC2C0 == code || // Lo       HANGUL SYLLABLE SYI
		0xC2DC == code || // Lo       HANGUL SYLLABLE SI
		0xC2F8 == code || // Lo       HANGUL SYLLABLE SSA
		0xC314 == code || // Lo       HANGUL SYLLABLE SSAE
		0xC330 == code || // Lo       HANGUL SYLLABLE SSYA
		0xC34C == code || // Lo       HANGUL SYLLABLE SSYAE
		0xC368 == code || // Lo       HANGUL SYLLABLE SSEO
		0xC384 == code || // Lo       HANGUL SYLLABLE SSE
		0xC3A0 == code || // Lo       HANGUL SYLLABLE SSYEO
		0xC3BC == code || // Lo       HANGUL SYLLABLE SSYE
		0xC3D8 == code || // Lo       HANGUL SYLLABLE SSO
		0xC3F4 == code || // Lo       HANGUL SYLLABLE SSWA
		0xC410 == code || // Lo       HANGUL SYLLABLE SSWAE
		0xC42C == code || // Lo       HANGUL SYLLABLE SSOE
		0xC448 == code || // Lo       HANGUL SYLLABLE SSYO
		0xC464 == code || // Lo       HANGUL SYLLABLE SSU
		0xC480 == code || // Lo       HANGUL SYLLABLE SSWEO
		0xC49C == code || // Lo       HANGUL SYLLABLE SSWE
		0xC4B8 == code || // Lo       HANGUL SYLLABLE SSWI
		0xC4D4 == code || // Lo       HANGUL SYLLABLE SSYU
		0xC4F0 == code || // Lo       HANGUL SYLLABLE SSEU
		0xC50C == code || // Lo       HANGUL SYLLABLE SSYI
		0xC528 == code || // Lo       HANGUL SYLLABLE SSI
		0xC544 == code || // Lo       HANGUL SYLLABLE A
		0xC560 == code || // Lo       HANGUL SYLLABLE AE
		0xC57C == code || // Lo       HANGUL SYLLABLE YA
		0xC598 == code || // Lo       HANGUL SYLLABLE YAE
		0xC5B4 == code || // Lo       HANGUL SYLLABLE EO
		0xC5D0 == code || // Lo       HANGUL SYLLABLE E
		0xC5EC == code || // Lo       HANGUL SYLLABLE YEO
		0xC608 == code || // Lo       HANGUL SYLLABLE YE
		0xC624 == code || // Lo       HANGUL SYLLABLE O
		0xC640 == code || // Lo       HANGUL SYLLABLE WA
		0xC65C == code || // Lo       HANGUL SYLLABLE WAE
		0xC678 == code || // Lo       HANGUL SYLLABLE OE
		0xC694 == code || // Lo       HANGUL SYLLABLE YO
		0xC6B0 == code || // Lo       HANGUL SYLLABLE U
		0xC6CC == code || // Lo       HANGUL SYLLABLE WEO
		0xC6E8 == code || // Lo       HANGUL SYLLABLE WE
		0xC704 == code || // Lo       HANGUL SYLLABLE WI
		0xC720 == code || // Lo       HANGUL SYLLABLE YU
		0xC73C == code || // Lo       HANGUL SYLLABLE EU
		0xC758 == code || // Lo       HANGUL SYLLABLE YI
		0xC774 == code || // Lo       HANGUL SYLLABLE I
		0xC790 == code || // Lo       HANGUL SYLLABLE JA
		0xC7AC == code || // Lo       HANGUL SYLLABLE JAE
		0xC7C8 == code || // Lo       HANGUL SYLLABLE JYA
		0xC7E4 == code || // Lo       HANGUL SYLLABLE JYAE
		0xC800 == code || // Lo       HANGUL SYLLABLE JEO
		0xC81C == code || // Lo       HANGUL SYLLABLE JE
		0xC838 == code || // Lo       HANGUL SYLLABLE JYEO
		0xC854 == code || // Lo       HANGUL SYLLABLE JYE
		0xC870 == code || // Lo       HANGUL SYLLABLE JO
		0xC88C == code || // Lo       HANGUL SYLLABLE JWA
		0xC8A8 == code || // Lo       HANGUL SYLLABLE JWAE
		0xC8C4 == code || // Lo       HANGUL SYLLABLE JOE
		0xC8E0 == code || // Lo       HANGUL SYLLABLE JYO
		0xC8FC == code || // Lo       HANGUL SYLLABLE JU
		0xC918 == code || // Lo       HANGUL SYLLABLE JWEO
		0xC934 == code || // Lo       HANGUL SYLLABLE JWE
		0xC950 == code || // Lo       HANGUL SYLLABLE JWI
		0xC96C == code || // Lo       HANGUL SYLLABLE JYU
		0xC988 == code || // Lo       HANGUL SYLLABLE JEU
		0xC9A4 == code || // Lo       HANGUL SYLLABLE JYI
		0xC9C0 == code || // Lo       HANGUL SYLLABLE JI
		0xC9DC == code || // Lo       HANGUL SYLLABLE JJA
		0xC9F8 == code || // Lo       HANGUL SYLLABLE JJAE
		0xCA14 == code || // Lo       HANGUL SYLLABLE JJYA
		0xCA30 == code || // Lo       HANGUL SYLLABLE JJYAE
		0xCA4C == code || // Lo       HANGUL SYLLABLE JJEO
		0xCA68 == code || // Lo       HANGUL SYLLABLE JJE
		0xCA84 == code || // Lo       HANGUL SYLLABLE JJYEO
		0xCAA0 == code || // Lo       HANGUL SYLLABLE JJYE
		0xCABC == code || // Lo       HANGUL SYLLABLE JJO
		0xCAD8 == code || // Lo       HANGUL SYLLABLE JJWA
		0xCAF4 == code || // Lo       HANGUL SYLLABLE JJWAE
		0xCB10 == code || // Lo       HANGUL SYLLABLE JJOE
		0xCB2C == code || // Lo       HANGUL SYLLABLE JJYO
		0xCB48 == code || // Lo       HANGUL SYLLABLE JJU
		0xCB64 == code || // Lo       HANGUL SYLLABLE JJWEO
		0xCB80 == code || // Lo       HANGUL SYLLABLE JJWE
		0xCB9C == code || // Lo       HANGUL SYLLABLE JJWI
		0xCBB8 == code || // Lo       HANGUL SYLLABLE JJYU
		0xCBD4 == code || // Lo       HANGUL SYLLABLE JJEU
		0xCBF0 == code || // Lo       HANGUL SYLLABLE JJYI
		0xCC0C == code || // Lo       HANGUL SYLLABLE JJI
		0xCC28 == code || // Lo       HANGUL SYLLABLE CA
		0xCC44 == code || // Lo       HANGUL SYLLABLE CAE
		0xCC60 == code || // Lo       HANGUL SYLLABLE CYA
		0xCC7C == code || // Lo       HANGUL SYLLABLE CYAE
		0xCC98 == code || // Lo       HANGUL SYLLABLE CEO
		0xCCB4 == code || // Lo       HANGUL SYLLABLE CE
		0xCCD0 == code || // Lo       HANGUL SYLLABLE CYEO
		0xCCEC == code || // Lo       HANGUL SYLLABLE CYE
		0xCD08 == code || // Lo       HANGUL SYLLABLE CO
		0xCD24 == code || // Lo       HANGUL SYLLABLE CWA
		0xCD40 == code || // Lo       HANGUL SYLLABLE CWAE
		0xCD5C == code || // Lo       HANGUL SYLLABLE COE
		0xCD78 == code || // Lo       HANGUL SYLLABLE CYO
		0xCD94 == code || // Lo       HANGUL SYLLABLE CU
		0xCDB0 == code || // Lo       HANGUL SYLLABLE CWEO
		0xCDCC == code || // Lo       HANGUL SYLLABLE CWE
		0xCDE8 == code || // Lo       HANGUL SYLLABLE CWI
		0xCE04 == code || // Lo       HANGUL SYLLABLE CYU
		0xCE20 == code || // Lo       HANGUL SYLLABLE CEU
		0xCE3C == code || // Lo       HANGUL SYLLABLE CYI
		0xCE58 == code || // Lo       HANGUL SYLLABLE CI
		0xCE74 == code || // Lo       HANGUL SYLLABLE KA
		0xCE90 == code || // Lo       HANGUL SYLLABLE KAE
		0xCEAC == code || // Lo       HANGUL SYLLABLE KYA
		0xCEC8 == code || // Lo       HANGUL SYLLABLE KYAE
		0xCEE4 == code || // Lo       HANGUL SYLLABLE KEO
		0xCF00 == code || // Lo       HANGUL SYLLABLE KE
		0xCF1C == code || // Lo       HANGUL SYLLABLE KYEO
		0xCF38 == code || // Lo       HANGUL SYLLABLE KYE
		0xCF54 == code || // Lo       HANGUL SYLLABLE KO
		0xCF70 == code || // Lo       HANGUL SYLLABLE KWA
		0xCF8C == code || // Lo       HANGUL SYLLABLE KWAE
		0xCFA8 == code || // Lo       HANGUL SYLLABLE KOE
		0xCFC4 == code || // Lo       HANGUL SYLLABLE KYO
		0xCFE0 == code || // Lo       HANGUL SYLLABLE KU
		0xCFFC == code || // Lo       HANGUL SYLLABLE KWEO
		0xD018 == code || // Lo       HANGUL SYLLABLE KWE
		0xD034 == code || // Lo       HANGUL SYLLABLE KWI
		0xD050 == code || // Lo       HANGUL SYLLABLE KYU
		0xD06C == code || // Lo       HANGUL SYLLABLE KEU
		0xD088 == code || // Lo       HANGUL SYLLABLE KYI
		0xD0A4 == code || // Lo       HANGUL SYLLABLE KI
		0xD0C0 == code || // Lo       HANGUL SYLLABLE TA
		0xD0DC == code || // Lo       HANGUL SYLLABLE TAE
		0xD0F8 == code || // Lo       HANGUL SYLLABLE TYA
		0xD114 == code || // Lo       HANGUL SYLLABLE TYAE
		0xD130 == code || // Lo       HANGUL SYLLABLE TEO
		0xD14C == code || // Lo       HANGUL SYLLABLE TE
		0xD168 == code || // Lo       HANGUL SYLLABLE TYEO
		0xD184 == code || // Lo       HANGUL SYLLABLE TYE
		0xD1A0 == code || // Lo       HANGUL SYLLABLE TO
		0xD1BC == code || // Lo       HANGUL SYLLABLE TWA
		0xD1D8 == code || // Lo       HANGUL SYLLABLE TWAE
		0xD1F4 == code || // Lo       HANGUL SYLLABLE TOE
		0xD210 == code || // Lo       HANGUL SYLLABLE TYO
		0xD22C == code || // Lo       HANGUL SYLLABLE TU
		0xD248 == code || // Lo       HANGUL SYLLABLE TWEO
		0xD264 == code || // Lo       HANGUL SYLLABLE TWE
		0xD280 == code || // Lo       HANGUL SYLLABLE TWI
		0xD29C == code || // Lo       HANGUL SYLLABLE TYU
		0xD2B8 == code || // Lo       HANGUL SYLLABLE TEU
		0xD2D4 == code || // Lo       HANGUL SYLLABLE TYI
		0xD2F0 == code || // Lo       HANGUL SYLLABLE TI
		0xD30C == code || // Lo       HANGUL SYLLABLE PA
		0xD328 == code || // Lo       HANGUL SYLLABLE PAE
		0xD344 == code || // Lo       HANGUL SYLLABLE PYA
		0xD360 == code || // Lo       HANGUL SYLLABLE PYAE
		0xD37C == code || // Lo       HANGUL SYLLABLE PEO
		0xD398 == code || // Lo       HANGUL SYLLABLE PE
		0xD3B4 == code || // Lo       HANGUL SYLLABLE PYEO
		0xD3D0 == code || // Lo       HANGUL SYLLABLE PYE
		0xD3EC == code || // Lo       HANGUL SYLLABLE PO
		0xD408 == code || // Lo       HANGUL SYLLABLE PWA
		0xD424 == code || // Lo       HANGUL SYLLABLE PWAE
		0xD440 == code || // Lo       HANGUL SYLLABLE POE
		0xD45C == code || // Lo       HANGUL SYLLABLE PYO
		0xD478 == code || // Lo       HANGUL SYLLABLE PU
		0xD494 == code || // Lo       HANGUL SYLLABLE PWEO
		0xD4B0 == code || // Lo       HANGUL SYLLABLE PWE
		0xD4CC == code || // Lo       HANGUL SYLLABLE PWI
		0xD4E8 == code || // Lo       HANGUL SYLLABLE PYU
		0xD504 == code || // Lo       HANGUL SYLLABLE PEU
		0xD520 == code || // Lo       HANGUL SYLLABLE PYI
		0xD53C == code || // Lo       HANGUL SYLLABLE PI
		0xD558 == code || // Lo       HANGUL SYLLABLE HA
		0xD574 == code || // Lo       HANGUL SYLLABLE HAE
		0xD590 == code || // Lo       HANGUL SYLLABLE HYA
		0xD5AC == code || // Lo       HANGUL SYLLABLE HYAE
		0xD5C8 == code || // Lo       HANGUL SYLLABLE HEO
		0xD5E4 == code || // Lo       HANGUL SYLLABLE HE
		0xD600 == code || // Lo       HANGUL SYLLABLE HYEO
		0xD61C == code || // Lo       HANGUL SYLLABLE HYE
		0xD638 == code || // Lo       HANGUL SYLLABLE HO
		0xD654 == code || // Lo       HANGUL SYLLABLE HWA
		0xD670 == code || // Lo       HANGUL SYLLABLE HWAE
		0xD68C == code || // Lo       HANGUL SYLLABLE HOE
		0xD6A8 == code || // Lo       HANGUL SYLLABLE HYO
		0xD6C4 == code || // Lo       HANGUL SYLLABLE HU
		0xD6E0 == code || // Lo       HANGUL SYLLABLE HWEO
		0xD6FC == code || // Lo       HANGUL SYLLABLE HWE
		0xD718 == code || // Lo       HANGUL SYLLABLE HWI
		0xD734 == code || // Lo       HANGUL SYLLABLE HYU
		0xD750 == code || // Lo       HANGUL SYLLABLE HEU
		0xD76C == code || // Lo       HANGUL SYLLABLE HYI
		0xD788 == code // Lo       HANGUL SYLLABLE HI
		){
			return LV;
		}
		
		if(
		(0xAC01 <= code && code <= 0xAC1B) || // Lo  [27] HANGUL SYLLABLE GAG..HANGUL SYLLABLE GAH
		(0xAC1D <= code && code <= 0xAC37) || // Lo  [27] HANGUL SYLLABLE GAEG..HANGUL SYLLABLE GAEH
		(0xAC39 <= code && code <= 0xAC53) || // Lo  [27] HANGUL SYLLABLE GYAG..HANGUL SYLLABLE GYAH
		(0xAC55 <= code && code <= 0xAC6F) || // Lo  [27] HANGUL SYLLABLE GYAEG..HANGUL SYLLABLE GYAEH
		(0xAC71 <= code && code <= 0xAC8B) || // Lo  [27] HANGUL SYLLABLE GEOG..HANGUL SYLLABLE GEOH
		(0xAC8D <= code && code <= 0xACA7) || // Lo  [27] HANGUL SYLLABLE GEG..HANGUL SYLLABLE GEH
		(0xACA9 <= code && code <= 0xACC3) || // Lo  [27] HANGUL SYLLABLE GYEOG..HANGUL SYLLABLE GYEOH
		(0xACC5 <= code && code <= 0xACDF) || // Lo  [27] HANGUL SYLLABLE GYEG..HANGUL SYLLABLE GYEH
		(0xACE1 <= code && code <= 0xACFB) || // Lo  [27] HANGUL SYLLABLE GOG..HANGUL SYLLABLE GOH
		(0xACFD <= code && code <= 0xAD17) || // Lo  [27] HANGUL SYLLABLE GWAG..HANGUL SYLLABLE GWAH
		(0xAD19 <= code && code <= 0xAD33) || // Lo  [27] HANGUL SYLLABLE GWAEG..HANGUL SYLLABLE GWAEH
		(0xAD35 <= code && code <= 0xAD4F) || // Lo  [27] HANGUL SYLLABLE GOEG..HANGUL SYLLABLE GOEH
		(0xAD51 <= code && code <= 0xAD6B) || // Lo  [27] HANGUL SYLLABLE GYOG..HANGUL SYLLABLE GYOH
		(0xAD6D <= code && code <= 0xAD87) || // Lo  [27] HANGUL SYLLABLE GUG..HANGUL SYLLABLE GUH
		(0xAD89 <= code && code <= 0xADA3) || // Lo  [27] HANGUL SYLLABLE GWEOG..HANGUL SYLLABLE GWEOH
		(0xADA5 <= code && code <= 0xADBF) || // Lo  [27] HANGUL SYLLABLE GWEG..HANGUL SYLLABLE GWEH
		(0xADC1 <= code && code <= 0xADDB) || // Lo  [27] HANGUL SYLLABLE GWIG..HANGUL SYLLABLE GWIH
		(0xADDD <= code && code <= 0xADF7) || // Lo  [27] HANGUL SYLLABLE GYUG..HANGUL SYLLABLE GYUH
		(0xADF9 <= code && code <= 0xAE13) || // Lo  [27] HANGUL SYLLABLE GEUG..HANGUL SYLLABLE GEUH
		(0xAE15 <= code && code <= 0xAE2F) || // Lo  [27] HANGUL SYLLABLE GYIG..HANGUL SYLLABLE GYIH
		(0xAE31 <= code && code <= 0xAE4B) || // Lo  [27] HANGUL SYLLABLE GIG..HANGUL SYLLABLE GIH
		(0xAE4D <= code && code <= 0xAE67) || // Lo  [27] HANGUL SYLLABLE GGAG..HANGUL SYLLABLE GGAH
		(0xAE69 <= code && code <= 0xAE83) || // Lo  [27] HANGUL SYLLABLE GGAEG..HANGUL SYLLABLE GGAEH
		(0xAE85 <= code && code <= 0xAE9F) || // Lo  [27] HANGUL SYLLABLE GGYAG..HANGUL SYLLABLE GGYAH
		(0xAEA1 <= code && code <= 0xAEBB) || // Lo  [27] HANGUL SYLLABLE GGYAEG..HANGUL SYLLABLE GGYAEH
		(0xAEBD <= code && code <= 0xAED7) || // Lo  [27] HANGUL SYLLABLE GGEOG..HANGUL SYLLABLE GGEOH
		(0xAED9 <= code && code <= 0xAEF3) || // Lo  [27] HANGUL SYLLABLE GGEG..HANGUL SYLLABLE GGEH
		(0xAEF5 <= code && code <= 0xAF0F) || // Lo  [27] HANGUL SYLLABLE GGYEOG..HANGUL SYLLABLE GGYEOH
		(0xAF11 <= code && code <= 0xAF2B) || // Lo  [27] HANGUL SYLLABLE GGYEG..HANGUL SYLLABLE GGYEH
		(0xAF2D <= code && code <= 0xAF47) || // Lo  [27] HANGUL SYLLABLE GGOG..HANGUL SYLLABLE GGOH
		(0xAF49 <= code && code <= 0xAF63) || // Lo  [27] HANGUL SYLLABLE GGWAG..HANGUL SYLLABLE GGWAH
		(0xAF65 <= code && code <= 0xAF7F) || // Lo  [27] HANGUL SYLLABLE GGWAEG..HANGUL SYLLABLE GGWAEH
		(0xAF81 <= code && code <= 0xAF9B) || // Lo  [27] HANGUL SYLLABLE GGOEG..HANGUL SYLLABLE GGOEH
		(0xAF9D <= code && code <= 0xAFB7) || // Lo  [27] HANGUL SYLLABLE GGYOG..HANGUL SYLLABLE GGYOH
		(0xAFB9 <= code && code <= 0xAFD3) || // Lo  [27] HANGUL SYLLABLE GGUG..HANGUL SYLLABLE GGUH
		(0xAFD5 <= code && code <= 0xAFEF) || // Lo  [27] HANGUL SYLLABLE GGWEOG..HANGUL SYLLABLE GGWEOH
		(0xAFF1 <= code && code <= 0xB00B) || // Lo  [27] HANGUL SYLLABLE GGWEG..HANGUL SYLLABLE GGWEH
		(0xB00D <= code && code <= 0xB027) || // Lo  [27] HANGUL SYLLABLE GGWIG..HANGUL SYLLABLE GGWIH
		(0xB029 <= code && code <= 0xB043) || // Lo  [27] HANGUL SYLLABLE GGYUG..HANGUL SYLLABLE GGYUH
		(0xB045 <= code && code <= 0xB05F) || // Lo  [27] HANGUL SYLLABLE GGEUG..HANGUL SYLLABLE GGEUH
		(0xB061 <= code && code <= 0xB07B) || // Lo  [27] HANGUL SYLLABLE GGYIG..HANGUL SYLLABLE GGYIH
		(0xB07D <= code && code <= 0xB097) || // Lo  [27] HANGUL SYLLABLE GGIG..HANGUL SYLLABLE GGIH
		(0xB099 <= code && code <= 0xB0B3) || // Lo  [27] HANGUL SYLLABLE NAG..HANGUL SYLLABLE NAH
		(0xB0B5 <= code && code <= 0xB0CF) || // Lo  [27] HANGUL SYLLABLE NAEG..HANGUL SYLLABLE NAEH
		(0xB0D1 <= code && code <= 0xB0EB) || // Lo  [27] HANGUL SYLLABLE NYAG..HANGUL SYLLABLE NYAH
		(0xB0ED <= code && code <= 0xB107) || // Lo  [27] HANGUL SYLLABLE NYAEG..HANGUL SYLLABLE NYAEH
		(0xB109 <= code && code <= 0xB123) || // Lo  [27] HANGUL SYLLABLE NEOG..HANGUL SYLLABLE NEOH
		(0xB125 <= code && code <= 0xB13F) || // Lo  [27] HANGUL SYLLABLE NEG..HANGUL SYLLABLE NEH
		(0xB141 <= code && code <= 0xB15B) || // Lo  [27] HANGUL SYLLABLE NYEOG..HANGUL SYLLABLE NYEOH
		(0xB15D <= code && code <= 0xB177) || // Lo  [27] HANGUL SYLLABLE NYEG..HANGUL SYLLABLE NYEH
		(0xB179 <= code && code <= 0xB193) || // Lo  [27] HANGUL SYLLABLE NOG..HANGUL SYLLABLE NOH
		(0xB195 <= code && code <= 0xB1AF) || // Lo  [27] HANGUL SYLLABLE NWAG..HANGUL SYLLABLE NWAH
		(0xB1B1 <= code && code <= 0xB1CB) || // Lo  [27] HANGUL SYLLABLE NWAEG..HANGUL SYLLABLE NWAEH
		(0xB1CD <= code && code <= 0xB1E7) || // Lo  [27] HANGUL SYLLABLE NOEG..HANGUL SYLLABLE NOEH
		(0xB1E9 <= code && code <= 0xB203) || // Lo  [27] HANGUL SYLLABLE NYOG..HANGUL SYLLABLE NYOH
		(0xB205 <= code && code <= 0xB21F) || // Lo  [27] HANGUL SYLLABLE NUG..HANGUL SYLLABLE NUH
		(0xB221 <= code && code <= 0xB23B) || // Lo  [27] HANGUL SYLLABLE NWEOG..HANGUL SYLLABLE NWEOH
		(0xB23D <= code && code <= 0xB257) || // Lo  [27] HANGUL SYLLABLE NWEG..HANGUL SYLLABLE NWEH
		(0xB259 <= code && code <= 0xB273) || // Lo  [27] HANGUL SYLLABLE NWIG..HANGUL SYLLABLE NWIH
		(0xB275 <= code && code <= 0xB28F) || // Lo  [27] HANGUL SYLLABLE NYUG..HANGUL SYLLABLE NYUH
		(0xB291 <= code && code <= 0xB2AB) || // Lo  [27] HANGUL SYLLABLE NEUG..HANGUL SYLLABLE NEUH
		(0xB2AD <= code && code <= 0xB2C7) || // Lo  [27] HANGUL SYLLABLE NYIG..HANGUL SYLLABLE NYIH
		(0xB2C9 <= code && code <= 0xB2E3) || // Lo  [27] HANGUL SYLLABLE NIG..HANGUL SYLLABLE NIH
		(0xB2E5 <= code && code <= 0xB2FF) || // Lo  [27] HANGUL SYLLABLE DAG..HANGUL SYLLABLE DAH
		(0xB301 <= code && code <= 0xB31B) || // Lo  [27] HANGUL SYLLABLE DAEG..HANGUL SYLLABLE DAEH
		(0xB31D <= code && code <= 0xB337) || // Lo  [27] HANGUL SYLLABLE DYAG..HANGUL SYLLABLE DYAH
		(0xB339 <= code && code <= 0xB353) || // Lo  [27] HANGUL SYLLABLE DYAEG..HANGUL SYLLABLE DYAEH
		(0xB355 <= code && code <= 0xB36F) || // Lo  [27] HANGUL SYLLABLE DEOG..HANGUL SYLLABLE DEOH
		(0xB371 <= code && code <= 0xB38B) || // Lo  [27] HANGUL SYLLABLE DEG..HANGUL SYLLABLE DEH
		(0xB38D <= code && code <= 0xB3A7) || // Lo  [27] HANGUL SYLLABLE DYEOG..HANGUL SYLLABLE DYEOH
		(0xB3A9 <= code && code <= 0xB3C3) || // Lo  [27] HANGUL SYLLABLE DYEG..HANGUL SYLLABLE DYEH
		(0xB3C5 <= code && code <= 0xB3DF) || // Lo  [27] HANGUL SYLLABLE DOG..HANGUL SYLLABLE DOH
		(0xB3E1 <= code && code <= 0xB3FB) || // Lo  [27] HANGUL SYLLABLE DWAG..HANGUL SYLLABLE DWAH
		(0xB3FD <= code && code <= 0xB417) || // Lo  [27] HANGUL SYLLABLE DWAEG..HANGUL SYLLABLE DWAEH
		(0xB419 <= code && code <= 0xB433) || // Lo  [27] HANGUL SYLLABLE DOEG..HANGUL SYLLABLE DOEH
		(0xB435 <= code && code <= 0xB44F) || // Lo  [27] HANGUL SYLLABLE DYOG..HANGUL SYLLABLE DYOH
		(0xB451 <= code && code <= 0xB46B) || // Lo  [27] HANGUL SYLLABLE DUG..HANGUL SYLLABLE DUH
		(0xB46D <= code && code <= 0xB487) || // Lo  [27] HANGUL SYLLABLE DWEOG..HANGUL SYLLABLE DWEOH
		(0xB489 <= code && code <= 0xB4A3) || // Lo  [27] HANGUL SYLLABLE DWEG..HANGUL SYLLABLE DWEH
		(0xB4A5 <= code && code <= 0xB4BF) || // Lo  [27] HANGUL SYLLABLE DWIG..HANGUL SYLLABLE DWIH
		(0xB4C1 <= code && code <= 0xB4DB) || // Lo  [27] HANGUL SYLLABLE DYUG..HANGUL SYLLABLE DYUH
		(0xB4DD <= code && code <= 0xB4F7) || // Lo  [27] HANGUL SYLLABLE DEUG..HANGUL SYLLABLE DEUH
		(0xB4F9 <= code && code <= 0xB513) || // Lo  [27] HANGUL SYLLABLE DYIG..HANGUL SYLLABLE DYIH
		(0xB515 <= code && code <= 0xB52F) || // Lo  [27] HANGUL SYLLABLE DIG..HANGUL SYLLABLE DIH
		(0xB531 <= code && code <= 0xB54B) || // Lo  [27] HANGUL SYLLABLE DDAG..HANGUL SYLLABLE DDAH
		(0xB54D <= code && code <= 0xB567) || // Lo  [27] HANGUL SYLLABLE DDAEG..HANGUL SYLLABLE DDAEH
		(0xB569 <= code && code <= 0xB583) || // Lo  [27] HANGUL SYLLABLE DDYAG..HANGUL SYLLABLE DDYAH
		(0xB585 <= code && code <= 0xB59F) || // Lo  [27] HANGUL SYLLABLE DDYAEG..HANGUL SYLLABLE DDYAEH
		(0xB5A1 <= code && code <= 0xB5BB) || // Lo  [27] HANGUL SYLLABLE DDEOG..HANGUL SYLLABLE DDEOH
		(0xB5BD <= code && code <= 0xB5D7) || // Lo  [27] HANGUL SYLLABLE DDEG..HANGUL SYLLABLE DDEH
		(0xB5D9 <= code && code <= 0xB5F3) || // Lo  [27] HANGUL SYLLABLE DDYEOG..HANGUL SYLLABLE DDYEOH
		(0xB5F5 <= code && code <= 0xB60F) || // Lo  [27] HANGUL SYLLABLE DDYEG..HANGUL SYLLABLE DDYEH
		(0xB611 <= code && code <= 0xB62B) || // Lo  [27] HANGUL SYLLABLE DDOG..HANGUL SYLLABLE DDOH
		(0xB62D <= code && code <= 0xB647) || // Lo  [27] HANGUL SYLLABLE DDWAG..HANGUL SYLLABLE DDWAH
		(0xB649 <= code && code <= 0xB663) || // Lo  [27] HANGUL SYLLABLE DDWAEG..HANGUL SYLLABLE DDWAEH
		(0xB665 <= code && code <= 0xB67F) || // Lo  [27] HANGUL SYLLABLE DDOEG..HANGUL SYLLABLE DDOEH
		(0xB681 <= code && code <= 0xB69B) || // Lo  [27] HANGUL SYLLABLE DDYOG..HANGUL SYLLABLE DDYOH
		(0xB69D <= code && code <= 0xB6B7) || // Lo  [27] HANGUL SYLLABLE DDUG..HANGUL SYLLABLE DDUH
		(0xB6B9 <= code && code <= 0xB6D3) || // Lo  [27] HANGUL SYLLABLE DDWEOG..HANGUL SYLLABLE DDWEOH
		(0xB6D5 <= code && code <= 0xB6EF) || // Lo  [27] HANGUL SYLLABLE DDWEG..HANGUL SYLLABLE DDWEH
		(0xB6F1 <= code && code <= 0xB70B) || // Lo  [27] HANGUL SYLLABLE DDWIG..HANGUL SYLLABLE DDWIH
		(0xB70D <= code && code <= 0xB727) || // Lo  [27] HANGUL SYLLABLE DDYUG..HANGUL SYLLABLE DDYUH
		(0xB729 <= code && code <= 0xB743) || // Lo  [27] HANGUL SYLLABLE DDEUG..HANGUL SYLLABLE DDEUH
		(0xB745 <= code && code <= 0xB75F) || // Lo  [27] HANGUL SYLLABLE DDYIG..HANGUL SYLLABLE DDYIH
		(0xB761 <= code && code <= 0xB77B) || // Lo  [27] HANGUL SYLLABLE DDIG..HANGUL SYLLABLE DDIH
		(0xB77D <= code && code <= 0xB797) || // Lo  [27] HANGUL SYLLABLE RAG..HANGUL SYLLABLE RAH
		(0xB799 <= code && code <= 0xB7B3) || // Lo  [27] HANGUL SYLLABLE RAEG..HANGUL SYLLABLE RAEH
		(0xB7B5 <= code && code <= 0xB7CF) || // Lo  [27] HANGUL SYLLABLE RYAG..HANGUL SYLLABLE RYAH
		(0xB7D1 <= code && code <= 0xB7EB) || // Lo  [27] HANGUL SYLLABLE RYAEG..HANGUL SYLLABLE RYAEH
		(0xB7ED <= code && code <= 0xB807) || // Lo  [27] HANGUL SYLLABLE REOG..HANGUL SYLLABLE REOH
		(0xB809 <= code && code <= 0xB823) || // Lo  [27] HANGUL SYLLABLE REG..HANGUL SYLLABLE REH
		(0xB825 <= code && code <= 0xB83F) || // Lo  [27] HANGUL SYLLABLE RYEOG..HANGUL SYLLABLE RYEOH
		(0xB841 <= code && code <= 0xB85B) || // Lo  [27] HANGUL SYLLABLE RYEG..HANGUL SYLLABLE RYEH
		(0xB85D <= code && code <= 0xB877) || // Lo  [27] HANGUL SYLLABLE ROG..HANGUL SYLLABLE ROH
		(0xB879 <= code && code <= 0xB893) || // Lo  [27] HANGUL SYLLABLE RWAG..HANGUL SYLLABLE RWAH
		(0xB895 <= code && code <= 0xB8AF) || // Lo  [27] HANGUL SYLLABLE RWAEG..HANGUL SYLLABLE RWAEH
		(0xB8B1 <= code && code <= 0xB8CB) || // Lo  [27] HANGUL SYLLABLE ROEG..HANGUL SYLLABLE ROEH
		(0xB8CD <= code && code <= 0xB8E7) || // Lo  [27] HANGUL SYLLABLE RYOG..HANGUL SYLLABLE RYOH
		(0xB8E9 <= code && code <= 0xB903) || // Lo  [27] HANGUL SYLLABLE RUG..HANGUL SYLLABLE RUH
		(0xB905 <= code && code <= 0xB91F) || // Lo  [27] HANGUL SYLLABLE RWEOG..HANGUL SYLLABLE RWEOH
		(0xB921 <= code && code <= 0xB93B) || // Lo  [27] HANGUL SYLLABLE RWEG..HANGUL SYLLABLE RWEH
		(0xB93D <= code && code <= 0xB957) || // Lo  [27] HANGUL SYLLABLE RWIG..HANGUL SYLLABLE RWIH
		(0xB959 <= code && code <= 0xB973) || // Lo  [27] HANGUL SYLLABLE RYUG..HANGUL SYLLABLE RYUH
		(0xB975 <= code && code <= 0xB98F) || // Lo  [27] HANGUL SYLLABLE REUG..HANGUL SYLLABLE REUH
		(0xB991 <= code && code <= 0xB9AB) || // Lo  [27] HANGUL SYLLABLE RYIG..HANGUL SYLLABLE RYIH
		(0xB9AD <= code && code <= 0xB9C7) || // Lo  [27] HANGUL SYLLABLE RIG..HANGUL SYLLABLE RIH
		(0xB9C9 <= code && code <= 0xB9E3) || // Lo  [27] HANGUL SYLLABLE MAG..HANGUL SYLLABLE MAH
		(0xB9E5 <= code && code <= 0xB9FF) || // Lo  [27] HANGUL SYLLABLE MAEG..HANGUL SYLLABLE MAEH
		(0xBA01 <= code && code <= 0xBA1B) || // Lo  [27] HANGUL SYLLABLE MYAG..HANGUL SYLLABLE MYAH
		(0xBA1D <= code && code <= 0xBA37) || // Lo  [27] HANGUL SYLLABLE MYAEG..HANGUL SYLLABLE MYAEH
		(0xBA39 <= code && code <= 0xBA53) || // Lo  [27] HANGUL SYLLABLE MEOG..HANGUL SYLLABLE MEOH
		(0xBA55 <= code && code <= 0xBA6F) || // Lo  [27] HANGUL SYLLABLE MEG..HANGUL SYLLABLE MEH
		(0xBA71 <= code && code <= 0xBA8B) || // Lo  [27] HANGUL SYLLABLE MYEOG..HANGUL SYLLABLE MYEOH
		(0xBA8D <= code && code <= 0xBAA7) || // Lo  [27] HANGUL SYLLABLE MYEG..HANGUL SYLLABLE MYEH
		(0xBAA9 <= code && code <= 0xBAC3) || // Lo  [27] HANGUL SYLLABLE MOG..HANGUL SYLLABLE MOH
		(0xBAC5 <= code && code <= 0xBADF) || // Lo  [27] HANGUL SYLLABLE MWAG..HANGUL SYLLABLE MWAH
		(0xBAE1 <= code && code <= 0xBAFB) || // Lo  [27] HANGUL SYLLABLE MWAEG..HANGUL SYLLABLE MWAEH
		(0xBAFD <= code && code <= 0xBB17) || // Lo  [27] HANGUL SYLLABLE MOEG..HANGUL SYLLABLE MOEH
		(0xBB19 <= code && code <= 0xBB33) || // Lo  [27] HANGUL SYLLABLE MYOG..HANGUL SYLLABLE MYOH
		(0xBB35 <= code && code <= 0xBB4F) || // Lo  [27] HANGUL SYLLABLE MUG..HANGUL SYLLABLE MUH
		(0xBB51 <= code && code <= 0xBB6B) || // Lo  [27] HANGUL SYLLABLE MWEOG..HANGUL SYLLABLE MWEOH
		(0xBB6D <= code && code <= 0xBB87) || // Lo  [27] HANGUL SYLLABLE MWEG..HANGUL SYLLABLE MWEH
		(0xBB89 <= code && code <= 0xBBA3) || // Lo  [27] HANGUL SYLLABLE MWIG..HANGUL SYLLABLE MWIH
		(0xBBA5 <= code && code <= 0xBBBF) || // Lo  [27] HANGUL SYLLABLE MYUG..HANGUL SYLLABLE MYUH
		(0xBBC1 <= code && code <= 0xBBDB) || // Lo  [27] HANGUL SYLLABLE MEUG..HANGUL SYLLABLE MEUH
		(0xBBDD <= code && code <= 0xBBF7) || // Lo  [27] HANGUL SYLLABLE MYIG..HANGUL SYLLABLE MYIH
		(0xBBF9 <= code && code <= 0xBC13) || // Lo  [27] HANGUL SYLLABLE MIG..HANGUL SYLLABLE MIH
		(0xBC15 <= code && code <= 0xBC2F) || // Lo  [27] HANGUL SYLLABLE BAG..HANGUL SYLLABLE BAH
		(0xBC31 <= code && code <= 0xBC4B) || // Lo  [27] HANGUL SYLLABLE BAEG..HANGUL SYLLABLE BAEH
		(0xBC4D <= code && code <= 0xBC67) || // Lo  [27] HANGUL SYLLABLE BYAG..HANGUL SYLLABLE BYAH
		(0xBC69 <= code && code <= 0xBC83) || // Lo  [27] HANGUL SYLLABLE BYAEG..HANGUL SYLLABLE BYAEH
		(0xBC85 <= code && code <= 0xBC9F) || // Lo  [27] HANGUL SYLLABLE BEOG..HANGUL SYLLABLE BEOH
		(0xBCA1 <= code && code <= 0xBCBB) || // Lo  [27] HANGUL SYLLABLE BEG..HANGUL SYLLABLE BEH
		(0xBCBD <= code && code <= 0xBCD7) || // Lo  [27] HANGUL SYLLABLE BYEOG..HANGUL SYLLABLE BYEOH
		(0xBCD9 <= code && code <= 0xBCF3) || // Lo  [27] HANGUL SYLLABLE BYEG..HANGUL SYLLABLE BYEH
		(0xBCF5 <= code && code <= 0xBD0F) || // Lo  [27] HANGUL SYLLABLE BOG..HANGUL SYLLABLE BOH
		(0xBD11 <= code && code <= 0xBD2B) || // Lo  [27] HANGUL SYLLABLE BWAG..HANGUL SYLLABLE BWAH
		(0xBD2D <= code && code <= 0xBD47) || // Lo  [27] HANGUL SYLLABLE BWAEG..HANGUL SYLLABLE BWAEH
		(0xBD49 <= code && code <= 0xBD63) || // Lo  [27] HANGUL SYLLABLE BOEG..HANGUL SYLLABLE BOEH
		(0xBD65 <= code && code <= 0xBD7F) || // Lo  [27] HANGUL SYLLABLE BYOG..HANGUL SYLLABLE BYOH
		(0xBD81 <= code && code <= 0xBD9B) || // Lo  [27] HANGUL SYLLABLE BUG..HANGUL SYLLABLE BUH
		(0xBD9D <= code && code <= 0xBDB7) || // Lo  [27] HANGUL SYLLABLE BWEOG..HANGUL SYLLABLE BWEOH
		(0xBDB9 <= code && code <= 0xBDD3) || // Lo  [27] HANGUL SYLLABLE BWEG..HANGUL SYLLABLE BWEH
		(0xBDD5 <= code && code <= 0xBDEF) || // Lo  [27] HANGUL SYLLABLE BWIG..HANGUL SYLLABLE BWIH
		(0xBDF1 <= code && code <= 0xBE0B) || // Lo  [27] HANGUL SYLLABLE BYUG..HANGUL SYLLABLE BYUH
		(0xBE0D <= code && code <= 0xBE27) || // Lo  [27] HANGUL SYLLABLE BEUG..HANGUL SYLLABLE BEUH
		(0xBE29 <= code && code <= 0xBE43) || // Lo  [27] HANGUL SYLLABLE BYIG..HANGUL SYLLABLE BYIH
		(0xBE45 <= code && code <= 0xBE5F) || // Lo  [27] HANGUL SYLLABLE BIG..HANGUL SYLLABLE BIH
		(0xBE61 <= code && code <= 0xBE7B) || // Lo  [27] HANGUL SYLLABLE BBAG..HANGUL SYLLABLE BBAH
		(0xBE7D <= code && code <= 0xBE97) || // Lo  [27] HANGUL SYLLABLE BBAEG..HANGUL SYLLABLE BBAEH
		(0xBE99 <= code && code <= 0xBEB3) || // Lo  [27] HANGUL SYLLABLE BBYAG..HANGUL SYLLABLE BBYAH
		(0xBEB5 <= code && code <= 0xBECF) || // Lo  [27] HANGUL SYLLABLE BBYAEG..HANGUL SYLLABLE BBYAEH
		(0xBED1 <= code && code <= 0xBEEB) || // Lo  [27] HANGUL SYLLABLE BBEOG..HANGUL SYLLABLE BBEOH
		(0xBEED <= code && code <= 0xBF07) || // Lo  [27] HANGUL SYLLABLE BBEG..HANGUL SYLLABLE BBEH
		(0xBF09 <= code && code <= 0xBF23) || // Lo  [27] HANGUL SYLLABLE BBYEOG..HANGUL SYLLABLE BBYEOH
		(0xBF25 <= code && code <= 0xBF3F) || // Lo  [27] HANGUL SYLLABLE BBYEG..HANGUL SYLLABLE BBYEH
		(0xBF41 <= code && code <= 0xBF5B) || // Lo  [27] HANGUL SYLLABLE BBOG..HANGUL SYLLABLE BBOH
		(0xBF5D <= code && code <= 0xBF77) || // Lo  [27] HANGUL SYLLABLE BBWAG..HANGUL SYLLABLE BBWAH
		(0xBF79 <= code && code <= 0xBF93) || // Lo  [27] HANGUL SYLLABLE BBWAEG..HANGUL SYLLABLE BBWAEH
		(0xBF95 <= code && code <= 0xBFAF) || // Lo  [27] HANGUL SYLLABLE BBOEG..HANGUL SYLLABLE BBOEH
		(0xBFB1 <= code && code <= 0xBFCB) || // Lo  [27] HANGUL SYLLABLE BBYOG..HANGUL SYLLABLE BBYOH
		(0xBFCD <= code && code <= 0xBFE7) || // Lo  [27] HANGUL SYLLABLE BBUG..HANGUL SYLLABLE BBUH
		(0xBFE9 <= code && code <= 0xC003) || // Lo  [27] HANGUL SYLLABLE BBWEOG..HANGUL SYLLABLE BBWEOH
		(0xC005 <= code && code <= 0xC01F) || // Lo  [27] HANGUL SYLLABLE BBWEG..HANGUL SYLLABLE BBWEH
		(0xC021 <= code && code <= 0xC03B) || // Lo  [27] HANGUL SYLLABLE BBWIG..HANGUL SYLLABLE BBWIH
		(0xC03D <= code && code <= 0xC057) || // Lo  [27] HANGUL SYLLABLE BBYUG..HANGUL SYLLABLE BBYUH
		(0xC059 <= code && code <= 0xC073) || // Lo  [27] HANGUL SYLLABLE BBEUG..HANGUL SYLLABLE BBEUH
		(0xC075 <= code && code <= 0xC08F) || // Lo  [27] HANGUL SYLLABLE BBYIG..HANGUL SYLLABLE BBYIH
		(0xC091 <= code && code <= 0xC0AB) || // Lo  [27] HANGUL SYLLABLE BBIG..HANGUL SYLLABLE BBIH
		(0xC0AD <= code && code <= 0xC0C7) || // Lo  [27] HANGUL SYLLABLE SAG..HANGUL SYLLABLE SAH
		(0xC0C9 <= code && code <= 0xC0E3) || // Lo  [27] HANGUL SYLLABLE SAEG..HANGUL SYLLABLE SAEH
		(0xC0E5 <= code && code <= 0xC0FF) || // Lo  [27] HANGUL SYLLABLE SYAG..HANGUL SYLLABLE SYAH
		(0xC101 <= code && code <= 0xC11B) || // Lo  [27] HANGUL SYLLABLE SYAEG..HANGUL SYLLABLE SYAEH
		(0xC11D <= code && code <= 0xC137) || // Lo  [27] HANGUL SYLLABLE SEOG..HANGUL SYLLABLE SEOH
		(0xC139 <= code && code <= 0xC153) || // Lo  [27] HANGUL SYLLABLE SEG..HANGUL SYLLABLE SEH
		(0xC155 <= code && code <= 0xC16F) || // Lo  [27] HANGUL SYLLABLE SYEOG..HANGUL SYLLABLE SYEOH
		(0xC171 <= code && code <= 0xC18B) || // Lo  [27] HANGUL SYLLABLE SYEG..HANGUL SYLLABLE SYEH
		(0xC18D <= code && code <= 0xC1A7) || // Lo  [27] HANGUL SYLLABLE SOG..HANGUL SYLLABLE SOH
		(0xC1A9 <= code && code <= 0xC1C3) || // Lo  [27] HANGUL SYLLABLE SWAG..HANGUL SYLLABLE SWAH
		(0xC1C5 <= code && code <= 0xC1DF) || // Lo  [27] HANGUL SYLLABLE SWAEG..HANGUL SYLLABLE SWAEH
		(0xC1E1 <= code && code <= 0xC1FB) || // Lo  [27] HANGUL SYLLABLE SOEG..HANGUL SYLLABLE SOEH
		(0xC1FD <= code && code <= 0xC217) || // Lo  [27] HANGUL SYLLABLE SYOG..HANGUL SYLLABLE SYOH
		(0xC219 <= code && code <= 0xC233) || // Lo  [27] HANGUL SYLLABLE SUG..HANGUL SYLLABLE SUH
		(0xC235 <= code && code <= 0xC24F) || // Lo  [27] HANGUL SYLLABLE SWEOG..HANGUL SYLLABLE SWEOH
		(0xC251 <= code && code <= 0xC26B) || // Lo  [27] HANGUL SYLLABLE SWEG..HANGUL SYLLABLE SWEH
		(0xC26D <= code && code <= 0xC287) || // Lo  [27] HANGUL SYLLABLE SWIG..HANGUL SYLLABLE SWIH
		(0xC289 <= code && code <= 0xC2A3) || // Lo  [27] HANGUL SYLLABLE SYUG..HANGUL SYLLABLE SYUH
		(0xC2A5 <= code && code <= 0xC2BF) || // Lo  [27] HANGUL SYLLABLE SEUG..HANGUL SYLLABLE SEUH
		(0xC2C1 <= code && code <= 0xC2DB) || // Lo  [27] HANGUL SYLLABLE SYIG..HANGUL SYLLABLE SYIH
		(0xC2DD <= code && code <= 0xC2F7) || // Lo  [27] HANGUL SYLLABLE SIG..HANGUL SYLLABLE SIH
		(0xC2F9 <= code && code <= 0xC313) || // Lo  [27] HANGUL SYLLABLE SSAG..HANGUL SYLLABLE SSAH
		(0xC315 <= code && code <= 0xC32F) || // Lo  [27] HANGUL SYLLABLE SSAEG..HANGUL SYLLABLE SSAEH
		(0xC331 <= code && code <= 0xC34B) || // Lo  [27] HANGUL SYLLABLE SSYAG..HANGUL SYLLABLE SSYAH
		(0xC34D <= code && code <= 0xC367) || // Lo  [27] HANGUL SYLLABLE SSYAEG..HANGUL SYLLABLE SSYAEH
		(0xC369 <= code && code <= 0xC383) || // Lo  [27] HANGUL SYLLABLE SSEOG..HANGUL SYLLABLE SSEOH
		(0xC385 <= code && code <= 0xC39F) || // Lo  [27] HANGUL SYLLABLE SSEG..HANGUL SYLLABLE SSEH
		(0xC3A1 <= code && code <= 0xC3BB) || // Lo  [27] HANGUL SYLLABLE SSYEOG..HANGUL SYLLABLE SSYEOH
		(0xC3BD <= code && code <= 0xC3D7) || // Lo  [27] HANGUL SYLLABLE SSYEG..HANGUL SYLLABLE SSYEH
		(0xC3D9 <= code && code <= 0xC3F3) || // Lo  [27] HANGUL SYLLABLE SSOG..HANGUL SYLLABLE SSOH
		(0xC3F5 <= code && code <= 0xC40F) || // Lo  [27] HANGUL SYLLABLE SSWAG..HANGUL SYLLABLE SSWAH
		(0xC411 <= code && code <= 0xC42B) || // Lo  [27] HANGUL SYLLABLE SSWAEG..HANGUL SYLLABLE SSWAEH
		(0xC42D <= code && code <= 0xC447) || // Lo  [27] HANGUL SYLLABLE SSOEG..HANGUL SYLLABLE SSOEH
		(0xC449 <= code && code <= 0xC463) || // Lo  [27] HANGUL SYLLABLE SSYOG..HANGUL SYLLABLE SSYOH
		(0xC465 <= code && code <= 0xC47F) || // Lo  [27] HANGUL SYLLABLE SSUG..HANGUL SYLLABLE SSUH
		(0xC481 <= code && code <= 0xC49B) || // Lo  [27] HANGUL SYLLABLE SSWEOG..HANGUL SYLLABLE SSWEOH
		(0xC49D <= code && code <= 0xC4B7) || // Lo  [27] HANGUL SYLLABLE SSWEG..HANGUL SYLLABLE SSWEH
		(0xC4B9 <= code && code <= 0xC4D3) || // Lo  [27] HANGUL SYLLABLE SSWIG..HANGUL SYLLABLE SSWIH
		(0xC4D5 <= code && code <= 0xC4EF) || // Lo  [27] HANGUL SYLLABLE SSYUG..HANGUL SYLLABLE SSYUH
		(0xC4F1 <= code && code <= 0xC50B) || // Lo  [27] HANGUL SYLLABLE SSEUG..HANGUL SYLLABLE SSEUH
		(0xC50D <= code && code <= 0xC527) || // Lo  [27] HANGUL SYLLABLE SSYIG..HANGUL SYLLABLE SSYIH
		(0xC529 <= code && code <= 0xC543) || // Lo  [27] HANGUL SYLLABLE SSIG..HANGUL SYLLABLE SSIH
		(0xC545 <= code && code <= 0xC55F) || // Lo  [27] HANGUL SYLLABLE AG..HANGUL SYLLABLE AH
		(0xC561 <= code && code <= 0xC57B) || // Lo  [27] HANGUL SYLLABLE AEG..HANGUL SYLLABLE AEH
		(0xC57D <= code && code <= 0xC597) || // Lo  [27] HANGUL SYLLABLE YAG..HANGUL SYLLABLE YAH
		(0xC599 <= code && code <= 0xC5B3) || // Lo  [27] HANGUL SYLLABLE YAEG..HANGUL SYLLABLE YAEH
		(0xC5B5 <= code && code <= 0xC5CF) || // Lo  [27] HANGUL SYLLABLE EOG..HANGUL SYLLABLE EOH
		(0xC5D1 <= code && code <= 0xC5EB) || // Lo  [27] HANGUL SYLLABLE EG..HANGUL SYLLABLE EH
		(0xC5ED <= code && code <= 0xC607) || // Lo  [27] HANGUL SYLLABLE YEOG..HANGUL SYLLABLE YEOH
		(0xC609 <= code && code <= 0xC623) || // Lo  [27] HANGUL SYLLABLE YEG..HANGUL SYLLABLE YEH
		(0xC625 <= code && code <= 0xC63F) || // Lo  [27] HANGUL SYLLABLE OG..HANGUL SYLLABLE OH
		(0xC641 <= code && code <= 0xC65B) || // Lo  [27] HANGUL SYLLABLE WAG..HANGUL SYLLABLE WAH
		(0xC65D <= code && code <= 0xC677) || // Lo  [27] HANGUL SYLLABLE WAEG..HANGUL SYLLABLE WAEH
		(0xC679 <= code && code <= 0xC693) || // Lo  [27] HANGUL SYLLABLE OEG..HANGUL SYLLABLE OEH
		(0xC695 <= code && code <= 0xC6AF) || // Lo  [27] HANGUL SYLLABLE YOG..HANGUL SYLLABLE YOH
		(0xC6B1 <= code && code <= 0xC6CB) || // Lo  [27] HANGUL SYLLABLE UG..HANGUL SYLLABLE UH
		(0xC6CD <= code && code <= 0xC6E7) || // Lo  [27] HANGUL SYLLABLE WEOG..HANGUL SYLLABLE WEOH
		(0xC6E9 <= code && code <= 0xC703) || // Lo  [27] HANGUL SYLLABLE WEG..HANGUL SYLLABLE WEH
		(0xC705 <= code && code <= 0xC71F) || // Lo  [27] HANGUL SYLLABLE WIG..HANGUL SYLLABLE WIH
		(0xC721 <= code && code <= 0xC73B) || // Lo  [27] HANGUL SYLLABLE YUG..HANGUL SYLLABLE YUH
		(0xC73D <= code && code <= 0xC757) || // Lo  [27] HANGUL SYLLABLE EUG..HANGUL SYLLABLE EUH
		(0xC759 <= code && code <= 0xC773) || // Lo  [27] HANGUL SYLLABLE YIG..HANGUL SYLLABLE YIH
		(0xC775 <= code && code <= 0xC78F) || // Lo  [27] HANGUL SYLLABLE IG..HANGUL SYLLABLE IH
		(0xC791 <= code && code <= 0xC7AB) || // Lo  [27] HANGUL SYLLABLE JAG..HANGUL SYLLABLE JAH
		(0xC7AD <= code && code <= 0xC7C7) || // Lo  [27] HANGUL SYLLABLE JAEG..HANGUL SYLLABLE JAEH
		(0xC7C9 <= code && code <= 0xC7E3) || // Lo  [27] HANGUL SYLLABLE JYAG..HANGUL SYLLABLE JYAH
		(0xC7E5 <= code && code <= 0xC7FF) || // Lo  [27] HANGUL SYLLABLE JYAEG..HANGUL SYLLABLE JYAEH
		(0xC801 <= code && code <= 0xC81B) || // Lo  [27] HANGUL SYLLABLE JEOG..HANGUL SYLLABLE JEOH
		(0xC81D <= code && code <= 0xC837) || // Lo  [27] HANGUL SYLLABLE JEG..HANGUL SYLLABLE JEH
		(0xC839 <= code && code <= 0xC853) || // Lo  [27] HANGUL SYLLABLE JYEOG..HANGUL SYLLABLE JYEOH
		(0xC855 <= code && code <= 0xC86F) || // Lo  [27] HANGUL SYLLABLE JYEG..HANGUL SYLLABLE JYEH
		(0xC871 <= code && code <= 0xC88B) || // Lo  [27] HANGUL SYLLABLE JOG..HANGUL SYLLABLE JOH
		(0xC88D <= code && code <= 0xC8A7) || // Lo  [27] HANGUL SYLLABLE JWAG..HANGUL SYLLABLE JWAH
		(0xC8A9 <= code && code <= 0xC8C3) || // Lo  [27] HANGUL SYLLABLE JWAEG..HANGUL SYLLABLE JWAEH
		(0xC8C5 <= code && code <= 0xC8DF) || // Lo  [27] HANGUL SYLLABLE JOEG..HANGUL SYLLABLE JOEH
		(0xC8E1 <= code && code <= 0xC8FB) || // Lo  [27] HANGUL SYLLABLE JYOG..HANGUL SYLLABLE JYOH
		(0xC8FD <= code && code <= 0xC917) || // Lo  [27] HANGUL SYLLABLE JUG..HANGUL SYLLABLE JUH
		(0xC919 <= code && code <= 0xC933) || // Lo  [27] HANGUL SYLLABLE JWEOG..HANGUL SYLLABLE JWEOH
		(0xC935 <= code && code <= 0xC94F) || // Lo  [27] HANGUL SYLLABLE JWEG..HANGUL SYLLABLE JWEH
		(0xC951 <= code && code <= 0xC96B) || // Lo  [27] HANGUL SYLLABLE JWIG..HANGUL SYLLABLE JWIH
		(0xC96D <= code && code <= 0xC987) || // Lo  [27] HANGUL SYLLABLE JYUG..HANGUL SYLLABLE JYUH
		(0xC989 <= code && code <= 0xC9A3) || // Lo  [27] HANGUL SYLLABLE JEUG..HANGUL SYLLABLE JEUH
		(0xC9A5 <= code && code <= 0xC9BF) || // Lo  [27] HANGUL SYLLABLE JYIG..HANGUL SYLLABLE JYIH
		(0xC9C1 <= code && code <= 0xC9DB) || // Lo  [27] HANGUL SYLLABLE JIG..HANGUL SYLLABLE JIH
		(0xC9DD <= code && code <= 0xC9F7) || // Lo  [27] HANGUL SYLLABLE JJAG..HANGUL SYLLABLE JJAH
		(0xC9F9 <= code && code <= 0xCA13) || // Lo  [27] HANGUL SYLLABLE JJAEG..HANGUL SYLLABLE JJAEH
		(0xCA15 <= code && code <= 0xCA2F) || // Lo  [27] HANGUL SYLLABLE JJYAG..HANGUL SYLLABLE JJYAH
		(0xCA31 <= code && code <= 0xCA4B) || // Lo  [27] HANGUL SYLLABLE JJYAEG..HANGUL SYLLABLE JJYAEH
		(0xCA4D <= code && code <= 0xCA67) || // Lo  [27] HANGUL SYLLABLE JJEOG..HANGUL SYLLABLE JJEOH
		(0xCA69 <= code && code <= 0xCA83) || // Lo  [27] HANGUL SYLLABLE JJEG..HANGUL SYLLABLE JJEH
		(0xCA85 <= code && code <= 0xCA9F) || // Lo  [27] HANGUL SYLLABLE JJYEOG..HANGUL SYLLABLE JJYEOH
		(0xCAA1 <= code && code <= 0xCABB) || // Lo  [27] HANGUL SYLLABLE JJYEG..HANGUL SYLLABLE JJYEH
		(0xCABD <= code && code <= 0xCAD7) || // Lo  [27] HANGUL SYLLABLE JJOG..HANGUL SYLLABLE JJOH
		(0xCAD9 <= code && code <= 0xCAF3) || // Lo  [27] HANGUL SYLLABLE JJWAG..HANGUL SYLLABLE JJWAH
		(0xCAF5 <= code && code <= 0xCB0F) || // Lo  [27] HANGUL SYLLABLE JJWAEG..HANGUL SYLLABLE JJWAEH
		(0xCB11 <= code && code <= 0xCB2B) || // Lo  [27] HANGUL SYLLABLE JJOEG..HANGUL SYLLABLE JJOEH
		(0xCB2D <= code && code <= 0xCB47) || // Lo  [27] HANGUL SYLLABLE JJYOG..HANGUL SYLLABLE JJYOH
		(0xCB49 <= code && code <= 0xCB63) || // Lo  [27] HANGUL SYLLABLE JJUG..HANGUL SYLLABLE JJUH
		(0xCB65 <= code && code <= 0xCB7F) || // Lo  [27] HANGUL SYLLABLE JJWEOG..HANGUL SYLLABLE JJWEOH
		(0xCB81 <= code && code <= 0xCB9B) || // Lo  [27] HANGUL SYLLABLE JJWEG..HANGUL SYLLABLE JJWEH
		(0xCB9D <= code && code <= 0xCBB7) || // Lo  [27] HANGUL SYLLABLE JJWIG..HANGUL SYLLABLE JJWIH
		(0xCBB9 <= code && code <= 0xCBD3) || // Lo  [27] HANGUL SYLLABLE JJYUG..HANGUL SYLLABLE JJYUH
		(0xCBD5 <= code && code <= 0xCBEF) || // Lo  [27] HANGUL SYLLABLE JJEUG..HANGUL SYLLABLE JJEUH
		(0xCBF1 <= code && code <= 0xCC0B) || // Lo  [27] HANGUL SYLLABLE JJYIG..HANGUL SYLLABLE JJYIH
		(0xCC0D <= code && code <= 0xCC27) || // Lo  [27] HANGUL SYLLABLE JJIG..HANGUL SYLLABLE JJIH
		(0xCC29 <= code && code <= 0xCC43) || // Lo  [27] HANGUL SYLLABLE CAG..HANGUL SYLLABLE CAH
		(0xCC45 <= code && code <= 0xCC5F) || // Lo  [27] HANGUL SYLLABLE CAEG..HANGUL SYLLABLE CAEH
		(0xCC61 <= code && code <= 0xCC7B) || // Lo  [27] HANGUL SYLLABLE CYAG..HANGUL SYLLABLE CYAH
		(0xCC7D <= code && code <= 0xCC97) || // Lo  [27] HANGUL SYLLABLE CYAEG..HANGUL SYLLABLE CYAEH
		(0xCC99 <= code && code <= 0xCCB3) || // Lo  [27] HANGUL SYLLABLE CEOG..HANGUL SYLLABLE CEOH
		(0xCCB5 <= code && code <= 0xCCCF) || // Lo  [27] HANGUL SYLLABLE CEG..HANGUL SYLLABLE CEH
		(0xCCD1 <= code && code <= 0xCCEB) || // Lo  [27] HANGUL SYLLABLE CYEOG..HANGUL SYLLABLE CYEOH
		(0xCCED <= code && code <= 0xCD07) || // Lo  [27] HANGUL SYLLABLE CYEG..HANGUL SYLLABLE CYEH
		(0xCD09 <= code && code <= 0xCD23) || // Lo  [27] HANGUL SYLLABLE COG..HANGUL SYLLABLE COH
		(0xCD25 <= code && code <= 0xCD3F) || // Lo  [27] HANGUL SYLLABLE CWAG..HANGUL SYLLABLE CWAH
		(0xCD41 <= code && code <= 0xCD5B) || // Lo  [27] HANGUL SYLLABLE CWAEG..HANGUL SYLLABLE CWAEH
		(0xCD5D <= code && code <= 0xCD77) || // Lo  [27] HANGUL SYLLABLE COEG..HANGUL SYLLABLE COEH
		(0xCD79 <= code && code <= 0xCD93) || // Lo  [27] HANGUL SYLLABLE CYOG..HANGUL SYLLABLE CYOH
		(0xCD95 <= code && code <= 0xCDAF) || // Lo  [27] HANGUL SYLLABLE CUG..HANGUL SYLLABLE CUH
		(0xCDB1 <= code && code <= 0xCDCB) || // Lo  [27] HANGUL SYLLABLE CWEOG..HANGUL SYLLABLE CWEOH
		(0xCDCD <= code && code <= 0xCDE7) || // Lo  [27] HANGUL SYLLABLE CWEG..HANGUL SYLLABLE CWEH
		(0xCDE9 <= code && code <= 0xCE03) || // Lo  [27] HANGUL SYLLABLE CWIG..HANGUL SYLLABLE CWIH
		(0xCE05 <= code && code <= 0xCE1F) || // Lo  [27] HANGUL SYLLABLE CYUG..HANGUL SYLLABLE CYUH
		(0xCE21 <= code && code <= 0xCE3B) || // Lo  [27] HANGUL SYLLABLE CEUG..HANGUL SYLLABLE CEUH
		(0xCE3D <= code && code <= 0xCE57) || // Lo  [27] HANGUL SYLLABLE CYIG..HANGUL SYLLABLE CYIH
		(0xCE59 <= code && code <= 0xCE73) || // Lo  [27] HANGUL SYLLABLE CIG..HANGUL SYLLABLE CIH
		(0xCE75 <= code && code <= 0xCE8F) || // Lo  [27] HANGUL SYLLABLE KAG..HANGUL SYLLABLE KAH
		(0xCE91 <= code && code <= 0xCEAB) || // Lo  [27] HANGUL SYLLABLE KAEG..HANGUL SYLLABLE KAEH
		(0xCEAD <= code && code <= 0xCEC7) || // Lo  [27] HANGUL SYLLABLE KYAG..HANGUL SYLLABLE KYAH
		(0xCEC9 <= code && code <= 0xCEE3) || // Lo  [27] HANGUL SYLLABLE KYAEG..HANGUL SYLLABLE KYAEH
		(0xCEE5 <= code && code <= 0xCEFF) || // Lo  [27] HANGUL SYLLABLE KEOG..HANGUL SYLLABLE KEOH
		(0xCF01 <= code && code <= 0xCF1B) || // Lo  [27] HANGUL SYLLABLE KEG..HANGUL SYLLABLE KEH
		(0xCF1D <= code && code <= 0xCF37) || // Lo  [27] HANGUL SYLLABLE KYEOG..HANGUL SYLLABLE KYEOH
		(0xCF39 <= code && code <= 0xCF53) || // Lo  [27] HANGUL SYLLABLE KYEG..HANGUL SYLLABLE KYEH
		(0xCF55 <= code && code <= 0xCF6F) || // Lo  [27] HANGUL SYLLABLE KOG..HANGUL SYLLABLE KOH
		(0xCF71 <= code && code <= 0xCF8B) || // Lo  [27] HANGUL SYLLABLE KWAG..HANGUL SYLLABLE KWAH
		(0xCF8D <= code && code <= 0xCFA7) || // Lo  [27] HANGUL SYLLABLE KWAEG..HANGUL SYLLABLE KWAEH
		(0xCFA9 <= code && code <= 0xCFC3) || // Lo  [27] HANGUL SYLLABLE KOEG..HANGUL SYLLABLE KOEH
		(0xCFC5 <= code && code <= 0xCFDF) || // Lo  [27] HANGUL SYLLABLE KYOG..HANGUL SYLLABLE KYOH
		(0xCFE1 <= code && code <= 0xCFFB) || // Lo  [27] HANGUL SYLLABLE KUG..HANGUL SYLLABLE KUH
		(0xCFFD <= code && code <= 0xD017) || // Lo  [27] HANGUL SYLLABLE KWEOG..HANGUL SYLLABLE KWEOH
		(0xD019 <= code && code <= 0xD033) || // Lo  [27] HANGUL SYLLABLE KWEG..HANGUL SYLLABLE KWEH
		(0xD035 <= code && code <= 0xD04F) || // Lo  [27] HANGUL SYLLABLE KWIG..HANGUL SYLLABLE KWIH
		(0xD051 <= code && code <= 0xD06B) || // Lo  [27] HANGUL SYLLABLE KYUG..HANGUL SYLLABLE KYUH
		(0xD06D <= code && code <= 0xD087) || // Lo  [27] HANGUL SYLLABLE KEUG..HANGUL SYLLABLE KEUH
		(0xD089 <= code && code <= 0xD0A3) || // Lo  [27] HANGUL SYLLABLE KYIG..HANGUL SYLLABLE KYIH
		(0xD0A5 <= code && code <= 0xD0BF) || // Lo  [27] HANGUL SYLLABLE KIG..HANGUL SYLLABLE KIH
		(0xD0C1 <= code && code <= 0xD0DB) || // Lo  [27] HANGUL SYLLABLE TAG..HANGUL SYLLABLE TAH
		(0xD0DD <= code && code <= 0xD0F7) || // Lo  [27] HANGUL SYLLABLE TAEG..HANGUL SYLLABLE TAEH
		(0xD0F9 <= code && code <= 0xD113) || // Lo  [27] HANGUL SYLLABLE TYAG..HANGUL SYLLABLE TYAH
		(0xD115 <= code && code <= 0xD12F) || // Lo  [27] HANGUL SYLLABLE TYAEG..HANGUL SYLLABLE TYAEH
		(0xD131 <= code && code <= 0xD14B) || // Lo  [27] HANGUL SYLLABLE TEOG..HANGUL SYLLABLE TEOH
		(0xD14D <= code && code <= 0xD167) || // Lo  [27] HANGUL SYLLABLE TEG..HANGUL SYLLABLE TEH
		(0xD169 <= code && code <= 0xD183) || // Lo  [27] HANGUL SYLLABLE TYEOG..HANGUL SYLLABLE TYEOH
		(0xD185 <= code && code <= 0xD19F) || // Lo  [27] HANGUL SYLLABLE TYEG..HANGUL SYLLABLE TYEH
		(0xD1A1 <= code && code <= 0xD1BB) || // Lo  [27] HANGUL SYLLABLE TOG..HANGUL SYLLABLE TOH
		(0xD1BD <= code && code <= 0xD1D7) || // Lo  [27] HANGUL SYLLABLE TWAG..HANGUL SYLLABLE TWAH
		(0xD1D9 <= code && code <= 0xD1F3) || // Lo  [27] HANGUL SYLLABLE TWAEG..HANGUL SYLLABLE TWAEH
		(0xD1F5 <= code && code <= 0xD20F) || // Lo  [27] HANGUL SYLLABLE TOEG..HANGUL SYLLABLE TOEH
		(0xD211 <= code && code <= 0xD22B) || // Lo  [27] HANGUL SYLLABLE TYOG..HANGUL SYLLABLE TYOH
		(0xD22D <= code && code <= 0xD247) || // Lo  [27] HANGUL SYLLABLE TUG..HANGUL SYLLABLE TUH
		(0xD249 <= code && code <= 0xD263) || // Lo  [27] HANGUL SYLLABLE TWEOG..HANGUL SYLLABLE TWEOH
		(0xD265 <= code && code <= 0xD27F) || // Lo  [27] HANGUL SYLLABLE TWEG..HANGUL SYLLABLE TWEH
		(0xD281 <= code && code <= 0xD29B) || // Lo  [27] HANGUL SYLLABLE TWIG..HANGUL SYLLABLE TWIH
		(0xD29D <= code && code <= 0xD2B7) || // Lo  [27] HANGUL SYLLABLE TYUG..HANGUL SYLLABLE TYUH
		(0xD2B9 <= code && code <= 0xD2D3) || // Lo  [27] HANGUL SYLLABLE TEUG..HANGUL SYLLABLE TEUH
		(0xD2D5 <= code && code <= 0xD2EF) || // Lo  [27] HANGUL SYLLABLE TYIG..HANGUL SYLLABLE TYIH
		(0xD2F1 <= code && code <= 0xD30B) || // Lo  [27] HANGUL SYLLABLE TIG..HANGUL SYLLABLE TIH
		(0xD30D <= code && code <= 0xD327) || // Lo  [27] HANGUL SYLLABLE PAG..HANGUL SYLLABLE PAH
		(0xD329 <= code && code <= 0xD343) || // Lo  [27] HANGUL SYLLABLE PAEG..HANGUL SYLLABLE PAEH
		(0xD345 <= code && code <= 0xD35F) || // Lo  [27] HANGUL SYLLABLE PYAG..HANGUL SYLLABLE PYAH
		(0xD361 <= code && code <= 0xD37B) || // Lo  [27] HANGUL SYLLABLE PYAEG..HANGUL SYLLABLE PYAEH
		(0xD37D <= code && code <= 0xD397) || // Lo  [27] HANGUL SYLLABLE PEOG..HANGUL SYLLABLE PEOH
		(0xD399 <= code && code <= 0xD3B3) || // Lo  [27] HANGUL SYLLABLE PEG..HANGUL SYLLABLE PEH
		(0xD3B5 <= code && code <= 0xD3CF) || // Lo  [27] HANGUL SYLLABLE PYEOG..HANGUL SYLLABLE PYEOH
		(0xD3D1 <= code && code <= 0xD3EB) || // Lo  [27] HANGUL SYLLABLE PYEG..HANGUL SYLLABLE PYEH
		(0xD3ED <= code && code <= 0xD407) || // Lo  [27] HANGUL SYLLABLE POG..HANGUL SYLLABLE POH
		(0xD409 <= code && code <= 0xD423) || // Lo  [27] HANGUL SYLLABLE PWAG..HANGUL SYLLABLE PWAH
		(0xD425 <= code && code <= 0xD43F) || // Lo  [27] HANGUL SYLLABLE PWAEG..HANGUL SYLLABLE PWAEH
		(0xD441 <= code && code <= 0xD45B) || // Lo  [27] HANGUL SYLLABLE POEG..HANGUL SYLLABLE POEH
		(0xD45D <= code && code <= 0xD477) || // Lo  [27] HANGUL SYLLABLE PYOG..HANGUL SYLLABLE PYOH
		(0xD479 <= code && code <= 0xD493) || // Lo  [27] HANGUL SYLLABLE PUG..HANGUL SYLLABLE PUH
		(0xD495 <= code && code <= 0xD4AF) || // Lo  [27] HANGUL SYLLABLE PWEOG..HANGUL SYLLABLE PWEOH
		(0xD4B1 <= code && code <= 0xD4CB) || // Lo  [27] HANGUL SYLLABLE PWEG..HANGUL SYLLABLE PWEH
		(0xD4CD <= code && code <= 0xD4E7) || // Lo  [27] HANGUL SYLLABLE PWIG..HANGUL SYLLABLE PWIH
		(0xD4E9 <= code && code <= 0xD503) || // Lo  [27] HANGUL SYLLABLE PYUG..HANGUL SYLLABLE PYUH
		(0xD505 <= code && code <= 0xD51F) || // Lo  [27] HANGUL SYLLABLE PEUG..HANGUL SYLLABLE PEUH
		(0xD521 <= code && code <= 0xD53B) || // Lo  [27] HANGUL SYLLABLE PYIG..HANGUL SYLLABLE PYIH
		(0xD53D <= code && code <= 0xD557) || // Lo  [27] HANGUL SYLLABLE PIG..HANGUL SYLLABLE PIH
		(0xD559 <= code && code <= 0xD573) || // Lo  [27] HANGUL SYLLABLE HAG..HANGUL SYLLABLE HAH
		(0xD575 <= code && code <= 0xD58F) || // Lo  [27] HANGUL SYLLABLE HAEG..HANGUL SYLLABLE HAEH
		(0xD591 <= code && code <= 0xD5AB) || // Lo  [27] HANGUL SYLLABLE HYAG..HANGUL SYLLABLE HYAH
		(0xD5AD <= code && code <= 0xD5C7) || // Lo  [27] HANGUL SYLLABLE HYAEG..HANGUL SYLLABLE HYAEH
		(0xD5C9 <= code && code <= 0xD5E3) || // Lo  [27] HANGUL SYLLABLE HEOG..HANGUL SYLLABLE HEOH
		(0xD5E5 <= code && code <= 0xD5FF) || // Lo  [27] HANGUL SYLLABLE HEG..HANGUL SYLLABLE HEH
		(0xD601 <= code && code <= 0xD61B) || // Lo  [27] HANGUL SYLLABLE HYEOG..HANGUL SYLLABLE HYEOH
		(0xD61D <= code && code <= 0xD637) || // Lo  [27] HANGUL SYLLABLE HYEG..HANGUL SYLLABLE HYEH
		(0xD639 <= code && code <= 0xD653) || // Lo  [27] HANGUL SYLLABLE HOG..HANGUL SYLLABLE HOH
		(0xD655 <= code && code <= 0xD66F) || // Lo  [27] HANGUL SYLLABLE HWAG..HANGUL SYLLABLE HWAH
		(0xD671 <= code && code <= 0xD68B) || // Lo  [27] HANGUL SYLLABLE HWAEG..HANGUL SYLLABLE HWAEH
		(0xD68D <= code && code <= 0xD6A7) || // Lo  [27] HANGUL SYLLABLE HOEG..HANGUL SYLLABLE HOEH
		(0xD6A9 <= code && code <= 0xD6C3) || // Lo  [27] HANGUL SYLLABLE HYOG..HANGUL SYLLABLE HYOH
		(0xD6C5 <= code && code <= 0xD6DF) || // Lo  [27] HANGUL SYLLABLE HUG..HANGUL SYLLABLE HUH
		(0xD6E1 <= code && code <= 0xD6FB) || // Lo  [27] HANGUL SYLLABLE HWEOG..HANGUL SYLLABLE HWEOH
		(0xD6FD <= code && code <= 0xD717) || // Lo  [27] HANGUL SYLLABLE HWEG..HANGUL SYLLABLE HWEH
		(0xD719 <= code && code <= 0xD733) || // Lo  [27] HANGUL SYLLABLE HWIG..HANGUL SYLLABLE HWIH
		(0xD735 <= code && code <= 0xD74F) || // Lo  [27] HANGUL SYLLABLE HYUG..HANGUL SYLLABLE HYUH
		(0xD751 <= code && code <= 0xD76B) || // Lo  [27] HANGUL SYLLABLE HEUG..HANGUL SYLLABLE HEUH
		(0xD76D <= code && code <= 0xD787) || // Lo  [27] HANGUL SYLLABLE HYIG..HANGUL SYLLABLE HYIH
		(0xD789 <= code && code <= 0xD7A3) // Lo  [27] HANGUL SYLLABLE HIG..HANGUL SYLLABLE HIH
		){
			return LVT;
		}
		
		if(
		0x261D == code || // So       WHITE UP POINTING INDEX
		0x26F9 == code || // So       PERSON WITH BALL
		(0x270A <= code && code <= 0x270D) || // So   [4] RAISED FIST..WRITING HAND
		0x1F385 == code || // So       FATHER CHRISTMAS
		(0x1F3C2 <= code && code <= 0x1F3C4) || // So   [3] SNOWBOARDER..SURFER
		0x1F3C7 == code || // So       HORSE RACING
		(0x1F3CA <= code && code <= 0x1F3CC) || // So   [3] SWIMMER..GOLFER
		(0x1F442 <= code && code <= 0x1F443) || // So   [2] EAR..NOSE
		(0x1F446 <= code && code <= 0x1F450) || // So  [11] WHITE UP POINTING BACKHAND INDEX..OPEN HANDS SIGN
		0x1F46E == code || // So       POLICE OFFICER
		(0x1F470 <= code && code <= 0x1F478) || // So   [9] BRIDE WITH VEIL..PRINCESS
		0x1F47C == code || // So       BABY ANGEL
		(0x1F481 <= code && code <= 0x1F483) || // So   [3] INFORMATION DESK PERSON..DANCER
		(0x1F485 <= code && code <= 0x1F487) || // So   [3] NAIL POLISH..HAIRCUT
		0x1F4AA == code || // So       FLEXED BICEPS
		(0x1F574 <= code && code <= 0x1F575) || // So   [2] MAN IN BUSINESS SUIT LEVITATING..SLEUTH OR SPY
		0x1F57A == code || // So       MAN DANCING
		0x1F590 == code || // So       RAISED HAND WITH FINGERS SPLAYED
		(0x1F595 <= code && code <= 0x1F596) || // So   [2] REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS
		(0x1F645 <= code && code <= 0x1F647) || // So   [3] FACE WITH NO GOOD GESTURE..PERSON BOWING DEEPLY
		(0x1F64B <= code && code <= 0x1F64F) || // So   [5] HAPPY PERSON RAISING ONE HAND..PERSON WITH FOLDED HANDS
		0x1F6A3 == code || // So       ROWBOAT
		(0x1F6B4 <= code && code <= 0x1F6B6) || // So   [3] BICYCLIST..PEDESTRIAN
		0x1F6C0 == code || // So       BATH
		0x1F6CC == code || // So       SLEEPING ACCOMMODATION
		(0x1F918 <= code && code <= 0x1F91C) || // So   [5] SIGN OF THE HORNS..RIGHT-FACING FIST
		(0x1F91E <= code && code <= 0x1F91F) || // So   [2] HAND WITH INDEX AND MIDDLE FINGERS CROSSED..I LOVE YOU HAND SIGN
		0x1F926 == code || // So       FACE PALM
		(0x1F930 <= code && code <= 0x1F939) || // So  [10] PREGNANT WOMAN..JUGGLING
		(0x1F93D <= code && code <= 0x1F93E) || // So   [2] WATER POLO..HANDBALL
		(0x1F9D1 <= code && code <= 0x1F9DD) // So  [13] ADULT..ELF
		){
			return E_Base;
		}

		if(
		(0x1F3FB <= code && code <= 0x1F3FF) // Sk   [5] EMOJI MODIFIER FITZPATRICK TYPE-1-2..EMOJI MODIFIER FITZPATRICK TYPE-6
		){
			return E_Modifier;
		}

		if(
		0x200D == code // Cf       ZERO WIDTH JOINER
		){
			return ZWJ;
		}

		if(
		0x2640 == code || // So       FEMALE SIGN
		0x2642 == code || // So       MALE SIGN
		(0x2695 <= code && code <= 0x2696) || // So   [2] STAFF OF AESCULAPIUS..SCALES
		0x2708 == code || // So       AIRPLANE
		0x2764 == code || // So       HEAVY BLACK HEART
		0x1F308 == code || // So       RAINBOW
		0x1F33E == code || // So       EAR OF RICE
		0x1F373 == code || // So       COOKING
		0x1F393 == code || // So       GRADUATION CAP
		0x1F3A4 == code || // So       MICROPHONE
		0x1F3A8 == code || // So       ARTIST PALETTE
		0x1F3EB == code || // So       SCHOOL
		0x1F3ED == code || // So       FACTORY
		0x1F48B == code || // So       KISS MARK
		(0x1F4BB <= code && code <= 0x1F4BC) || // So   [2] PERSONAL COMPUTER..BRIEFCASE
		0x1F527 == code || // So       WRENCH
		0x1F52C == code || // So       MICROSCOPE
		0x1F5E8 == code || // So       LEFT SPEECH BUBBLE
		0x1F680 == code || // So       ROCKET
		0x1F692 == code // So       FIRE ENGINE
		){
			return Glue_After_Zwj;
		}

		if(
		(0x1F466 <= code && code <= 0x1F469) // So   [4] BOY..WOMAN
		){
			return E_Base_GAZ;
		}
		
		
		//all unlisted characters have a grapheme break property of "Other"
		return Other;
	}
	return this;
}

if ( true && module.exports) {
    module.exports = GraphemeSplitter;
}


/***/ }),
/* 377 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cache": () => /* reexport safe */ _Cache__WEBPACK_IMPORTED_MODULE_0__.Cache,
/* harmony export */   "DEFAULT_RC_FILENAME": () => /* reexport safe */ _Configuration__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_RC_FILENAME,
/* harmony export */   "DEFAULT_LOCK_FILENAME": () => /* reexport safe */ _Configuration__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_LOCK_FILENAME,
/* harmony export */   "Configuration": () => /* reexport safe */ _Configuration__WEBPACK_IMPORTED_MODULE_1__.Configuration,
/* harmony export */   "FormatType": () => /* reexport safe */ _Configuration__WEBPACK_IMPORTED_MODULE_1__.FormatType,
/* harmony export */   "ProjectLookup": () => /* reexport safe */ _Configuration__WEBPACK_IMPORTED_MODULE_1__.ProjectLookup,
/* harmony export */   "SettingsType": () => /* reexport safe */ _Configuration__WEBPACK_IMPORTED_MODULE_1__.SettingsType,
/* harmony export */   "BuildType": () => /* reexport safe */ _Installer__WEBPACK_IMPORTED_MODULE_2__.BuildType,
/* harmony export */   "LightReport": () => /* reexport safe */ _LightReport__WEBPACK_IMPORTED_MODULE_3__.LightReport,
/* harmony export */   "Manifest": () => /* reexport safe */ _Manifest__WEBPACK_IMPORTED_MODULE_4__.Manifest,
/* harmony export */   "MessageName": () => /* reexport safe */ _MessageName__WEBPACK_IMPORTED_MODULE_5__.MessageName,
/* harmony export */   "Project": () => /* reexport safe */ _Project__WEBPACK_IMPORTED_MODULE_6__.Project,
/* harmony export */   "TAG_REGEXP": () => /* reexport safe */ _ProtocolResolver__WEBPACK_IMPORTED_MODULE_7__.TAG_REGEXP,
/* harmony export */   "ReportError": () => /* reexport safe */ _Report__WEBPACK_IMPORTED_MODULE_8__.ReportError,
/* harmony export */   "Report": () => /* reexport safe */ _Report__WEBPACK_IMPORTED_MODULE_8__.Report,
/* harmony export */   "StreamReport": () => /* reexport safe */ _StreamReport__WEBPACK_IMPORTED_MODULE_9__.StreamReport,
/* harmony export */   "TelemetryManager": () => /* reexport safe */ _TelemetryManager__WEBPACK_IMPORTED_MODULE_10__.TelemetryManager,
/* harmony export */   "ThrowReport": () => /* reexport safe */ _ThrowReport__WEBPACK_IMPORTED_MODULE_11__.ThrowReport,
/* harmony export */   "VirtualFetcher": () => /* reexport safe */ _VirtualFetcher__WEBPACK_IMPORTED_MODULE_12__.VirtualFetcher,
/* harmony export */   "WorkspaceResolver": () => /* reexport safe */ _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_13__.WorkspaceResolver,
/* harmony export */   "Workspace": () => /* reexport safe */ _Workspace__WEBPACK_IMPORTED_MODULE_14__.Workspace,
/* harmony export */   "YarnVersion": () => /* reexport safe */ _YarnVersion__WEBPACK_IMPORTED_MODULE_15__.YarnVersion,
/* harmony export */   "LinkType": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_16__.LinkType,
/* harmony export */   "PackageExtensionType": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_16__.PackageExtensionType,
/* harmony export */   "PackageExtensionStatus": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_16__.PackageExtensionStatus,
/* harmony export */   "hashUtils": () => /* reexport module object */ _hashUtils__WEBPACK_IMPORTED_MODULE_17__,
/* harmony export */   "httpUtils": () => /* reexport module object */ _httpUtils__WEBPACK_IMPORTED_MODULE_18__,
/* harmony export */   "execUtils": () => /* reexport module object */ _execUtils__WEBPACK_IMPORTED_MODULE_19__,
/* harmony export */   "folderUtils": () => /* reexport module object */ _folderUtils__WEBPACK_IMPORTED_MODULE_20__,
/* harmony export */   "formatUtils": () => /* reexport module object */ _formatUtils__WEBPACK_IMPORTED_MODULE_21__,
/* harmony export */   "miscUtils": () => /* reexport module object */ _miscUtils__WEBPACK_IMPORTED_MODULE_22__,
/* harmony export */   "scriptUtils": () => /* reexport module object */ _scriptUtils__WEBPACK_IMPORTED_MODULE_23__,
/* harmony export */   "semverUtils": () => /* reexport module object */ _semverUtils__WEBPACK_IMPORTED_MODULE_24__,
/* harmony export */   "structUtils": () => /* reexport module object */ _structUtils__WEBPACK_IMPORTED_MODULE_25__,
/* harmony export */   "tgzUtils": () => /* reexport module object */ _tgzUtils__WEBPACK_IMPORTED_MODULE_26__,
/* harmony export */   "treeUtils": () => /* reexport module object */ _treeUtils__WEBPACK_IMPORTED_MODULE_27__
/* harmony export */ });
/* harmony import */ var _execUtils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(373);
/* harmony import */ var _folderUtils__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(223);
/* harmony import */ var _formatUtils__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(13);
/* harmony import */ var _hashUtils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(71);
/* harmony import */ var _httpUtils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(239);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(177);
/* harmony import */ var _scriptUtils__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(340);
/* harmony import */ var _semverUtils__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(231);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(26);
/* harmony import */ var _tgzUtils__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(380);
/* harmony import */ var _treeUtils__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(411);
/* harmony import */ var _Cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(378);
/* harmony import */ var _Configuration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(181);
/* harmony import */ var _Installer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(339);
/* harmony import */ var _LightReport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(379);
/* harmony import */ var _Manifest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(237);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(180);
/* harmony import */ var _Project__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(254);
/* harmony import */ var _ProtocolResolver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(230);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(233);
/* harmony import */ var _StreamReport__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(374);
/* harmony import */ var _TelemetryManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(238);
/* harmony import */ var _ThrowReport__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(335);
/* harmony import */ var _VirtualFetcher__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(235);
/* harmony import */ var _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(229);
/* harmony import */ var _Workspace__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(334);
/* harmony import */ var _YarnVersion__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(372);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(179);









































/***/ }),
/* 378 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cache": () => /* binding */ Cache
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(165);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(172);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(163);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(168);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(341);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(180);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(233);
/* harmony import */ var _hashUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(71);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(177);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);









const CACHE_VERSION = 7;
class Cache {
  constructor(cacheCwd, {
    configuration,
    immutable = configuration.get(`enableImmutableCache`),
    check = false
  }) {
    // Contains the list of cache files that got accessed since the last time
    // you cleared the variable. Useful to know which files aren't needed
    // anymore when used in conjunction with fetchEverything.
    this.markedFiles = new Set();
    this.mutexes = new Map();
    this.configuration = configuration;
    this.cwd = cacheCwd;
    this.immutable = immutable;
    this.check = check;
    const cacheKeyOverride = configuration.get(`cacheKeyOverride`);

    if (cacheKeyOverride !== null) {
      this.cacheKey = `${cacheKeyOverride}`;
    } else {
      const compressionLevel = configuration.get(`compressionLevel`);
      const compressionKey = compressionLevel !== _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_COMPRESSION_LEVEL ? `c${compressionLevel}` : ``;
      this.cacheKey = [CACHE_VERSION, compressionKey].join(``);
    }
  }

  static async find(configuration, {
    immutable,
    check
  } = {}) {
    const cache = new Cache(configuration.get(`cacheFolder`), {
      configuration,
      immutable,
      check
    });
    await cache.setup();
    return cache;
  }

  get mirrorCwd() {
    if (!this.configuration.get(`enableMirror`)) return null;
    const mirrorCwd = `${this.configuration.get(`globalFolder`)}/cache`;
    return mirrorCwd !== this.cwd ? mirrorCwd : null;
  }

  getVersionFilename(locator) {
    return `${_structUtils__WEBPACK_IMPORTED_MODULE_3__.slugifyLocator(locator)}-${this.cacheKey}.zip`;
  }

  getChecksumFilename(locator, checksum) {
    // We only want the actual checksum (not the cache version, since the whole
    // point is to avoid changing the filenames when the cache version changes)
    const contentChecksum = getHashComponent(checksum); // We only care about the first few characters. It doesn't matter if that
    // makes the hash easier to collide with, because we check the file hashes
    // during each install anyway.

    const significantChecksum = contentChecksum.slice(0, 10);
    return `${_structUtils__WEBPACK_IMPORTED_MODULE_3__.slugifyLocator(locator)}-${significantChecksum}.zip`;
  }

  getLocatorPath(locator, expectedChecksum) {
    // If there is no mirror, then the local cache *is* the mirror, in which
    // case we use the versioned filename pattern.
    if (this.mirrorCwd === null) return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(this.cwd, this.getVersionFilename(locator)); // If we don't yet know the checksum, discard the path resolution for now
    // until the checksum can be obtained from somewhere (mirror or network).

    if (expectedChecksum === null) return null; // If the cache key changed then we assume that the content probably got
    // altered as well and thus the existing path won't be good enough anymore.

    const cacheKey = getCacheKeyComponent(expectedChecksum);
    if (cacheKey !== this.cacheKey) return null;
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(this.cwd, this.getChecksumFilename(locator, expectedChecksum));
  }

  getLocatorMirrorPath(locator) {
    const mirrorCwd = this.mirrorCwd;
    return mirrorCwd !== null ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(mirrorCwd, this.getVersionFilename(locator)) : null;
  }

  async setup() {
    if (!this.configuration.get(`enableGlobalCache`)) {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.mkdirPromise(this.cwd, {
        recursive: true
      });
      const gitignorePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(this.cwd, `.gitignore`);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.changeFilePromise(gitignorePath, `/.gitignore\n*.flock\n`);
    }
  }

  async fetchPackageFromCache(locator, expectedChecksum, {
    onHit,
    onMiss,
    loader,
    skipIntegrityCheck
  }) {
    const mirrorPath = this.getLocatorMirrorPath(locator);
    const baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.NodeFS();

    const validateFile = async (path, refetchPath = null) => {
      const actualChecksum = !skipIntegrityCheck || !expectedChecksum ? `${this.cacheKey}/${await _hashUtils__WEBPACK_IMPORTED_MODULE_7__.checksumFile(path)}` : expectedChecksum;

      if (refetchPath !== null) {
        const previousChecksum = !skipIntegrityCheck || !expectedChecksum ? `${this.cacheKey}/${await _hashUtils__WEBPACK_IMPORTED_MODULE_7__.checksumFile(refetchPath)}` : expectedChecksum;

        if (actualChecksum !== previousChecksum) {
          throw new _Report__WEBPACK_IMPORTED_MODULE_8__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_9__.MessageName.CACHE_CHECKSUM_MISMATCH, `The remote archive doesn't match the local checksum - has the local cache been corrupted?`);
        }
      }

      if (expectedChecksum !== null && actualChecksum !== expectedChecksum) {
        let checksumBehavior; // Using --check-cache overrides any preconfigured checksum behavior

        if (this.check) checksumBehavior = `throw`; // If the lockfile references an old cache format, we tolerate different checksums
        else if (getCacheKeyComponent(expectedChecksum) !== getCacheKeyComponent(actualChecksum)) checksumBehavior = `update`;else checksumBehavior = this.configuration.get(`checksumBehavior`);

        switch (checksumBehavior) {
          case `ignore`:
            return expectedChecksum;

          case `update`:
            return actualChecksum;

          default:
          case `throw`:
            {
              throw new _Report__WEBPACK_IMPORTED_MODULE_8__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_9__.MessageName.CACHE_CHECKSUM_MISMATCH, `The remote archive doesn't match the expected checksum`);
            }
        }
      }

      return actualChecksum;
    };

    const validateFileAgainstRemote = async cachePath => {
      if (!loader) throw new Error(`Cache check required but no loader configured for ${_structUtils__WEBPACK_IMPORTED_MODULE_3__.prettyLocator(this.configuration, locator)}`);
      const zipFs = await loader();
      const refetchPath = zipFs.getRealPath();
      zipFs.saveAndClose();
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.chmodPromise(refetchPath, 0o644);
      return await validateFile(cachePath, refetchPath);
    };

    const loadPackageThroughMirror = async () => {
      if (mirrorPath === null || !(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.existsPromise(mirrorPath))) {
        const zipFs = await loader();
        const realPath = zipFs.getRealPath();
        zipFs.saveAndClose();
        return realPath;
      }

      const tempDir = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.mktempPromise();
      const tempPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(tempDir, this.getVersionFilename(locator));
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.copyFilePromise(mirrorPath, tempPath, (fs__WEBPACK_IMPORTED_MODULE_1___default().constants.COPYFILE_FICLONE));
      return tempPath;
    };

    const loadPackage = async () => {
      if (!loader) throw new Error(`Cache entry required but missing for ${_structUtils__WEBPACK_IMPORTED_MODULE_3__.prettyLocator(this.configuration, locator)}`);
      if (this.immutable) throw new _Report__WEBPACK_IMPORTED_MODULE_8__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_9__.MessageName.IMMUTABLE_CACHE, `Cache entry required but missing for ${_structUtils__WEBPACK_IMPORTED_MODULE_3__.prettyLocator(this.configuration, locator)}`);
      const originalPath = await loadPackageThroughMirror();
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.chmodPromise(originalPath, 0o644); // Do this before moving the file so that we don't pollute the cache with corrupted archives

      const checksum = await validateFile(originalPath);
      const cachePath = this.getLocatorPath(locator, checksum);
      if (!cachePath) throw new Error(`Assertion failed: Expected the cache path to be available`);
      return await this.writeFileWithLock(cachePath, async () => {
        return await this.writeFileWithLock(mirrorPath, async () => {
          // Doing a move is important to ensure atomic writes (todo: cross-drive?)
          await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.movePromise(originalPath, cachePath);
          if (mirrorPath !== null) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.copyFilePromise(cachePath, mirrorPath, (fs__WEBPACK_IMPORTED_MODULE_1___default().constants.COPYFILE_FICLONE));
          return [cachePath, checksum];
        });
      });
    };

    const loadPackageThroughMutex = async () => {
      const mutexedLoad = async () => {
        // We don't yet know whether the cache path can be computed yet, since that
        // depends on whether the cache is actually the mirror or not, and whether
        // the checksum is known or not.
        const tentativeCachePath = this.getLocatorPath(locator, expectedChecksum);
        const cacheExists = tentativeCachePath !== null ? await baseFs.existsPromise(tentativeCachePath) : false;
        const action = cacheExists ? onHit : onMiss;
        if (action) action();

        if (!cacheExists) {
          return loadPackage();
        } else {
          let checksum = null;
          const cachePath = tentativeCachePath;
          if (this.check) checksum = await validateFileAgainstRemote(cachePath);else checksum = await validateFile(cachePath);
          return [cachePath, checksum];
        }
      };

      const mutex = mutexedLoad();
      this.mutexes.set(locator.locatorHash, mutex);

      try {
        return await mutex;
      } finally {
        this.mutexes.delete(locator.locatorHash);
      }
    };

    for (let mutex; mutex = this.mutexes.get(locator.locatorHash);) await mutex;

    const [cachePath, checksum] = await loadPackageThroughMutex();
    this.markedFiles.add(cachePath);
    let zipFs = null;
    const libzip = await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)();
    const lazyFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.LazyFS(() => _miscUtils__WEBPACK_IMPORTED_MODULE_11__.prettifySyncErrors(() => {
      return zipFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ZipFS(cachePath, {
        baseFs,
        libzip,
        readOnly: true
      });
    }, message => {
      return `Failed to open the cache entry for ${_structUtils__WEBPACK_IMPORTED_MODULE_3__.prettyLocator(this.configuration, locator)}: ${message}`;
    }), _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath); // We use an AliasFS to speed up getRealPath calls (e.g. VirtualFetcher.ensureVirtualLink)
    // (there's no need to create the lazy baseFs instance to gather the already-known cachePath)

    const aliasFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__.AliasFS(cachePath, {
      baseFs: lazyFs,
      pathUtils: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath
    });

    const releaseFs = () => {
      if (zipFs !== null) {
        zipFs.discardAndClose();
      }
    };

    return [aliasFs, releaseFs, checksum];
  }

  async writeFileWithLock(file, generator) {
    if (file === null) return await generator();
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.dirname(file), {
      recursive: true
    });
    return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.lockPromise(file, async () => {
      return await generator();
    });
  }

}

function getCacheKeyComponent(checksum) {
  const split = checksum.indexOf(`/`);
  return split !== -1 ? checksum.slice(0, split) : null;
}

function getHashComponent(checksum) {
  const split = checksum.indexOf(`/`);
  return split !== -1 ? checksum.slice(split + 1) : checksum;
}

/***/ }),
/* 379 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LightReport": () => /* binding */ LightReport
/* harmony export */ });
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(233);
/* harmony import */ var _StreamReport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(374);
/* harmony import */ var _formatUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);



class LightReport extends _Report__WEBPACK_IMPORTED_MODULE_0__.Report {
  constructor({
    configuration,
    stdout,
    suggestInstall = true
  }) {
    super();
    this.errorCount = 0;
    _formatUtils__WEBPACK_IMPORTED_MODULE_1__.addLogFilterSupport(this, {
      configuration
    });
    this.configuration = configuration;
    this.stdout = stdout;
    this.suggestInstall = suggestInstall;
  }

  static async start(opts, cb) {
    const report = new this(opts);

    try {
      await cb(report);
    } catch (error) {
      report.reportExceptionOnce(error);
    } finally {
      await report.finalize();
    }

    return report;
  }

  hasErrors() {
    return this.errorCount > 0;
  }

  exitCode() {
    return this.hasErrors() ? 1 : 0;
  }

  reportCacheHit(locator) {}

  reportCacheMiss(locator) {}

  startTimerSync(what, opts, cb) {
    const realCb = typeof opts === `function` ? opts : cb;
    return realCb();
  }

  async startTimerPromise(what, opts, cb) {
    const realCb = typeof opts === `function` ? opts : cb;
    return await realCb();
  }

  async startCacheReport(cb) {
    return await cb();
  }

  reportSeparator() {}

  reportInfo(name, text) {}

  reportWarning(name, text) {}

  reportError(name, text) {
    this.errorCount += 1;
    this.stdout.write(`${_formatUtils__WEBPACK_IMPORTED_MODULE_1__.pretty(this.configuration, ``, `redBright`)} ${this.formatNameWithHyperlink(name)}: ${text}\n`);
  }

  reportProgress(progress) {
    const promise = Promise.resolve().then(async () => {
      // eslint-disable-next-line no-empty-pattern
      for await (const {} of progress) {// No need to do anything; we just want to consume the progress events
      }
    });

    const stop = () => {// Nothing to stop
    };

    return { ...promise,
      stop
    };
  }

  reportJson(data) {// Just ignore the json output
  }

  async finalize() {
    if (this.errorCount > 0) {
      this.stdout.write(`${_formatUtils__WEBPACK_IMPORTED_MODULE_1__.pretty(this.configuration, ``, `redBright`)} Errors happened when preparing the environment required to run this command.\n`);

      if (this.suggestInstall) {
        this.stdout.write(`${_formatUtils__WEBPACK_IMPORTED_MODULE_1__.pretty(this.configuration, ``, `redBright`)} This might be caused by packages being missing from the lockfile, in which case running "yarn install" might help.\n`);
      }
    }
  }

  formatNameWithHyperlink(name) {
    return (0,_StreamReport__WEBPACK_IMPORTED_MODULE_2__.formatNameWithHyperlink)(name, {
      configuration: this.configuration,
      json: false
    });
  }

}

/***/ }),
/* 380 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeArchiveFromDirectory": () => /* binding */ makeArchiveFromDirectory,
/* harmony export */   "convertToZip": () => /* binding */ convertToZip,
/* harmony export */   "extractArchiveTo": () => /* binding */ extractArchiveTo
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(165);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(163);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(341);
/* harmony import */ var tar_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(381);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(164);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_3__);





const gunzip = (0,util__WEBPACK_IMPORTED_MODULE_2__.promisify)((zlib__WEBPACK_IMPORTED_MODULE_3___default().gunzip));
async function makeArchiveFromDirectory(source, {
  baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.NodeFS(),
  prefixPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.PortablePath.root,
  compressionLevel,
  inMemory = false
} = {}) {
  const libzip = await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)();
  let zipFs;

  if (inMemory) {
    zipFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ZipFS(null, {
      libzip,
      level: compressionLevel
    });
  } else {
    const tmpFolder = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.xfs.mktempPromise();
    const tmpFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(tmpFolder, `archive.zip`);
    zipFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ZipFS(tmpFile, {
      create: true,
      libzip,
      level: compressionLevel
    });
  }

  const target = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.PortablePath.root, prefixPath);
  await zipFs.copyPromise(target, source, {
    baseFs,
    stableTime: true,
    stableSort: true
  });
  return zipFs;
}
async function convertToZip(tgz, opts) {
  const tmpFolder = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.xfs.mktempPromise();
  const tmpFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(tmpFolder, `archive.zip`);
  const {
    compressionLevel,
    ...bufferOpts
  } = opts;
  return await extractArchiveTo(tgz, new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ZipFS(tmpFile, {
    create: true,
    libzip: await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)(),
    level: compressionLevel
  }), bufferOpts);
}
async function extractArchiveTo(tgz, targetFs, {
  stripComponents = 0,
  prefixPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.PortablePath.dot
} = {}) {
  // 1980-01-01, like Fedora
  const defaultTime = 315532800;
  const parser = tar_stream__WEBPACK_IMPORTED_MODULE_1__.extract();

  function ignore(entry) {
    // Disallow absolute paths; might be malicious (ex: /etc/passwd)
    if (entry.name[0] === `/`) return true;
    const parts = entry.name.split(/\//g); // We also ignore paths that could lead to escaping outside the archive

    if (parts.some(part => part === `..`)) return true;
    if (parts.length <= stripComponents) return true;
    return false;
  }

  parser.on(`entry`, (header, stream, next) => {
    var _a, _b;

    if (ignore(header)) {
      next();
      return;
    }

    const parts = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.normalize(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.toPortablePath(header.name)).replace(/\/$/, ``).split(/\//g);

    if (parts.length <= stripComponents) {
      stream.resume();
      next();
      return;
    }

    const slicePath = parts.slice(stripComponents).join(`/`);
    const mappedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(prefixPath, slicePath);
    let mode = 0o644; // If a single executable bit is set, normalize so that all are

    if (header.type === `directory` || (((_a = header.mode) !== null && _a !== void 0 ? _a : 0) & 0o111) !== 0) mode |= 0o111;

    switch (header.type) {
      case `directory`:
        {
          targetFs.mkdirpSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.dirname(mappedPath), {
            chmod: 0o755,
            utimes: [defaultTime, defaultTime]
          });
          targetFs.mkdirSync(mappedPath);
          targetFs.chmodSync(mappedPath, mode);
          targetFs.utimesSync(mappedPath, defaultTime, defaultTime);
          next();
        }
        break;

      case `file`:
        {
          targetFs.mkdirpSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.dirname(mappedPath), {
            chmod: 0o755,
            utimes: [defaultTime, defaultTime]
          });
          const chunks = [];
          stream.on(`data`, chunk => chunks.push(chunk));
          stream.on(`end`, () => {
            targetFs.writeFileSync(mappedPath, Buffer.concat(chunks));
            targetFs.chmodSync(mappedPath, mode);
            targetFs.utimesSync(mappedPath, defaultTime, defaultTime);
            next();
          });
        }
        break;

      case `symlink`:
        {
          targetFs.mkdirpSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.dirname(mappedPath), {
            chmod: 0o755,
            utimes: [defaultTime, defaultTime]
          });
          targetFs.symlinkSync(header.linkname, mappedPath);
          (_b = targetFs.lutimesSync) === null || _b === void 0 ? void 0 : _b.call(targetFs, mappedPath, defaultTime, defaultTime);
          next();
        }
        break;

      default:
        {
          stream.resume();
          next();
        }
    }
  });
  const gunzipped = await gunzip(tgz);
  return await new Promise((resolve, reject) => {
    parser.on(`error`, error => {
      reject(error);
    });
    parser.on(`finish`, () => {
      resolve(targetFs);
    });
    parser.end(gunzipped);
  });
}

/***/ }),
/* 381 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.extract = __webpack_require__(382)
exports.pack = __webpack_require__(405)


/***/ }),
/* 382 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(90)
var bl = __webpack_require__(383)
var headers = __webpack_require__(404)

var Writable = __webpack_require__(384).Writable
var PassThrough = __webpack_require__(384).PassThrough

var noop = function () {}

var overflow = function (size) {
  size &= 511
  return size && 512 - size
}

var emptyStream = function (self, offset) {
  var s = new Source(self, offset)
  s.end()
  return s
}

var mixinPax = function (header, pax) {
  if (pax.path) header.name = pax.path
  if (pax.linkpath) header.linkname = pax.linkpath
  if (pax.size) header.size = parseInt(pax.size, 10)
  header.pax = pax
  return header
}

var Source = function (self, offset) {
  this._parent = self
  this.offset = offset
  PassThrough.call(this)
}

util.inherits(Source, PassThrough)

Source.prototype.destroy = function (err) {
  this._parent.destroy(err)
}

var Extract = function (opts) {
  if (!(this instanceof Extract)) return new Extract(opts)
  Writable.call(this, opts)

  opts = opts || {}

  this._offset = 0
  this._buffer = bl()
  this._missing = 0
  this._partial = false
  this._onparse = noop
  this._header = null
  this._stream = null
  this._overflow = null
  this._cb = null
  this._locked = false
  this._destroyed = false
  this._pax = null
  this._paxGlobal = null
  this._gnuLongPath = null
  this._gnuLongLinkPath = null

  var self = this
  var b = self._buffer

  var oncontinue = function () {
    self._continue()
  }

  var onunlock = function (err) {
    self._locked = false
    if (err) return self.destroy(err)
    if (!self._stream) oncontinue()
  }

  var onstreamend = function () {
    self._stream = null
    var drain = overflow(self._header.size)
    if (drain) self._parse(drain, ondrain)
    else self._parse(512, onheader)
    if (!self._locked) oncontinue()
  }

  var ondrain = function () {
    self._buffer.consume(overflow(self._header.size))
    self._parse(512, onheader)
    oncontinue()
  }

  var onpaxglobalheader = function () {
    var size = self._header.size
    self._paxGlobal = headers.decodePax(b.slice(0, size))
    b.consume(size)
    onstreamend()
  }

  var onpaxheader = function () {
    var size = self._header.size
    self._pax = headers.decodePax(b.slice(0, size))
    if (self._paxGlobal) self._pax = Object.assign({}, self._paxGlobal, self._pax)
    b.consume(size)
    onstreamend()
  }

  var ongnulongpath = function () {
    var size = self._header.size
    this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)
    b.consume(size)
    onstreamend()
  }

  var ongnulonglinkpath = function () {
    var size = self._header.size
    this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)
    b.consume(size)
    onstreamend()
  }

  var onheader = function () {
    var offset = self._offset
    var header
    try {
      header = self._header = headers.decode(b.slice(0, 512), opts.filenameEncoding)
    } catch (err) {
      self.emit('error', err)
    }
    b.consume(512)

    if (!header) {
      self._parse(512, onheader)
      oncontinue()
      return
    }
    if (header.type === 'gnu-long-path') {
      self._parse(header.size, ongnulongpath)
      oncontinue()
      return
    }
    if (header.type === 'gnu-long-link-path') {
      self._parse(header.size, ongnulonglinkpath)
      oncontinue()
      return
    }
    if (header.type === 'pax-global-header') {
      self._parse(header.size, onpaxglobalheader)
      oncontinue()
      return
    }
    if (header.type === 'pax-header') {
      self._parse(header.size, onpaxheader)
      oncontinue()
      return
    }

    if (self._gnuLongPath) {
      header.name = self._gnuLongPath
      self._gnuLongPath = null
    }

    if (self._gnuLongLinkPath) {
      header.linkname = self._gnuLongLinkPath
      self._gnuLongLinkPath = null
    }

    if (self._pax) {
      self._header = header = mixinPax(header, self._pax)
      self._pax = null
    }

    self._locked = true

    if (!header.size || header.type === 'directory') {
      self._parse(512, onheader)
      self.emit('entry', header, emptyStream(self, offset), onunlock)
      return
    }

    self._stream = new Source(self, offset)

    self.emit('entry', header, self._stream, onunlock)
    self._parse(header.size, onstreamend)
    oncontinue()
  }

  this._onheader = onheader
  this._parse(512, onheader)
}

util.inherits(Extract, Writable)

Extract.prototype.destroy = function (err) {
  if (this._destroyed) return
  this._destroyed = true

  if (err) this.emit('error', err)
  this.emit('close')
  if (this._stream) this._stream.emit('close')
}

Extract.prototype._parse = function (size, onparse) {
  if (this._destroyed) return
  this._offset += size
  this._missing = size
  if (onparse === this._onheader) this._partial = false
  this._onparse = onparse
}

Extract.prototype._continue = function () {
  if (this._destroyed) return
  var cb = this._cb
  this._cb = noop
  if (this._overflow) this._write(this._overflow, undefined, cb)
  else cb()
}

Extract.prototype._write = function (data, enc, cb) {
  if (this._destroyed) return

  var s = this._stream
  var b = this._buffer
  var missing = this._missing
  if (data.length) this._partial = true

  // we do not reach end-of-chunk now. just forward it

  if (data.length < missing) {
    this._missing -= data.length
    this._overflow = null
    if (s) return s.write(data, cb)
    b.append(data)
    return cb()
  }

  // end-of-chunk. the parser should call cb.

  this._cb = cb
  this._missing = 0

  var overflow = null
  if (data.length > missing) {
    overflow = data.slice(missing)
    data = data.slice(0, missing)
  }

  if (s) s.end(data)
  else b.append(data)

  this._overflow = overflow
  this._onparse()
}

Extract.prototype._final = function (cb) {
  if (this._partial) return this.destroy(new Error('Unexpected end of data'))
  cb()
}

module.exports = Extract


/***/ }),
/* 383 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DuplexStream = __webpack_require__(384).Duplex
  , util         = __webpack_require__(90)

function BufferList (callback) {
  if (!(this instanceof BufferList))
    return new BufferList(callback)

  this._bufs  = []
  this.length = 0

  if (typeof callback == 'function') {
    this._callback = callback

    var piper = function piper (err) {
      if (this._callback) {
        this._callback(err)
        this._callback = null
      }
    }.bind(this)

    this.on('pipe', function onPipe (src) {
      src.on('error', piper)
    })
    this.on('unpipe', function onUnpipe (src) {
      src.removeListener('error', piper)
    })
  } else {
    this.append(callback)
  }

  DuplexStream.call(this)
}


util.inherits(BufferList, DuplexStream)


BufferList.prototype._offset = function _offset (offset) {
  var tot = 0, i = 0, _t
  if (offset === 0) return [ 0, 0 ]
  for (; i < this._bufs.length; i++) {
    _t = tot + this._bufs[i].length
    if (offset < _t || i == this._bufs.length - 1) {
      return [ i, offset - tot ]
    }
    tot = _t
  }
}

BufferList.prototype._reverseOffset = function (blOffset) {
  var bufferId = blOffset[0]
  var offset = blOffset[1]
  for (var i = 0; i < bufferId; i++) {
    offset += this._bufs[i].length
  }
  return offset
}

BufferList.prototype.append = function append (buf) {
  var i = 0

  if (Buffer.isBuffer(buf)) {
    this._appendBuffer(buf)
  } else if (Array.isArray(buf)) {
    for (; i < buf.length; i++)
      this.append(buf[i])
  } else if (buf instanceof BufferList) {
    // unwrap argument into individual BufferLists
    for (; i < buf._bufs.length; i++)
      this.append(buf._bufs[i])
  } else if (buf != null) {
    // coerce number arguments to strings, since Buffer(number) does
    // uninitialized memory allocation
    if (typeof buf == 'number')
      buf = buf.toString()

    this._appendBuffer(Buffer.from(buf))
  }

  return this
}


BufferList.prototype._appendBuffer = function appendBuffer (buf) {
  this._bufs.push(buf)
  this.length += buf.length
}


BufferList.prototype._write = function _write (buf, encoding, callback) {
  this._appendBuffer(buf)

  if (typeof callback == 'function')
    callback()
}


BufferList.prototype._read = function _read (size) {
  if (!this.length)
    return this.push(null)

  size = Math.min(size, this.length)
  this.push(this.slice(0, size))
  this.consume(size)
}


BufferList.prototype.end = function end (chunk) {
  DuplexStream.prototype.end.call(this, chunk)

  if (this._callback) {
    this._callback(null, this.slice())
    this._callback = null
  }
}


BufferList.prototype.get = function get (index) {
  if (index > this.length || index < 0) {
    return undefined
  }
  var offset = this._offset(index)
  return this._bufs[offset[0]][offset[1]]
}


BufferList.prototype.slice = function slice (start, end) {
  if (typeof start == 'number' && start < 0)
    start += this.length
  if (typeof end == 'number' && end < 0)
    end += this.length
  return this.copy(null, 0, start, end)
}


BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart != 'number' || srcStart < 0)
    srcStart = 0
  if (typeof srcEnd != 'number' || srcEnd > this.length)
    srcEnd = this.length
  if (srcStart >= this.length)
    return dst || Buffer.alloc(0)
  if (srcEnd <= 0)
    return dst || Buffer.alloc(0)

  var copy   = !!dst
    , off    = this._offset(srcStart)
    , len    = srcEnd - srcStart
    , bytes  = len
    , bufoff = (copy && dstStart) || 0
    , start  = off[1]
    , l
    , i

  // copy/slice everything
  if (srcStart === 0 && srcEnd == this.length) {
    if (!copy) { // slice, but full concat if multiple buffers
      return this._bufs.length === 1
        ? this._bufs[0]
        : Buffer.concat(this._bufs, this.length)
    }

    // copy, need to copy individual buffers
    for (i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff)
      bufoff += this._bufs[i].length
    }

    return dst
  }

  // easy, cheap case where it's a subset of one of the buffers
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy
      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
      : this._bufs[off[0]].slice(start, start + bytes)
  }

  if (!copy) // a slice, we need something to copy in to
    dst = Buffer.allocUnsafe(len)

  for (i = off[0]; i < this._bufs.length; i++) {
    l = this._bufs[i].length - start

    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start)
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes)
      break
    }

    bufoff += l
    bytes -= l

    if (start)
      start = 0
  }

  return dst
}

BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
  start = start || 0
  end = typeof end !== 'number' ? this.length : end

  if (start < 0)
    start += this.length
  if (end < 0)
    end += this.length

  if (start === end) {
    return new BufferList()
  }
  var startOffset = this._offset(start)
    , endOffset = this._offset(end)
    , buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)

  if (endOffset[1] == 0)
    buffers.pop()
  else
    buffers[buffers.length-1] = buffers[buffers.length-1].slice(0, endOffset[1])

  if (startOffset[1] != 0)
    buffers[0] = buffers[0].slice(startOffset[1])

  return new BufferList(buffers)
}

BufferList.prototype.toString = function toString (encoding, start, end) {
  return this.slice(start, end).toString(encoding)
}

BufferList.prototype.consume = function consume (bytes) {
  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length
      this.length -= this._bufs[0].length
      this._bufs.shift()
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes)
      this.length -= bytes
      break
    }
  }
  return this
}


BufferList.prototype.duplicate = function duplicate () {
  var i = 0
    , copy = new BufferList()

  for (; i < this._bufs.length; i++)
    copy.append(this._bufs[i])

  return copy
}


BufferList.prototype._destroy = function _destroy (err, cb) {
  this._bufs.length = 0
  this.length = 0
  cb(err)
}


BufferList.prototype.indexOf = function (search, offset, encoding) {
  if (encoding === undefined && typeof offset === 'string') {
    encoding = offset
    offset = undefined
  }
  if (typeof search === 'function' || Array.isArray(search)) {
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
  } else if (typeof search === 'number') {
      search = Buffer.from([search])
  } else if (typeof search === 'string') {
    search = Buffer.from(search, encoding)
  } else if (search instanceof BufferList) {
    search = search.slice()
  } else if (!Buffer.isBuffer(search)) {
    search = Buffer.from(search)
  }

  offset = Number(offset || 0)
  if (isNaN(offset)) {
    offset = 0
  }

  if (offset < 0) {
    offset = this.length + offset
  }

  if (offset < 0) {
    offset = 0
  }

  if (search.length === 0) {
    return offset > this.length ? this.length : offset
  }

  var blOffset = this._offset(offset)
  var blIndex = blOffset[0] // index of which internal buffer we're working on
  var buffOffset = blOffset[1] // offset of the internal buffer we're working on

  // scan over each buffer
  for (blIndex; blIndex < this._bufs.length; blIndex++) {
    var buff = this._bufs[blIndex]
    while(buffOffset < buff.length) {
      var availableWindow = buff.length - buffOffset
      if (availableWindow >= search.length) {
        var nativeSearchResult = buff.indexOf(search, buffOffset)
        if (nativeSearchResult !== -1) {
          return this._reverseOffset([blIndex, nativeSearchResult])
        }
        buffOffset = buff.length - search.length + 1 // end of native search window
      } else {
        var revOffset = this._reverseOffset([blIndex, buffOffset])
        if (this._match(revOffset, search)) {
          return revOffset
        }
        buffOffset++
      }
    }
    buffOffset = 0
  }
  return -1
}

BufferList.prototype._match = function(offset, search) {
  if (this.length - offset < search.length) {
    return false
  }
  for (var searchOffset = 0; searchOffset < search.length ; searchOffset++) {
    if(this.get(offset + searchOffset) !== search[searchOffset]){
      return false
    }
  }
  return true
}


;(function () {
  var methods = {
      'readDoubleBE' : 8
    , 'readDoubleLE' : 8
    , 'readFloatBE'  : 4
    , 'readFloatLE'  : 4
    , 'readInt32BE'  : 4
    , 'readInt32LE'  : 4
    , 'readUInt32BE' : 4
    , 'readUInt32LE' : 4
    , 'readInt16BE'  : 2
    , 'readInt16LE'  : 2
    , 'readUInt16BE' : 2
    , 'readUInt16LE' : 2
    , 'readInt8'     : 1
    , 'readUInt8'    : 1
    , 'readIntBE'    : null
    , 'readIntLE'    : null
    , 'readUIntBE'   : null
    , 'readUIntLE'   : null
  }

  for (var m in methods) {
    (function (m) {
      if (methods[m] === null) {
        BufferList.prototype[m] = function (offset, byteLength) {
          return this.slice(offset, offset + byteLength)[m](0, byteLength)
        }
      }
      else {
        BufferList.prototype[m] = function (offset) {
          return this.slice(offset, offset + methods[m])[m](0)
        }
      }
    }(m))
  }
}())


module.exports = BufferList


/***/ }),
/* 384 */
/***/ ((module, exports, __webpack_require__) => {

var Stream = __webpack_require__(76);
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream.Readable;
  Object.assign(module.exports, Stream);
  module.exports.Stream = Stream;
} else {
  exports = module.exports = __webpack_require__(385);
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __webpack_require__(395);
  exports.Duplex = __webpack_require__(394);
  exports.Transform = __webpack_require__(401);
  exports.PassThrough = __webpack_require__(402);
  exports.finished = __webpack_require__(400);
  exports.pipeline = __webpack_require__(403);
}


/***/ }),
/* 385 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __webpack_require__(119).EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(386);
/*</replacement>*/


var Buffer = __webpack_require__(210).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __webpack_require__(90);

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(387);

var destroyImpl = __webpack_require__(388);

var _require = __webpack_require__(389),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __webpack_require__(390).codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

var _require2 = __webpack_require__(391),
    emitExperimentalWarning = _require2.emitExperimentalWarning; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;

__webpack_require__(392)(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(394);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(397).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(394);
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(397).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc); // if setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    emitExperimentalWarning('Readable[Symbol.asyncIterator]');

    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(399);
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

/***/ }),
/* 386 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(76);


/***/ }),
/* 387 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = __webpack_require__(210),
    Buffer = _require.Buffer;

var _require2 = __webpack_require__(90),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  var _proto = BufferList.prototype;

  _proto.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  _proto.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  _proto.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  _proto.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  _proto.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  _proto.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  } // Consumes a specified amount of bytes or characters from the buffered data.
  ;

  _proto.consume = function consume(n, hasStrings) {
    var ret;

    if (n < this.head.data.length) {
      // `slice` is the same for buffers and strings.
      ret = this.head.data.slice(0, n);
      this.head.data = this.head.data.slice(n);
    } else if (n === this.head.data.length) {
      // First chunk is a perfect match.
      ret = this.shift();
    } else {
      // Result spans more than one buffer.
      ret = hasStrings ? this._getString(n) : this._getBuffer(n);
    }

    return ret;
  };

  _proto.first = function first() {
    return this.head.data;
  } // Consumes a specified amount of characters from the buffered data.
  ;

  _proto._getString = function _getString(n) {
    var p = this.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;

    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;

      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = str.slice(nb);
        }

        break;
      }

      ++c;
    }

    this.length -= c;
    return ret;
  } // Consumes a specified amount of bytes from the buffered data.
  ;

  _proto._getBuffer = function _getBuffer(n) {
    var ret = Buffer.allocUnsafe(n);
    var p = this.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;

    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;

      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = buf.slice(nb);
        }

        break;
      }

      ++c;
    }

    this.length -= c;
    return ret;
  } // Make sure the linked list only shows the minimal necessary information.
  ;

  _proto[custom] = function (_, options) {
    return inspect(this, _objectSpread({}, options, {
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: false
    }));
  };

  return BufferList;
}();

/***/ }),
/* 388 */
/***/ ((module) => {

"use strict";
 // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      process.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      process.nextTick(emitErrorAndCloseNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 389 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = __webpack_require__(390).codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),
/* 390 */
/***/ ((module) => {

"use strict";


const codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error
  }

  function getMessage (arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message
    } else {
      return message(arg1, arg2, arg3)
    }
  }

  class NodeError extends Base {
    constructor (arg1, arg2, arg3) {
      super(getMessage(arg1, arg2, arg3));
    }
  }

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;

  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    const len = expected.length;
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
             expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
	return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
	if (this_len === undefined || this_len > str.length) {
		this_len = str.length;
	}
	return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"'
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  let determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  let msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = includes(name, '.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  }

  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented'
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

module.exports.codes = codes;


/***/ }),
/* 391 */
/***/ ((module) => {

"use strict";


var experimentalWarnings = new Set();

function emitExperimentalWarning(feature) {
  if (experimentalWarnings.has(feature)) return;
  var msg = feature + ' is an experimental feature. This feature could ' +
       'change at any time';
  experimentalWarnings.add(feature);
  process.emitWarning(msg, 'ExperimentalWarning');
}

function noop() {}

module.exports.emitExperimentalWarning = process.emitWarning
  ? emitExperimentalWarning
  : noop;


/***/ }),
/* 392 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(90);
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  module.exports = __webpack_require__(393);
}


/***/ }),
/* 393 */
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 394 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __webpack_require__(385);

var Writable = __webpack_require__(395);

__webpack_require__(392)(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),
/* 395 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(396)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(386);
/*</replacement>*/


var Buffer = __webpack_require__(210).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __webpack_require__(388);

var _require = __webpack_require__(389),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __webpack_require__(390).codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

__webpack_require__(392)(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(394);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(394); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    stream.emit('error', er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),
/* 396 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = __webpack_require__(90).deprecate;


/***/ }),
/* 397 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(398).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 398 */
/***/ ((module, exports, __webpack_require__) => {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(210)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 399 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = __webpack_require__(400);

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(null, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(null, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(null, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kLastPromise, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(null, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

/***/ }),
/* 400 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = __webpack_require__(390).codes.ERR_STREAM_PREMATURE_CLOSE;

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function once(callback) {
  var called = false;
  return function (err) {
    if (called) return;
    called = true;
    callback.call(this, err);
  };
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var ws = stream._writableState;
  var rs = stream._readableState;
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var onfinish = function onfinish() {
    writable = false;
    if (!readable) callback.call(stream);
  };

  var onend = function onend() {
    readable = false;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    if (readable && !(rs && rs.ended)) {
      return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
    }

    if (writable && !(ws && ws.ended)) {
      return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !ws) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),
/* 401 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = __webpack_require__(390).codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __webpack_require__(394);

__webpack_require__(392)(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),
/* 402 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(401);

__webpack_require__(392)(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 403 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = __webpack_require__(390).codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(400);
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),
/* 404 */
/***/ ((__unused_webpack_module, exports) => {

var alloc = Buffer.alloc

var ZEROS = '0000000000000000000'
var SEVENS = '7777777777777777777'
var ZERO_OFFSET = '0'.charCodeAt(0)
var USTAR = 'ustar\x0000'
var MASK = parseInt('7777', 8)

var clamp = function (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

var toType = function (flag) {
  switch (flag) {
    case 0:
      return 'file'
    case 1:
      return 'link'
    case 2:
      return 'symlink'
    case 3:
      return 'character-device'
    case 4:
      return 'block-device'
    case 5:
      return 'directory'
    case 6:
      return 'fifo'
    case 7:
      return 'contiguous-file'
    case 72:
      return 'pax-header'
    case 55:
      return 'pax-global-header'
    case 27:
      return 'gnu-long-link-path'
    case 28:
    case 30:
      return 'gnu-long-path'
  }

  return null
}

var toTypeflag = function (flag) {
  switch (flag) {
    case 'file':
      return 0
    case 'link':
      return 1
    case 'symlink':
      return 2
    case 'character-device':
      return 3
    case 'block-device':
      return 4
    case 'directory':
      return 5
    case 'fifo':
      return 6
    case 'contiguous-file':
      return 7
    case 'pax-header':
      return 72
  }

  return 0
}

var indexOf = function (block, num, offset, end) {
  for (; offset < end; offset++) {
    if (block[offset] === num) return offset
  }
  return end
}

var cksum = function (block) {
  var sum = 8 * 32
  for (var i = 0; i < 148; i++) sum += block[i]
  for (var j = 156; j < 512; j++) sum += block[j]
  return sum
}

var encodeOct = function (val, n) {
  val = val.toString(8)
  if (val.length > n) return SEVENS.slice(0, n) + ' '
  else return ZEROS.slice(0, n - val.length) + val + ' '
}

/* Copied from the node-tar repo and modified to meet
 * tar-stream coding standard.
 *
 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
 */
function parse256 (buf) {
  // first byte MUST be either 80 or FF
  // 80 for positive, FF for 2's comp
  var positive
  if (buf[0] === 0x80) positive = true
  else if (buf[0] === 0xFF) positive = false
  else return null

  // build up a base-256 tuple from the least sig to the highest
  var zero = false
  var tuple = []
  for (var i = buf.length - 1; i > 0; i--) {
    var byte = buf[i]
    if (positive) tuple.push(byte)
    else if (zero && byte === 0) tuple.push(0)
    else if (zero) {
      zero = false
      tuple.push(0x100 - byte)
    } else tuple.push(0xFF - byte)
  }

  var sum = 0
  var l = tuple.length
  for (i = 0; i < l; i++) {
    sum += tuple[i] * Math.pow(256, i)
  }

  return positive ? sum : -1 * sum
}

var decodeOct = function (val, offset, length) {
  val = val.slice(offset, offset + length)
  offset = 0

  // If prefixed with 0x80 then parse as a base-256 integer
  if (val[offset] & 0x80) {
    return parse256(val)
  } else {
    // Older versions of tar can prefix with spaces
    while (offset < val.length && val[offset] === 32) offset++
    var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)
    while (offset < end && val[offset] === 0) offset++
    if (end === offset) return 0
    return parseInt(val.slice(offset, end).toString(), 8)
  }
}

var decodeStr = function (val, offset, length, encoding) {
  return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding)
}

var addLength = function (str) {
  var len = Buffer.byteLength(str)
  var digits = Math.floor(Math.log(len) / Math.log(10)) + 1
  if (len + digits >= Math.pow(10, digits)) digits++

  return (len + digits) + str
}

exports.decodeLongPath = function (buf, encoding) {
  return decodeStr(buf, 0, buf.length, encoding)
}

exports.encodePax = function (opts) { // TODO: encode more stuff in pax
  var result = ''
  if (opts.name) result += addLength(' path=' + opts.name + '\n')
  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\n')
  var pax = opts.pax
  if (pax) {
    for (var key in pax) {
      result += addLength(' ' + key + '=' + pax[key] + '\n')
    }
  }
  return Buffer.from(result)
}

exports.decodePax = function (buf) {
  var result = {}

  while (buf.length) {
    var i = 0
    while (i < buf.length && buf[i] !== 32) i++
    var len = parseInt(buf.slice(0, i).toString(), 10)
    if (!len) return result

    var b = buf.slice(i + 1, len - 1).toString()
    var keyIndex = b.indexOf('=')
    if (keyIndex === -1) return result
    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)

    buf = buf.slice(len)
  }

  return result
}

exports.encode = function (opts) {
  var buf = alloc(512)
  var name = opts.name
  var prefix = ''

  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'
  if (Buffer.byteLength(name) !== name.length) return null // utf-8

  while (Buffer.byteLength(name) > 100) {
    var i = name.indexOf('/')
    if (i === -1) return null
    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)
    name = name.slice(i + 1)
  }

  if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null
  if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null

  buf.write(name)
  buf.write(encodeOct(opts.mode & MASK, 6), 100)
  buf.write(encodeOct(opts.uid, 6), 108)
  buf.write(encodeOct(opts.gid, 6), 116)
  buf.write(encodeOct(opts.size, 11), 124)
  buf.write(encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)

  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)

  if (opts.linkname) buf.write(opts.linkname, 157)

  buf.write(USTAR, 257)
  if (opts.uname) buf.write(opts.uname, 265)
  if (opts.gname) buf.write(opts.gname, 297)
  buf.write(encodeOct(opts.devmajor || 0, 6), 329)
  buf.write(encodeOct(opts.devminor || 0, 6), 337)

  if (prefix) buf.write(prefix, 345)

  buf.write(encodeOct(cksum(buf), 6), 148)

  return buf
}

exports.decode = function (buf, filenameEncoding) {
  var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET

  var name = decodeStr(buf, 0, 100, filenameEncoding)
  var mode = decodeOct(buf, 100, 8)
  var uid = decodeOct(buf, 108, 8)
  var gid = decodeOct(buf, 116, 8)
  var size = decodeOct(buf, 124, 12)
  var mtime = decodeOct(buf, 136, 12)
  var type = toType(typeflag)
  var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)
  var uname = decodeStr(buf, 265, 32)
  var gname = decodeStr(buf, 297, 32)
  var devmajor = decodeOct(buf, 329, 8)
  var devminor = decodeOct(buf, 337, 8)

  if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name

  // to support old tar versions that use trailing / to indicate dirs
  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5

  var c = cksum(buf)

  // checksum is still initial value if header was null.
  if (c === 8 * 32) return null

  // valid checksum
  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')

  return {
    name: name,
    mode: mode,
    uid: uid,
    gid: gid,
    size: size,
    mtime: new Date(1000 * mtime),
    type: type,
    linkname: linkname,
    uname: uname,
    gname: gname,
    devmajor: devmajor,
    devminor: devminor
  }
}


/***/ }),
/* 405 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constants = __webpack_require__(406)
var eos = __webpack_require__(408)
var inherits = __webpack_require__(392)
var alloc = Buffer.alloc

var Readable = __webpack_require__(384).Readable
var Writable = __webpack_require__(384).Writable
var StringDecoder = __webpack_require__(234).StringDecoder

var headers = __webpack_require__(404)

var DMODE = parseInt('755', 8)
var FMODE = parseInt('644', 8)

var END_OF_TAR = alloc(1024)

var noop = function () {}

var overflow = function (self, size) {
  size &= 511
  if (size) self.push(END_OF_TAR.slice(0, 512 - size))
}

function modeToType (mode) {
  switch (mode & constants.S_IFMT) {
    case constants.S_IFBLK: return 'block-device'
    case constants.S_IFCHR: return 'character-device'
    case constants.S_IFDIR: return 'directory'
    case constants.S_IFIFO: return 'fifo'
    case constants.S_IFLNK: return 'symlink'
  }

  return 'file'
}

var Sink = function (to) {
  Writable.call(this)
  this.written = 0
  this._to = to
  this._destroyed = false
}

inherits(Sink, Writable)

Sink.prototype._write = function (data, enc, cb) {
  this.written += data.length
  if (this._to.push(data)) return cb()
  this._to._drain = cb
}

Sink.prototype.destroy = function () {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var LinkSink = function () {
  Writable.call(this)
  this.linkname = ''
  this._decoder = new StringDecoder('utf-8')
  this._destroyed = false
}

inherits(LinkSink, Writable)

LinkSink.prototype._write = function (data, enc, cb) {
  this.linkname += this._decoder.write(data)
  cb()
}

LinkSink.prototype.destroy = function () {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var Void = function () {
  Writable.call(this)
  this._destroyed = false
}

inherits(Void, Writable)

Void.prototype._write = function (data, enc, cb) {
  cb(new Error('No body allowed for this entry'))
}

Void.prototype.destroy = function () {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var Pack = function (opts) {
  if (!(this instanceof Pack)) return new Pack(opts)
  Readable.call(this, opts)

  this._drain = noop
  this._finalized = false
  this._finalizing = false
  this._destroyed = false
  this._stream = null
}

inherits(Pack, Readable)

Pack.prototype.entry = function (header, buffer, callback) {
  if (this._stream) throw new Error('already piping an entry')
  if (this._finalized || this._destroyed) return

  if (typeof buffer === 'function') {
    callback = buffer
    buffer = null
  }

  if (!callback) callback = noop

  var self = this

  if (!header.size || header.type === 'symlink') header.size = 0
  if (!header.type) header.type = modeToType(header.mode)
  if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE
  if (!header.uid) header.uid = 0
  if (!header.gid) header.gid = 0
  if (!header.mtime) header.mtime = new Date()

  if (typeof buffer === 'string') buffer = Buffer.from(buffer)
  if (Buffer.isBuffer(buffer)) {
    header.size = buffer.length
    this._encode(header)
    this.push(buffer)
    overflow(self, header.size)
    process.nextTick(callback)
    return new Void()
  }

  if (header.type === 'symlink' && !header.linkname) {
    var linkSink = new LinkSink()
    eos(linkSink, function (err) {
      if (err) { // stream was closed
        self.destroy()
        return callback(err)
      }

      header.linkname = linkSink.linkname
      self._encode(header)
      callback()
    })

    return linkSink
  }

  this._encode(header)

  if (header.type !== 'file' && header.type !== 'contiguous-file') {
    process.nextTick(callback)
    return new Void()
  }

  var sink = new Sink(this)

  this._stream = sink

  eos(sink, function (err) {
    self._stream = null

    if (err) { // stream was closed
      self.destroy()
      return callback(err)
    }

    if (sink.written !== header.size) { // corrupting tar
      self.destroy()
      return callback(new Error('size mismatch'))
    }

    overflow(self, header.size)
    if (self._finalizing) self.finalize()
    callback()
  })

  return sink
}

Pack.prototype.finalize = function () {
  if (this._stream) {
    this._finalizing = true
    return
  }

  if (this._finalized) return
  this._finalized = true
  this.push(END_OF_TAR)
  this.push(null)
}

Pack.prototype.destroy = function (err) {
  if (this._destroyed) return
  this._destroyed = true

  if (err) this.emit('error', err)
  this.emit('close')
  if (this._stream && this._stream.destroy) this._stream.destroy()
}

Pack.prototype._encode = function (header) {
  if (!header.pax) {
    var buf = headers.encode(header)
    if (buf) {
      this.push(buf)
      return
    }
  }
  this._encodePax(header)
}

Pack.prototype._encodePax = function (header) {
  var paxHeader = headers.encodePax({
    name: header.name,
    linkname: header.linkname,
    pax: header.pax
  })

  var newHeader = {
    name: 'PaxHeader',
    mode: header.mode,
    uid: header.uid,
    gid: header.gid,
    size: paxHeader.length,
    mtime: header.mtime,
    type: 'pax-header',
    linkname: header.linkname && 'PaxHeader',
    uname: header.uname,
    gname: header.gname,
    devmajor: header.devmajor,
    devminor: header.devminor
  }

  this.push(headers.encode(newHeader))
  this.push(paxHeader)
  overflow(this, paxHeader.length)

  newHeader.size = header.size
  newHeader.type = header.type
  this.push(headers.encode(newHeader))
}

Pack.prototype._read = function (n) {
  var drain = this._drain
  this._drain = noop
  drain()
}

module.exports = Pack


/***/ }),
/* 406 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(8).constants || __webpack_require__(407)


/***/ }),
/* 407 */
/***/ ((module) => {

"use strict";
module.exports = require("constants");;

/***/ }),
/* 408 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(409);

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;


/***/ }),
/* 409 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(410)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),
/* 410 */
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),
/* 411 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "treeNodeToTreeify": () => /* binding */ treeNodeToTreeify,
/* harmony export */   "treeNodeToJson": () => /* binding */ treeNodeToJson,
/* harmony export */   "emitList": () => /* binding */ emitList,
/* harmony export */   "emitTree": () => /* binding */ emitTree
/* harmony export */ });
/* harmony import */ var treeify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(412);
/* harmony import */ var treeify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(treeify__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _formatUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);


function treeNodeToTreeify(printTree, {
  configuration
}) {
  const target = {};

  const copyTree = (printNode, targetNode) => {
    const iterator = Array.isArray(printNode) ? printNode.entries() : Object.entries(printNode);

    for (const [key, {
      label,
      value,
      children
    }] of iterator) {
      const finalParts = [];
      if (typeof label !== `undefined`) finalParts.push(_formatUtils__WEBPACK_IMPORTED_MODULE_1__.applyStyle(configuration, label, _formatUtils__WEBPACK_IMPORTED_MODULE_1__.Style.BOLD));
      if (typeof value !== `undefined`) finalParts.push(_formatUtils__WEBPACK_IMPORTED_MODULE_1__.pretty(configuration, value[0], value[1]));
      if (finalParts.length === 0) finalParts.push(_formatUtils__WEBPACK_IMPORTED_MODULE_1__.applyStyle(configuration, `${key}`, _formatUtils__WEBPACK_IMPORTED_MODULE_1__.Style.BOLD));
      const finalLabel = finalParts.join(`: `);
      const createdNode = targetNode[finalLabel] = {};

      if (typeof children !== `undefined`) {
        copyTree(children, createdNode);
      }
    }
  };

  if (typeof printTree.children === `undefined`) throw new Error(`The root node must only contain children`);
  copyTree(printTree.children, target);
  return target;
}
function treeNodeToJson(printTree) {
  const copyTree = printNode => {
    var _a;

    if (typeof printNode.children === `undefined`) {
      if (typeof printNode.value === `undefined`) throw new Error(`Assertion failed: Expected a value to be set if the children are missing`);
      return _formatUtils__WEBPACK_IMPORTED_MODULE_1__.json(printNode.value[0], printNode.value[1]);
    }

    const iterator = Array.isArray(printNode.children) ? printNode.children.entries() : Object.entries((_a = printNode.children) !== null && _a !== void 0 ? _a : {});
    const targetChildren = Array.isArray(printNode.children) ? [] : {};

    for (const [key, child] of iterator) targetChildren[key] = copyTree(child);

    if (typeof printNode.value === `undefined`) return targetChildren;
    return {
      value: _formatUtils__WEBPACK_IMPORTED_MODULE_1__.json(printNode.value[0], printNode.value[1]),
      children: targetChildren
    };
  };

  return copyTree(printTree);
}
function emitList(values, {
  configuration,
  stdout,
  json
}) {
  const children = values.map(value => ({
    value
  }));
  emitTree({
    children
  }, {
    configuration,
    stdout,
    json
  });
}
function emitTree(tree, {
  configuration,
  stdout,
  json,
  separators = 0
}) {
  var _a;

  if (json) {
    const iterator = Array.isArray(tree.children) ? tree.children.values() : Object.values((_a = tree.children) !== null && _a !== void 0 ? _a : {});

    for (const child of iterator) stdout.write(`${JSON.stringify(treeNodeToJson(child))}\n`);

    return;
  }

  let treeOutput = (0,treeify__WEBPACK_IMPORTED_MODULE_0__.asTree)(treeNodeToTreeify(tree, {
    configuration
  }), false, false); // A slight hack to add line returns between two top-level entries

  if (separators >= 1) treeOutput = treeOutput.replace(/^([])/gm, `\n$1`).replace(/^\n/, ``); // Another one for the second level fields. We run it twice because in some pathological cases the regex matches would

  if (separators >= 2) for (let t = 0; t < 2; ++t) treeOutput = treeOutput.replace(/^([ ].{2}[ ].{2}[^\n]+\n)(([ ]).{2}[].{2}[^\n]*\n[ ].{2}[ ].{2}[])/gm, `$1$3  \n$2`).replace(/^\n/, ``);
  if (separators >= 3) throw new Error(`Only the first two levels are accepted by treeUtils.emitTree`);
  stdout.write(treeOutput);
}

/***/ }),
/* 412 */
/***/ (function(module) {

//     treeify.js
//     Luke Plaster <notatestuser@gmail.com>
//     https://github.com/notatestuser/treeify.js

// do the universal module definition dance
(function (root, factory) {

  if (true) {
    module.exports = factory();
  } else {}

}(this, function() {

  function makePrefix(key, last) {
    var str = (last ? '' : '');
    if (key) {
      str += ' ';
    } else {
      str += '';
    }
    return str;
  }

  function filterKeys(obj, hideFunctions) {
    var keys = [];
    for (var branch in obj) {
      // always exclude anything in the object's prototype
      if (!obj.hasOwnProperty(branch)) {
        continue;
      }
      // ... and hide any keys mapped to functions if we've been told to
      if (hideFunctions && ((typeof obj[branch])==="function")) {
        continue;
      }
      keys.push(branch);
    }
    return keys;
  }

  function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {
    var line = '', index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);

    if (lastStatesCopy.push([ root, last ]) && lastStates.length > 0) {
      // based on the "was last element" states of whatever we're nested within,
      // we need to append either blankness or a branch to our line
      lastStates.forEach(function(lastState, idx) {
        if (idx > 0) {
          line += (lastState[1] ? ' ' : '') + '  ';
        }
        if ( ! circular && lastState[0] === root) {
          circular = true;
        }
      });

      // the prefix varies based on whether the key contains something to show and
      // whether we're dealing with the last element in this collection
      line += makePrefix(key, last) + key;

      // append values and the circular reference indicator
      showValues && (typeof root !== 'object' || root instanceof Date) && (line += ': ' + root);
      circular && (line += ' (circular ref.)');

      callback(line);
    }

    // can we descend into the next item?
    if ( ! circular && typeof root === 'object') {
      var keys = filterKeys(root, hideFunctions);
      keys.forEach(function(branch){
        // the last key is always printed with a different prefix, so we'll need to know if we have it
        lastKey = ++index === keys.length;

        // hold your breath for recursive action
        growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
      });
    }
  };

  // --------------------

  var Treeify = {};

  // Treeify.asLines
  // --------------------
  // Outputs the tree line-by-line, calling the lineCallback when each one is available.

  Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {
    /* hideFunctions and lineCallback are curried, which means we don't break apps using the older form */
    var hideFunctionsArg = typeof hideFunctions !== 'function' ? hideFunctions : false;
    growBranch('.', obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
  };

  // Treeify.asTree
  // --------------------
  // Outputs the entire tree, returning it as a string with line breaks.

  Treeify.asTree = function(obj, showValues, hideFunctions) {
    var tree = '';
    growBranch('.', obj, false, [], showValues, hideFunctions, function(line) {
      tree += line + '\n';
    });
    return tree;
  };

  // --------------------

  return Treeify;

}));


/***/ }),
/* 413 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.addMethod = addMethod;
exports.lazy = exports.ref = exports.boolean = void 0;

var _mixed = _interopRequireDefault(__webpack_require__(415));

exports.mixed = _mixed.default;

var _boolean = _interopRequireDefault(__webpack_require__(524));

exports.bool = _boolean.default;

var _string = _interopRequireDefault(__webpack_require__(526));

exports.string = _string.default;

var _number = _interopRequireDefault(__webpack_require__(528));

exports.number = _number.default;

var _date = _interopRequireDefault(__webpack_require__(529));

exports.date = _date.default;

var _object = _interopRequireDefault(__webpack_require__(531));

exports.object = _object.default;

var _array = _interopRequireDefault(__webpack_require__(551));

exports.array = _array.default;

var _Reference = _interopRequireDefault(__webpack_require__(521));

var _Lazy = _interopRequireDefault(__webpack_require__(552));

var _ValidationError = _interopRequireDefault(__webpack_require__(493));

exports.ValidationError = _ValidationError.default;

var _reach = _interopRequireDefault(__webpack_require__(523));

exports.reach = _reach.default;

var _isSchema = _interopRequireDefault(__webpack_require__(489));

exports.isSchema = _isSchema.default;

var _setLocale = _interopRequireDefault(__webpack_require__(553));

exports.setLocale = _setLocale.default;
var boolean = _boolean.default;
exports.boolean = boolean;

var ref = function ref(key, options) {
  return new _Reference.default(key, options);
};

exports.ref = ref;

var lazy = function lazy(fn) {
  return new _Lazy.default(fn);
};

exports.lazy = lazy;

function addMethod(schemaType, name, fn) {
  if (!schemaType || !(0, _isSchema.default)(schemaType.prototype)) throw new TypeError('You must provide a yup schema constructor function');
  if (typeof name !== 'string') throw new TypeError('A Method name must be provided');
  if (typeof fn !== 'function') throw new TypeError('Method function must be provided');
  schemaType.prototype[name] = fn;
}

/***/ }),
/* 414 */
/***/ ((module) => {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),
/* 415 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = SchemaType;

var _extends2 = _interopRequireDefault(__webpack_require__(416));

var _has = _interopRequireDefault(__webpack_require__(417));

var _cloneDeepWith = _interopRequireDefault(__webpack_require__(419));

var _toArray2 = _interopRequireDefault(__webpack_require__(479));

var _locale = __webpack_require__(486);

var _Condition = _interopRequireDefault(__webpack_require__(488));

var _runValidations = _interopRequireDefault(__webpack_require__(490));

var _prependDeep = _interopRequireDefault(__webpack_require__(494));

var _isSchema = _interopRequireDefault(__webpack_require__(489));

var _createValidation = _interopRequireDefault(__webpack_require__(495));

var _printValue = _interopRequireDefault(__webpack_require__(487));

var _Reference = _interopRequireDefault(__webpack_require__(521));

var _reach = __webpack_require__(523);

var RefSet =
/*#__PURE__*/
function () {
  function RefSet() {
    this.list = new Set();
    this.refs = new Map();
  }

  var _proto = RefSet.prototype;

  _proto.toArray = function toArray() {
    return (0, _toArray2.default)(this.list).concat((0, _toArray2.default)(this.refs.values()));
  };

  _proto.add = function add(value) {
    _Reference.default.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
  };

  _proto.delete = function _delete(value) {
    _Reference.default.isRef(value) ? this.refs.delete(value.key, value) : this.list.delete(value);
  };

  _proto.has = function has(value, resolve) {
    if (this.list.has(value)) return true;
    var item,
        values = this.refs.values();

    while (item = values.next(), !item.done) {
      if (resolve(item.value) === value) return true;
    }

    return false;
  };

  return RefSet;
}();

function SchemaType(options) {
  var _this = this;

  if (options === void 0) {
    options = {};
  }

  if (!(this instanceof SchemaType)) return new SchemaType();
  this._deps = [];
  this._conditions = [];
  this._options = {
    abortEarly: true,
    recursive: true
  };
  this._exclusive = Object.create(null);
  this._whitelist = new RefSet();
  this._blacklist = new RefSet();
  this.tests = [];
  this.transforms = [];
  this.withMutation(function () {
    _this.typeError(_locale.mixed.notType);
  });
  if ((0, _has.default)(options, 'default')) this._defaultDefault = options.default;
  this._type = options.type || 'mixed';
}

var proto = SchemaType.prototype = {
  __isYupSchema__: true,
  constructor: SchemaType,
  clone: function clone() {
    var _this2 = this;

    if (this._mutate) return this; // if the nested value is a schema we can skip cloning, since
    // they are already immutable

    return (0, _cloneDeepWith.default)(this, function (value) {
      if ((0, _isSchema.default)(value) && value !== _this2) return value;
    });
  },
  label: function label(_label) {
    var next = this.clone();
    next._label = _label;
    return next;
  },
  meta: function meta(obj) {
    if (arguments.length === 0) return this._meta;
    var next = this.clone();
    next._meta = (0, _extends2.default)(next._meta || {}, obj);
    return next;
  },
  withMutation: function withMutation(fn) {
    var before = this._mutate;
    this._mutate = true;
    var result = fn(this);
    this._mutate = before;
    return result;
  },
  concat: function concat(schema) {
    if (!schema || schema === this) return this;
    if (schema._type !== this._type && this._type !== 'mixed') throw new TypeError("You cannot `concat()` schema's of different types: " + this._type + " and " + schema._type);
    var next = (0, _prependDeep.default)(schema.clone(), this); // new undefined default is overriden by old non-undefined one, revert

    if ((0, _has.default)(schema, '_default')) next._default = schema._default;
    next.tests = this.tests;
    next._exclusive = this._exclusive; // manually add the new tests to ensure
    // the deduping logic is consistent

    next.withMutation(function (next) {
      schema.tests.forEach(function (fn) {
        next.test(fn.OPTIONS);
      });
    });
    return next;
  },
  isType: function isType(v) {
    if (this._nullable && v === null) return true;
    return !this._typeCheck || this._typeCheck(v);
  },
  resolve: function resolve(options) {
    var schema = this;

    if (schema._conditions.length) {
      var conditions = schema._conditions;
      schema = schema.clone();
      schema._conditions = [];
      schema = conditions.reduce(function (schema, condition) {
        return condition.resolve(schema, options);
      }, schema);
      schema = schema.resolve(options);
    }

    return schema;
  },
  cast: function cast(value, options) {
    if (options === void 0) {
      options = {};
    }

    var resolvedSchema = this.resolve((0, _extends2.default)({}, options, {
      value: value
    }));

    var result = resolvedSchema._cast(value, options);

    if (value !== undefined && options.assert !== false && resolvedSchema.isType(result) !== true) {
      var formattedValue = (0, _printValue.default)(value);
      var formattedResult = (0, _printValue.default)(result);
      throw new TypeError("The value of " + (options.path || 'field') + " could not be cast to a value " + ("that satisfies the schema type: \"" + resolvedSchema._type + "\". \n\n") + ("attempted value: " + formattedValue + " \n") + (formattedResult !== formattedValue ? "result of cast: " + formattedResult : ''));
    }

    return result;
  },
  _cast: function _cast(rawValue) {
    var _this3 = this;

    var value = rawValue === undefined ? rawValue : this.transforms.reduce(function (value, fn) {
      return fn.call(_this3, value, rawValue);
    }, rawValue);

    if (value === undefined && (0, _has.default)(this, '_default')) {
      value = this.default();
    }

    return value;
  },
  _validate: function _validate(_value, options) {
    var _this4 = this;

    if (options === void 0) {
      options = {};
    }

    var value = _value;
    var originalValue = options.originalValue != null ? options.originalValue : _value;

    var isStrict = this._option('strict', options);

    var endEarly = this._option('abortEarly', options);

    var sync = options.sync;
    var path = options.path;
    var label = this._label;

    if (!isStrict) {
      value = this._cast(value, (0, _extends2.default)({
        assert: false
      }, options));
    } // value is cast, we can check if it meets type requirements


    var validationParams = {
      value: value,
      path: path,
      schema: this,
      options: options,
      label: label,
      originalValue: originalValue,
      sync: sync
    };
    var initialTests = [];
    if (this._typeError) initialTests.push(this._typeError(validationParams));
    if (this._whitelistError) initialTests.push(this._whitelistError(validationParams));
    if (this._blacklistError) initialTests.push(this._blacklistError(validationParams));
    return (0, _runValidations.default)({
      validations: initialTests,
      endEarly: endEarly,
      value: value,
      path: path,
      sync: sync
    }).then(function (value) {
      return (0, _runValidations.default)({
        path: path,
        sync: sync,
        value: value,
        endEarly: endEarly,
        validations: _this4.tests.map(function (fn) {
          return fn(validationParams);
        })
      });
    });
  },
  validate: function validate(value, options) {
    if (options === void 0) {
      options = {};
    }

    var schema = this.resolve((0, _extends2.default)({}, options, {
      value: value
    }));
    return schema._validate(value, options);
  },
  validateSync: function validateSync(value, options) {
    if (options === void 0) {
      options = {};
    }

    var schema = this.resolve((0, _extends2.default)({}, options, {
      value: value
    }));
    var result, err;

    schema._validate(value, (0, _extends2.default)({}, options, {
      sync: true
    })).then(function (r) {
      return result = r;
    }).catch(function (e) {
      return err = e;
    });

    if (err) throw err;
    return result;
  },
  isValid: function isValid(value, options) {
    return this.validate(value, options).then(function () {
      return true;
    }).catch(function (err) {
      if (err.name === 'ValidationError') return false;
      throw err;
    });
  },
  isValidSync: function isValidSync(value, options) {
    try {
      this.validateSync(value, options);
      return true;
    } catch (err) {
      if (err.name === 'ValidationError') return false;
      throw err;
    }
  },
  getDefault: function getDefault(options) {
    if (options === void 0) {
      options = {};
    }

    var schema = this.resolve(options);
    return schema.default();
  },
  default: function _default(def) {
    if (arguments.length === 0) {
      var defaultValue = (0, _has.default)(this, '_default') ? this._default : this._defaultDefault;
      return typeof defaultValue === 'function' ? defaultValue.call(this) : (0, _cloneDeepWith.default)(defaultValue);
    }

    var next = this.clone();
    next._default = def;
    return next;
  },
  strict: function strict(isStrict) {
    if (isStrict === void 0) {
      isStrict = true;
    }

    var next = this.clone();
    next._options.strict = isStrict;
    return next;
  },
  _isPresent: function _isPresent(value) {
    return value != null;
  },
  required: function required(message) {
    if (message === void 0) {
      message = _locale.mixed.required;
    }

    return this.test({
      message: message,
      name: 'required',
      exclusive: true,
      test: function test(value) {
        return this.schema._isPresent(value);
      }
    });
  },
  notRequired: function notRequired() {
    var next = this.clone();
    next.tests = next.tests.filter(function (test) {
      return test.OPTIONS.name !== 'required';
    });
    return next;
  },
  nullable: function nullable(isNullable) {
    if (isNullable === void 0) {
      isNullable = true;
    }

    var next = this.clone();
    next._nullable = isNullable;
    return next;
  },
  transform: function transform(fn) {
    var next = this.clone();
    next.transforms.push(fn);
    return next;
  },

  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */
  test: function test() {
    var opts;

    if (arguments.length === 1) {
      if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'function') {
        opts = {
          test: arguments.length <= 0 ? undefined : arguments[0]
        };
      } else {
        opts = arguments.length <= 0 ? undefined : arguments[0];
      }
    } else if (arguments.length === 2) {
      opts = {
        name: arguments.length <= 0 ? undefined : arguments[0],
        test: arguments.length <= 1 ? undefined : arguments[1]
      };
    } else {
      opts = {
        name: arguments.length <= 0 ? undefined : arguments[0],
        message: arguments.length <= 1 ? undefined : arguments[1],
        test: arguments.length <= 2 ? undefined : arguments[2]
      };
    }

    if (opts.message === undefined) opts.message = _locale.mixed.default;
    if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');
    var next = this.clone();
    var validate = (0, _createValidation.default)(opts);
    var isExclusive = opts.exclusive || opts.name && next._exclusive[opts.name] === true;

    if (opts.exclusive && !opts.name) {
      throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');
    }

    next._exclusive[opts.name] = !!opts.exclusive;
    next.tests = next.tests.filter(function (fn) {
      if (fn.OPTIONS.name === opts.name) {
        if (isExclusive) return false;
        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
      }

      return true;
    });
    next.tests.push(validate);
    return next;
  },
  when: function when(keys, options) {
    if (arguments.length === 1) {
      options = keys;
      keys = '.';
    }

    var next = this.clone(),
        deps = [].concat(keys).map(function (key) {
      return new _Reference.default(key);
    });
    deps.forEach(function (dep) {
      if (dep.isSibling) next._deps.push(dep.key);
    });

    next._conditions.push(new _Condition.default(deps, options));

    return next;
  },
  typeError: function typeError(message) {
    var next = this.clone();
    next._typeError = (0, _createValidation.default)({
      message: message,
      name: 'typeError',
      test: function test(value) {
        if (value !== undefined && !this.schema.isType(value)) return this.createError({
          params: {
            type: this.schema._type
          }
        });
        return true;
      }
    });
    return next;
  },
  oneOf: function oneOf(enums, message) {
    if (message === void 0) {
      message = _locale.mixed.oneOf;
    }

    var next = this.clone();
    enums.forEach(function (val) {
      next._whitelist.add(val);

      next._blacklist.delete(val);
    });
    next._whitelistError = (0, _createValidation.default)({
      message: message,
      name: 'oneOf',
      test: function test(value) {
        if (value === undefined) return true;
        var valids = this.schema._whitelist;
        return valids.has(value, this.resolve) ? true : this.createError({
          params: {
            values: valids.toArray().join(', ')
          }
        });
      }
    });
    return next;
  },
  notOneOf: function notOneOf(enums, message) {
    if (message === void 0) {
      message = _locale.mixed.notOneOf;
    }

    var next = this.clone();
    enums.forEach(function (val) {
      next._blacklist.add(val);

      next._whitelist.delete(val);
    });
    next._blacklistError = (0, _createValidation.default)({
      message: message,
      name: 'notOneOf',
      test: function test(value) {
        var invalids = this.schema._blacklist;
        if (invalids.has(value, this.resolve)) return this.createError({
          params: {
            values: invalids.toArray().join(', ')
          }
        });
        return true;
      }
    });
    return next;
  },
  strip: function strip(_strip) {
    if (_strip === void 0) {
      _strip = true;
    }

    var next = this.clone();
    next._strip = _strip;
    return next;
  },
  _option: function _option(key, overrides) {
    return (0, _has.default)(overrides, key) ? overrides[key] : this._options[key];
  },
  describe: function describe() {
    var next = this.clone();
    return {
      type: next._type,
      meta: next._meta,
      label: next._label,
      tests: next.tests.map(function (fn) {
        return {
          name: fn.OPTIONS.name,
          params: fn.OPTIONS.params
        };
      }).filter(function (n, idx, list) {
        return list.findIndex(function (c) {
          return c.name === n.name;
        }) === idx;
      })
    };
  }
};
var _arr = ['validate', 'validateSync'];

var _loop = function _loop() {
  var method = _arr[_i];

  proto[method + "At"] = function (path, value, options) {
    if (options === void 0) {
      options = {};
    }

    var _getIn = (0, _reach.getIn)(this, path, value, options.context),
        parent = _getIn.parent,
        parentPath = _getIn.parentPath,
        schema = _getIn.schema;

    return schema[method](parent && parent[parentPath], (0, _extends2.default)({}, options, {
      parent: parent,
      path: path
    }));
  };
};

for (var _i = 0; _i < _arr.length; _i++) {
  _loop();
}

var _arr2 = ['equals', 'is'];

for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
  var alias = _arr2[_i2];
  proto[alias] = proto.oneOf;
}

var _arr3 = ['not', 'nope'];

for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
  var _alias = _arr3[_i3];
  proto[_alias] = proto.notOneOf;
}

proto.optional = proto.notRequired;
module.exports = exports["default"];

/***/ }),
/* 416 */
/***/ ((module) => {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),
/* 417 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHas = __webpack_require__(418),
    hasPath = __webpack_require__(317);

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;


/***/ }),
/* 418 */
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;


/***/ }),
/* 419 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(420);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.cloneWith` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the deep cloned value.
 * @see _.cloneWith
 * @example
 *
 * function customizer(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(true);
 *   }
 * }
 *
 * var el = _.cloneDeepWith(document.body, customizer);
 *
 * console.log(el === document.body);
 * // => false
 * console.log(el.nodeName);
 * // => 'BODY'
 * console.log(el.childNodes.length);
 * // => 20
 */
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
}

module.exports = cloneDeepWith;


/***/ }),
/* 420 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(421),
    arrayEach = __webpack_require__(427),
    assignValue = __webpack_require__(311),
    baseAssign = __webpack_require__(428),
    baseAssignIn = __webpack_require__(444),
    cloneBuffer = __webpack_require__(448),
    copyArray = __webpack_require__(449),
    copySymbols = __webpack_require__(450),
    copySymbolsIn = __webpack_require__(454),
    getAllKeys = __webpack_require__(457),
    getAllKeysIn = __webpack_require__(459),
    getTag = __webpack_require__(460),
    initCloneArray = __webpack_require__(465),
    initCloneByTag = __webpack_require__(466),
    initCloneObject = __webpack_require__(473),
    isArray = __webpack_require__(261),
    isBuffer = __webpack_require__(433),
    isMap = __webpack_require__(475),
    isObject = __webpack_require__(282),
    isSet = __webpack_require__(477),
    keys = __webpack_require__(430);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 421 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(291),
    stackClear = __webpack_require__(422),
    stackDelete = __webpack_require__(423),
    stackGet = __webpack_require__(424),
    stackHas = __webpack_require__(425),
    stackSet = __webpack_require__(426);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 422 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(291);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 423 */
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 424 */
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 425 */
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 426 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(291),
    Map = __webpack_require__(299),
    MapCache = __webpack_require__(274);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 427 */
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 428 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(429),
    keys = __webpack_require__(430);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 429 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(311),
    baseAssignValue = __webpack_require__(312);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 430 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(431),
    baseKeys = __webpack_require__(439),
    isArrayLike = __webpack_require__(443);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 431 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(432),
    isArguments = __webpack_require__(318),
    isArray = __webpack_require__(261),
    isBuffer = __webpack_require__(433),
    isIndex = __webpack_require__(314),
    isTypedArray = __webpack_require__(435);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 432 */
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 433 */
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(266),
    stubFalse = __webpack_require__(434);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),
/* 434 */
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 435 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(436),
    baseUnary = __webpack_require__(437),
    nodeUtil = __webpack_require__(438);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 436 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(264),
    isLength = __webpack_require__(320),
    isObjectLike = __webpack_require__(270);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 437 */
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 438 */
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(267);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),
/* 439 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(440),
    nativeKeys = __webpack_require__(441);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 440 */
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 441 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(442);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 442 */
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 443 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(281),
    isLength = __webpack_require__(320);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 444 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(429),
    keysIn = __webpack_require__(445);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),
/* 445 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(431),
    baseKeysIn = __webpack_require__(446),
    isArrayLike = __webpack_require__(443);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 446 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(282),
    isPrototype = __webpack_require__(440),
    nativeKeysIn = __webpack_require__(447);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 447 */
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 448 */
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(266);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),
/* 449 */
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 450 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(429),
    getSymbols = __webpack_require__(451);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 451 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(452),
    stubArray = __webpack_require__(453);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 452 */
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 453 */
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 454 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(429),
    getSymbolsIn = __webpack_require__(455);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),
/* 455 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(324),
    getPrototype = __webpack_require__(456),
    getSymbols = __webpack_require__(451),
    stubArray = __webpack_require__(453);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),
/* 456 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(442);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 457 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(458),
    getSymbols = __webpack_require__(451),
    keys = __webpack_require__(430);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 458 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(324),
    isArray = __webpack_require__(261);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 459 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(458),
    getSymbolsIn = __webpack_require__(455),
    keysIn = __webpack_require__(445);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),
/* 460 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(461),
    Map = __webpack_require__(299),
    Promise = __webpack_require__(462),
    Set = __webpack_require__(463),
    WeakMap = __webpack_require__(464),
    baseGetTag = __webpack_require__(264),
    toSource = __webpack_require__(285);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 461 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(279),
    root = __webpack_require__(266);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 462 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(279),
    root = __webpack_require__(266);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 463 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(279),
    root = __webpack_require__(266);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 464 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(279),
    root = __webpack_require__(266);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 465 */
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 466 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(467),
    cloneDataView = __webpack_require__(469),
    cloneRegExp = __webpack_require__(470),
    cloneSymbol = __webpack_require__(471),
    cloneTypedArray = __webpack_require__(472);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 467 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__(468);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 468 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(266);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 469 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(467);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 470 */
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 471 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(265);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 472 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(467);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 473 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(474),
    getPrototype = __webpack_require__(456),
    isPrototype = __webpack_require__(440);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 474 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(282);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 475 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(476),
    baseUnary = __webpack_require__(437),
    nodeUtil = __webpack_require__(438);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),
/* 476 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(460),
    isObjectLike = __webpack_require__(270);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),
/* 477 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(478),
    baseUnary = __webpack_require__(437),
    nodeUtil = __webpack_require__(438);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),
/* 478 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(460),
    isObjectLike = __webpack_require__(270);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),
/* 479 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(265),
    copyArray = __webpack_require__(449),
    getTag = __webpack_require__(460),
    isArrayLike = __webpack_require__(443),
    isString = __webpack_require__(480),
    iteratorToArray = __webpack_require__(481),
    mapToArray = __webpack_require__(482),
    setToArray = __webpack_require__(483),
    stringToArray = __webpack_require__(369),
    values = __webpack_require__(484);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Built-in value references. */
var symIterator = Symbol ? Symbol.iterator : undefined;

/**
 * Converts `value` to an array.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Array} Returns the converted array.
 * @example
 *
 * _.toArray({ 'a': 1, 'b': 2 });
 * // => [1, 2]
 *
 * _.toArray('abc');
 * // => ['a', 'b', 'c']
 *
 * _.toArray(1);
 * // => []
 *
 * _.toArray(null);
 * // => []
 */
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike(value)) {
    return isString(value) ? stringToArray(value) : copyArray(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray(value[symIterator]());
  }
  var tag = getTag(value),
      func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

  return func(value);
}

module.exports = toArray;


/***/ }),
/* 480 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(264),
    isArray = __webpack_require__(261),
    isObjectLike = __webpack_require__(270);

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),
/* 481 */
/***/ ((module) => {

/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

module.exports = iteratorToArray;


/***/ }),
/* 482 */
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),
/* 483 */
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),
/* 484 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseValues = __webpack_require__(485),
    keys = __webpack_require__(430);

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;


/***/ }),
/* 485 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(308);

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),
/* 486 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = exports.array = exports.object = exports.boolean = exports.date = exports.number = exports.string = exports.mixed = void 0;

var _printValue = _interopRequireDefault(__webpack_require__(487));

var mixed = {
  default: '${path} is invalid',
  required: '${path} is a required field',
  oneOf: '${path} must be one of the following values: ${values}',
  notOneOf: '${path} must not be one of the following values: ${values}',
  notType: function notType(_ref) {
    var path = _ref.path,
        type = _ref.type,
        value = _ref.value,
        originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " must be a `" + type + "` type, " + ("but the final value was: `" + (0, _printValue.default)(value, true) + "`") + (isCast ? " (cast from the value `" + (0, _printValue.default)(originalValue, true) + "`)." : '.');

    if (value === null) {
      msg += "\n If \"null\" is intended as an empty value be sure to mark the schema as `.nullable()`";
    }

    return msg;
  }
};
exports.mixed = mixed;
var string = {
  length: '${path} must be exactly ${length} characters',
  min: '${path} must be at least ${min} characters',
  max: '${path} must be at most ${max} characters',
  matches: '${path} must match the following: "${regex}"',
  email: '${path} must be a valid email',
  url: '${path} must be a valid URL',
  trim: '${path} must be a trimmed string',
  lowercase: '${path} must be a lowercase string',
  uppercase: '${path} must be a upper case string'
};
exports.string = string;
var number = {
  min: '${path} must be greater than or equal to ${min}',
  max: '${path} must be less than or equal to ${max}',
  lessThan: '${path} must be less than ${less}',
  moreThan: '${path} must be greater than ${more}',
  notEqual: '${path} must be not equal to ${notEqual}',
  positive: '${path} must be a positive number',
  negative: '${path} must be a negative number',
  integer: '${path} must be an integer'
};
exports.number = number;
var date = {
  min: '${path} field must be later than ${min}',
  max: '${path} field must be at earlier than ${max}'
};
exports.date = date;
var boolean = {};
exports.boolean = boolean;
var object = {
  noUnknown: '${path} field cannot have keys not specified in the object shape'
};
exports.object = object;
var array = {
  min: '${path} field must have at least ${min} items',
  max: '${path} field must have less than or equal to ${max} items'
};
exports.array = array;
var _default = {
  mixed: mixed,
  string: string,
  number: number,
  date: date,
  object: object,
  array: array,
  boolean: boolean
};
exports.default = _default;

/***/ }),
/* 487 */
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = printValue;
var toString = Object.prototype.toString;
var errorToString = Error.prototype.toString;
var regExpToString = RegExp.prototype.toString;
var symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : function () {
  return '';
};
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;

function printNumber(val) {
  if (val != +val) return 'NaN';
  var isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? '-0' : '' + val;
}

function printSimpleValue(val, quoteStrings) {
  if (quoteStrings === void 0) {
    quoteStrings = false;
  }

  if (val == null || val === true || val === false) return '' + val;
  var typeOf = typeof val;
  if (typeOf === 'number') return printNumber(val);
  if (typeOf === 'string') return quoteStrings ? "\"" + val + "\"" : val;
  if (typeOf === 'function') return '[Function ' + (val.name || 'anonymous') + ']';
  if (typeOf === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
  var tag = toString.call(val).slice(8, -1);
  if (tag === 'Date') return isNaN(val.getTime()) ? '' + val : val.toISOString(val);
  if (tag === 'Error' || val instanceof Error) return '[' + errorToString.call(val) + ']';
  if (tag === 'RegExp') return regExpToString.call(val);
  return null;
}

function printValue(value, quoteStrings) {
  var result = printSimpleValue(value, quoteStrings);
  if (result !== null) return result;
  return JSON.stringify(value, function (key, value) {
    var result = printSimpleValue(this[key], quoteStrings);
    if (result !== null) return result;
    return value;
  }, 2);
}

module.exports = exports["default"];

/***/ }),
/* 488 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = void 0;

var _has = _interopRequireDefault(__webpack_require__(417));

var _isSchema = _interopRequireDefault(__webpack_require__(489));

var Condition =
/*#__PURE__*/
function () {
  function Condition(refs, options) {
    this.refs = refs;

    if (typeof options === 'function') {
      this.fn = options;
      return;
    }

    if (!(0, _has.default)(options, 'is')) throw new TypeError('`is:` is required for `when()` conditions');
    if (!options.then && !options.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');
    var is = options.is,
        then = options.then,
        otherwise = options.otherwise;
    var check = typeof is === 'function' ? is : function () {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      return values.every(function (value) {
        return value === is;
      });
    };

    this.fn = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var options = args.pop();
      var schema = args.pop();
      var branch = check.apply(void 0, args) ? then : otherwise;
      if (!branch) return undefined;
      if (typeof branch === 'function') return branch(schema);
      return schema.concat(branch.resolve(options));
    };
  }

  var _proto = Condition.prototype;

  _proto.resolve = function resolve(base, options) {
    var values = this.refs.map(function (ref) {
      return ref.getValue(options);
    });
    var schema = this.fn.apply(base, values.concat(base, options));
    if (schema === undefined || schema === base) return base;
    if (!(0, _isSchema.default)(schema)) throw new TypeError('conditions must return a schema object');
    return schema.resolve(options);
  };

  return Condition;
}();

var _default = Condition;
exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 489 */
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _default = function _default(obj) {
  return obj && obj.__isYupSchema__;
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 490 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.propagateErrors = propagateErrors;
exports.settled = settled;
exports.collectErrors = collectErrors;
exports.default = runValidations;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(491));

var _synchronousPromise = __webpack_require__(492);

var _ValidationError = _interopRequireDefault(__webpack_require__(493));

var promise = function promise(sync) {
  return sync ? _synchronousPromise.SynchronousPromise : Promise;
};

var unwrapError = function unwrapError(errors) {
  if (errors === void 0) {
    errors = [];
  }

  return errors.inner && errors.inner.length ? errors.inner : [].concat(errors);
};

function scopeToValue(promises, value, sync) {
  //console.log('scopeToValue', promises, value)
  var p = promise(sync).all(promises); //console.log('scopeToValue B', p)

  var b = p.catch(function (err) {
    if (err.name === 'ValidationError') err.value = value;
    throw err;
  }); //console.log('scopeToValue c', b)

  var c = b.then(function () {
    return value;
  }); //console.log('scopeToValue d', c)

  return c;
}
/**
 * If not failing on the first error, catch the errors
 * and collect them in an array
 */


function propagateErrors(endEarly, errors) {
  return endEarly ? null : function (err) {
    errors.push(err);
    return err.value;
  };
}

function settled(promises, sync) {
  var Promise = promise(sync);
  return Promise.all(promises.map(function (p) {
    return Promise.resolve(p).then(function (value) {
      return {
        fulfilled: true,
        value: value
      };
    }, function (value) {
      return {
        fulfilled: false,
        value: value
      };
    });
  }));
}

function collectErrors(_ref) {
  var validations = _ref.validations,
      value = _ref.value,
      path = _ref.path,
      sync = _ref.sync,
      errors = _ref.errors,
      sort = _ref.sort;
  errors = unwrapError(errors);
  return settled(validations, sync).then(function (results) {
    var nestedErrors = results.filter(function (r) {
      return !r.fulfilled;
    }).reduce(function (arr, _ref2) {
      var error = _ref2.value;

      // we are only collecting validation errors
      if (!_ValidationError.default.isError(error)) {
        throw error;
      }

      return arr.concat(error);
    }, []);
    if (sort) nestedErrors.sort(sort); //show parent errors after the nested ones: name.first, name

    errors = nestedErrors.concat(errors);
    if (errors.length) throw new _ValidationError.default(errors, value, path);
    return value;
  });
}

function runValidations(_ref3) {
  var endEarly = _ref3.endEarly,
      options = (0, _objectWithoutPropertiesLoose2.default)(_ref3, ["endEarly"]);
  if (endEarly) return scopeToValue(options.validations, options.value, options.sync);
  return collectErrors(options);
}

/***/ }),
/* 491 */
/***/ ((module) => {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;

/***/ }),
/* 492 */
/***/ ((module) => {

"use strict";
/* jshint node: true */

function makeArrayFrom(obj) {
  return Array.prototype.slice.apply(obj);
}
var
  PENDING = "pending",
  RESOLVED = "resolved",
  REJECTED = "rejected";

function SynchronousPromise(handler) {
  this.status = PENDING;
  this._continuations = [];
  this._parent = null;
  this._paused = false;
  if (handler) {
    handler.call(
      this,
      this._continueWith.bind(this),
      this._failWith.bind(this)
    );
  }
}

function looksLikeAPromise(obj) {
  return obj && typeof (obj.then) === "function";
}

function passThrough(value) {
  return value;
}

SynchronousPromise.prototype = {
  then: function (nextFn, catchFn) {
    var next = SynchronousPromise.unresolved()._setParent(this);
    if (this._isRejected()) {
      if (this._paused) {
        this._continuations.push({
          promise: next,
          nextFn: nextFn,
          catchFn: catchFn
        });
        return next;
      }
      if (catchFn) {
        try {
          var catchResult = catchFn(this._error);
          if (looksLikeAPromise(catchResult)) {
            this._chainPromiseData(catchResult, next);
            return next;
          } else {
            return SynchronousPromise.resolve(catchResult)._setParent(this);
          }
        } catch (e) {
          return SynchronousPromise.reject(e)._setParent(this);
        }
      }
      return SynchronousPromise.reject(this._error)._setParent(this);
    }
    this._continuations.push({
      promise: next,
      nextFn: nextFn,
      catchFn: catchFn
    });
    this._runResolutions();
    return next;
  },
  catch: function (handler) {
    if (this._isResolved()) {
      return SynchronousPromise.resolve(this._data)._setParent(this);
    }
    var next = SynchronousPromise.unresolved()._setParent(this);
    this._continuations.push({
      promise: next,
      catchFn: handler
    });
    this._runRejections();
    return next;
  },
  finally: function(callback) {
    var ran = false;
    function runFinally(result, err) {
      if (!ran) {
        ran = true;
        if (!callback) {
          callback = passThrough;
        }
        var callbackResult = callback(result);
        if (looksLikeAPromise(callbackResult)) {
          return callbackResult.then(function() {
            if (err) {
              throw err;
            }
            return result;
          });
        } else {
          return result;
        }
      }
    }
    return this
      .then(function(result) {
        return runFinally(result);
      })
      .catch(function(err) {
        return runFinally(null, err);
      });
  },
  pause: function () {
    this._paused = true;
    return this;
  },
  resume: function () {
    var firstPaused = this._findFirstPaused();
    if (firstPaused) {
      firstPaused._paused = false;
      firstPaused._runResolutions();
      firstPaused._runRejections();
    }
    return this;
  },
  _findAncestry: function () {
    return this._continuations.reduce(function (acc, cur) {
      if (cur.promise) {
        var node = {
          promise: cur.promise,
          children: cur.promise._findAncestry()
        };
        acc.push(node);
      }
      return acc;
    }, []);
  },
  _setParent: function (parent) {
    if (this._parent) {
      throw new Error("parent already set");
    }
    this._parent = parent;
    return this;
  },
  _continueWith: function (data) {
    var firstPending = this._findFirstPending();
    if (firstPending) {
      firstPending._data = data;
      firstPending._setResolved();
    }
  },
  _findFirstPending: function () {
    return this._findFirstAncestor(function (test) {
      return test._isPending && test._isPending();
    });
  },
  _findFirstPaused: function () {
    return this._findFirstAncestor(function (test) {
      return test._paused;
    });
  },
  _findFirstAncestor: function (matching) {
    var test = this;
    var result;
    while (test) {
      if (matching(test)) {
        result = test;
      }
      test = test._parent;
    }
    return result;
  },
  _failWith: function (error) {
    var firstRejected = this._findFirstPending();
    if (firstRejected) {
      firstRejected._error = error;
      firstRejected._setRejected();
    }
  },
  _takeContinuations: function () {
    return this._continuations.splice(0, this._continuations.length);
  },
  _runRejections: function () {
    if (this._paused || !this._isRejected()) {
      return;
    }
    var
      error = this._error,
      continuations = this._takeContinuations(),
      self = this;
    continuations.forEach(function (cont) {
      if (cont.catchFn) {
        try {
          var catchResult = cont.catchFn(error);
          self._handleUserFunctionResult(catchResult, cont.promise);
        } catch (e) {
          cont.promise.reject(e);
        }
      } else {
        cont.promise.reject(error);
      }
    });
  },
  _runResolutions: function () {
    if (this._paused || !this._isResolved() || this._isPending()) {
      return;
    }
    var continuations = this._takeContinuations();
    if (looksLikeAPromise(this._data)) {
      return this._handleWhenResolvedDataIsPromise(this._data);
    }
    var data = this._data;
    var self = this;
    continuations.forEach(function (cont) {
      if (cont.nextFn) {
        try {
          var result = cont.nextFn(data);
          self._handleUserFunctionResult(result, cont.promise);
        } catch (e) {
          self._handleResolutionError(e, cont);
        }
      } else if (cont.promise) {
        cont.promise.resolve(data);
      }
    });
  },
  _handleResolutionError: function (e, continuation) {
    this._setRejected();
    if (continuation.catchFn) {
      try {
        continuation.catchFn(e);
        return;
      } catch (e2) {
        e = e2;
      }
    }
    if (continuation.promise) {
      continuation.promise.reject(e);
    }
  },
  _handleWhenResolvedDataIsPromise: function (data) {
    var self = this;
    return data.then(function (result) {
      self._data = result;
      self._runResolutions();
    }).catch(function (error) {
      self._error = error;
      self._setRejected();
      self._runRejections();
    });
  },
  _handleUserFunctionResult: function (data, nextSynchronousPromise) {
    if (looksLikeAPromise(data)) {
      this._chainPromiseData(data, nextSynchronousPromise);
    } else {
      nextSynchronousPromise.resolve(data);
    }
  },
  _chainPromiseData: function (promiseData, nextSynchronousPromise) {
    promiseData.then(function (newData) {
      nextSynchronousPromise.resolve(newData);
    }).catch(function (newError) {
      nextSynchronousPromise.reject(newError);
    });
  },
  _setResolved: function () {
    this.status = RESOLVED;
    if (!this._paused) {
      this._runResolutions();
    }
  },
  _setRejected: function () {
    this.status = REJECTED;
    if (!this._paused) {
      this._runRejections();
    }
  },
  _isPending: function () {
    return this.status === PENDING;
  },
  _isResolved: function () {
    return this.status === RESOLVED;
  },
  _isRejected: function () {
    return this.status === REJECTED;
  }
};

SynchronousPromise.resolve = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    if (looksLikeAPromise(result)) {
      result.then(function (newResult) {
        resolve(newResult);
      }).catch(function (error) {
        reject(error);
      });
    } else {
      resolve(result);
    }
  });
};

SynchronousPromise.reject = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    reject(result);
  });
};

SynchronousPromise.unresolved = function () {
  return new SynchronousPromise(function (resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
  });
};

SynchronousPromise.all = function () {
  var args = makeArrayFrom(arguments);
  if (Array.isArray(args[0])) {
    args = args[0];
  }
  if (!args.length) {
    return SynchronousPromise.resolve([]);
  }
  return new SynchronousPromise(function (resolve, reject) {
    var
      allData = [],
      numResolved = 0,
      doResolve = function () {
        if (numResolved === args.length) {
          resolve(allData);
        }
      },
      rejected = false,
      doReject = function (err) {
        if (rejected) {
          return;
        }
        rejected = true;
        reject(err);
      };
    args.forEach(function (arg, idx) {
      SynchronousPromise.resolve(arg).then(function (thisResult) {
        allData[idx] = thisResult;
        numResolved += 1;
        doResolve();
      }).catch(function (err) {
        doReject(err);
      });
    });
  });
};

/* jshint ignore:start */
if (Promise === SynchronousPromise) {
  throw new Error("Please use SynchronousPromise.installGlobally() to install globally");
}
var RealPromise = Promise;
SynchronousPromise.installGlobally = function(__awaiter) {
  if (Promise === SynchronousPromise) {
    return __awaiter;
  }
  var result = patchAwaiterIfRequired(__awaiter);
  Promise = SynchronousPromise;
  return result;
};

SynchronousPromise.uninstallGlobally = function() {
  if (Promise === SynchronousPromise) {
    Promise = RealPromise;
  }
};

function patchAwaiterIfRequired(__awaiter) {
  if (typeof(__awaiter) === "undefined" || __awaiter.__patched) {
    return __awaiter;
  }
  var originalAwaiter = __awaiter;
  __awaiter = function() {
    var Promise = RealPromise;
    originalAwaiter.apply(this, makeArrayFrom(arguments));
  };
  __awaiter.__patched = true;
  return __awaiter;
}
/* jshint ignore:end */

module.exports = {
  SynchronousPromise: SynchronousPromise
};


/***/ }),
/* 493 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = ValidationError;

var _printValue = _interopRequireDefault(__webpack_require__(487));

var strReg = /\$\{\s*(\w+)\s*\}/g;

var replace = function replace(str) {
  return function (params) {
    return str.replace(strReg, function (_, key) {
      return (0, _printValue.default)(params[key]);
    });
  };
};

function ValidationError(errors, value, field, type) {
  var _this = this;

  this.name = 'ValidationError';
  this.value = value;
  this.path = field;
  this.type = type;
  this.errors = [];
  this.inner = [];
  if (errors) [].concat(errors).forEach(function (err) {
    _this.errors = _this.errors.concat(err.errors || err);
    if (err.inner) _this.inner = _this.inner.concat(err.inner.length ? err.inner : err);
  });
  this.message = this.errors.length > 1 ? this.errors.length + " errors occurred" : this.errors[0];
  if (Error.captureStackTrace) Error.captureStackTrace(this, ValidationError);
}

ValidationError.prototype = Object.create(Error.prototype);
ValidationError.prototype.constructor = ValidationError;

ValidationError.isError = function (err) {
  return err && err.name === 'ValidationError';
};

ValidationError.formatError = function (message, params) {
  if (typeof message === 'string') message = replace(message);

  var fn = function fn(params) {
    params.path = params.label || params.path || 'this';
    return typeof message === 'function' ? message(params) : message;
  };

  return arguments.length === 1 ? fn : fn(params);
};

module.exports = exports["default"];

/***/ }),
/* 494 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = prependDeep;

var _has = _interopRequireDefault(__webpack_require__(417));

var _isSchema = _interopRequireDefault(__webpack_require__(489));

var isObject = function isObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
};

function prependDeep(target, source) {
  for (var key in source) {
    if ((0, _has.default)(source, key)) {
      var sourceVal = source[key],
          targetVal = target[key];

      if (targetVal === undefined) {
        target[key] = sourceVal;
      } else if (targetVal === sourceVal) {
        continue;
      } else if ((0, _isSchema.default)(targetVal)) {
        if ((0, _isSchema.default)(sourceVal)) target[key] = sourceVal.concat(targetVal);
      } else if (isObject(targetVal)) {
        if (isObject(sourceVal)) target[key] = prependDeep(targetVal, sourceVal);
      } else if (Array.isArray(targetVal)) {
        if (Array.isArray(sourceVal)) target[key] = sourceVal.concat(targetVal);
      }
    }
  }

  return target;
}

module.exports = exports["default"];

/***/ }),
/* 495 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.createErrorFactory = createErrorFactory;
exports.default = createValidation;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(491));

var _extends2 = _interopRequireDefault(__webpack_require__(416));

var _mapValues = _interopRequireDefault(__webpack_require__(496));

var _ValidationError = _interopRequireDefault(__webpack_require__(493));

var _Reference = _interopRequireDefault(__webpack_require__(521));

var _synchronousPromise = __webpack_require__(492);

var formatError = _ValidationError.default.formatError;

var thenable = function thenable(p) {
  return p && typeof p.then === 'function' && typeof p.catch === 'function';
};

function runTest(testFn, ctx, value, sync) {
  var result = testFn.call(ctx, value);
  if (!sync) return Promise.resolve(result);

  if (thenable(result)) {
    throw new Error("Validation test of type: \"" + ctx.type + "\" returned a Promise during a synchronous validate. " + "This test will finish after the validate call has returned");
  }

  return _synchronousPromise.SynchronousPromise.resolve(result);
}

function resolveParams(oldParams, newParams, resolve) {
  return (0, _mapValues.default)((0, _extends2.default)({}, oldParams, newParams), resolve);
}

function createErrorFactory(_ref) {
  var value = _ref.value,
      label = _ref.label,
      resolve = _ref.resolve,
      originalValue = _ref.originalValue,
      opts = (0, _objectWithoutPropertiesLoose2.default)(_ref, ["value", "label", "resolve", "originalValue"]);
  return function createError(_temp) {
    var _ref2 = _temp === void 0 ? {} : _temp,
        _ref2$path = _ref2.path,
        path = _ref2$path === void 0 ? opts.path : _ref2$path,
        _ref2$message = _ref2.message,
        message = _ref2$message === void 0 ? opts.message : _ref2$message,
        _ref2$type = _ref2.type,
        type = _ref2$type === void 0 ? opts.name : _ref2$type,
        params = _ref2.params;

    params = (0, _extends2.default)({
      path: path,
      value: value,
      originalValue: originalValue,
      label: label
    }, resolveParams(opts.params, params, resolve));
    return (0, _extends2.default)(new _ValidationError.default(formatError(message, params), value, path, type), {
      params: params
    });
  };
}

function createValidation(options) {
  var name = options.name,
      message = options.message,
      test = options.test,
      params = options.params;

  function validate(_ref3) {
    var value = _ref3.value,
        path = _ref3.path,
        label = _ref3.label,
        options = _ref3.options,
        originalValue = _ref3.originalValue,
        sync = _ref3.sync,
        rest = (0, _objectWithoutPropertiesLoose2.default)(_ref3, ["value", "path", "label", "options", "originalValue", "sync"]);
    var parent = options.parent;

    var resolve = function resolve(item) {
      return _Reference.default.isRef(item) ? item.getValue({
        value: value,
        parent: parent,
        context: options.context
      }) : item;
    };

    var createError = createErrorFactory({
      message: message,
      path: path,
      value: value,
      originalValue: originalValue,
      params: params,
      label: label,
      resolve: resolve,
      name: name
    });
    var ctx = (0, _extends2.default)({
      path: path,
      parent: parent,
      type: name,
      createError: createError,
      resolve: resolve,
      options: options
    }, rest);
    return runTest(test, ctx, value, sync).then(function (validOrError) {
      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();
    });
  }

  validate.OPTIONS = options;
  return validate;
}

/***/ }),
/* 496 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(312),
    baseForOwn = __webpack_require__(497),
    baseIteratee = __webpack_require__(500);

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;


/***/ }),
/* 497 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(498),
    keys = __webpack_require__(430);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),
/* 498 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(499);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 499 */
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 500 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMatches = __webpack_require__(501),
    baseMatchesProperty = __webpack_require__(516),
    identity = __webpack_require__(331),
    isArray = __webpack_require__(261),
    property = __webpack_require__(518);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),
/* 501 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__(502),
    getMatchData = __webpack_require__(513),
    matchesStrictComparable = __webpack_require__(515);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),
/* 502 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(421),
    baseIsEqual = __webpack_require__(503);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),
/* 503 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(504),
    isObjectLike = __webpack_require__(270);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),
/* 504 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(421),
    equalArrays = __webpack_require__(505),
    equalByTag = __webpack_require__(511),
    equalObjects = __webpack_require__(512),
    getTag = __webpack_require__(460),
    isArray = __webpack_require__(261),
    isBuffer = __webpack_require__(433),
    isTypedArray = __webpack_require__(435);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),
/* 505 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(506),
    arraySome = __webpack_require__(509),
    cacheHas = __webpack_require__(510);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),
/* 506 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(274),
    setCacheAdd = __webpack_require__(507),
    setCacheHas = __webpack_require__(508);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),
/* 507 */
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),
/* 508 */
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),
/* 509 */
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),
/* 510 */
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),
/* 511 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(265),
    Uint8Array = __webpack_require__(468),
    eq = __webpack_require__(295),
    equalArrays = __webpack_require__(505),
    mapToArray = __webpack_require__(482),
    setToArray = __webpack_require__(483);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),
/* 512 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(457);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),
/* 513 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__(514),
    keys = __webpack_require__(430);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),
/* 514 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(282);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),
/* 515 */
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),
/* 516 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(503),
    get = __webpack_require__(517),
    hasIn = __webpack_require__(315),
    isKey = __webpack_require__(262),
    isStrictComparable = __webpack_require__(514),
    matchesStrictComparable = __webpack_require__(515),
    toKey = __webpack_require__(309);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),
/* 517 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(259);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),
/* 518 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(519),
    basePropertyDeep = __webpack_require__(520),
    isKey = __webpack_require__(262),
    toKey = __webpack_require__(309);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),
/* 519 */
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),
/* 520 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(259);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),
/* 521 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(416));

var _propertyExpr = __webpack_require__(522);

var prefixes = {
  context: '$',
  value: '.'
};

var Reference =
/*#__PURE__*/
function () {
  function Reference(key, options) {
    if (options === void 0) {
      options = {};
    }

    if (typeof key !== 'string') throw new TypeError('ref must be a string, got: ' + key);
    this.key = key.trim();
    if (key === '') throw new TypeError('ref must be a non-empty string');
    this.isContext = this.key[0] === prefixes.context;
    this.isValue = this.key[0] === prefixes.value;
    this.isSibling = !this.isContext && !this.isValue;
    var prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : '';
    this.path = this.key.slice(prefix.length);
    this.getter = this.path && (0, _propertyExpr.getter)(this.path, true);
    this.map = options.map;
  }

  var _proto = Reference.prototype;

  _proto.getValue = function getValue(options) {
    var result = this.isContext ? options.context : this.isValue ? options.value : options.parent;
    if (this.getter) result = this.getter(result || {});
    if (this.map) result = this.map(result);
    return result;
  };

  _proto.cast = function cast(value, options) {
    return this.getValue((0, _extends2.default)({}, options, {
      value: value
    }));
  };

  _proto.resolve = function resolve() {
    return this;
  };

  _proto.describe = function describe() {
    return {
      type: 'ref',
      key: this.key
    };
  };

  _proto.toString = function toString() {
    return "Ref(" + this.key + ")";
  };

  Reference.isRef = function isRef(value) {
    return value && value.__isYupRef;
  };

  return Reference;
}();

exports.default = Reference;
Reference.prototype.__isYupRef = true;
module.exports = exports["default"];

/***/ }),
/* 522 */
/***/ ((module) => {

"use strict";
/**
 * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>
 */


function Cache(maxSize) {
  this._maxSize = maxSize
  this.clear()
}
Cache.prototype.clear = function() {
  this._size = 0
  this._values = {}
}
Cache.prototype.get = function(key) {
  return this._values[key]
}
Cache.prototype.set = function(key, value) {
  this._size >= this._maxSize && this.clear()
  if (!this._values.hasOwnProperty(key)) {
    this._size++
  }
  return this._values[key] = value
}

var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
  DIGIT_REGEX = /^\d+$/,
  LEAD_DIGIT_REGEX = /^\d/,
  SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
  CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/,
  MAX_CACHE_SIZE = 512

var contentSecurityPolicy = false,
  pathCache = new Cache(MAX_CACHE_SIZE),
  setCache = new Cache(MAX_CACHE_SIZE),
  getCache = new Cache(MAX_CACHE_SIZE)

try {
  new Function('')
} catch (error) {
  contentSecurityPolicy = true
}

module.exports = {
  Cache: Cache,

  expr: expr,

  split: split,

  normalizePath: normalizePath,

  setter: contentSecurityPolicy
    ? function(path) {
      var parts = normalizePath(path)
      return function(data, value) {
        return setterFallback(parts, data, value)
      }
    }
    : function(path) {
      return setCache.get(path) || setCache.set(
        path,
        new Function(
          'data, value',
          expr(path, 'data') + ' = value'
        )
      )
    },

  getter: contentSecurityPolicy
    ? function(path, safe) {
      var parts = normalizePath(path)
      return function(data) {
        return getterFallback(parts, safe, data)
      }
    }
    : function(path, safe) {
      var key = path + '_' + safe
      return getCache.get(key) || getCache.set(
        key,
        new Function('data', 'return ' + expr(path, safe, 'data'))
      )
    },

  join: function(segments) {
    return segments.reduce(function(path, part) {
      return (
        path +
        (isQuoted(part) || DIGIT_REGEX.test(part)
          ? '[' + part + ']'
          : (path ? '.' : '') + part)
      )
    }, '')
  },

  forEach: function(path, cb, thisArg) {
    forEach(split(path), cb, thisArg)
  }
}

function setterFallback(parts, data, value) {
  var index = 0,
    len = parts.length
  while (index < len - 1) {
    data = data[parts[index++]]
  }
  data[parts[index]] = value
}

function getterFallback(parts, safe, data) {
  var index = 0,
    len = parts.length
  while (index < len) {
    if (data != null || !safe) {
      data = data[parts[index++]]
    } else {
      return
    }
  }
  return data
}

function normalizePath(path) {
  return pathCache.get(path) || pathCache.set(
    path,
    split(path).map(function(part) {
      return part.replace(CLEAN_QUOTES_REGEX, '$2')
    })
  )
}

function split(path) {
  return path.match(SPLIT_REGEX)
}

function expr(expression, safe, param) {
  expression = expression || ''

  if (typeof safe === 'string') {
    param = safe
    safe = false
  }

  param = param || 'data'

  if (expression && expression.charAt(0) !== '[') expression = '.' + expression

  return safe ? makeSafe(expression, param) : param + expression
}

function forEach(parts, iter, thisArg) {
  var len = parts.length,
    part,
    idx,
    isArray,
    isBracket

  for (idx = 0; idx < len; idx++) {
    part = parts[idx]

    if (part) {
      if (shouldBeQuoted(part)) {
        part = '"' + part + '"'
      }

      isBracket = isQuoted(part)
      isArray = !isBracket && /^\d+$/.test(part)

      iter.call(thisArg, part, isBracket, isArray, idx, parts)
    }
  }
}

function isQuoted(str) {
  return (
    typeof str === 'string' && str && ["'", '"'].indexOf(str.charAt(0)) !== -1
  )
}

function makeSafe(path, param) {
  var result = param,
    parts = split(path),
    isLast

  forEach(parts, function(part, isBracket, isArray, idx, parts) {
    isLast = idx === parts.length - 1

    part = isBracket || isArray ? '[' + part + ']' : '.' + part

    result += part + (!isLast ? ' || {})' : ')')
  })

  return new Array(parts.length + 1).join('(') + result
}

function hasLeadingNumber(part) {
  return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX)
}

function hasSpecialChars(part) {
  return SPEC_CHAR_REGEX.test(part)
}

function shouldBeQuoted(part) {
  return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part))
}


/***/ }),
/* 523 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.getIn = getIn;
exports.default = void 0;

var _propertyExpr = __webpack_require__(522);

var _has = _interopRequireDefault(__webpack_require__(417));

var trim = function trim(part) {
  return part.substr(0, part.length - 1).substr(1);
};

function getIn(schema, path, value, context) {
  var parent, lastPart, lastPartDebug; // if only one "value" arg then use it for both

  context = context || value;
  if (!path) return {
    parent: parent,
    parentPath: path,
    schema: schema
  };
  (0, _propertyExpr.forEach)(path, function (_part, isBracket, isArray) {
    var part = isBracket ? trim(_part) : _part;

    if (isArray || (0, _has.default)(schema, '_subType')) {
      // we skipped an array: foo[].bar
      var idx = isArray ? parseInt(part, 10) : 0;
      schema = schema.resolve({
        context: context,
        parent: parent,
        value: value
      })._subType;

      if (value) {
        if (isArray && idx >= value.length) {
          throw new Error("Yup.reach cannot resolve an array item at index: " + _part + ", in the path: " + path + ". " + "because there is no value at that index. ");
        }

        value = value[idx];
      }
    }

    if (!isArray) {
      schema = schema.resolve({
        context: context,
        parent: parent,
        value: value
      });
      if (!(0, _has.default)(schema, 'fields') || !(0, _has.default)(schema.fields, part)) throw new Error("The schema does not contain the path: " + path + ". " + ("(failed at: " + lastPartDebug + " which is a type: \"" + schema._type + "\") "));
      schema = schema.fields[part];
      parent = value;
      value = value && value[part];
      lastPart = part;
      lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;
    }
  });
  return {
    schema: schema,
    parent: parent,
    parentPath: lastPart
  };
}

var reach = function reach(obj, path, value, context) {
  return getIn(obj, path, value, context).schema;
};

var _default = reach;
exports.default = _default;

/***/ }),
/* 524 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = void 0;

var _inherits = _interopRequireDefault(__webpack_require__(525));

var _mixed = _interopRequireDefault(__webpack_require__(415));

var _default = BooleanSchema;
exports.default = _default;

function BooleanSchema() {
  var _this = this;

  if (!(this instanceof BooleanSchema)) return new BooleanSchema();

  _mixed.default.call(this, {
    type: 'boolean'
  });

  this.withMutation(function () {
    _this.transform(function (value) {
      if (!this.isType(value)) {
        if (/^(true|1)$/i.test(value)) return true;
        if (/^(false|0)$/i.test(value)) return false;
      }

      return value;
    });
  });
}

(0, _inherits.default)(BooleanSchema, _mixed.default, {
  _typeCheck: function _typeCheck(v) {
    if (v instanceof Boolean) v = v.valueOf();
    return typeof v === 'boolean';
  }
});
module.exports = exports["default"];

/***/ }),
/* 525 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = inherits;

var _extends2 = _interopRequireDefault(__webpack_require__(416));

function inherits(ctor, superCtor, spec) {
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  (0, _extends2.default)(ctor.prototype, spec);
}

module.exports = exports["default"];

/***/ }),
/* 526 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = StringSchema;

var _inherits = _interopRequireDefault(__webpack_require__(525));

var _mixed = _interopRequireDefault(__webpack_require__(415));

var _locale = __webpack_require__(486);

var _isAbsent = _interopRequireDefault(__webpack_require__(527));

// eslint-disable-next-line
var rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i; // eslint-disable-next-line

var rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;

var isTrimmed = function isTrimmed(value) {
  return (0, _isAbsent.default)(value) || value === value.trim();
};

function StringSchema() {
  var _this = this;

  if (!(this instanceof StringSchema)) return new StringSchema();

  _mixed.default.call(this, {
    type: 'string'
  });

  this.withMutation(function () {
    _this.transform(function (value) {
      if (this.isType(value)) return value;
      return value != null && value.toString ? value.toString() : value;
    });
  });
}

(0, _inherits.default)(StringSchema, _mixed.default, {
  _typeCheck: function _typeCheck(value) {
    if (value instanceof String) value = value.valueOf();
    return typeof value === 'string';
  },
  _isPresent: function _isPresent(value) {
    return _mixed.default.prototype._cast.call(this, value) && value.length > 0;
  },
  length: function length(_length, message) {
    if (message === void 0) {
      message = _locale.string.length;
    }

    return this.test({
      message: message,
      name: 'length',
      exclusive: true,
      params: {
        length: _length
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value.length === this.resolve(_length);
      }
    });
  },
  min: function min(_min, message) {
    if (message === void 0) {
      message = _locale.string.min;
    }

    return this.test({
      message: message,
      name: 'min',
      exclusive: true,
      params: {
        min: _min
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value.length >= this.resolve(_min);
      }
    });
  },
  max: function max(_max, message) {
    if (message === void 0) {
      message = _locale.string.max;
    }

    return this.test({
      name: 'max',
      exclusive: true,
      message: message,
      params: {
        max: _max
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value.length <= this.resolve(_max);
      }
    });
  },
  matches: function matches(regex, options) {
    var excludeEmptyString = false;
    var message;

    if (options) {
      if (options.message || options.hasOwnProperty('excludeEmptyString')) {
        excludeEmptyString = options.excludeEmptyString;
        message = options.message;
      } else message = options;
    }

    return this.test({
      message: message || _locale.string.matches,
      params: {
        regex: regex
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value === '' && excludeEmptyString || regex.test(value);
      }
    });
  },
  email: function email(message) {
    if (message === void 0) {
      message = _locale.string.email;
    }

    return this.matches(rEmail, {
      message: message,
      excludeEmptyString: true
    });
  },
  url: function url(message) {
    if (message === void 0) {
      message = _locale.string.url;
    }

    return this.matches(rUrl, {
      message: message,
      excludeEmptyString: true
    });
  },
  //-- transforms --
  ensure: function ensure() {
    return this.default('').transform(function (val) {
      return val === null ? '' : val;
    });
  },
  trim: function trim(message) {
    if (message === void 0) {
      message = _locale.string.trim;
    }

    return this.transform(function (val) {
      return val != null ? val.trim() : val;
    }).test({
      message: message,
      name: 'trim',
      test: isTrimmed
    });
  },
  lowercase: function lowercase(message) {
    if (message === void 0) {
      message = _locale.string.lowercase;
    }

    return this.transform(function (value) {
      return !(0, _isAbsent.default)(value) ? value.toLowerCase() : value;
    }).test({
      message: message,
      name: 'string_case',
      exclusive: true,
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value === value.toLowerCase();
      }
    });
  },
  uppercase: function uppercase(message) {
    if (message === void 0) {
      message = _locale.string.uppercase;
    }

    return this.transform(function (value) {
      return !(0, _isAbsent.default)(value) ? value.toUpperCase() : value;
    }).test({
      message: message,
      name: 'string_case',
      exclusive: true,
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value === value.toUpperCase();
      }
    });
  }
});
module.exports = exports["default"];

/***/ }),
/* 527 */
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _default = function _default(value) {
  return value == null;
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 528 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = NumberSchema;

var _inherits = _interopRequireDefault(__webpack_require__(525));

var _mixed = _interopRequireDefault(__webpack_require__(415));

var _locale = __webpack_require__(486);

var _isAbsent = _interopRequireDefault(__webpack_require__(527));

var isNaN = function isNaN(value) {
  return value != +value;
};

var isInteger = function isInteger(val) {
  return (0, _isAbsent.default)(val) || val === (val | 0);
};

function NumberSchema() {
  var _this = this;

  if (!(this instanceof NumberSchema)) return new NumberSchema();

  _mixed.default.call(this, {
    type: 'number'
  });

  this.withMutation(function () {
    _this.transform(function (value) {
      var parsed = value;

      if (typeof parsed === 'string') {
        parsed = parsed.replace(/\s/g, '');
        if (parsed === '') return NaN; // don't use parseFloat to avoid positives on alpha-numeric strings

        parsed = +parsed;
      }

      if (this.isType(parsed)) return parsed;
      return parseFloat(parsed);
    });
  });
}

(0, _inherits.default)(NumberSchema, _mixed.default, {
  _typeCheck: function _typeCheck(value) {
    if (value instanceof Number) value = value.valueOf();
    return typeof value === 'number' && !isNaN(value);
  },
  min: function min(_min, message) {
    if (message === void 0) {
      message = _locale.number.min;
    }

    return this.test({
      message: message,
      name: 'min',
      exclusive: true,
      params: {
        min: _min
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value >= this.resolve(_min);
      }
    });
  },
  max: function max(_max, message) {
    if (message === void 0) {
      message = _locale.number.max;
    }

    return this.test({
      message: message,
      name: 'max',
      exclusive: true,
      params: {
        max: _max
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value <= this.resolve(_max);
      }
    });
  },
  lessThan: function lessThan(less, message) {
    if (message === void 0) {
      message = _locale.number.lessThan;
    }

    return this.test({
      message: message,
      name: 'max',
      exclusive: true,
      params: {
        less: less
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value < this.resolve(less);
      }
    });
  },
  moreThan: function moreThan(more, message) {
    if (message === void 0) {
      message = _locale.number.moreThan;
    }

    return this.test({
      message: message,
      name: 'min',
      exclusive: true,
      params: {
        more: more
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value > this.resolve(more);
      }
    });
  },
  positive: function positive(msg) {
    if (msg === void 0) {
      msg = _locale.number.positive;
    }

    return this.moreThan(0, msg);
  },
  negative: function negative(msg) {
    if (msg === void 0) {
      msg = _locale.number.negative;
    }

    return this.lessThan(0, msg);
  },
  integer: function integer(message) {
    if (message === void 0) {
      message = _locale.number.integer;
    }

    return this.test({
      name: 'integer',
      message: message,
      test: isInteger
    });
  },
  truncate: function truncate() {
    return this.transform(function (value) {
      return !(0, _isAbsent.default)(value) ? value | 0 : value;
    });
  },
  round: function round(method) {
    var avail = ['ceil', 'floor', 'round', 'trunc'];
    method = method && method.toLowerCase() || 'round'; // this exists for symemtry with the new Math.trunc

    if (method === 'trunc') return this.truncate();
    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));
    return this.transform(function (value) {
      return !(0, _isAbsent.default)(value) ? Math[method](value) : value;
    });
  }
});
module.exports = exports["default"];

/***/ }),
/* 529 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = void 0;

var _mixed = _interopRequireDefault(__webpack_require__(415));

var _inherits = _interopRequireDefault(__webpack_require__(525));

var _isodate = _interopRequireDefault(__webpack_require__(530));

var _locale = __webpack_require__(486);

var _isAbsent = _interopRequireDefault(__webpack_require__(527));

var _Reference = _interopRequireDefault(__webpack_require__(521));

var invalidDate = new Date('');

var isDate = function isDate(obj) {
  return Object.prototype.toString.call(obj) === '[object Date]';
};

var _default = DateSchema;
exports.default = _default;

function DateSchema() {
  var _this = this;

  if (!(this instanceof DateSchema)) return new DateSchema();

  _mixed.default.call(this, {
    type: 'date'
  });

  this.withMutation(function () {
    _this.transform(function (value) {
      if (this.isType(value)) return value;
      value = (0, _isodate.default)(value);
      return value ? new Date(value) : invalidDate;
    });
  });
}

(0, _inherits.default)(DateSchema, _mixed.default, {
  _typeCheck: function _typeCheck(v) {
    return isDate(v) && !isNaN(v.getTime());
  },
  min: function min(_min, message) {
    if (message === void 0) {
      message = _locale.date.min;
    }

    var limit = _min;

    if (!_Reference.default.isRef(limit)) {
      limit = this.cast(_min);
      if (!this._typeCheck(limit)) throw new TypeError('`min` must be a Date or a value that can be `cast()` to a Date');
    }

    return this.test({
      message: message,
      name: 'min',
      exclusive: true,
      params: {
        min: _min
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value >= this.resolve(limit);
      }
    });
  },
  max: function max(_max, message) {
    if (message === void 0) {
      message = _locale.date.max;
    }

    var limit = _max;

    if (!_Reference.default.isRef(limit)) {
      limit = this.cast(_max);
      if (!this._typeCheck(limit)) throw new TypeError('`max` must be a Date or a value that can be `cast()` to a Date');
    }

    return this.test({
      message: message,
      name: 'max',
      exclusive: true,
      params: {
        max: _max
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value <= this.resolve(limit);
      }
    });
  }
});
module.exports = exports["default"];

/***/ }),
/* 530 */
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = parseIsoDate;

/* eslint-disable */

/**
 *
 * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>
 * NON-CONFORMANT EDITION.
 *  2011 Colin Snover <http://zetafleet.com>
 * Released under MIT license.
 */
//              1 YYYY                 2 MM        3 DD              4 HH     5 mm        6 ss            7 msec         8 Z 9     10 tzHH    11 tzmm
var isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;

function parseIsoDate(date) {
  var numericKeys = [1, 4, 5, 6, 7, 10, 11],
      minutesOffset = 0,
      timestamp,
      struct;

  if (struct = isoReg.exec(date)) {
    // avoid NaN timestamps caused by undefined values being passed to Date.UTC
    for (var i = 0, k; k = numericKeys[i]; ++i) {
      struct[k] = +struct[k] || 0;
    } // allow undefined days and months


    struct[2] = (+struct[2] || 1) - 1;
    struct[3] = +struct[3] || 1; // allow arbitrary sub-second precision beyond milliseconds

    struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0; // timestamps without timezone identifiers should be considered local time

    if ((struct[8] === undefined || struct[8] === '') && (struct[9] === undefined || struct[9] === '')) timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);else {
      if (struct[8] !== 'Z' && struct[9] !== undefined) {
        minutesOffset = struct[10] * 60 + struct[11];
        if (struct[9] === '+') minutesOffset = 0 - minutesOffset;
      }

      timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
    }
  } else timestamp = Date.parse ? Date.parse(date) : NaN;

  return timestamp;
}

module.exports = exports["default"];

/***/ }),
/* 531 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = __webpack_require__(532);

var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = ObjectSchema;

var _taggedTemplateLiteralLoose2 = _interopRequireDefault(__webpack_require__(534));

var _extends2 = _interopRequireDefault(__webpack_require__(416));

var _has = _interopRequireDefault(__webpack_require__(417));

var _snakeCase2 = _interopRequireDefault(__webpack_require__(535));

var _camelCase2 = _interopRequireDefault(__webpack_require__(545));

var _mapKeys = _interopRequireDefault(__webpack_require__(546));

var _mapValues = _interopRequireDefault(__webpack_require__(496));

var _propertyExpr = __webpack_require__(522);

var _mixed = _interopRequireDefault(__webpack_require__(415));

var _locale = __webpack_require__(486);

var _sortFields = _interopRequireDefault(__webpack_require__(547));

var _sortByKeyOrder = _interopRequireDefault(__webpack_require__(549));

var _inherits = _interopRequireDefault(__webpack_require__(525));

var _makePath = _interopRequireDefault(__webpack_require__(550));

var _runValidations = _interopRequireWildcard(__webpack_require__(490));

function _templateObject2() {
  var data = (0, _taggedTemplateLiteralLoose2.default)(["", ".", ""]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0, _taggedTemplateLiteralLoose2.default)(["", ".", ""]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var isObject = function isObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
};

function unknown(ctx, value) {
  var known = Object.keys(ctx.fields);
  return Object.keys(value).filter(function (key) {
    return known.indexOf(key) === -1;
  });
}

function ObjectSchema(spec) {
  var _this2 = this;

  if (!(this instanceof ObjectSchema)) return new ObjectSchema(spec);

  _mixed.default.call(this, {
    type: 'object',
    default: function _default() {
      var _this = this;

      if (!this._nodes.length) return undefined;
      var dft = {};

      this._nodes.forEach(function (key) {
        dft[key] = _this.fields[key].default ? _this.fields[key].default() : undefined;
      });

      return dft;
    }
  });

  this.fields = Object.create(null);
  this._nodes = [];
  this._excludedEdges = [];
  this.withMutation(function () {
    _this2.transform(function coerce(value) {
      if (typeof value === 'string') {
        try {
          value = JSON.parse(value);
        } catch (err) {
          value = null;
        }
      }

      if (this.isType(value)) return value;
      return null;
    });

    if (spec) {
      _this2.shape(spec);
    }
  });
}

(0, _inherits.default)(ObjectSchema, _mixed.default, {
  _typeCheck: function _typeCheck(value) {
    return isObject(value) || typeof value === 'function';
  },
  _cast: function _cast(_value, options) {
    var _this3 = this;

    if (options === void 0) {
      options = {};
    }

    var value = _mixed.default.prototype._cast.call(this, _value, options); //should ignore nulls here


    if (value === undefined) return this.default();
    if (!this._typeCheck(value)) return value;
    var fields = this.fields;
    var strip = this._option('stripUnknown', options) === true;

    var props = this._nodes.concat(Object.keys(value).filter(function (v) {
      return _this3._nodes.indexOf(v) === -1;
    }));

    var intermediateValue = {}; // is filled during the transform below

    var innerOptions = (0, _extends2.default)({}, options, {
      parent: intermediateValue,
      __validating: false
    });
    var isChanged = false;
    props.forEach(function (prop) {
      var field = fields[prop];
      var exists = (0, _has.default)(value, prop);

      if (field) {
        var fieldValue;
        var strict = field._options && field._options.strict; // safe to mutate since this is fired in sequence

        innerOptions.path = (0, _makePath.default)(_templateObject(), options.path, prop);
        innerOptions.value = value[prop];
        field = field.resolve(innerOptions);

        if (field._strip === true) {
          isChanged = isChanged || prop in value;
          return;
        }

        fieldValue = !options.__validating || !strict ? field.cast(value[prop], innerOptions) : value[prop];
        if (fieldValue !== undefined) intermediateValue[prop] = fieldValue;
      } else if (exists && !strip) intermediateValue[prop] = value[prop];

      if (intermediateValue[prop] !== value[prop]) isChanged = true;
    });
    return isChanged ? intermediateValue : value;
  },
  _validate: function _validate(_value, opts) {
    var _this4 = this;

    if (opts === void 0) {
      opts = {};
    }

    var endEarly, recursive;
    var sync = opts.sync;
    var errors = [];
    var originalValue = opts.originalValue != null ? opts.originalValue : _value;
    endEarly = this._option('abortEarly', opts);
    recursive = this._option('recursive', opts);
    opts = (0, _extends2.default)({}, opts, {
      __validating: true,
      originalValue: originalValue
    });
    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {
      if (!recursive || !isObject(value)) {
        // only iterate though actual objects
        if (errors.length) throw errors[0];
        return value;
      }

      originalValue = originalValue || value;

      var validations = _this4._nodes.map(function (key) {
        var path = (0, _makePath.default)(_templateObject2(), opts.path, key);
        var field = _this4.fields[key];
        var innerOptions = (0, _extends2.default)({}, opts, {
          path: path,
          parent: value,
          originalValue: originalValue[key]
        });

        if (field && field.validate) {
          // inner fields are always strict:
          // 1. this isn't strict so the casting will also have cast inner values
          // 2. this is strict in which case the nested values weren't cast either
          innerOptions.strict = true;
          return field.validate(value[key], innerOptions);
        }

        return Promise.resolve(true);
      });

      return (0, _runValidations.default)({
        sync: sync,
        validations: validations,
        value: value,
        errors: errors,
        endEarly: endEarly,
        path: opts.path,
        sort: (0, _sortByKeyOrder.default)(_this4.fields)
      });
    });
  },
  concat: function concat(schema) {
    var next = _mixed.default.prototype.concat.call(this, schema);

    next._nodes = (0, _sortFields.default)(next.fields, next._excludedEdges);
    return next;
  },
  shape: function shape(schema, excludes) {
    if (excludes === void 0) {
      excludes = [];
    }

    var next = this.clone();
    var fields = (0, _extends2.default)(next.fields, schema);
    next.fields = fields;

    if (excludes.length) {
      if (!Array.isArray(excludes[0])) excludes = [excludes];
      var keys = excludes.map(function (_ref) {
        var first = _ref[0],
            second = _ref[1];
        return first + "-" + second;
      });
      next._excludedEdges = next._excludedEdges.concat(keys);
    }

    next._nodes = (0, _sortFields.default)(fields, next._excludedEdges);
    return next;
  },
  from: function from(_from, to, alias) {
    var fromGetter = (0, _propertyExpr.getter)(_from, true);
    return this.transform(function (obj) {
      if (obj == null) return obj;
      var newObj = obj;

      if ((0, _has.default)(obj, _from)) {
        newObj = (0, _extends2.default)({}, obj);
        if (!alias) delete newObj[_from];
        newObj[to] = fromGetter(obj);
      }

      return newObj;
    });
  },
  noUnknown: function noUnknown(noAllow, message) {
    if (noAllow === void 0) {
      noAllow = true;
    }

    if (message === void 0) {
      message = _locale.object.noUnknown;
    }

    if (typeof noAllow === 'string') {
      message = noAllow;
      noAllow = true;
    }

    var next = this.test({
      name: 'noUnknown',
      exclusive: true,
      message: message,
      test: function test(value) {
        return value == null || !noAllow || unknown(this.schema, value).length === 0;
      }
    });
    next._options.stripUnknown = noAllow;
    return next;
  },
  unknown: function unknown(allow, message) {
    if (allow === void 0) {
      allow = true;
    }

    if (message === void 0) {
      message = _locale.object.noUnknown;
    }

    return this.noUnknown(!allow, message);
  },
  transformKeys: function transformKeys(fn) {
    return this.transform(function (obj) {
      return obj && (0, _mapKeys.default)(obj, function (_, key) {
        return fn(key);
      });
    });
  },
  camelCase: function camelCase() {
    return this.transformKeys(_camelCase2.default);
  },
  snakeCase: function snakeCase() {
    return this.transformKeys(_snakeCase2.default);
  },
  constantCase: function constantCase() {
    return this.transformKeys(function (key) {
      return (0, _snakeCase2.default)(key).toUpperCase();
    });
  },
  describe: function describe() {
    var base = _mixed.default.prototype.describe.call(this);

    base.fields = (0, _mapValues.default)(this.fields, function (value) {
      return value.describe();
    });
    return base;
  }
});
module.exports = exports["default"];

/***/ }),
/* 532 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = __webpack_require__(533);

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),
/* 533 */
/***/ ((module) => {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 534 */
/***/ ((module) => {

function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  strings.raw = raw;
  return strings;
}

module.exports = _taggedTemplateLiteralLoose;

/***/ }),
/* 535 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createCompounder = __webpack_require__(536);

/**
 * Converts `string` to
 * [snake case](https://en.wikipedia.org/wiki/Snake_case).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the snake cased string.
 * @example
 *
 * _.snakeCase('Foo Bar');
 * // => 'foo_bar'
 *
 * _.snakeCase('fooBar');
 * // => 'foo_bar'
 *
 * _.snakeCase('--FOO-BAR--');
 * // => 'foo_bar'
 */
var snakeCase = createCompounder(function(result, word, index) {
  return result + (index ? '_' : '') + word.toLowerCase();
});

module.exports = snakeCase;


/***/ }),
/* 536 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayReduce = __webpack_require__(537),
    deburr = __webpack_require__(538),
    words = __webpack_require__(541);

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

module.exports = createCompounder;


/***/ }),
/* 537 */
/***/ ((module) => {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),
/* 538 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var deburrLetter = __webpack_require__(539),
    toString = __webpack_require__(306);

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;


/***/ }),
/* 539 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePropertyOf = __webpack_require__(540);

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

module.exports = deburrLetter;


/***/ }),
/* 540 */
/***/ ((module) => {

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;


/***/ }),
/* 541 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var asciiWords = __webpack_require__(542),
    hasUnicodeWord = __webpack_require__(543),
    toString = __webpack_require__(306),
    unicodeWords = __webpack_require__(544);

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = words;


/***/ }),
/* 542 */
/***/ ((module) => {

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

module.exports = asciiWords;


/***/ }),
/* 543 */
/***/ ((module) => {

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

module.exports = hasUnicodeWord;


/***/ }),
/* 544 */
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

module.exports = unicodeWords;


/***/ }),
/* 545 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var capitalize = __webpack_require__(363),
    createCompounder = __webpack_require__(536);

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

module.exports = camelCase;


/***/ }),
/* 546 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(312),
    baseForOwn = __webpack_require__(497),
    baseIteratee = __webpack_require__(500);

/**
 * The opposite of `_.mapValues`; this method creates an object with the
 * same values as `object` and keys generated by running each own enumerable
 * string keyed property of `object` thru `iteratee`. The iteratee is invoked
 * with three arguments: (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapValues
 * @example
 *
 * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
 *   return key + value;
 * });
 * // => { 'a1': 1, 'b2': 2 }
 */
function mapKeys(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, iteratee(value, key, object), value);
  });
  return result;
}

module.exports = mapKeys;


/***/ }),
/* 547 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = sortFields;

var _has = _interopRequireDefault(__webpack_require__(417));

var _toposort = _interopRequireDefault(__webpack_require__(548));

var _propertyExpr = __webpack_require__(522);

var _Reference = _interopRequireDefault(__webpack_require__(521));

var _isSchema = _interopRequireDefault(__webpack_require__(489));

function sortFields(fields, excludes) {
  if (excludes === void 0) {
    excludes = [];
  }

  var edges = [],
      nodes = [];

  function addNode(depPath, key) {
    var node = (0, _propertyExpr.split)(depPath)[0];
    if (!~nodes.indexOf(node)) nodes.push(node);
    if (!~excludes.indexOf(key + "-" + node)) edges.push([key, node]);
  }

  for (var key in fields) {
    if ((0, _has.default)(fields, key)) {
      var value = fields[key];
      if (!~nodes.indexOf(key)) nodes.push(key);
      if (_Reference.default.isRef(value) && value.isSibling) addNode(value.path, key);else if ((0, _isSchema.default)(value) && value._deps) value._deps.forEach(function (path) {
        return addNode(path, key);
      });
    }
  }

  return _toposort.default.array(nodes, edges).reverse();
}

module.exports = exports["default"];

/***/ }),
/* 548 */
/***/ ((module) => {


/**
 * Topological sorting function
 *
 * @param {Array} edges
 * @returns {Array}
 */

module.exports = function(edges) {
  return toposort(uniqueNodes(edges), edges)
}

module.exports.array = toposort

function toposort(nodes, edges) {
  var cursor = nodes.length
    , sorted = new Array(cursor)
    , visited = {}
    , i = cursor
    // Better data structures make algorithm much faster.
    , outgoingEdges = makeOutgoingEdges(edges)
    , nodesHash = makeNodesHash(nodes)

  // check for unknown nodes
  edges.forEach(function(edge) {
    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
      throw new Error('Unknown node. There is an unknown node in the supplied edges.')
    }
  })

  while (i--) {
    if (!visited[i]) visit(nodes[i], i, new Set())
  }

  return sorted

  function visit(node, i, predecessors) {
    if(predecessors.has(node)) {
      var nodeRep
      try {
        nodeRep = ", node was:" + JSON.stringify(node)
      } catch(e) {
        nodeRep = ""
      }
      throw new Error('Cyclic dependency' + nodeRep)
    }

    if (!nodesHash.has(node)) {
      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: '+JSON.stringify(node))
    }

    if (visited[i]) return;
    visited[i] = true

    var outgoing = outgoingEdges.get(node) || new Set()
    outgoing = Array.from(outgoing)

    if (i = outgoing.length) {
      predecessors.add(node)
      do {
        var child = outgoing[--i]
        visit(child, nodesHash.get(child), predecessors)
      } while (i)
      predecessors.delete(node)
    }

    sorted[--cursor] = node
  }
}

function uniqueNodes(arr){
  var res = new Set()
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i]
    res.add(edge[0])
    res.add(edge[1])
  }
  return Array.from(res)
}

function makeOutgoingEdges(arr){
  var edges = new Map()
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i]
    if (!edges.has(edge[0])) edges.set(edge[0], new Set())
    if (!edges.has(edge[1])) edges.set(edge[1], new Set())
    edges.get(edge[0]).add(edge[1])
  }
  return edges
}

function makeNodesHash(arr){
  var res = new Map()
  for (var i = 0, len = arr.length; i < len; i++) {
    res.set(arr[i], i)
  }
  return res
}


/***/ }),
/* 549 */
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = sortByKeyOrder;

function findIndex(arr, err) {
  var idx = Infinity;
  arr.some(function (key, ii) {
    if (err.path.indexOf(key) !== -1) {
      idx = ii;
      return true;
    }
  });
  return idx;
}

function sortByKeyOrder(fields) {
  var keys = Object.keys(fields);
  return function (a, b) {
    return findIndex(keys, a) - findIndex(keys, b);
  };
}

module.exports = exports["default"];

/***/ }),
/* 550 */
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = makePath;

function makePath(strings) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }

  var path = strings.reduce(function (str, next) {
    var value = values.shift();
    return str + (value == null ? '' : value) + next;
  });
  return path.replace(/^\./, '');
}

module.exports = exports["default"];

/***/ }),
/* 551 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = __webpack_require__(532);

var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(416));

var _taggedTemplateLiteralLoose2 = _interopRequireDefault(__webpack_require__(534));

var _inherits = _interopRequireDefault(__webpack_require__(525));

var _isAbsent = _interopRequireDefault(__webpack_require__(527));

var _isSchema = _interopRequireDefault(__webpack_require__(489));

var _makePath = _interopRequireDefault(__webpack_require__(550));

var _printValue = _interopRequireDefault(__webpack_require__(487));

var _mixed = _interopRequireDefault(__webpack_require__(415));

var _locale = __webpack_require__(486);

var _runValidations = _interopRequireWildcard(__webpack_require__(490));

function _templateObject() {
  var data = (0, _taggedTemplateLiteralLoose2.default)(["", "[", "]"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var _default = ArraySchema;
exports.default = _default;

function ArraySchema(type) {
  var _this = this;

  if (!(this instanceof ArraySchema)) return new ArraySchema(type);

  _mixed.default.call(this, {
    type: 'array'
  }); // `undefined` specifically means uninitialized, as opposed to
  // "no subtype"


  this._subType = undefined;
  this.withMutation(function () {
    _this.transform(function (values) {
      if (typeof values === 'string') try {
        values = JSON.parse(values);
      } catch (err) {
        values = null;
      }
      return this.isType(values) ? values : null;
    });

    if (type) _this.of(type);
  });
}

(0, _inherits.default)(ArraySchema, _mixed.default, {
  _typeCheck: function _typeCheck(v) {
    return Array.isArray(v);
  },
  _cast: function _cast(_value, _opts) {
    var _this2 = this;

    var value = _mixed.default.prototype._cast.call(this, _value, _opts); //should ignore nulls here


    if (!this._typeCheck(value) || !this._subType) return value;
    var isChanged = false;
    var castArray = value.map(function (v) {
      var castElement = _this2._subType.cast(v, _opts);

      if (castElement !== v) {
        isChanged = true;
      }

      return castElement;
    });
    return isChanged ? castArray : value;
  },
  _validate: function _validate(_value, options) {
    var _this3 = this;

    if (options === void 0) {
      options = {};
    }

    var errors = [];
    var sync = options.sync;
    var path = options.path;
    var subType = this._subType;

    var endEarly = this._option('abortEarly', options);

    var recursive = this._option('recursive', options);

    var originalValue = options.originalValue != null ? options.originalValue : _value;
    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {
      if (!recursive || !subType || !_this3._typeCheck(value)) {
        if (errors.length) throw errors[0];
        return value;
      }

      originalValue = originalValue || value;
      var validations = value.map(function (item, idx) {
        var path = (0, _makePath.default)(_templateObject(), options.path, idx); // object._validate note for isStrict explanation

        var innerOptions = (0, _extends2.default)({}, options, {
          path: path,
          strict: true,
          parent: value,
          originalValue: originalValue[idx]
        });
        if (subType.validate) return subType.validate(item, innerOptions);
        return true;
      });
      return (0, _runValidations.default)({
        sync: sync,
        path: path,
        value: value,
        errors: errors,
        endEarly: endEarly,
        validations: validations
      });
    });
  },
  _isPresent: function _isPresent(value) {
    return _mixed.default.prototype._cast.call(this, value) && value.length > 0;
  },
  of: function of(schema) {
    var next = this.clone();
    if (schema !== false && !(0, _isSchema.default)(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema, or `false` to negate a current sub-schema. ' + 'not: ' + (0, _printValue.default)(schema));
    next._subType = schema;
    return next;
  },
  min: function min(_min, message) {
    message = message || _locale.array.min;
    return this.test({
      message: message,
      name: 'min',
      exclusive: true,
      params: {
        min: _min
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value.length >= this.resolve(_min);
      }
    });
  },
  max: function max(_max, message) {
    message = message || _locale.array.max;
    return this.test({
      message: message,
      name: 'max',
      exclusive: true,
      params: {
        max: _max
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value.length <= this.resolve(_max);
      }
    });
  },
  ensure: function ensure() {
    var _this4 = this;

    return this.default(function () {
      return [];
    }).transform(function (val) {
      if (_this4.isType(val)) return val;
      return val === null ? [] : [].concat(val);
    });
  },
  compact: function compact(rejector) {
    var reject = !rejector ? function (v) {
      return !!v;
    } : function (v, i, a) {
      return !rejector(v, i, a);
    };
    return this.transform(function (values) {
      return values != null ? values.filter(reject) : values;
    });
  },
  describe: function describe() {
    var base = _mixed.default.prototype.describe.call(this);

    if (this._subType) base.innerType = this._subType.describe();
    return base;
  }
});
module.exports = exports["default"];

/***/ }),
/* 552 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = void 0;

var _isSchema = _interopRequireDefault(__webpack_require__(489));

var Lazy =
/*#__PURE__*/
function () {
  function Lazy(mapFn) {
    this._resolve = function (value, options) {
      var schema = mapFn(value, options);
      if (!(0, _isSchema.default)(schema)) throw new TypeError('lazy() functions must return a valid schema');
      return schema.resolve(options);
    };
  }

  var _proto = Lazy.prototype;

  _proto.resolve = function resolve(options) {
    return this._resolve(options.value, options);
  };

  _proto.cast = function cast(value, options) {
    return this._resolve(value, options).cast(value, options);
  };

  _proto.validate = function validate(value, options) {
    return this._resolve(value, options).validate(value, options);
  };

  _proto.validateSync = function validateSync(value, options) {
    return this._resolve(value, options).validateSync(value, options);
  };

  _proto.validateAt = function validateAt(path, value, options) {
    return this._resolve(value, options).validateAt(path, value, options);
  };

  _proto.validateSyncAt = function validateSyncAt(path, value, options) {
    return this._resolve(value, options).validateSyncAt(path, value, options);
  };

  return Lazy;
}();

Lazy.prototype.__isYupSchema__ = true;
var _default = Lazy;
exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 553 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(414);

exports.__esModule = true;
exports.default = setLocale;

var _locale = _interopRequireDefault(__webpack_require__(486));

function setLocale(custom) {
  Object.keys(custom).forEach(function (type) {
    Object.keys(custom[type]).forEach(function (method) {
      _locale.default[type][method] = custom[type][method];
    });
  });
}

module.exports = exports["default"];

/***/ }),
/* 554 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dedupeUtils": () => /* reexport module object */ _suggestUtils__WEBPACK_IMPORTED_MODULE_32__,
/* harmony export */   "suggestUtils": () => /* reexport module object */ _suggestUtils__WEBPACK_IMPORTED_MODULE_32__,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(181);
/* harmony import */ var _commands_add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(555);
/* harmony import */ var _commands_bin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(601);
/* harmony import */ var _commands_cache_clean__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(602);
/* harmony import */ var _commands_config_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(603);
/* harmony import */ var _commands_config_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(604);
/* harmony import */ var _commands_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(607);
/* harmony import */ var _commands_dedupe__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(608);
/* harmony import */ var _commands_entries_clipanion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(610);
/* harmony import */ var _commands_entries_help__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(612);
/* harmony import */ var _commands_entries_run__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(613);
/* harmony import */ var _commands_entries_version__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(614);
/* harmony import */ var _commands_exec__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(615);
/* harmony import */ var _commands_info__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(616);
/* harmony import */ var _commands_install__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(617);
/* harmony import */ var _commands_link__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(618);
/* harmony import */ var _commands_node__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(619);
/* harmony import */ var _commands_plugin_import_sources__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(620);
/* harmony import */ var _commands_plugin_import__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(623);
/* harmony import */ var _commands_plugin_list__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(625);
/* harmony import */ var _commands_plugin_remove__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(626);
/* harmony import */ var _commands_plugin_runtime__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(627);
/* harmony import */ var _commands_rebuild__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(628);
/* harmony import */ var _commands_remove__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(629);
/* harmony import */ var _commands_runIndex__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(630);
/* harmony import */ var _commands_run__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(631);
/* harmony import */ var _commands_set_resolution__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(632);
/* harmony import */ var _commands_set_version_sources__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(621);
/* harmony import */ var _commands_set_version__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(622);
/* harmony import */ var _commands_up__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(633);
/* harmony import */ var _commands_why__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(634);
/* harmony import */ var _commands_workspaces_list__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(635);
/* harmony import */ var _commands_workspace__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(636);
/* harmony import */ var _suggestUtils__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(600);




































const plugin = {
  configuration: {
    enableImmutableInstalls: {
      description: `If true, prevents the install command from modifying the lockfile`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_33__.SettingsType.BOOLEAN,
      default: false
    },
    defaultSemverRangePrefix: {
      description: `The default save prefix: '^', '~' or ''`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_33__.SettingsType.STRING,
      values: [`^`, `~`, ``],
      default: _suggestUtils__WEBPACK_IMPORTED_MODULE_32__.Modifier.CARET
    }
  },
  commands: [_commands_cache_clean__WEBPACK_IMPORTED_MODULE_2__.default, _commands_config_get__WEBPACK_IMPORTED_MODULE_3__.default, _commands_config_set__WEBPACK_IMPORTED_MODULE_4__.default, _commands_set_resolution__WEBPACK_IMPORTED_MODULE_25__.default, _commands_set_version_sources__WEBPACK_IMPORTED_MODULE_26__.default, _commands_set_version__WEBPACK_IMPORTED_MODULE_27__.default, _commands_workspaces_list__WEBPACK_IMPORTED_MODULE_30__.default, _commands_entries_clipanion__WEBPACK_IMPORTED_MODULE_7__.default, _commands_entries_help__WEBPACK_IMPORTED_MODULE_8__.default, _commands_entries_run__WEBPACK_IMPORTED_MODULE_9__.default, _commands_entries_version__WEBPACK_IMPORTED_MODULE_10__.default, _commands_add__WEBPACK_IMPORTED_MODULE_0__.default, _commands_bin__WEBPACK_IMPORTED_MODULE_1__.default, _commands_config__WEBPACK_IMPORTED_MODULE_5__.default, _commands_dedupe__WEBPACK_IMPORTED_MODULE_6__.default, _commands_exec__WEBPACK_IMPORTED_MODULE_11__.default, _commands_info__WEBPACK_IMPORTED_MODULE_12__.default, _commands_install__WEBPACK_IMPORTED_MODULE_13__.default, _commands_link__WEBPACK_IMPORTED_MODULE_14__.default, _commands_node__WEBPACK_IMPORTED_MODULE_15__.default, _commands_plugin_import_sources__WEBPACK_IMPORTED_MODULE_16__.default, _commands_plugin_import__WEBPACK_IMPORTED_MODULE_17__.default, _commands_plugin_remove__WEBPACK_IMPORTED_MODULE_19__.default, _commands_plugin_list__WEBPACK_IMPORTED_MODULE_18__.default, _commands_plugin_runtime__WEBPACK_IMPORTED_MODULE_20__.default, _commands_rebuild__WEBPACK_IMPORTED_MODULE_21__.default, _commands_remove__WEBPACK_IMPORTED_MODULE_22__.default, _commands_runIndex__WEBPACK_IMPORTED_MODULE_23__.default, _commands_run__WEBPACK_IMPORTED_MODULE_24__.default, _commands_up__WEBPACK_IMPORTED_MODULE_28__.default, _commands_why__WEBPACK_IMPORTED_MODULE_29__.default, _commands_workspace__WEBPACK_IMPORTED_MODULE_31__.default]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 555 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ AddCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(379);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(556);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(enquirer__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _suggestUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(600);







 // eslint-disable-next-line arca/no-default-export

class AddCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.packages = [];
    this.json = false;
    this.exact = false;
    this.tilde = false;
    this.caret = false;
    this.dev = false;
    this.peer = false;
    this.optional = false;
    this.preferDev = false;
    this.interactive = null;
    this.cached = false;
  }

  async execute() {
    var _a;

    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    await project.restoreInstallState({
      restoreResolutions: false
    });
    const interactive = (_a = this.interactive) !== null && _a !== void 0 ? _a : configuration.get(`preferInteractive`);
    const modifier = _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.getModifier(this, project);
    const strategies = [...(interactive ? [_suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Strategy.REUSE] : []), _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Strategy.PROJECT, ...(this.cached ? [_suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Strategy.CACHE] : []), _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Strategy.LATEST];
    const maxResults = interactive ? Infinity : 1;
    const allSuggestions = await Promise.all(this.packages.map(async pseudoDescriptor => {
      const request = pseudoDescriptor.match(/^\.{0,2}\//) ? await _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.extractDescriptorFromPath(pseudoDescriptor, {
        cwd: this.context.cwd,
        workspace
      }) : _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.parseDescriptor(pseudoDescriptor);
      const target = suggestTarget(workspace, request, {
        dev: this.dev,
        peer: this.peer,
        preferDev: this.preferDev,
        optional: this.optional
      });
      const suggestions = await _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.getSuggestedDescriptors(request, {
        project,
        workspace,
        cache,
        target,
        modifier,
        strategies,
        maxResults
      });
      return [request, suggestions, target];
    }));
    const checkReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LightReport.start({
      configuration,
      stdout: this.context.stdout,
      suggestInstall: false
    }, async report => {
      for (const [request, {
        suggestions,
        rejections
      }] of allSuggestions) {
        const nonNullSuggestions = suggestions.filter(suggestion => {
          return suggestion.descriptor !== null;
        });

        if (nonNullSuggestions.length === 0) {
          const [firstError] = rejections;
          if (typeof firstError === `undefined`) throw new Error(`Assertion failed: Expected an error to have been set`);
          const prettyError = this.cli.error(firstError);

          if (!project.configuration.get(`enableNetwork`)) {
            report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.CANT_SUGGEST_RESOLUTIONS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.prettyDescriptor(configuration, request)} can't be resolved to a satisfying range (note: network resolution has been disabled):\n\n${prettyError}`);
          } else {
            report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.CANT_SUGGEST_RESOLUTIONS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.prettyDescriptor(configuration, request)} can't be resolved to a satisfying range:\n\n${prettyError}`);
          }
        }
      }
    });
    if (checkReport.hasErrors()) return checkReport.exitCode();
    let askedQuestions = false;
    const afterWorkspaceDependencyAdditionList = [];
    const afterWorkspaceDependencyReplacementList = [];

    for (const [,
    /*request*/
    {
      suggestions
    }, target] of allSuggestions) {
      let selected;
      const nonNullSuggestions = suggestions.filter(suggestion => {
        return suggestion.descriptor !== null;
      });
      const firstSuggestedDescriptor = nonNullSuggestions[0].descriptor;
      const areAllTheSame = nonNullSuggestions.every(suggestion => _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.areDescriptorsEqual(suggestion.descriptor, firstSuggestedDescriptor));

      if (nonNullSuggestions.length === 1 || areAllTheSame) {
        selected = firstSuggestedDescriptor;
      } else {
        askedQuestions = true;
        ({
          answer: selected
        } = await (0,enquirer__WEBPACK_IMPORTED_MODULE_2__.prompt)({
          type: `select`,
          name: `answer`,
          message: `Which range do you want to use?`,
          choices: suggestions.map(({
            descriptor,
            name,
            reason
          }) => descriptor ? {
            name,
            hint: reason,
            descriptor
          } : {
            name,
            hint: reason,
            disabled: true
          }),
          onCancel: () => process.exit(130),

          result(name) {
            // @ts-expect-error: The enquirer types don't include find
            return this.find(name, `descriptor`);
          },

          stdin: this.context.stdin,
          stdout: this.context.stdout
        }));
      }

      const current = workspace.manifest[target].get(selected.identHash);

      if (typeof current === `undefined` || current.descriptorHash !== selected.descriptorHash) {
        workspace.manifest[target].set(selected.identHash, selected);

        if (this.optional) {
          if (target === `dependencies`) {
            workspace.manifest.ensureDependencyMeta({ ...selected,
              range: `unknown`
            }).optional = true;
          } else if (target === `peerDependencies`) {
            workspace.manifest.ensurePeerDependencyMeta({ ...selected,
              range: `unknown`
            }).optional = true;
          }
        }

        if (typeof current === `undefined`) {
          afterWorkspaceDependencyAdditionList.push([workspace, target, selected, strategies]);
        } else {
          afterWorkspaceDependencyReplacementList.push([workspace, target, current, selected]);
        }
      }
    }

    await configuration.triggerMultipleHooks(hooks => hooks.afterWorkspaceDependencyAddition, afterWorkspaceDependencyAdditionList);
    await configuration.triggerMultipleHooks(hooks => hooks.afterWorkspaceDependencyReplacement, afterWorkspaceDependencyReplacementList);
    if (askedQuestions) this.context.stdout.write(`\n`);
    const installReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout,
      includeLogs: !this.context.quiet
    }, async report => {
      await project.install({
        cache,
        report
      });
    });
    return installReport.exitCode();
  }

}
AddCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `add dependencies to the project`,
  details: `
      This command adds a package to the package.json for the nearest workspace.

      - If it didn't exist before, the package will by default be added to the regular \`dependencies\` field, but this behavior can be overriden thanks to the \`-D,--dev\` flag (which will cause the dependency to be added to the \`devDependencies\` field instead) and the \`-P,--peer\` flag (which will do the same but for \`peerDependencies\`).

      - If the package was already listed in your dependencies, it will by default be upgraded whether it's part of your \`dependencies\` or \`devDependencies\` (it won't ever update \`peerDependencies\`, though).

      - If set, the \`--prefer-dev\` flag will operate as a more flexible \`-D,--dev\` in that it will add the package to your \`devDependencies\` if it isn't already listed in either \`dependencies\` or \`devDependencies\`, but it will also happily upgrade your \`dependencies\` if that's what you already use (whereas \`-D,--dev\` would throw an exception).

      - If set, the \`-O,--optional\` flag will add the package to the \`optionalDependencies\` field and, in combination with the \`-P,--peer\` flag, it will add the package as an optional peer dependency. If the package was already listed in your \`dependencies\`, it will be upgraded to \`optionalDependencies\`. If the package was already listed in your \`peerDependencies\`, in combination with the \`-P,--peer\` flag, it will be upgraded to an optional peer dependency: \`"peerDependenciesMeta": { "<package>": { "optional": true } }\`

      - If the added package doesn't specify a range at all its \`latest\` tag will be resolved and the returned version will be used to generate a new semver range (using the \`^\` modifier by default unless otherwise configured via the \`defaultSemverRangePrefix\` configuration, or the \`~\` modifier if \`-T,--tilde\` is specified, or no modifier at all if \`-E,--exact\` is specified). Two exceptions to this rule: the first one is that if the package is a workspace then its local version will be used, and the second one is that if you use \`-P,--peer\` the default range will be \`*\` and won't be resolved at all.

      - If the added package specifies a range (such as \`^1.0.0\`, \`latest\`, or \`rc\`), Yarn will add this range as-is in the resulting package.json entry (in particular, tags such as \`rc\` will be encoded as-is rather than being converted into a semver range).

      If the \`--cached\` option is used, Yarn will preferably reuse the highest version already used somewhere within the project, even if through a transitive dependency.

      If the \`-i,--interactive\` option is used (or if the \`preferInteractive\` settings is toggled on) the command will first try to check whether other workspaces in the project use the specified package and, if so, will offer to reuse them.

      For a compilation of all the supported protocols, please consult the dedicated page from our website: https://yarnpkg.com/features/protocols.
    `,
  examples: [[`Add a regular package to the current workspace`, `$0 add lodash`], [`Add a specific version for a package to the current workspace`, `$0 add lodash@1.2.3`], [`Add a package from a GitHub repository (the master branch) to the current workspace using a URL`, `$0 add lodash@https://github.com/lodash/lodash`], [`Add a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol`, `$0 add lodash@github:lodash/lodash`], [`Add a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol (shorthand)`, `$0 add lodash@lodash/lodash`], [`Add a package from a specific branch of a GitHub repository to the current workspace using the GitHub protocol (shorthand)`, `$0 add lodash-es@lodash/lodash#es`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Rest()], AddCommand.prototype, "packages", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], AddCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-E,--exact`, {
  description: `Don't use any semver modifier on the resolved range`
})], AddCommand.prototype, "exact", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-T,--tilde`, {
  description: `Use the \`~\` semver modifier on the resolved range`
})], AddCommand.prototype, "tilde", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-C,--caret`, {
  description: `Use the \`^\` semver modifier on the resolved range`
})], AddCommand.prototype, "caret", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-D,--dev`, {
  description: `Add a package as a dev dependency`
})], AddCommand.prototype, "dev", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-P,--peer`, {
  description: `Add a package as a peer dependency`
})], AddCommand.prototype, "peer", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-O,--optional`, {
  description: `Add / upgrade a package to an optional regular / peer dependency`
})], AddCommand.prototype, "optional", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--prefer-dev`, {
  description: `Add / upgrade a package to a dev dependency`
})], AddCommand.prototype, "preferDev", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-i,--interactive`, {
  description: `Reuse the specified package from other workspaces in the project`
})], AddCommand.prototype, "interactive", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--cached`, {
  description: `Reuse the highest version already used somewhere within the project`
})], AddCommand.prototype, "cached", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`add`)], AddCommand.prototype, "execute", null);

function suggestTarget(workspace, ident, {
  dev,
  peer,
  preferDev,
  optional
}) {
  const hasRegular = workspace.manifest[_suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.REGULAR].has(ident.identHash);
  const hasDev = workspace.manifest[_suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.DEVELOPMENT].has(ident.identHash);
  const hasPeer = workspace.manifest[_suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.PEER].has(ident.identHash);
  if ((dev || peer) && hasRegular) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Package "${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.prettyIdent(workspace.project.configuration, ident)}" is already listed as a regular dependency - remove the -D,-P flags or remove it from your dependencies first`);
  if (!dev && !peer && hasPeer) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Package "${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.prettyIdent(workspace.project.configuration, ident)}" is already listed as a peer dependency - use either of -D or -P, or remove it from your peer dependencies first`);
  if (optional && hasDev) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Package "${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.prettyIdent(workspace.project.configuration, ident)}" is already listed as a dev dependency - remove the -O flag or remove it from your dev dependencies first`);
  if (optional && !peer && hasPeer) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Package "${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.prettyIdent(workspace.project.configuration, ident)}" is already listed as a peer dependency - remove the -O flag or add the -P flag or remove it from your peer dependencies first`);
  if ((dev || preferDev) && optional) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Package "${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.prettyIdent(workspace.project.configuration, ident)}" cannot simultaneously be a dev dependency and an optional dependency`);
  if (peer) return _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.PEER;
  if (dev || preferDev) return _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.DEVELOPMENT;
  if (hasRegular) return _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.REGULAR;
  if (hasDev) return _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.DEVELOPMENT;
  return _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.REGULAR;
}

/***/ }),
/* 556 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const assert = __webpack_require__(246);
const Events = __webpack_require__(119);
const utils = __webpack_require__(557);

/**
 * Create an instance of `Enquirer`.
 *
 * ```js
 * const Enquirer = require('enquirer');
 * const enquirer = new Enquirer();
 * ```
 * @name Enquirer
 * @param {Object} `options` (optional) Options to use with all prompts.
 * @param {Object} `answers` (optional) Answers object to initialize with.
 * @api public
 */

class Enquirer extends Events {
  constructor(options, answers) {
    super();
    this.options = utils.merge({}, options);
    this.answers = { ...answers };
  }

  /**
   * Register a custom prompt type.
   *
   * ```js
   * const Enquirer = require('enquirer');
   * const enquirer = new Enquirer();
   * enquirer.register('customType', require('./custom-prompt'));
   * ```
   * @name register()
   * @param {String} `type`
   * @param {Function|Prompt} `fn` `Prompt` class, or a function that returns a `Prompt` class.
   * @return {Object} Returns the Enquirer instance
   * @api public
   */

  register(type, fn) {
    if (utils.isObject(type)) {
      for (let key of Object.keys(type)) this.register(key, type[key]);
      return this;
    }
    assert.equal(typeof fn, 'function', 'expected a function');
    let name = type.toLowerCase();
    if (fn.prototype instanceof this.Prompt) {
      this.prompts[name] = fn;
    } else {
      this.prompts[name] = fn(this.Prompt, this);
    }
    return this;
  }

  /**
   * Prompt function that takes a "question" object or array of question objects,
   * and returns an object with responses from the user.
   *
   * ```js
   * const Enquirer = require('enquirer');
   * const enquirer = new Enquirer();
   *
   * const response = await enquirer.prompt({
   *   type: 'input',
   *   name: 'username',
   *   message: 'What is your username?'
   * });
   * console.log(response);
   * ```
   * @name prompt()
   * @param {Array|Object} `questions` Options objects for one or more prompts to run.
   * @return {Promise} Promise that returns an "answers" object with the user's responses.
   * @api public
   */

  async prompt(questions = []) {
    for (let question of [].concat(questions)) {
      try {
        if (typeof question === 'function') question = await question.call(this);
        await this.ask(utils.merge({}, this.options, question));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    return this.answers;
  }

  async ask(question) {
    if (typeof question === 'function') {
      question = await question.call(this);
    }

    let opts = utils.merge({}, this.options, question);
    let { type, name } = question;
    let { set, get } = utils;

    if (typeof type === 'function') {
      type = await type.call(this, question, this.answers);
    }

    if (!type) return this.answers[name];

    assert(this.prompts[type], `Prompt "${type}" is not registered`);

    let prompt = new this.prompts[type](opts);
    let value = get(this.answers, name);

    prompt.state.answers = this.answers;
    prompt.enquirer = this;

    if (name) {
      prompt.on('submit', value => {
        this.emit('answer', name, value, prompt);
        set(this.answers, name, value);
      });
    }

    // bubble events
    let emit = prompt.emit.bind(prompt);
    prompt.emit = (...args) => {
      this.emit.call(this, ...args);
      return emit(...args);
    };

    this.emit('prompt', prompt, this);

    if (opts.autofill && value != null) {
      prompt.value = prompt.input = value;

      // if "autofill=show" render the prompt, otherwise stay "silent"
      if (opts.autofill === 'show') {
        await prompt.submit();
      }
    } else {
      value = prompt.value = await prompt.run();
    }

    return value;
  }

  /**
   * Use an enquirer plugin.
   *
   * ```js
   * const Enquirer = require('enquirer');
   * const enquirer = new Enquirer();
   * const plugin = enquirer => {
   *   // do stuff to enquire instance
   * };
   * enquirer.use(plugin);
   * ```
   * @name use()
   * @param {Function} `plugin` Plugin function that takes an instance of Enquirer.
   * @return {Object} Returns the Enquirer instance.
   * @api public
   */

  use(plugin) {
    plugin.call(this, this);
    return this;
  }

  set Prompt(value) {
    this._Prompt = value;
  }
  get Prompt() {
    return this._Prompt || this.constructor.Prompt;
  }

  get prompts() {
    return this.constructor.prompts;
  }

  static set Prompt(value) {
    this._Prompt = value;
  }
  static get Prompt() {
    return this._Prompt || __webpack_require__(560);
  }

  static get prompts() {
    return __webpack_require__(570);
  }

  static get types() {
    return __webpack_require__(599);
  }

  /**
   * Prompt function that takes a "question" object or array of question objects,
   * and returns an object with responses from the user.
   *
   * ```js
   * const { prompt } = require('enquirer');
   * const response = await prompt({
   *   type: 'input',
   *   name: 'username',
   *   message: 'What is your username?'
   * });
   * console.log(response);
   * ```
   * @name Enquirer#prompt
   * @param {Array|Object} `questions` Options objects for one or more prompts to run.
   * @return {Promise} Promise that returns an "answers" object with the user's responses.
   * @api public
   */

  static get prompt() {
    const fn = (questions, ...rest) => {
      let enquirer = new this(...rest);
      let emit = enquirer.emit.bind(enquirer);
      enquirer.emit = (...args) => {
        fn.emit(...args);
        return emit(...args);
      };
      return enquirer.prompt(questions);
    };
    utils.mixinEmitter(fn, new Events());
    return fn;
  }
}

utils.mixinEmitter(Enquirer, new Events());
const prompts = Enquirer.prompts;

for (let name of Object.keys(prompts)) {
  let key = name.toLowerCase();

  let run = options => new prompts[name](options).run();
  Enquirer.prompt[key] = run;
  Enquirer[key] = run;

  if (!Enquirer[name]) {
    Reflect.defineProperty(Enquirer, name, { get: () => prompts[name] });
  }
}

const exp = name => {
  utils.defineExport(Enquirer, name, () => Enquirer.types[name]);
};

exp('ArrayPrompt');
exp('AuthPrompt');
exp('BooleanPrompt');
exp('NumberPrompt');
exp('StringPrompt');

module.exports = Enquirer;


/***/ }),
/* 557 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const toString = Object.prototype.toString;
const colors = __webpack_require__(558);
let called = false;
let fns = [];

const complements = {
  'yellow': 'blue',
  'cyan': 'red',
  'green': 'magenta',
  'black': 'white',
  'blue': 'yellow',
  'red': 'cyan',
  'magenta': 'green',
  'white': 'black'
};

exports.longest = (arr, prop) => {
  return arr.reduce((a, v) => Math.max(a, prop ? v[prop].length : v.length), 0);
};

exports.hasColor = str => !!str && colors.hasColor(str);

const isObject = exports.isObject = val => {
  return val !== null && typeof val === 'object' && !Array.isArray(val);
};

exports.nativeType = val => {
  return toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, '');
};

exports.isAsyncFn = val => {
  return exports.nativeType(val) === 'asyncfunction';
};

exports.isPrimitive = val => {
  return val != null && typeof val !== 'object' && typeof val !== 'function';
};

exports.resolve = (context, value, ...rest) => {
  if (typeof value === 'function') {
    return value.call(context, ...rest);
  }
  return value;
};

exports.scrollDown = (choices = []) => [...choices.slice(1), choices[0]];
exports.scrollUp = (choices = []) => [choices.pop(), ...choices];

exports.reorder = (arr = []) => {
  let res = arr.slice();
  res.sort((a, b) => {
    if (a.index > b.index) return 1;
    if (a.index < b.index) return -1;
    return 0;
  });
  return res;
};

exports.swap = (arr, index, pos) => {
  let len = arr.length;
  let idx = pos === len ? 0 : pos < 0 ? len - 1 : pos;
  let choice = arr[index];
  arr[index] = arr[idx];
  arr[idx] = choice;
};

exports.width = (stream, fallback = 80) => {
  let columns = (stream && stream.columns) ? stream.columns : fallback;
  if (stream && typeof stream.getWindowSize === 'function') {
    columns = stream.getWindowSize()[0];
  }
  if (process.platform === 'win32') {
    return columns - 1;
  }
  return columns;
};

exports.height = (stream, fallback = 20) => {
  let rows = (stream && stream.rows) ? stream.rows : fallback;
  if (stream && typeof stream.getWindowSize === 'function') {
    rows = stream.getWindowSize()[1];
  }
  return rows;
};

exports.wordWrap = (str, options = {}) => {
  if (!str) return str;

  if (typeof options === 'number') {
    options = { width: options };
  }

  let { indent = '', newline = ('\n' + indent), width = 80 } = options;
  let spaces = (newline + indent).match(/[^\S\n]/g) || [];
  width -= spaces.length;
  let source = `.{1,${width}}([\\s\\u200B]+|$)|[^\\s\\u200B]+?([\\s\\u200B]+|$)`;
  let output = str.trim();
  let regex = new RegExp(source, 'g');
  let lines = output.match(regex) || [];
  lines = lines.map(line => line.replace(/\n$/, ''));
  if (options.padEnd) lines = lines.map(line => line.padEnd(width, ' '));
  if (options.padStart) lines = lines.map(line => line.padStart(width, ' '));
  return indent + lines.join(newline);
};

exports.unmute = color => {
  let name = color.stack.find(n => colors.keys.color.includes(n));
  if (name) {
    return colors[name];
  }
  let bg = color.stack.find(n => n.slice(2) === 'bg');
  if (bg) {
    return colors[name.slice(2)];
  }
  return str => str;
};

exports.pascal = str => str ? str[0].toUpperCase() + str.slice(1) : '';

exports.inverse = color => {
  if (!color || !color.stack) return color;
  let name = color.stack.find(n => colors.keys.color.includes(n));
  if (name) {
    let col = colors['bg' + exports.pascal(name)];
    return col ? col.black : color;
  }
  let bg = color.stack.find(n => n.slice(0, 2) === 'bg');
  if (bg) {
    return colors[bg.slice(2).toLowerCase()] || color;
  }
  return colors.none;
};

exports.complement = color => {
  if (!color || !color.stack) return color;
  let name = color.stack.find(n => colors.keys.color.includes(n));
  let bg = color.stack.find(n => n.slice(0, 2) === 'bg');
  if (name && !bg) {
    return colors[complements[name] || name];
  }
  if (bg) {
    let lower = bg.slice(2).toLowerCase();
    let comp = complements[lower];
    if (!comp) return color;
    return colors['bg' + exports.pascal(comp)] || color;
  }
  return colors.none;
};

exports.meridiem = date => {
  let hours = date.getHours();
  let minutes = date.getMinutes();
  let ampm = hours >= 12 ? 'pm' : 'am';
  hours = hours % 12;
  let hrs = hours === 0 ? 12 : hours;
  let min = minutes < 10 ? '0' + minutes : minutes;
  return hrs + ':' + min + ' ' + ampm;
};

/**
 * Set a value on the given object.
 * @param {Object} obj
 * @param {String} prop
 * @param {any} value
 */

exports.set = (obj = {}, prop = '', val) => {
  return prop.split('.').reduce((acc, k, i, arr) => {
    let value = arr.length - 1 > i ? (acc[k] || {}) : val;
    if (!exports.isObject(value) && i < arr.length - 1) value = {};
    return (acc[k] = value);
  }, obj);
};

/**
 * Get a value from the given object.
 * @param {Object} obj
 * @param {String} prop
 */

exports.get = (obj = {}, prop = '', fallback) => {
  let value = obj[prop] == null
    ? prop.split('.').reduce((acc, k) => acc && acc[k], obj)
    : obj[prop];
  return value == null ? fallback : value;
};

exports.mixin = (target, b) => {
  if (!isObject(target)) return b;
  if (!isObject(b)) return target;
  for (let key of Object.keys(b)) {
    let desc = Object.getOwnPropertyDescriptor(b, key);
    if (desc.hasOwnProperty('value')) {
      if (target.hasOwnProperty(key) && isObject(desc.value)) {
        let existing = Object.getOwnPropertyDescriptor(target, key);
        if (isObject(existing.value)) {
          target[key] = exports.merge({}, target[key], b[key]);
        } else {
          Reflect.defineProperty(target, key, desc);
        }
      } else {
        Reflect.defineProperty(target, key, desc);
      }
    } else {
      Reflect.defineProperty(target, key, desc);
    }
  }
  return target;
};

exports.merge = (...args) => {
  let target = {};
  for (let ele of args) exports.mixin(target, ele);
  return target;
};

exports.mixinEmitter = (obj, emitter) => {
  let proto = emitter.constructor.prototype;
  for (let key of Object.keys(proto)) {
    let val = proto[key];
    if (typeof val === 'function') {
      exports.define(obj, key, val.bind(emitter));
    } else {
      exports.define(obj, key, val);
    }
  }
};

exports.onExit = callback => {
  const onExit = (quit, code) => {
    if (called) return;

    called = true;
    fns.forEach(fn => fn());

    if (quit === true) {
      process.exit(128 + code);
    }
  };

  if (fns.length === 0) {
    process.once('SIGTERM', onExit.bind(null, true, 15));
    process.once('SIGINT', onExit.bind(null, true, 2));
    process.once('exit', onExit);
  }

  fns.push(callback);
};

exports.define = (obj, key, value) => {
  Reflect.defineProperty(obj, key, { value });
};

exports.defineExport = (obj, key, fn) => {
  let custom;
  Reflect.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    set(val) {
      custom = val;
    },
    get() {
      return custom ? custom() : fn();
    }
  });
};


/***/ }),
/* 558 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
const identity = val => val;

/* eslint-disable no-control-regex */
// this is a modified version of https://github.com/chalk/ansi-regex (MIT License)
const ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;

const create = () => {
  const colors = { enabled: true, visible: true, styles: {}, keys: {} };

  if ('FORCE_COLOR' in process.env) {
    colors.enabled = process.env.FORCE_COLOR !== '0';
  }

  const ansi = style => {
    let open = style.open = `\u001b[${style.codes[0]}m`;
    let close = style.close = `\u001b[${style.codes[1]}m`;
    let regex = style.regex = new RegExp(`\\u001b\\[${style.codes[1]}m`, 'g');
    style.wrap = (input, newline) => {
      if (input.includes(close)) input = input.replace(regex, close + open);
      let output = open + input + close;
      // see https://github.com/chalk/chalk/pull/92, thanks to the
      // chalk contributors for this fix. However, we've confirmed that
      // this issue is also present in Windows terminals
      return newline ? output.replace(/\r*\n/g, `${close}$&${open}`) : output;
    };
    return style;
  };

  const wrap = (style, input, newline) => {
    return typeof style === 'function' ? style(input) : style.wrap(input, newline);
  };

  const style = (input, stack) => {
    if (input === '' || input == null) return '';
    if (colors.enabled === false) return input;
    if (colors.visible === false) return '';
    let str = '' + input;
    let nl = str.includes('\n');
    let n = stack.length;
    if (n > 0 && stack.includes('unstyle')) {
      stack = [...new Set(['unstyle', ...stack])].reverse();
    }
    while (n-- > 0) str = wrap(colors.styles[stack[n]], str, nl);
    return str;
  };

  const define = (name, codes, type) => {
    colors.styles[name] = ansi({ name, codes });
    let keys = colors.keys[type] || (colors.keys[type] = []);
    keys.push(name);

    Reflect.defineProperty(colors, name, {
      configurable: true,
      enumerable: true,
      set(value) {
        colors.alias(name, value);
      },
      get() {
        let color = input => style(input, color.stack);
        Reflect.setPrototypeOf(color, colors);
        color.stack = this.stack ? this.stack.concat(name) : [name];
        return color;
      }
    });
  };

  define('reset', [0, 0], 'modifier');
  define('bold', [1, 22], 'modifier');
  define('dim', [2, 22], 'modifier');
  define('italic', [3, 23], 'modifier');
  define('underline', [4, 24], 'modifier');
  define('inverse', [7, 27], 'modifier');
  define('hidden', [8, 28], 'modifier');
  define('strikethrough', [9, 29], 'modifier');

  define('black', [30, 39], 'color');
  define('red', [31, 39], 'color');
  define('green', [32, 39], 'color');
  define('yellow', [33, 39], 'color');
  define('blue', [34, 39], 'color');
  define('magenta', [35, 39], 'color');
  define('cyan', [36, 39], 'color');
  define('white', [37, 39], 'color');
  define('gray', [90, 39], 'color');
  define('grey', [90, 39], 'color');

  define('bgBlack', [40, 49], 'bg');
  define('bgRed', [41, 49], 'bg');
  define('bgGreen', [42, 49], 'bg');
  define('bgYellow', [43, 49], 'bg');
  define('bgBlue', [44, 49], 'bg');
  define('bgMagenta', [45, 49], 'bg');
  define('bgCyan', [46, 49], 'bg');
  define('bgWhite', [47, 49], 'bg');

  define('blackBright', [90, 39], 'bright');
  define('redBright', [91, 39], 'bright');
  define('greenBright', [92, 39], 'bright');
  define('yellowBright', [93, 39], 'bright');
  define('blueBright', [94, 39], 'bright');
  define('magentaBright', [95, 39], 'bright');
  define('cyanBright', [96, 39], 'bright');
  define('whiteBright', [97, 39], 'bright');

  define('bgBlackBright', [100, 49], 'bgBright');
  define('bgRedBright', [101, 49], 'bgBright');
  define('bgGreenBright', [102, 49], 'bgBright');
  define('bgYellowBright', [103, 49], 'bgBright');
  define('bgBlueBright', [104, 49], 'bgBright');
  define('bgMagentaBright', [105, 49], 'bgBright');
  define('bgCyanBright', [106, 49], 'bgBright');
  define('bgWhiteBright', [107, 49], 'bgBright');

  colors.ansiRegex = ANSI_REGEX;
  colors.hasColor = colors.hasAnsi = str => {
    colors.ansiRegex.lastIndex = 0;
    return typeof str === 'string' && str !== '' && colors.ansiRegex.test(str);
  };

  colors.alias = (name, color) => {
    let fn = typeof color === 'string' ? colors[color] : color;

    if (typeof fn !== 'function') {
      throw new TypeError('Expected alias to be the name of an existing color (string) or a function');
    }

    if (!fn.stack) {
      Reflect.defineProperty(fn, 'name', { value: name });
      colors.styles[name] = fn;
      fn.stack = [name];
    }

    Reflect.defineProperty(colors, name, {
      configurable: true,
      enumerable: true,
      set(value) {
        colors.alias(name, value);
      },
      get() {
        let color = input => style(input, color.stack);
        Reflect.setPrototypeOf(color, colors);
        color.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
        return color;
      }
    });
  };

  colors.theme = custom => {
    if (!isObject(custom)) throw new TypeError('Expected theme to be an object');
    for (let name of Object.keys(custom)) {
      colors.alias(name, custom[name]);
    }
    return colors;
  };

  colors.alias('unstyle', str => {
    if (typeof str === 'string' && str !== '') {
      colors.ansiRegex.lastIndex = 0;
      return str.replace(colors.ansiRegex, '');
    }
    return '';
  });

  colors.alias('noop', str => str);
  colors.none = colors.clear = colors.noop;

  colors.stripColor = colors.unstyle;
  colors.symbols = __webpack_require__(559);
  colors.define = define;
  return colors;
};

module.exports = create();
module.exports.create = create;


/***/ }),
/* 559 */
/***/ ((module) => {

"use strict";


const isHyper = process.env.TERM_PROGRAM === 'Hyper';
const isWindows = process.platform === 'win32';
const isLinux = process.platform === 'linux';

const common = {
  ballotDisabled: '',
  ballotOff: '',
  ballotOn: '',
  bullet: '',
  bulletWhite: '',
  fullBlock: '',
  heart: '',
  identicalTo: '',
  line: '',
  mark: '',
  middot: '',
  minus: '',
  multiplication: '',
  obelus: '',
  pencilDownRight: '',
  pencilRight: '',
  pencilUpRight: '',
  percent: '%',
  pilcrow2: '',
  pilcrow: '',
  plusMinus: '',
  section: '',
  starsOff: '',
  starsOn: '',
  upDownArrow: ''
};

const windows = Object.assign({}, common, {
  check: '',
  cross: '',
  ellipsisLarge: '...',
  ellipsis: '...',
  info: 'i',
  question: '?',
  questionSmall: '?',
  pointer: '>',
  pointerSmall: '',
  radioOff: '( )',
  radioOn: '(*)',
  warning: ''
});

const other = Object.assign({}, common, {
  ballotCross: '',
  check: '',
  cross: '',
  ellipsisLarge: '',
  ellipsis: '',
  info: '',
  question: '?',
  questionFull: '',
  questionSmall: '',
  pointer: isLinux ? '' : '',
  pointerSmall: isLinux ? '' : '',
  radioOff: '',
  radioOn: '',
  warning: ''
});

module.exports = (isWindows && !isHyper) ? windows : other;
Reflect.defineProperty(module.exports, 'common', { enumerable: false, value: common });
Reflect.defineProperty(module.exports, 'windows', { enumerable: false, value: windows });
Reflect.defineProperty(module.exports, 'other', { enumerable: false, value: other });


/***/ }),
/* 560 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Events = __webpack_require__(119);
const colors = __webpack_require__(558);
const keypress = __webpack_require__(561);
const timer = __webpack_require__(564);
const State = __webpack_require__(565);
const theme = __webpack_require__(566);
const utils = __webpack_require__(557);
const ansi = __webpack_require__(569);

/**
 * Base class for creating a new Prompt.
 * @param {Object} `options` Question object.
 */

class Prompt extends Events {
  constructor(options = {}) {
    super();
    this.name = options.name;
    this.type = options.type;
    this.options = options;
    theme(this);
    timer(this);
    this.state = new State(this);
    this.initial = [options.initial, options.default].find(v => v != null);
    this.stdout = options.stdout || process.stdout;
    this.stdin = options.stdin || process.stdin;
    this.scale = options.scale || 1;
    this.term = this.options.term || process.env.TERM_PROGRAM;
    this.margin = margin(this.options.margin);
    this.setMaxListeners(0);
    setOptions(this);
  }

  async keypress(input, event = {}) {
    this.keypressed = true;
    let key = keypress.action(input, keypress(input, event), this.options.actions);
    this.state.keypress = key;
    this.emit('keypress', input, key);
    this.emit('state', this.state.clone());
    let fn = this.options[key.action] || this[key.action] || this.dispatch;
    if (typeof fn === 'function') {
      return await fn.call(this, input, key);
    }
    this.alert();
  }

  alert() {
    delete this.state.alert;
    if (this.options.show === false) {
      this.emit('alert');
    } else {
      this.stdout.write(ansi.code.beep);
    }
  }

  cursorHide() {
    this.stdout.write(ansi.cursor.hide());
    utils.onExit(() => this.cursorShow());
  }

  cursorShow() {
    this.stdout.write(ansi.cursor.show());
  }

  write(str) {
    if (!str) return;
    if (this.stdout && this.state.show !== false) {
      this.stdout.write(str);
    }
    this.state.buffer += str;
  }

  clear(lines = 0) {
    let buffer = this.state.buffer;
    this.state.buffer = '';
    if ((!buffer && !lines) || this.options.show === false) return;
    this.stdout.write(ansi.cursor.down(lines) + ansi.clear(buffer, this.width));
  }

  restore() {
    if (this.state.closed || this.options.show === false) return;

    let { prompt, after, rest } = this.sections();
    let { cursor, initial = '', input = '', value = '' } = this;

    let size = this.state.size = rest.length;
    let state = { after, cursor, initial, input, prompt, size, value };
    let codes = ansi.cursor.restore(state);
    if (codes) {
      this.stdout.write(codes);
    }
  }

  sections() {
    let { buffer, input, prompt } = this.state;
    prompt = colors.unstyle(prompt);
    let buf = colors.unstyle(buffer);
    let idx = buf.indexOf(prompt);
    let header = buf.slice(0, idx);
    let rest = buf.slice(idx);
    let lines = rest.split('\n');
    let first = lines[0];
    let last = lines[lines.length - 1];
    let promptLine = prompt + (input ? ' ' + input : '');
    let len = promptLine.length;
    let after = len < first.length ? first.slice(len + 1) : '';
    return { header, prompt: first, after, rest: lines.slice(1), last };
  }

  async submit() {
    this.state.submitted = true;
    this.state.validating = true;

    // this will only be called when the prompt is directly submitted
    // without initializing, i.e. when the prompt is skipped, etc. Otherwize,
    // "options.onSubmit" is will be handled by the "initialize()" method.
    if (this.options.onSubmit) {
      await this.options.onSubmit.call(this, this.name, this.value, this);
    }

    let result = this.state.error || await this.validate(this.value, this.state);
    if (result !== true) {
      let error = '\n' + this.symbols.pointer + ' ';

      if (typeof result === 'string') {
        error += result.trim();
      } else {
        error += 'Invalid input';
      }

      this.state.error = '\n' + this.styles.danger(error);
      this.state.submitted = false;
      await this.render();
      await this.alert();
      this.state.validating = false;
      this.state.error = void 0;
      return;
    }

    this.state.validating = false;
    await this.render();
    await this.close();

    this.value = await this.result(this.value);
    this.emit('submit', this.value);
  }

  async cancel(err) {
    this.state.cancelled = this.state.submitted = true;

    await this.render();
    await this.close();

    if (typeof this.options.onCancel === 'function') {
      await this.options.onCancel.call(this, this.name, this.value, this);
    }

    this.emit('cancel', await this.error(err));
  }

  async close() {
    this.state.closed = true;

    try {
      let sections = this.sections();
      let lines = Math.ceil(sections.prompt.length / this.width);
      if (sections.rest) {
        this.write(ansi.cursor.down(sections.rest.length));
      }
      this.write('\n'.repeat(lines));
    } catch (err) { /* do nothing */ }

    this.emit('close');
  }

  start() {
    if (!this.stop && this.options.show !== false) {
      this.stop = keypress.listen(this, this.keypress.bind(this));
      this.once('close', this.stop);
    }
  }

  async skip() {
    this.skipped = this.options.skip === true;
    if (typeof this.options.skip === 'function') {
      this.skipped = await this.options.skip.call(this, this.name, this.value);
    }
    return this.skipped;
  }

  async initialize() {
    let { format, options, result } = this;

    this.format = () => format.call(this, this.value);
    this.result = () => result.call(this, this.value);

    if (typeof options.initial === 'function') {
      this.initial = await options.initial.call(this, this);
    }

    if (typeof options.onRun === 'function') {
      await options.onRun.call(this, this);
    }

    // if "options.onSubmit" is defined, we wrap the "submit" method to guarantee
    // that "onSubmit" will always called first thing inside the submit
    // method, regardless of how it's handled in inheriting prompts.
    if (typeof options.onSubmit === 'function') {
      let onSubmit = options.onSubmit.bind(this);
      let submit = this.submit.bind(this);
      delete this.options.onSubmit;
      this.submit = async() => {
        await onSubmit(this.name, this.value, this);
        return submit();
      };
    }

    await this.start();
    await this.render();
  }

  render() {
    throw new Error('expected prompt to have a custom render method');
  }

  run() {
    return new Promise(async(resolve, reject) => {
      this.once('submit', resolve);
      this.once('cancel', reject);
      if (await this.skip()) {
        this.render = () => {};
        return this.submit();
      }
      await this.initialize();
      this.emit('run');
    });
  }

  async element(name, choice, i) {
    let { options, state, symbols, timers } = this;
    let timer = timers && timers[name];
    state.timer = timer;
    let value = options[name] || state[name] || symbols[name];
    let val = choice && choice[name] != null ? choice[name] : await value;
    if (val === '') return val;

    let res = await this.resolve(val, state, choice, i);
    if (!res && choice && choice[name]) {
      return this.resolve(value, state, choice, i);
    }
    return res;
  }

  async prefix() {
    let element = await this.element('prefix') || this.symbols;
    let timer = this.timers && this.timers.prefix;
    let state = this.state;
    state.timer = timer;
    if (utils.isObject(element)) element = element[state.status] || element.pending;
    if (!utils.hasColor(element)) {
      let style = this.styles[state.status] || this.styles.pending;
      return style(element);
    }
    return element;
  }

  async message() {
    let message = await this.element('message');
    if (!utils.hasColor(message)) {
      return this.styles.strong(message);
    }
    return message;
  }

  async separator() {
    let element = await this.element('separator') || this.symbols;
    let timer = this.timers && this.timers.separator;
    let state = this.state;
    state.timer = timer;
    let value = element[state.status] || element.pending || state.separator;
    let ele = await this.resolve(value, state);
    if (utils.isObject(ele)) ele = ele[state.status] || ele.pending;
    if (!utils.hasColor(ele)) {
      return this.styles.muted(ele);
    }
    return ele;
  }

  async pointer(choice, i) {
    let val = await this.element('pointer', choice, i);

    if (typeof val === 'string' && utils.hasColor(val)) {
      return val;
    }

    if (val) {
      let styles = this.styles;
      let focused = this.index === i;
      let style = focused ? styles.primary : val => val;
      let ele = await this.resolve(val[focused ? 'on' : 'off'] || val, this.state);
      let styled = !utils.hasColor(ele) ? style(ele) : ele;
      return focused ? styled : ' '.repeat(ele.length);
    }
  }

  async indicator(choice, i) {
    let val = await this.element('indicator', choice, i);
    if (typeof val === 'string' && utils.hasColor(val)) {
      return val;
    }
    if (val) {
      let styles = this.styles;
      let enabled = choice.enabled === true;
      let style = enabled ? styles.success : styles.dark;
      let ele = val[enabled ? 'on' : 'off'] || val;
      return !utils.hasColor(ele) ? style(ele) : ele;
    }
    return '';
  }

  body() {
    return null;
  }

  footer() {
    if (this.state.status === 'pending') {
      return this.element('footer');
    }
  }

  header() {
    if (this.state.status === 'pending') {
      return this.element('header');
    }
  }

  async hint() {
    if (this.state.status === 'pending' && !this.isValue(this.state.input)) {
      let hint = await this.element('hint');
      if (!utils.hasColor(hint)) {
        return this.styles.muted(hint);
      }
      return hint;
    }
  }

  error(err) {
    return !this.state.submitted ? (err || this.state.error) : '';
  }

  format(value) {
    return value;
  }

  result(value) {
    return value;
  }

  validate(value) {
    if (this.options.required === true) {
      return this.isValue(value);
    }
    return true;
  }

  isValue(value) {
    return value != null && value !== '';
  }

  resolve(value, ...args) {
    return utils.resolve(this, value, ...args);
  }

  get base() {
    return Prompt.prototype;
  }

  get style() {
    return this.styles[this.state.status];
  }

  get height() {
    return this.options.rows || utils.height(this.stdout, 25);
  }
  get width() {
    return this.options.columns || utils.width(this.stdout, 80);
  }
  get size() {
    return { width: this.width, height: this.height };
  }

  set cursor(value) {
    this.state.cursor = value;
  }
  get cursor() {
    return this.state.cursor;
  }

  set input(value) {
    this.state.input = value;
  }
  get input() {
    return this.state.input;
  }

  set value(value) {
    this.state.value = value;
  }
  get value() {
    let { input, value } = this.state;
    let result = [value, input].find(this.isValue.bind(this));
    return this.isValue(result) ? result : this.initial;
  }

  static get prompt() {
    return options => new this(options).run();
  }
}

function setOptions(prompt) {
  let isValidKey = key => {
    return prompt[key] === void 0 || typeof prompt[key] === 'function';
  };

  let ignore = [
    'actions',
    'choices',
    'initial',
    'margin',
    'roles',
    'styles',
    'symbols',
    'theme',
    'timers',
    'value'
  ];

  let ignoreFn = [
    'body',
    'footer',
    'error',
    'header',
    'hint',
    'indicator',
    'message',
    'prefix',
    'separator',
    'skip'
  ];

  for (let key of Object.keys(prompt.options)) {
    if (ignore.includes(key)) continue;
    if (/^on[A-Z]/.test(key)) continue;
    let option = prompt.options[key];
    if (typeof option === 'function' && isValidKey(key)) {
      if (!ignoreFn.includes(key)) {
        prompt[key] = option.bind(prompt);
      }
    } else if (typeof prompt[key] !== 'function') {
      prompt[key] = option;
    }
  }
}

function margin(value) {
  if (typeof value === 'number') {
    value = [value, value, value, value];
  }
  let arr = [].concat(value || []);
  let pad = i => i % 2 === 0 ? '\n' : ' ';
  let res = [];
  for (let i = 0; i < 4; i++) {
    let char = pad(i);
    if (arr[i]) {
      res.push(char.repeat(arr[i]));
    } else {
      res.push('');
    }
  }
  return res;
}

module.exports = Prompt;


/***/ }),
/* 561 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const readline = __webpack_require__(562);
const combos = __webpack_require__(563);

/* eslint-disable no-control-regex */
const metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/;
const fnKeyRe = /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;
const keyName = {
    /* xterm/gnome ESC O letter */
    'OP': 'f1',
    'OQ': 'f2',
    'OR': 'f3',
    'OS': 'f4',
    /* xterm/rxvt ESC [ number ~ */
    '[11~': 'f1',
    '[12~': 'f2',
    '[13~': 'f3',
    '[14~': 'f4',
    /* from Cygwin and used in libuv */
    '[[A': 'f1',
    '[[B': 'f2',
    '[[C': 'f3',
    '[[D': 'f4',
    '[[E': 'f5',
    /* common */
    '[15~': 'f5',
    '[17~': 'f6',
    '[18~': 'f7',
    '[19~': 'f8',
    '[20~': 'f9',
    '[21~': 'f10',
    '[23~': 'f11',
    '[24~': 'f12',
    /* xterm ESC [ letter */
    '[A': 'up',
    '[B': 'down',
    '[C': 'right',
    '[D': 'left',
    '[E': 'clear',
    '[F': 'end',
    '[H': 'home',
    /* xterm/gnome ESC O letter */
    'OA': 'up',
    'OB': 'down',
    'OC': 'right',
    'OD': 'left',
    'OE': 'clear',
    'OF': 'end',
    'OH': 'home',
    /* xterm/rxvt ESC [ number ~ */
    '[1~': 'home',
    '[2~': 'insert',
    '[3~': 'delete',
    '[4~': 'end',
    '[5~': 'pageup',
    '[6~': 'pagedown',
    /* putty */
    '[[5~': 'pageup',
    '[[6~': 'pagedown',
    /* rxvt */
    '[7~': 'home',
    '[8~': 'end',
    /* rxvt keys with modifiers */
    '[a': 'up',
    '[b': 'down',
    '[c': 'right',
    '[d': 'left',
    '[e': 'clear',

    '[2$': 'insert',
    '[3$': 'delete',
    '[5$': 'pageup',
    '[6$': 'pagedown',
    '[7$': 'home',
    '[8$': 'end',

    'Oa': 'up',
    'Ob': 'down',
    'Oc': 'right',
    'Od': 'left',
    'Oe': 'clear',

    '[2^': 'insert',
    '[3^': 'delete',
    '[5^': 'pageup',
    '[6^': 'pagedown',
    '[7^': 'home',
    '[8^': 'end',
    /* misc. */
    '[Z': 'tab',
}

function isShiftKey(code) {
    return ['[a', '[b', '[c', '[d', '[e', '[2$', '[3$', '[5$', '[6$', '[7$', '[8$', '[Z'].includes(code)
}

function isCtrlKey(code) {
    return [ 'Oa', 'Ob', 'Oc', 'Od', 'Oe', '[2^', '[3^', '[5^', '[6^', '[7^', '[8^'].includes(code)
}

const keypress = (s = '', event = {}) => {
  let parts;
  let key = {
    name: event.name,
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    sequence: s,
    raw: s,
    ...event
  };

  if (Buffer.isBuffer(s)) {
    if (s[0] > 127 && s[1] === void 0) {
      s[0] -= 128;
      s = '\x1b' + String(s);
    } else {
      s = String(s);
    }
  } else if (s !== void 0 && typeof s !== 'string') {
    s = String(s);
  } else if (!s) {
    s = key.sequence || '';
  }

  key.sequence = key.sequence || s || key.name;

  if (s === '\r') {
    // carriage return
    key.raw = void 0;
    key.name = 'return';
  } else if (s === '\n') {
    // enter, should have been called linefeed
    key.name = 'enter';
  } else if (s === '\t') {
    // tab
    key.name = 'tab';
  } else if (s === '\b' || s === '\x7f' || s === '\x1b\x7f' || s === '\x1b\b') {
    // backspace or ctrl+h
    key.name = 'backspace';
    key.meta = s.charAt(0) === '\x1b';
  } else if (s === '\x1b' || s === '\x1b\x1b') {
    // escape key
    key.name = 'escape';
    key.meta = s.length === 2;
  } else if (s === ' ' || s === '\x1b ') {
    key.name = 'space';
    key.meta = s.length === 2;
  } else if (s <= '\x1a') {
    // ctrl+letter
    key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);
    key.ctrl = true;
  } else if (s.length === 1 && s >= '0' && s <= '9') {
    // number
    key.name = 'number';
  } else if (s.length === 1 && s >= 'a' && s <= 'z') {
    // lowercase letter
    key.name = s;
  } else if (s.length === 1 && s >= 'A' && s <= 'Z') {
    // shift+letter
    key.name = s.toLowerCase();
    key.shift = true;
  } else if ((parts = metaKeyCodeRe.exec(s))) {
    // meta+character key
    key.meta = true;
    key.shift = /^[A-Z]$/.test(parts[1]);
  } else if ((parts = fnKeyRe.exec(s))) {
    let segs = [...s];

    if (segs[0] === '\u001b' && segs[1] === '\u001b') {
      key.option = true;
    }

    // ansi escape sequence
    // reassemble the key code leaving out leading \x1b's,
    // the modifier key bitflag and any meaningless "1;" sequence
    let code = [parts[1], parts[2], parts[4], parts[6]].filter(Boolean).join('');
    let modifier = (parts[3] || parts[5] || 1) - 1;

    // Parse the key modifier
    key.ctrl = !!(modifier & 4);
    key.meta = !!(modifier & 10);
    key.shift = !!(modifier & 1);
    key.code = code;

    key.name = keyName[code];
    key.shift = isShiftKey(code) || key.shift;
    key.ctrl = isCtrlKey(code) || key.ctrl;
  }
  return key;
};

keypress.listen = (options = {}, onKeypress) => {
  let { stdin } = options;

  if (!stdin || (stdin !== process.stdin && !stdin.isTTY)) {
    throw new Error('Invalid stream passed');
  }

  let rl = readline.createInterface({ terminal: true, input: stdin });
  readline.emitKeypressEvents(stdin, rl);

  let on = (buf, key) => onKeypress(buf, keypress(buf, key), rl);
  let isRaw = stdin.isRaw;

  if (stdin.isTTY) stdin.setRawMode(true);
  stdin.on('keypress', on);
  rl.resume();

  let off = () => {
    if (stdin.isTTY) stdin.setRawMode(isRaw);
    stdin.removeListener('keypress', on);
    rl.pause();
    rl.close();
  };

  return off;
};

keypress.action = (buf, key, customActions) => {
  let obj = { ...combos, ...customActions };
  if (key.ctrl) {
    key.action = obj.ctrl[key.name];
    return key;
  }

  if (key.option && obj.option) {
    key.action = obj.option[key.name];
    return key;
  }

  if (key.shift) {
    key.action = obj.shift[key.name];
    return key;
  }

  key.action = obj.keys[key.name];
  return key;
};

module.exports = keypress;


/***/ }),
/* 562 */
/***/ ((module) => {

"use strict";
module.exports = require("readline");;

/***/ }),
/* 563 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Actions are mappings from keypress event names to method names
 * in the prompts.
 */

exports.ctrl = {
  a: 'first',
  b: 'backward',
  c: 'cancel',
  d: 'deleteForward',
  e: 'last',
  f: 'forward',
  g: 'reset',
  i: 'tab',
  k: 'cutForward',
  l: 'reset',
  n: 'newItem',
  m: 'cancel',
  j: 'submit',
  p: 'search',
  r: 'remove',
  s: 'save',
  u: 'undo',
  w: 'cutLeft',
  x: 'toggleCursor',
  v: 'paste'
};

exports.shift = {
  up: 'shiftUp',
  down: 'shiftDown',
  left: 'shiftLeft',
  right: 'shiftRight',
  tab: 'prev'
};

exports.fn = {
  up: 'pageUp',
  down: 'pageDown',
  left: 'pageLeft',
  right: 'pageRight',
  delete: 'deleteForward'
};

// <alt> on Windows
exports.option = {
  b: 'backward',
  f: 'forward',
  d: 'cutRight',
  left: 'cutLeft',
  up: 'altUp',
  down: 'altDown'
};

exports.keys = {
  pageup: 'pageUp', // <fn>+<up> (mac), <Page Up> (windows)
  pagedown: 'pageDown', // <fn>+<down> (mac), <Page Down> (windows)
  home: 'home', // <fn>+<left> (mac), <home> (windows)
  end: 'end', // <fn>+<right> (mac), <end> (windows)
  cancel: 'cancel',
  delete: 'deleteForward',
  backspace: 'delete',
  down: 'down',
  enter: 'submit',
  escape: 'cancel',
  left: 'left',
  space: 'space',
  number: 'number',
  return: 'submit',
  right: 'right',
  tab: 'next',
  up: 'up'
};


/***/ }),
/* 564 */
/***/ ((module) => {

"use strict";


module.exports = prompt => {
  prompt.timers = prompt.timers || {};

  let timers = prompt.options.timers;
  if (!timers) return;

  for (let key of Object.keys(timers)) {
    let opts = timers[key];
    if (typeof opts === 'number') {
      opts = { interval: opts };
    }
    create(prompt, key, opts);
  }
};

function create(prompt, name, options = {}) {
  let timer = prompt.timers[name] = { name, start: Date.now(), ms: 0, tick: 0 };
  let ms = options.interval || 120;
  timer.frames = options.frames || [];
  timer.loading = true;

  let interval = setInterval(() => {
    timer.ms = Date.now() - timer.start;
    timer.tick++;
    prompt.render();
  }, ms);

  timer.stop = () => {
    timer.loading = false;
    clearInterval(interval);
  };

  Reflect.defineProperty(timer, 'interval', { value: interval });
  prompt.once('close', () => timer.stop());
  return timer.stop;
}


/***/ }),
/* 565 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { define, width } = __webpack_require__(557);

class State {
  constructor(prompt) {
    let options = prompt.options;
    define(this, '_prompt', prompt);
    this.type = prompt.type;
    this.name = prompt.name;
    this.message = '';
    this.header = '';
    this.footer = '';
    this.error = '';
    this.hint = '';
    this.input = '';
    this.cursor = 0;
    this.index = 0;
    this.lines = 0;
    this.tick = 0;
    this.prompt = '';
    this.buffer = '';
    this.width = width(options.stdout || process.stdout);
    Object.assign(this, options);
    this.name = this.name || this.message;
    this.message = this.message || this.name;
    this.symbols = prompt.symbols;
    this.styles = prompt.styles;
    this.required = new Set();
    this.cancelled = false;
    this.submitted = false;
  }

  clone() {
    let state = { ...this };
    state.status = this.status;
    state.buffer = Buffer.from(state.buffer);
    delete state.clone;
    return state;
  }

  set color(val) {
    this._color = val;
  }
  get color() {
    let styles = this.prompt.styles;
    if (this.cancelled) return styles.cancelled;
    if (this.submitted) return styles.submitted;
    let color = this._color || styles[this.status];
    return typeof color === 'function' ? color : styles.pending;
  }

  set loading(value) {
    this._loading = value;
  }
  get loading() {
    if (typeof this._loading === 'boolean') return this._loading;
    if (this.loadingChoices) return 'choices';
    return false;
  }

  get status() {
    if (this.cancelled) return 'cancelled';
    if (this.submitted) return 'submitted';
    return 'pending';
  }
}

module.exports = State;


/***/ }),
/* 566 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const styles = __webpack_require__(567);
const symbols = __webpack_require__(568);
const utils = __webpack_require__(557);

module.exports = prompt => {
  prompt.options = utils.merge({}, prompt.options.theme, prompt.options);
  prompt.symbols = symbols.merge(prompt.options);
  prompt.styles = styles.merge(prompt.options);
};


/***/ }),
/* 567 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(557);
const colors = __webpack_require__(558);

const styles = {
  default: colors.noop,
  noop: colors.noop,

  /**
   * Modifiers
   */

  set inverse(custom) {
    this._inverse = custom;
  },
  get inverse() {
    return this._inverse || utils.inverse(this.primary);
  },

  set complement(custom) {
    this._complement = custom;
  },
  get complement() {
    return this._complement || utils.complement(this.primary);
  },

  /**
   * Main color
   */

  primary: colors.cyan,

  /**
   * Main palette
   */

  success: colors.green,
  danger: colors.magenta,
  strong: colors.bold,
  warning: colors.yellow,
  muted: colors.dim,
  disabled: colors.gray,
  dark: colors.dim.gray,
  underline: colors.underline,

  set info(custom) {
    this._info = custom;
  },
  get info() {
    return this._info || this.primary;
  },

  set em(custom) {
    this._em = custom;
  },
  get em() {
    return this._em || this.primary.underline;
  },

  set heading(custom) {
    this._heading = custom;
  },
  get heading() {
    return this._heading || this.muted.underline;
  },

  /**
   * Statuses
   */

  set pending(custom) {
    this._pending = custom;
  },
  get pending() {
    return this._pending || this.primary;
  },

  set submitted(custom) {
    this._submitted = custom;
  },
  get submitted() {
    return this._submitted || this.success;
  },

  set cancelled(custom) {
    this._cancelled = custom;
  },
  get cancelled() {
    return this._cancelled || this.danger;
  },

  /**
   * Special styling
   */

  set typing(custom) {
    this._typing = custom;
  },
  get typing() {
    return this._typing || this.dim;
  },

  set placeholder(custom) {
    this._placeholder = custom;
  },
  get placeholder() {
    return this._placeholder || this.primary.dim;
  },

  set highlight(custom) {
    this._highlight = custom;
  },
  get highlight() {
    return this._highlight || this.inverse;
  }
};

styles.merge = (options = {}) => {
  if (options.styles && typeof options.styles.enabled === 'boolean') {
    colors.enabled = options.styles.enabled;
  }
  if (options.styles && typeof options.styles.visible === 'boolean') {
    colors.visible = options.styles.visible;
  }

  let result = utils.merge({}, styles, options.styles);
  delete result.merge;

  for (let key of Object.keys(colors)) {
    if (!result.hasOwnProperty(key)) {
      Reflect.defineProperty(result, key, { get: () => colors[key] });
    }
  }

  for (let key of Object.keys(colors.styles)) {
    if (!result.hasOwnProperty(key)) {
      Reflect.defineProperty(result, key, { get: () => colors[key] });
    }
  }
  return result;
};

module.exports = styles;


/***/ }),
/* 568 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const isWindows = process.platform === 'win32';
const colors = __webpack_require__(558);
const utils = __webpack_require__(557);

const symbols = {
  ...colors.symbols,
  upDownDoubleArrow: '',
  upDownDoubleArrow2: '',
  upDownArrow: '',
  asterisk: '*',
  asterism: '',
  bulletWhite: '',
  electricArrow: '',
  ellipsisLarge: '',
  ellipsisSmall: '',
  fullBlock: '',
  identicalTo: '',
  indicator: colors.symbols.check,
  leftAngle: '',
  mark: '',
  minus: '',
  multiplication: '',
  obelus: '',
  percent: '%',
  pilcrow: '',
  pilcrow2: '',
  pencilUpRight: '',
  pencilDownRight: '',
  pencilRight: '',
  plus: '+',
  plusMinus: '',
  pointRight: '',
  rightAngle: '',
  section: '',
  hexagon: { off: '', on: '', disabled: '' },
  ballot: { on: '', off: '', disabled: '' },
  stars: { on: '', off: '', disabled: '' },
  folder: { on: '', off: '', disabled: '' },
  prefix: {
    pending: colors.symbols.question,
    submitted: colors.symbols.check,
    cancelled: colors.symbols.cross
  },
  separator: {
    pending: colors.symbols.pointerSmall,
    submitted: colors.symbols.middot,
    cancelled: colors.symbols.middot
  },
  radio: {
    off: isWindows ? '( )' : '',
    on: isWindows ? '(*)' : '',
    disabled: isWindows ? '(|)' : ''
  },
  numbers: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
};

symbols.merge = options => {
  let result = utils.merge({}, colors.symbols, symbols, options.symbols);
  delete result.merge;
  return result;
};

module.exports = symbols;



/***/ }),
/* 569 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


const isTerm = process.env.TERM_PROGRAM === 'Apple_Terminal';
const colors = __webpack_require__(558);
const utils = __webpack_require__(557);
const ansi = module.exports = exports;
const ESC = '\u001b[';
const BEL = '\u0007';
let hidden = false;

const code = ansi.code = {
  bell: BEL,
  beep: BEL,
  beginning: `${ESC}G`,
  down: `${ESC}J`,
  esc: ESC,
  getPosition: `${ESC}6n`,
  hide: `${ESC}?25l`,
  line: `${ESC}2K`,
  lineEnd: `${ESC}K`,
  lineStart: `${ESC}1K`,
  restorePosition: ESC + (isTerm ? '8' : 'u'),
  savePosition: ESC + (isTerm ? '7' : 's'),
  screen: `${ESC}2J`,
  show: `${ESC}?25h`,
  up: `${ESC}1J`
};

const cursor = ansi.cursor = {
  get hidden() {
    return hidden;
  },

  hide() {
    hidden = true;
    return code.hide;
  },
  show() {
    hidden = false;
    return code.show;
  },

  forward: (count = 1) => `${ESC}${count}C`,
  backward: (count = 1) => `${ESC}${count}D`,
  nextLine: (count = 1) => `${ESC}E`.repeat(count),
  prevLine: (count = 1) => `${ESC}F`.repeat(count),

  up: (count = 1) => count ? `${ESC}${count}A` : '',
  down: (count = 1) => count ? `${ESC}${count}B` : '',
  right: (count = 1) => count ? `${ESC}${count}C` : '',
  left: (count = 1) => count ? `${ESC}${count}D` : '',

  to(x, y) {
    return y ? `${ESC}${y + 1};${x + 1}H` : `${ESC}${x + 1}G`;
  },

  move(x = 0, y = 0) {
    let res = '';
    res += (x < 0) ? cursor.left(-x) : (x > 0) ? cursor.right(x) : '';
    res += (y < 0) ? cursor.up(-y) : (y > 0) ? cursor.down(y) : '';
    return res;
  },

  restore(state = {}) {
    let { after, cursor, initial, input, prompt, size, value } = state;
    initial = utils.isPrimitive(initial) ? String(initial) : '';
    input = utils.isPrimitive(input) ? String(input) : '';
    value = utils.isPrimitive(value) ? String(value) : '';

    if (size) {
      let codes = ansi.cursor.up(size) + ansi.cursor.to(prompt.length);
      let diff = input.length - cursor;
      if (diff > 0) {
        codes += ansi.cursor.left(diff);
      }
      return codes;
    }

    if (value || after) {
      let pos = (!input && !!initial) ? -initial.length : -input.length + cursor;
      if (after) pos -= after.length;
      if (input === '' && initial && !prompt.includes(initial)) {
        pos += initial.length;
      }
      return ansi.cursor.move(pos);
    }
  }
};

const erase = ansi.erase = {
  screen: code.screen,
  up: code.up,
  down: code.down,
  line: code.line,
  lineEnd: code.lineEnd,
  lineStart: code.lineStart,
  lines(n) {
    let str = '';
    for (let i = 0; i < n; i++) {
      str += ansi.erase.line + (i < n - 1 ? ansi.cursor.up(1) : '');
    }
    if (n) str += ansi.code.beginning;
    return str;
  }
};

ansi.clear = (input = '', columns = process.stdout.columns) => {
  if (!columns) return erase.line + cursor.to(0);
  let width = str => [...colors.unstyle(str)].length;
  let lines = input.split(/\r?\n/);
  let rows = 0;
  for (let line of lines) {
    rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / columns);
  }
  return (erase.line + cursor.prevLine()).repeat(rows - 1) + erase.line + cursor.to(0);
};


/***/ }),
/* 570 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(557);

const define = (key, fn) => {
  utils.defineExport(exports, key, fn);
  utils.defineExport(exports, key.toLowerCase(), fn);
};

define('AutoComplete', () => __webpack_require__(571));
define('BasicAuth', () => __webpack_require__(575));
define('Confirm', () => __webpack_require__(579));
define('Editable', () => __webpack_require__(581));
define('Form', () => __webpack_require__(577));
define('Input', () => __webpack_require__(582));
define('Invisible', () => __webpack_require__(585));
define('List', () => __webpack_require__(586));
define('MultiSelect', () => __webpack_require__(587));
define('Numeral', () => __webpack_require__(588));
define('Password', () => __webpack_require__(590));
define('Scale', () => __webpack_require__(591));
define('Select', () => __webpack_require__(572));
define('Snippet', () => __webpack_require__(592));
define('Sort', () => __webpack_require__(594));
define('Survey', () => __webpack_require__(595));
define('Text', () => __webpack_require__(596));
define('Toggle', () => __webpack_require__(597));
define('Quiz', () => __webpack_require__(598));


/***/ }),
/* 571 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Select = __webpack_require__(572);

const highlight = (input, color) => {
  let val = input.toLowerCase();
  return str => {
    let s = str.toLowerCase();
    let i = s.indexOf(val);
    let colored = color(str.slice(i, i + val.length));
    return i >= 0 ? str.slice(0, i) + colored + str.slice(i + val.length) : str;
  };
};

class AutoComplete extends Select {
  constructor(options) {
    super(options);
    this.cursorShow();
  }

  moveCursor(n) {
    this.state.cursor += n;
  }

  dispatch(ch) {
    return this.append(ch);
  }

  space(ch) {
    return this.options.multiple ? super.space(ch) : this.append(ch);
  }

  append(ch) {
    let { cursor, input } = this.state;
    this.input = input.slice(0, cursor) + ch + input.slice(cursor);
    this.moveCursor(1);
    return this.complete();
  }

  delete() {
    let { cursor, input } = this.state;
    if (!input) return this.alert();
    this.input = input.slice(0, cursor - 1) + input.slice(cursor);
    this.moveCursor(-1);
    return this.complete();
  }

  deleteForward() {
    let { cursor, input } = this.state;
    if (input[cursor] === void 0) return this.alert();
    this.input = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
    return this.complete();
  }

  number(ch) {
    return this.append(ch);
  }

  async complete() {
    this.completing = true;
    this.choices = await this.suggest(this.input, this.state._choices);
    this.state.limit = void 0; // allow getter/setter to reset limit
    this.index = Math.min(Math.max(this.visible.length - 1, 0), this.index);
    await this.render();
    this.completing = false;
  }

  suggest(input = this.input, choices = this.state._choices) {
    if (typeof this.options.suggest === 'function') {
      return this.options.suggest.call(this, input, choices);
    }
    let str = input.toLowerCase();
    return choices.filter(ch => ch.message.toLowerCase().includes(str));
  }

  pointer() {
    return '';
  }

  format() {
    if (!this.focused) return this.input;
    if (this.options.multiple && this.state.submitted) {
      return this.selected.map(ch => this.styles.primary(ch.message)).join(', ');
    }
    if (this.state.submitted) {
      let value = this.value = this.input = this.focused.value;
      return this.styles.primary(value);
    }
    return this.input;
  }

  async render() {
    if (this.state.status !== 'pending') return super.render();
    let style = this.options.highlight
      ? this.options.highlight.bind(this)
      : this.styles.placeholder;

    let color = highlight(this.input, style);
    let choices = this.choices;
    this.choices = choices.map(ch => ({ ...ch, message: color(ch.message) }));
    await super.render();
    this.choices = choices;
  }

  submit() {
    if (this.options.multiple) {
      this.value = this.selected.map(ch => ch.name);
    }
    return super.submit();
  }
}

module.exports = AutoComplete;


/***/ }),
/* 572 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ArrayPrompt = __webpack_require__(573);
const utils = __webpack_require__(557);

class SelectPrompt extends ArrayPrompt {
  constructor(options) {
    super(options);
    this.emptyError = this.options.emptyError || 'No items were selected';
  }

  async dispatch(s, key) {
    if (this.multiple) {
      return this[key.name] ? await this[key.name](s, key) : await super.dispatch(s, key);
    }
    this.alert();
  }

  separator() {
    if (this.options.separator) return super.separator();
    let sep = this.styles.muted(this.symbols.ellipsis);
    return this.state.submitted ? super.separator() : sep;
  }

  pointer(choice, i) {
    return (!this.multiple || this.options.pointer) ? super.pointer(choice, i) : '';
  }

  indicator(choice, i) {
    return this.multiple ? super.indicator(choice, i) : '';
  }

  choiceMessage(choice, i) {
    let message = this.resolve(choice.message, this.state, choice, i);
    if (choice.role === 'heading' && !utils.hasColor(message)) {
      message = this.styles.strong(message);
    }
    return this.resolve(message, this.state, choice, i);
  }

  choiceSeparator() {
    return ':';
  }

  async renderChoice(choice, i) {
    await this.onChoice(choice, i);

    let focused = this.index === i;
    let pointer = await this.pointer(choice, i);
    let check = await this.indicator(choice, i) + (choice.pad || '');
    let hint = await this.resolve(choice.hint, this.state, choice, i);

    if (hint && !utils.hasColor(hint)) {
      hint = this.styles.muted(hint);
    }

    let ind = this.indent(choice);
    let msg = await this.choiceMessage(choice, i);
    let line = () => [this.margin[3], ind + pointer + check, msg, this.margin[1], hint].filter(Boolean).join(' ');

    if (choice.role === 'heading') {
      return line();
    }

    if (choice.disabled) {
      if (!utils.hasColor(msg)) {
        msg = this.styles.disabled(msg);
      }
      return line();
    }

    if (focused) {
      msg = this.styles.em(msg);
    }

    return line();
  }

  async renderChoices() {
    if (this.state.loading === 'choices') {
      return this.styles.warning('Loading choices');
    }

    if (this.state.submitted) return '';
    let choices = this.visible.map(async(ch, i) => await this.renderChoice(ch, i));
    let visible = await Promise.all(choices);
    if (!visible.length) visible.push(this.styles.danger('No matching choices'));
    let result = this.margin[0] + visible.join('\n');
    let header;

    if (this.options.choicesHeader) {
      header = await this.resolve(this.options.choicesHeader, this.state);
    }

    return [header, result].filter(Boolean).join('\n');
  }

  format() {
    if (!this.state.submitted || this.state.cancelled) return '';
    if (Array.isArray(this.selected)) {
      return this.selected.map(choice => this.styles.primary(choice.name)).join(', ');
    }
    return this.styles.primary(this.selected.name);
  }

  async render() {
    let { submitted, size } = this.state;

    let prompt = '';
    let header = await this.header();
    let prefix = await this.prefix();
    let separator = await this.separator();
    let message = await this.message();

    if (this.options.promptLine !== false) {
      prompt = [prefix, message, separator, ''].join(' ');
      this.state.prompt = prompt;
    }

    let output = await this.format();
    let help = (await this.error()) || (await this.hint());
    let body = await this.renderChoices();
    let footer = await this.footer();

    if (output) prompt += output;
    if (help && !prompt.includes(help)) prompt += ' ' + help;

    if (submitted && !output && !body.trim() && this.multiple && this.emptyError != null) {
      prompt += this.styles.danger(this.emptyError);
    }

    this.clear(size);
    this.write([header, prompt, body, footer].filter(Boolean).join('\n'));
    this.write(this.margin[2]);
    this.restore();
  }
}

module.exports = SelectPrompt;


/***/ }),
/* 573 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const colors = __webpack_require__(558);
const Prompt = __webpack_require__(560);
const roles = __webpack_require__(574);
const utils = __webpack_require__(557);
const { reorder, scrollUp, scrollDown, isObject, swap } = utils;

class ArrayPrompt extends Prompt {
  constructor(options) {
    super(options);
    this.cursorHide();
    this.maxSelected = options.maxSelected || Infinity;
    this.multiple = options.multiple || false;
    this.initial = options.initial || 0;
    this.delay = options.delay || 0;
    this.longest = 0;
    this.num = '';
  }

  async initialize() {
    if (typeof this.options.initial === 'function') {
      this.initial = await this.options.initial.call(this);
    }
    await this.reset(true);
    await super.initialize();
  }

  async reset() {
    let { choices, initial, autofocus, suggest } = this.options;
    this.state._choices = [];
    this.state.choices = [];

    this.choices = await Promise.all(await this.toChoices(choices));
    this.choices.forEach(ch => (ch.enabled = false));

    if (typeof suggest !== 'function' && this.selectable.length === 0) {
      throw new Error('At least one choice must be selectable');
    }

    if (isObject(initial)) initial = Object.keys(initial);
    if (Array.isArray(initial)) {
      if (autofocus != null) this.index = this.findIndex(autofocus);
      initial.forEach(v => this.enable(this.find(v)));
      await this.render();
    } else {
      if (autofocus != null) initial = autofocus;
      if (typeof initial === 'string') initial = this.findIndex(initial);
      if (typeof initial === 'number' && initial > -1) {
        this.index = Math.max(0, Math.min(initial, this.choices.length));
        this.enable(this.find(this.index));
      }
    }

    if (this.isDisabled(this.focused)) {
      await this.down();
    }
  }

  async toChoices(value, parent) {
    this.state.loadingChoices = true;
    let choices = [];
    let index = 0;

    let toChoices = async(items, parent) => {
      if (typeof items === 'function') items = await items.call(this);
      if (items instanceof Promise) items = await items;

      for (let i = 0; i < items.length; i++) {
        let choice = items[i] = await this.toChoice(items[i], index++, parent);
        choices.push(choice);

        if (choice.choices) {
          await toChoices(choice.choices, choice);
        }
      }
      return choices;
    };

    return toChoices(value, parent)
      .then(choices => {
        this.state.loadingChoices = false;
        return choices;
      });
  }

  async toChoice(ele, i, parent) {
    if (typeof ele === 'function') ele = await ele.call(this, this);
    if (ele instanceof Promise) ele = await ele;
    if (typeof ele === 'string') ele = { name: ele };

    if (ele.normalized) return ele;
    ele.normalized = true;

    let origVal = ele.value;
    let role = roles(ele.role, this.options);
    ele = role(this, ele);

    if (typeof ele.disabled === 'string' && !ele.hint) {
      ele.hint = ele.disabled;
      ele.disabled = true;
    }

    if (ele.disabled === true && ele.hint == null) {
      ele.hint = '(disabled)';
    }

    // if the choice was already normalized, return it
    if (ele.index != null) return ele;
    ele.name = ele.name || ele.key || ele.title || ele.value || ele.message;
    ele.message = ele.message || ele.name || '';
    ele.value = [ele.value, ele.name].find(this.isValue.bind(this));

    ele.input = '';
    ele.index = i;
    ele.cursor = 0;

    utils.define(ele, 'parent', parent);
    ele.level = parent ? parent.level + 1 : 1;
    if (ele.indent == null) {
      ele.indent = parent ? parent.indent + '  ' : (ele.indent || '');
    }

    ele.path = parent ? parent.path + '.' + ele.name : ele.name;
    ele.enabled = !!(this.multiple && !this.isDisabled(ele) && (ele.enabled || this.isSelected(ele)));

    if (!this.isDisabled(ele)) {
      this.longest = Math.max(this.longest, colors.unstyle(ele.message).length);
    }

    // shallow clone the choice first
    let choice = { ...ele };

    // then allow the choice to be reset using the "original" values
    ele.reset = (input = choice.input, value = choice.value) => {
      for (let key of Object.keys(choice)) ele[key] = choice[key];
      ele.input = input;
      ele.value = value;
    };

    if (origVal == null && typeof ele.initial === 'function') {
      ele.input = await ele.initial.call(this, this.state, ele, i);
    }

    return ele;
  }

  async onChoice(choice, i) {
    this.emit('choice', choice, i, this);

    if (typeof choice.onChoice === 'function') {
      await choice.onChoice.call(this, this.state, choice, i);
    }
  }

  async addChoice(ele, i, parent) {
    let choice = await this.toChoice(ele, i, parent);
    this.choices.push(choice);
    this.index = this.choices.length - 1;
    this.limit = this.choices.length;
    return choice;
  }

  async newItem(item, i, parent) {
    let ele = { name: 'New choice name?', editable: true, newChoice: true, ...item };
    let choice = await this.addChoice(ele, i, parent);

    choice.updateChoice = () => {
      delete choice.newChoice;
      choice.name = choice.message = choice.input;
      choice.input = '';
      choice.cursor = 0;
    };

    return this.render();
  }

  indent(choice) {
    if (choice.indent == null) {
      return choice.level > 1 ? '  '.repeat(choice.level - 1) : '';
    }
    return choice.indent;
  }

  dispatch(s, key) {
    if (this.multiple && this[key.name]) return this[key.name]();
    this.alert();
  }

  focus(choice, enabled) {
    if (typeof enabled !== 'boolean') enabled = choice.enabled;
    if (enabled && !choice.enabled && this.selected.length >= this.maxSelected) {
      return this.alert();
    }
    this.index = choice.index;
    choice.enabled = enabled && !this.isDisabled(choice);
    return choice;
  }

  space() {
    if (!this.multiple) return this.alert();
    this.toggle(this.focused);
    return this.render();
  }

  a() {
    if (this.maxSelected < this.choices.length) return this.alert();
    let enabled = this.selectable.every(ch => ch.enabled);
    this.choices.forEach(ch => (ch.enabled = !enabled));
    return this.render();
  }

  i() {
    // don't allow choices to be inverted if it will result in
    // more than the maximum number of allowed selected items.
    if (this.choices.length - this.selected.length > this.maxSelected) {
      return this.alert();
    }
    this.choices.forEach(ch => (ch.enabled = !ch.enabled));
    return this.render();
  }

  g(choice = this.focused) {
    if (!this.choices.some(ch => !!ch.parent)) return this.a();
    this.toggle((choice.parent && !choice.choices) ? choice.parent : choice);
    return this.render();
  }

  toggle(choice, enabled) {
    if (!choice.enabled && this.selected.length >= this.maxSelected) {
      return this.alert();
    }

    if (typeof enabled !== 'boolean') enabled = !choice.enabled;
    choice.enabled = enabled;

    if (choice.choices) {
      choice.choices.forEach(ch => this.toggle(ch, enabled));
    }

    let parent = choice.parent;
    while (parent) {
      let choices = parent.choices.filter(ch => this.isDisabled(ch));
      parent.enabled = choices.every(ch => ch.enabled === true);
      parent = parent.parent;
    }

    reset(this, this.choices);
    this.emit('toggle', choice, this);
    return choice;
  }

  enable(choice) {
    if (this.selected.length >= this.maxSelected) return this.alert();
    choice.enabled = !this.isDisabled(choice);
    choice.choices && choice.choices.forEach(this.enable.bind(this));
    return choice;
  }

  disable(choice) {
    choice.enabled = false;
    choice.choices && choice.choices.forEach(this.disable.bind(this));
    return choice;
  }

  number(n) {
    this.num += n;

    let number = num => {
      let i = Number(num);
      if (i > this.choices.length - 1) return this.alert();

      let focused = this.focused;
      let choice = this.choices.find(ch => i === ch.index);

      if (!choice.enabled && this.selected.length >= this.maxSelected) {
        return this.alert();
      }

      if (this.visible.indexOf(choice) === -1) {
        let choices = reorder(this.choices);
        let actualIdx = choices.indexOf(choice);

        if (focused.index > actualIdx) {
          let start = choices.slice(actualIdx, actualIdx + this.limit);
          let end = choices.filter(ch => !start.includes(ch));
          this.choices = start.concat(end);
        } else {
          let pos = actualIdx - this.limit + 1;
          this.choices = choices.slice(pos).concat(choices.slice(0, pos));
        }
      }

      this.index = this.choices.indexOf(choice);
      this.toggle(this.focused);
      return this.render();
    };

    clearTimeout(this.numberTimeout);

    return new Promise(resolve => {
      let len = this.choices.length;
      let num = this.num;

      let handle = (val = false, res) => {
        clearTimeout(this.numberTimeout);
        if (val) res = number(num);
        this.num = '';
        resolve(res);
      };

      if (num === '0' || (num.length === 1 && Number(num + '0') > len)) {
        return handle(true);
      }

      if (Number(num) > len) {
        return handle(false, this.alert());
      }

      this.numberTimeout = setTimeout(() => handle(true), this.delay);
    });
  }

  home() {
    this.choices = reorder(this.choices);
    this.index = 0;
    return this.render();
  }

  end() {
    let pos = this.choices.length - this.limit;
    let choices = reorder(this.choices);
    this.choices = choices.slice(pos).concat(choices.slice(0, pos));
    this.index = this.limit - 1;
    return this.render();
  }

  first() {
    this.index = 0;
    return this.render();
  }

  last() {
    this.index = this.visible.length - 1;
    return this.render();
  }

  prev() {
    if (this.visible.length <= 1) return this.alert();
    return this.up();
  }

  next() {
    if (this.visible.length <= 1) return this.alert();
    return this.down();
  }

  right() {
    if (this.cursor >= this.input.length) return this.alert();
    this.cursor++;
    return this.render();
  }

  left() {
    if (this.cursor <= 0) return this.alert();
    this.cursor--;
    return this.render();
  }

  up() {
    let len = this.choices.length;
    let vis = this.visible.length;
    let idx = this.index;
    if (this.options.scroll === false && idx === 0) {
      return this.alert();
    }
    if (len > vis && idx === 0) {
      return this.scrollUp();
    }
    this.index = ((idx - 1 % len) + len) % len;
    if (this.isDisabled()) {
      return this.up();
    }
    return this.render();
  }

  down() {
    let len = this.choices.length;
    let vis = this.visible.length;
    let idx = this.index;
    if (this.options.scroll === false && idx === vis - 1) {
      return this.alert();
    }
    if (len > vis && idx === vis - 1) {
      return this.scrollDown();
    }
    this.index = (idx + 1) % len;
    if (this.isDisabled()) {
      return this.down();
    }
    return this.render();
  }

  scrollUp(i = 0) {
    this.choices = scrollUp(this.choices);
    this.index = i;
    if (this.isDisabled()) {
      return this.up();
    }
    return this.render();
  }

  scrollDown(i = this.visible.length - 1) {
    this.choices = scrollDown(this.choices);
    this.index = i;
    if (this.isDisabled()) {
      return this.down();
    }
    return this.render();
  }

  async shiftUp() {
    if (this.options.sort === true) {
      this.sorting = true;
      this.swap(this.index - 1);
      await this.up();
      this.sorting = false;
      return;
    }
    return this.scrollUp(this.index);
  }

  async shiftDown() {
    if (this.options.sort === true) {
      this.sorting = true;
      this.swap(this.index + 1);
      await this.down();
      this.sorting = false;
      return;
    }
    return this.scrollDown(this.index);
  }

  pageUp() {
    if (this.visible.length <= 1) return this.alert();
    this.limit = Math.max(this.limit - 1, 0);
    this.index = Math.min(this.limit - 1, this.index);
    this._limit = this.limit;
    if (this.isDisabled()) {
      return this.up();
    }
    return this.render();
  }

  pageDown() {
    if (this.visible.length >= this.choices.length) return this.alert();
    this.index = Math.max(0, this.index);
    this.limit = Math.min(this.limit + 1, this.choices.length);
    this._limit = this.limit;
    if (this.isDisabled()) {
      return this.down();
    }
    return this.render();
  }

  swap(pos) {
    swap(this.choices, this.index, pos);
  }

  isDisabled(choice = this.focused) {
    let keys = ['disabled', 'collapsed', 'hidden', 'completing', 'readonly'];
    if (choice && keys.some(key => choice[key] === true)) {
      return true;
    }
    return choice && choice.role === 'heading';
  }

  isEnabled(choice = this.focused) {
    if (Array.isArray(choice)) return choice.every(ch => this.isEnabled(ch));
    if (choice.choices) {
      let choices = choice.choices.filter(ch => !this.isDisabled(ch));
      return choice.enabled && choices.every(ch => this.isEnabled(ch));
    }
    return choice.enabled && !this.isDisabled(choice);
  }

  isChoice(choice, value) {
    return choice.name === value || choice.index === Number(value);
  }

  isSelected(choice) {
    if (Array.isArray(this.initial)) {
      return this.initial.some(value => this.isChoice(choice, value));
    }
    return this.isChoice(choice, this.initial);
  }

  map(names = [], prop = 'value') {
    return [].concat(names || []).reduce((acc, name) => {
      acc[name] = this.find(name, prop);
      return acc;
    }, {});
  }

  filter(value, prop) {
    let isChoice = (ele, i) => [ele.name, i].includes(value);
    let fn = typeof value === 'function' ? value : isChoice;
    let choices = this.options.multiple ? this.state._choices : this.choices;
    let result = choices.filter(fn);
    if (prop) {
      return result.map(ch => ch[prop]);
    }
    return result;
  }

  find(value, prop) {
    if (isObject(value)) return prop ? value[prop] : value;
    let isChoice = (ele, i) => [ele.name, i].includes(value);
    let fn = typeof value === 'function' ? value : isChoice;
    let choice = this.choices.find(fn);
    if (choice) {
      return prop ? choice[prop] : choice;
    }
  }

  findIndex(value) {
    return this.choices.indexOf(this.find(value));
  }

  async submit() {
    let choice = this.focused;
    if (!choice) return this.alert();

    if (choice.newChoice) {
      if (!choice.input) return this.alert();
      choice.updateChoice();
      return this.render();
    }

    if (this.choices.some(ch => ch.newChoice)) {
      return this.alert();
    }

    let { reorder, sort } = this.options;
    let multi = this.multiple === true;
    let value = this.selected;
    if (value === void 0) {
      return this.alert();
    }

    // re-sort choices to original order
    if (Array.isArray(value) && reorder !== false && sort !== true) {
      value = utils.reorder(value);
    }

    this.value = multi ? value.map(ch => ch.name) : value.name;
    return super.submit();
  }

  set choices(choices = []) {
    this.state._choices = this.state._choices || [];
    this.state.choices = choices;

    for (let choice of choices) {
      if (!this.state._choices.some(ch => ch.name === choice.name)) {
        this.state._choices.push(choice);
      }
    }

    if (!this._initial && this.options.initial) {
      this._initial = true;
      let init = this.initial;
      if (typeof init === 'string' || typeof init === 'number') {
        let choice = this.find(init);
        if (choice) {
          this.initial = choice.index;
          this.focus(choice, true);
        }
      }
    }
  }
  get choices() {
    return reset(this, this.state.choices || []);
  }

  set visible(visible) {
    this.state.visible = visible;
  }
  get visible() {
    return (this.state.visible || this.choices).slice(0, this.limit);
  }

  set limit(num) {
    this.state.limit = num;
  }
  get limit() {
    let { state, options, choices } = this;
    let limit = state.limit || this._limit || options.limit || choices.length;
    return Math.min(limit, this.height);
  }

  set value(value) {
    super.value = value;
  }
  get value() {
    if (typeof super.value !== 'string' && super.value === this.initial) {
      return this.input;
    }
    return super.value;
  }

  set index(i) {
    this.state.index = i;
  }
  get index() {
    return Math.max(0, this.state ? this.state.index : 0);
  }

  get enabled() {
    return this.filter(this.isEnabled.bind(this));
  }

  get focused() {
    let choice = this.choices[this.index];
    if (choice && this.state.submitted && this.multiple !== true) {
      choice.enabled = true;
    }
    return choice;
  }

  get selectable() {
    return this.choices.filter(choice => !this.isDisabled(choice));
  }

  get selected() {
    return this.multiple ? this.enabled : this.focused;
  }
}

function reset(prompt, choices) {
  if (choices instanceof Promise) return choices;
  if (typeof choices === 'function') {
    if (utils.isAsyncFn(choices)) return choices;
    choices = choices.call(prompt, prompt);
  }
  for (let choice of choices) {
    if (Array.isArray(choice.choices)) {
      let items = choice.choices.filter(ch => !prompt.isDisabled(ch));
      choice.enabled = items.every(ch => ch.enabled === true);
    }
    if (prompt.isDisabled(choice) === true) {
      delete choice.enabled;
    }
  }
  return choices;
}

module.exports = ArrayPrompt;


/***/ }),
/* 574 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(557);
const roles = {
  default(prompt, choice) {
    return choice;
  },
  checkbox(prompt, choice) {
    throw new Error('checkbox role is not implemented yet');
  },
  editable(prompt, choice) {
    throw new Error('editable role is not implemented yet');
  },
  expandable(prompt, choice) {
    throw new Error('expandable role is not implemented yet');
  },
  heading(prompt, choice) {
    choice.disabled = '';
    choice.indicator = [choice.indicator, ' '].find(v => v != null);
    choice.message = choice.message || '';
    return choice;
  },
  input(prompt, choice) {
    throw new Error('input role is not implemented yet');
  },
  option(prompt, choice) {
    return roles.default(prompt, choice);
  },
  radio(prompt, choice) {
    throw new Error('radio role is not implemented yet');
  },
  separator(prompt, choice) {
    choice.disabled = '';
    choice.indicator = [choice.indicator, ' '].find(v => v != null);
    choice.message = choice.message || prompt.symbols.line.repeat(5);
    return choice;
  },
  spacer(prompt, choice) {
    return choice;
  }
};

module.exports = (name, options = {}) => {
  let role = utils.merge({}, roles, options.roles);
  return role[name] || role.default;
};


/***/ }),
/* 575 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AuthPrompt = __webpack_require__(576);

function defaultAuthenticate(value, state) {
  if (value.username === this.options.username && value.password === this.options.password) {
    return true;
  }
  return false;
}

const factory = (authenticate = defaultAuthenticate) => {
  const choices = [
    { name: 'username', message: 'username' },
    {
      name: 'password',
      message: 'password',
      format(input) {
        if (this.options.showPassword) {
          return input;
        }
        let color = this.state.submitted ? this.styles.primary : this.styles.muted;
        return color(this.symbols.asterisk.repeat(input.length));
      }
    }
  ];

  class BasicAuthPrompt extends AuthPrompt.create(authenticate) {
    constructor(options) {
      super({ ...options, choices });
    }

    static create(authenticate) {
      return factory(authenticate);
    }
  }

  return BasicAuthPrompt;
};

module.exports = factory();


/***/ }),
/* 576 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const FormPrompt = __webpack_require__(577);

const defaultAuthenticate = () => {
  throw new Error('expected prompt to have a custom authenticate method');
};

const factory = (authenticate = defaultAuthenticate) => {

  class AuthPrompt extends FormPrompt {
    constructor(options) {
      super(options);
    }

    async submit() {
      this.value = await authenticate.call(this, this.values, this.state);
      super.base.submit.call(this);
    }

    static create(authenticate) {
      return factory(authenticate);
    }
  }

  return AuthPrompt;
};

module.exports = factory();


/***/ }),
/* 577 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const colors = __webpack_require__(558);
const SelectPrompt = __webpack_require__(572);
const placeholder = __webpack_require__(578);

class FormPrompt extends SelectPrompt {
  constructor(options) {
    super({ ...options, multiple: true });
    this.type = 'form';
    this.initial = this.options.initial;
    this.align = [this.options.align, 'right'].find(v => v != null);
    this.emptyError = '';
    this.values = {};
  }

  async reset(first) {
    await super.reset();
    if (first === true) this._index = this.index;
    this.index = this._index;
    this.values = {};
    this.choices.forEach(choice => choice.reset && choice.reset());
    return this.render();
  }

  dispatch(char) {
    return !!char && this.append(char);
  }

  append(char) {
    let choice = this.focused;
    if (!choice) return this.alert();
    let { cursor, input } = choice;
    choice.value = choice.input = input.slice(0, cursor) + char + input.slice(cursor);
    choice.cursor++;
    return this.render();
  }

  delete() {
    let choice = this.focused;
    if (!choice || choice.cursor <= 0) return this.alert();
    let { cursor, input } = choice;
    choice.value = choice.input = input.slice(0, cursor - 1) + input.slice(cursor);
    choice.cursor--;
    return this.render();
  }

  deleteForward() {
    let choice = this.focused;
    if (!choice) return this.alert();
    let { cursor, input } = choice;
    if (input[cursor] === void 0) return this.alert();
    let str = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
    choice.value = choice.input = str;
    return this.render();
  }

  right() {
    let choice = this.focused;
    if (!choice) return this.alert();
    if (choice.cursor >= choice.input.length) return this.alert();
    choice.cursor++;
    return this.render();
  }

  left() {
    let choice = this.focused;
    if (!choice) return this.alert();
    if (choice.cursor <= 0) return this.alert();
    choice.cursor--;
    return this.render();
  }

  space(ch, key) {
    return this.dispatch(ch, key);
  }

  number(ch, key) {
    return this.dispatch(ch, key);
  }

  next() {
    let ch = this.focused;
    if (!ch) return this.alert();
    let { initial, input } = ch;
    if (initial && initial.startsWith(input) && input !== initial) {
      ch.value = ch.input = initial;
      ch.cursor = ch.value.length;
      return this.render();
    }
    return super.next();
  }

  prev() {
    let ch = this.focused;
    if (!ch) return this.alert();
    if (ch.cursor === 0) return super.prev();
    ch.value = ch.input = '';
    ch.cursor = 0;
    return this.render();
  }

  separator() {
    return '';
  }

  format(value) {
    return !this.state.submitted ? super.format(value) : '';
  }

  pointer() {
    return '';
  }

  indicator(choice) {
    return choice.input ? '' : '';
  }

  async choiceSeparator(choice, i) {
    let sep = await this.resolve(choice.separator, this.state, choice, i) || ':';
    return sep ? ' ' + this.styles.disabled(sep) : '';
  }

  async renderChoice(choice, i) {
    await this.onChoice(choice, i);

    let { state, styles } = this;
    let { cursor, initial = '', name, hint, input = '' } = choice;
    let { muted, submitted, primary, danger } = styles;

    let help = hint;
    let focused = this.index === i;
    let validate = choice.validate || (() => true);
    let sep = await this.choiceSeparator(choice, i);
    let msg = choice.message;

    if (this.align === 'right') msg = msg.padStart(this.longest + 1, ' ');
    if (this.align === 'left') msg = msg.padEnd(this.longest + 1, ' ');

    // re-populate the form values (answers) object
    let value = this.values[name] = (input || initial);
    let color = input ? 'success' : 'dark';

    if ((await validate.call(choice, value, this.state)) !== true) {
      color = 'danger';
    }

    let style = styles[color];
    let indicator = style(await this.indicator(choice, i)) + (choice.pad || '');

    let indent = this.indent(choice);
    let line = () => [indent, indicator, msg + sep, input, help].filter(Boolean).join(' ');

    if (state.submitted) {
      msg = colors.unstyle(msg);
      input = submitted(input);
      help = '';
      return line();
    }

    if (choice.format) {
      input = await choice.format.call(this, input, choice, i);
    } else {
      let color = this.styles.muted;
      let options = { input, initial, pos: cursor, showCursor: focused, color };
      input = placeholder(this, options);
    }

    if (!this.isValue(input)) {
      input = this.styles.muted(this.symbols.ellipsis);
    }

    if (choice.result) {
      this.values[name] = await choice.result.call(this, value, choice, i);
    }

    if (focused) {
      msg = primary(msg);
    }

    if (choice.error) {
      input += (input ? ' ' : '') + danger(choice.error.trim());
    } else if (choice.hint) {
      input += (input ? ' ' : '') + muted(choice.hint.trim());
    }

    return line();
  }

  async submit() {
    this.value = this.values;
    return super.base.submit.call(this);
  }
}

module.exports = FormPrompt;


/***/ }),
/* 578 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(557);

/**
 * Render a placeholder value with cursor and styling based on the
 * position of the cursor.
 *
 * @param {Object} `prompt` Prompt instance.
 * @param {String} `input` Input string.
 * @param {String} `initial` The initial user-provided value.
 * @param {Number} `pos` Current cursor position.
 * @param {Boolean} `showCursor` Render a simulated cursor using the inverse primary style.
 * @return {String} Returns the styled placeholder string.
 * @api public
 */

module.exports = (prompt, options = {}) => {
  prompt.cursorHide();

  let { input = '', initial = '', pos, showCursor = true, color } = options;
  let style = color || prompt.styles.placeholder;
  let inverse = utils.inverse(prompt.styles.primary);
  let blinker = str => inverse(prompt.styles.black(str));
  let output = input;
  let char = ' ';
  let reverse = blinker(char);

  if (prompt.blink && prompt.blink.off === true) {
    blinker = str => str;
    reverse = '';
  }

  if (showCursor && pos === 0 && initial === '' && input === '') {
    return blinker(char);
  }

  if (showCursor && pos === 0 && (input === initial || input === '')) {
    return blinker(initial[0]) + style(initial.slice(1));
  }

  initial = utils.isPrimitive(initial) ? `${initial}` : '';
  input = utils.isPrimitive(input) ? `${input}` : '';

  let placeholder = initial && initial.startsWith(input) && initial !== input;
  let cursor = placeholder ? blinker(initial[input.length]) : reverse;

  if (pos !== input.length && showCursor === true) {
    output = input.slice(0, pos) + blinker(input[pos]) + input.slice(pos + 1);
    cursor = '';
  }

  if (showCursor === false) {
    cursor = '';
  }

  if (placeholder) {
    let raw = prompt.styles.unstyle(output + cursor);
    return output + cursor + style(initial.slice(raw.length));
  }

  return output + cursor;
};


/***/ }),
/* 579 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BooleanPrompt = __webpack_require__(580);

class ConfirmPrompt extends BooleanPrompt {
  constructor(options) {
    super(options);
    this.default = this.options.default || (this.initial ? '(Y/n)' : '(y/N)');
  }
}

module.exports = ConfirmPrompt;



/***/ }),
/* 580 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Prompt = __webpack_require__(560);
const { isPrimitive, hasColor } = __webpack_require__(557);

class BooleanPrompt extends Prompt {
  constructor(options) {
    super(options);
    this.cursorHide();
  }

  async initialize() {
    let initial = await this.resolve(this.initial, this.state);
    this.input = await this.cast(initial);
    await super.initialize();
  }

  dispatch(ch) {
    if (!this.isValue(ch)) return this.alert();
    this.input = ch;
    return this.submit();
  }

  format(value) {
    let { styles, state } = this;
    return !state.submitted ? styles.primary(value) : styles.success(value);
  }

  cast(input) {
    return this.isTrue(input);
  }

  isTrue(input) {
    return /^[ty1]/i.test(input);
  }

  isFalse(input) {
    return /^[fn0]/i.test(input);
  }

  isValue(value) {
    return isPrimitive(value) && (this.isTrue(value) || this.isFalse(value));
  }

  async hint() {
    if (this.state.status === 'pending') {
      let hint = await this.element('hint');
      if (!hasColor(hint)) {
        return this.styles.muted(hint);
      }
      return hint;
    }
  }

  async render() {
    let { input, size } = this.state;

    let prefix = await this.prefix();
    let sep = await this.separator();
    let msg = await this.message();
    let hint = this.styles.muted(this.default);

    let promptLine = [prefix, msg, hint, sep].filter(Boolean).join(' ');
    this.state.prompt = promptLine;

    let header = await this.header();
    let value = this.value = this.cast(input);
    let output = await this.format(value);
    let help = (await this.error()) || (await this.hint());
    let footer = await this.footer();

    if (help && !promptLine.includes(help)) output += ' ' + help;
    promptLine += ' ' + output;

    this.clear(size);
    this.write([header, promptLine, footer].filter(Boolean).join('\n'));
    this.restore();
  }

  set value(value) {
    super.value = value;
  }
  get value() {
    return this.cast(super.value);
  }
}

module.exports = BooleanPrompt;


/***/ }),
/* 581 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Select = __webpack_require__(572);
const Form = __webpack_require__(577);
const form = Form.prototype;

class Editable extends Select {
  constructor(options) {
    super({ ...options, multiple: true });
    this.align = [this.options.align, 'left'].find(v => v != null);
    this.emptyError = '';
    this.values = {};
  }

  dispatch(char, key) {
    let choice = this.focused;
    let parent = choice.parent || {};
    if (!choice.editable && !parent.editable) {
      if (char === 'a' || char === 'i') return super[char]();
    }
    return form.dispatch.call(this, char, key);
  }

  append(char, key) {
    return form.append.call(this, char, key);
  }

  delete(char, key) {
    return form.delete.call(this, char, key);
  }

  space(char) {
    return this.focused.editable ? this.append(char) : super.space();
  }

  number(char) {
    return this.focused.editable ? this.append(char) : super.number(char);
  }

  next() {
    return this.focused.editable ? form.next.call(this) : super.next();
  }

  prev() {
    return this.focused.editable ? form.prev.call(this) : super.prev();
  }

  async indicator(choice, i) {
    let symbol = choice.indicator || '';
    let value = choice.editable ? symbol : super.indicator(choice, i);
    return await this.resolve(value, this.state, choice, i) || '';
  }

  indent(choice) {
    return choice.role === 'heading' ? '' : (choice.editable ? ' ' : '  ');
  }

  async renderChoice(choice, i) {
    choice.indent = '';
    if (choice.editable) return form.renderChoice.call(this, choice, i);
    return super.renderChoice(choice, i);
  }

  error() {
    return '';
  }

  footer() {
    return this.state.error;
  }

  async validate() {
    let result = true;

    for (let choice of this.choices) {
      if (typeof choice.validate !== 'function') {
        continue;
      }

      if (choice.role === 'heading') {
        continue;
      }

      let val = choice.parent ? this.value[choice.parent.name] : this.value;

      if (choice.editable) {
        val = choice.value === choice.name ? choice.initial || '' : choice.value;
      } else if (!this.isDisabled(choice)) {
        val = choice.enabled === true;
      }

      result = await choice.validate(val, this.state);

      if (result !== true) {
        break;
      }
    }

    if (result !== true) {
      this.state.error = typeof result === 'string' ? result : 'Invalid Input';
    }

    return result;
  }

  submit() {
    if (this.focused.newChoice === true) return super.submit();
    if (this.choices.some(ch => ch.newChoice)) {
      return this.alert();
    }

    this.value = {};

    for (let choice of this.choices) {
      let val = choice.parent ? this.value[choice.parent.name] : this.value;

      if (choice.role === 'heading') {
        this.value[choice.name] = {};
        continue;
      }

      if (choice.editable) {
        val[choice.name] = choice.value === choice.name
          ? (choice.initial || '')
          : choice.value;

      } else if (!this.isDisabled(choice)) {
        val[choice.name] = choice.enabled === true;
      }
    }

    return this.base.submit.call(this);
  }
}

module.exports = Editable;


/***/ }),
/* 582 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Prompt = __webpack_require__(583);
const completer = __webpack_require__(584);

class Input extends Prompt {
  constructor(options) {
    super(options);
    let history = this.options.history;
    if (history && history.store) {
      let initial = history.values || this.initial;
      this.autosave = !!history.autosave;
      this.store = history.store;
      this.data = this.store.get('values') || { past: [], present: initial };
      this.initial = this.data.present || this.data.past[this.data.past.length - 1];
    }
  }

  completion(action) {
    if (!this.store) return this.alert();
    this.data = completer(action, this.data, this.input);
    if (!this.data.present) return this.alert();
    this.input = this.data.present;
    this.cursor = this.input.length;
    return this.render();
  }

  altUp() {
    return this.completion('prev');
  }

  altDown() {
    return this.completion('next');
  }

  prev() {
    this.save();
    return super.prev();
  }

  save() {
    if (!this.store) return;
    this.data = completer('save', this.data, this.input);
    this.store.set('values', this.data);
  }

  submit() {
    if (this.store && this.autosave === true) {
      this.save();
    }
    return super.submit();
  }
}

module.exports = Input;


/***/ }),
/* 583 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Prompt = __webpack_require__(560);
const placeholder = __webpack_require__(578);
const { isPrimitive } = __webpack_require__(557);

class StringPrompt extends Prompt {
  constructor(options) {
    super(options);
    this.initial = isPrimitive(this.initial) ? String(this.initial) : '';
    if (this.initial) this.cursorHide();
    this.state.prevCursor = 0;
    this.state.clipboard = [];
  }

  async keypress(input, key = {}) {
    let prev = this.state.prevKeypress;
    this.state.prevKeypress = key;
    if (this.options.multiline === true && key.name === 'return') {
      if (!prev || prev.name !== 'return') {
        return this.append('\n', key);
      }
    }
    return super.keypress(input, key);
  }

  moveCursor(n) {
    this.cursor += n;
  }

  reset() {
    this.input = this.value = '';
    this.cursor = 0;
    return this.render();
  }

  dispatch(ch, key) {
    if (!ch || key.ctrl || key.code) return this.alert();
    this.append(ch);
  }

  append(ch) {
    let { cursor, input } = this.state;
    this.input = `${input}`.slice(0, cursor) + ch + `${input}`.slice(cursor);
    this.moveCursor(String(ch).length);
    this.render();
  }

  insert(str) {
    this.append(str);
  }

  delete() {
    let { cursor, input } = this.state;
    if (cursor <= 0) return this.alert();
    this.input = `${input}`.slice(0, cursor - 1) + `${input}`.slice(cursor);
    this.moveCursor(-1);
    this.render();
  }

  deleteForward() {
    let { cursor, input } = this.state;
    if (input[cursor] === void 0) return this.alert();
    this.input = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
    this.render();
  }

  cutForward() {
    let pos = this.cursor;
    if (this.input.length <= pos) return this.alert();
    this.state.clipboard.push(this.input.slice(pos));
    this.input = this.input.slice(0, pos);
    this.render();
  }

  cutLeft() {
    let pos = this.cursor;
    if (pos === 0) return this.alert();
    let before = this.input.slice(0, pos);
    let after = this.input.slice(pos);
    let words = before.split(' ');
    this.state.clipboard.push(words.pop());
    this.input = words.join(' ');
    this.cursor = this.input.length;
    this.input += after;
    this.render();
  }

  paste() {
    if (!this.state.clipboard.length) return this.alert();
    this.insert(this.state.clipboard.pop());
    this.render();
  }

  toggleCursor() {
    if (this.state.prevCursor) {
      this.cursor = this.state.prevCursor;
      this.state.prevCursor = 0;
    } else {
      this.state.prevCursor = this.cursor;
      this.cursor = 0;
    }
    this.render();
  }

  first() {
    this.cursor = 0;
    this.render();
  }

  last() {
    this.cursor = this.input.length - 1;
    this.render();
  }

  next() {
    let init = this.initial != null ? String(this.initial) : '';
    if (!init || !init.startsWith(this.input)) return this.alert();
    this.input = this.initial;
    this.cursor = this.initial.length;
    this.render();
  }

  prev() {
    if (!this.input) return this.alert();
    this.reset();
  }

  backward() {
    return this.left();
  }

  forward() {
    return this.right();
  }

  right() {
    if (this.cursor >= this.input.length) return this.alert();
    this.moveCursor(1);
    return this.render();
  }

  left() {
    if (this.cursor <= 0) return this.alert();
    this.moveCursor(-1);
    return this.render();
  }

  isValue(value) {
    return !!value;
  }

  async format(input = this.value) {
    let initial = await this.resolve(this.initial, this.state);
    if (!this.state.submitted) {
      return placeholder(this, { input, initial, pos: this.cursor });
    }
    return this.styles.submitted(input || initial);
  }

  async render() {
    let size = this.state.size;

    let prefix = await this.prefix();
    let separator = await this.separator();
    let message = await this.message();

    let prompt = [prefix, message, separator].filter(Boolean).join(' ');
    this.state.prompt = prompt;

    let header = await this.header();
    let output = await this.format();
    let help = (await this.error()) || (await this.hint());
    let footer = await this.footer();

    if (help && !output.includes(help)) output += ' ' + help;
    prompt += ' ' + output;

    this.clear(size);
    this.write([header, prompt, footer].filter(Boolean).join('\n'));
    this.restore();
  }
}

module.exports = StringPrompt;


/***/ }),
/* 584 */
/***/ ((module) => {

"use strict";


const unique = arr => arr.filter((v, i) => arr.lastIndexOf(v) === i);
const compact = arr => unique(arr).filter(Boolean);

module.exports = (action, data = {}, value = '') => {
  let { past = [], present = '' } = data;
  let rest, prev;

  switch (action) {
    case 'prev':
    case 'undo':
      rest = past.slice(0, past.length - 1);
      prev = past[past.length - 1] || '';
      return {
        past: compact([value, ...rest]),
        present: prev
      };

    case 'next':
    case 'redo':
      rest = past.slice(1);
      prev = past[0] || '';
      return {
        past: compact([...rest, value]),
        present: prev
      };

    case 'save':
      return {
        past: compact([...past, value]),
        present: ''
      };

    case 'remove':
      prev = compact(past.filter(v => v !== value));
      present = '';

      if (prev.length) {
        present = prev.pop();
      }

      return {
        past: prev,
        present
      };

    default: {
      throw new Error(`Invalid action: "${action}"`);
    }
  }
};


/***/ }),
/* 585 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const StringPrompt = __webpack_require__(583);

class InvisiblePrompt extends StringPrompt {
  format() {
    return '';
  }
}

module.exports = InvisiblePrompt;


/***/ }),
/* 586 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const StringPrompt = __webpack_require__(583);

class ListPrompt extends StringPrompt {
  constructor(options = {}) {
    super(options);
    this.sep = this.options.separator || /, */;
    this.initial = options.initial || '';
  }

  split(input = this.value) {
    return input ? String(input).split(this.sep) : [];
  }

  format() {
    let style = this.state.submitted ? this.styles.primary : val => val;
    return this.list.map(style).join(', ');
  }

  async submit(value) {
    let result = this.state.error || await this.validate(this.list, this.state);
    if (result !== true) {
      this.state.error = result;
      return super.submit();
    }
    this.value = this.list;
    return super.submit();
  }

  get list() {
    return this.split();
  }
}

module.exports = ListPrompt;


/***/ }),
/* 587 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Select = __webpack_require__(572);

class MultiSelect extends Select {
  constructor(options) {
    super({ ...options, multiple: true });
  }
}

module.exports = MultiSelect;


/***/ }),
/* 588 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(589);


/***/ }),
/* 589 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const StringPrompt = __webpack_require__(583);

class NumberPrompt extends StringPrompt {
  constructor(options = {}) {
    super({ style: 'number', ...options });
    this.min = this.isValue(options.min) ? this.toNumber(options.min) : -Infinity;
    this.max = this.isValue(options.max) ? this.toNumber(options.max) : Infinity;
    this.delay = options.delay != null ? options.delay : 1000;
    this.float = options.float !== false;
    this.round = options.round === true || options.float === false;
    this.major = options.major || 10;
    this.minor = options.minor || 1;
    this.initial = options.initial != null ? options.initial : '';
    this.input = String(this.initial);
    this.cursor = this.input.length;
    this.cursorShow();
  }

  append(ch) {
    if (!/[-+.]/.test(ch) || (ch === '.' && this.input.includes('.'))) {
      return this.alert('invalid number');
    }
    return super.append(ch);
  }

  number(ch) {
    return super.append(ch);
  }

  next() {
    if (this.input && this.input !== this.initial) return this.alert();
    if (!this.isValue(this.initial)) return this.alert();
    this.input = this.initial;
    this.cursor = String(this.initial).length;
    return this.render();
  }

  up(number) {
    let step = number || this.minor;
    let num = this.toNumber(this.input);
    if (num > this.max + step) return this.alert();
    this.input = `${num + step}`;
    return this.render();
  }

  down(number) {
    let step = number || this.minor;
    let num = this.toNumber(this.input);
    if (num < this.min - step) return this.alert();
    this.input = `${num - step}`;
    return this.render();
  }

  shiftDown() {
    return this.down(this.major);
  }

  shiftUp() {
    return this.up(this.major);
  }

  format(input = this.input) {
    if (typeof this.options.format === 'function') {
      return this.options.format.call(this, input);
    }
    return this.styles.info(input);
  }

  toNumber(value = '') {
    return this.float ? +value : Math.round(+value);
  }

  isValue(value) {
    return /^[-+]?[0-9]+((\.)|(\.[0-9]+))?$/.test(value);
  }

  submit() {
    let value = [this.input, this.initial].find(v => this.isValue(v));
    this.value = this.toNumber(value || 0);
    return super.submit();
  }
}

module.exports = NumberPrompt;


/***/ }),
/* 590 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const StringPrompt = __webpack_require__(583);

class PasswordPrompt extends StringPrompt {
  constructor(options) {
    super(options);
    this.cursorShow();
  }

  format(input = this.input) {
    if (!this.keypressed) return '';
    let color = this.state.submitted ? this.styles.primary : this.styles.muted;
    return color(this.symbols.asterisk.repeat(input.length));
  }
}

module.exports = PasswordPrompt;


/***/ }),
/* 591 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const colors = __webpack_require__(558);
const ArrayPrompt = __webpack_require__(573);
const utils = __webpack_require__(557);

class LikertScale extends ArrayPrompt {
  constructor(options = {}) {
    super(options);
    this.widths = [].concat(options.messageWidth || 50);
    this.align = [].concat(options.align || 'left');
    this.linebreak = options.linebreak || false;
    this.edgeLength = options.edgeLength || 3;
    this.newline = options.newline || '\n   ';
    let start = options.startNumber || 1;
    if (typeof this.scale === 'number') {
      this.scaleKey = false;
      this.scale = Array(this.scale).fill(0).map((v, i) => ({ name: i + start }));
    }
  }

  async reset() {
    this.tableized = false;
    await super.reset();
    return this.render();
  }

  tableize() {
    if (this.tableized === true) return;
    this.tableized = true;
    let longest = 0;

    for (let ch of this.choices) {
      longest = Math.max(longest, ch.message.length);
      ch.scaleIndex = ch.initial || 2;
      ch.scale = [];

      for (let i = 0; i < this.scale.length; i++) {
        ch.scale.push({ index: i });
      }
    }
    this.widths[0] = Math.min(this.widths[0], longest + 3);
  }

  async dispatch(s, key) {
    if (this.multiple) {
      return this[key.name] ? await this[key.name](s, key) : await super.dispatch(s, key);
    }
    this.alert();
  }

  heading(msg, item, i) {
    return this.styles.strong(msg);
  }

  separator() {
    return this.styles.muted(this.symbols.ellipsis);
  }

  right() {
    let choice = this.focused;
    if (choice.scaleIndex >= this.scale.length - 1) return this.alert();
    choice.scaleIndex++;
    return this.render();
  }

  left() {
    let choice = this.focused;
    if (choice.scaleIndex <= 0) return this.alert();
    choice.scaleIndex--;
    return this.render();
  }

  indent() {
    return '';
  }

  format() {
    if (this.state.submitted) {
      let values = this.choices.map(ch => this.styles.info(ch.index));
      return values.join(', ');
    }
    return '';
  }

  pointer() {
    return '';
  }

  /**
   * Render the scale "Key". Something like:
   * @return {String}
   */

  renderScaleKey() {
    if (this.scaleKey === false) return '';
    if (this.state.submitted) return '';
    let scale = this.scale.map(item => `   ${item.name} - ${item.message}`);
    let key = ['', ...scale].map(item => this.styles.muted(item));
    return key.join('\n');
  }

  /**
   * Render the heading row for the scale.
   * @return {String}
   */

  renderScaleHeading(max) {
    let keys = this.scale.map(ele => ele.name);
    if (typeof this.options.renderScaleHeading === 'function') {
      keys = this.options.renderScaleHeading.call(this, max);
    }
    let diff = this.scaleLength - keys.join('').length;
    let spacing = Math.round(diff / (keys.length - 1));
    let names = keys.map(key => this.styles.strong(key));
    let headings = names.join(' '.repeat(spacing));
    let padding = ' '.repeat(this.widths[0]);
    return this.margin[3] + padding + this.margin[1] + headings;
  }

  /**
   * Render a scale indicator =>  or  by default
   */

  scaleIndicator(choice, item, i) {
    if (typeof this.options.scaleIndicator === 'function') {
      return this.options.scaleIndicator.call(this, choice, item, i);
    }
    let enabled = choice.scaleIndex === item.index;
    if (item.disabled) return this.styles.hint(this.symbols.radio.disabled);
    if (enabled) return this.styles.success(this.symbols.radio.on);
    return this.symbols.radio.off;
  }

  /**
   * Render the actual scale => 
   */

  renderScale(choice, i) {
    let scale = choice.scale.map(item => this.scaleIndicator(choice, item, i));
    let padding = this.term === 'Hyper' ? '' : ' ';
    return scale.join(padding + this.symbols.line.repeat(this.edgeLength));
  }

  /**
   * Render a choice, including scale =>
   *   "The website is easy to navigate. "
   */

  async renderChoice(choice, i) {
    await this.onChoice(choice, i);

    let focused = this.index === i;
    let pointer = await this.pointer(choice, i);
    let hint = await choice.hint;

    if (hint && !utils.hasColor(hint)) {
      hint = this.styles.muted(hint);
    }

    let pad = str => this.margin[3] + str.replace(/\s+$/, '').padEnd(this.widths[0], ' ');
    let newline = this.newline;
    let ind = this.indent(choice);
    let message = await this.resolve(choice.message, this.state, choice, i);
    let scale = await this.renderScale(choice, i);
    let margin = this.margin[1] + this.margin[3];
    this.scaleLength = colors.unstyle(scale).length;
    this.widths[0] = Math.min(this.widths[0], this.width - this.scaleLength - margin.length);
    let msg = utils.wordWrap(message, { width: this.widths[0], newline });
    let lines = msg.split('\n').map(line => pad(line) + this.margin[1]);

    if (focused) {
      scale = this.styles.info(scale);
      lines = lines.map(line => this.styles.info(line));
    }

    lines[0] += scale;

    if (this.linebreak) lines.push('');
    return [ind + pointer, lines.join('\n')].filter(Boolean);
  }

  async renderChoices() {
    if (this.state.submitted) return '';
    this.tableize();
    let choices = this.visible.map(async(ch, i) => await this.renderChoice(ch, i));
    let visible = await Promise.all(choices);
    let heading = await this.renderScaleHeading();
    return this.margin[0] + [heading, ...visible.map(v => v.join(' '))].join('\n');
  }

  async render() {
    let { submitted, size } = this.state;

    let prefix = await this.prefix();
    let separator = await this.separator();
    let message = await this.message();

    let prompt = '';
    if (this.options.promptLine !== false) {
      prompt = [prefix, message, separator, ''].join(' ');
      this.state.prompt = prompt;
    }

    let header = await this.header();
    let output = await this.format();
    let key = await this.renderScaleKey();
    let help = await this.error() || await this.hint();
    let body = await this.renderChoices();
    let footer = await this.footer();
    let err = this.emptyError;

    if (output) prompt += output;
    if (help && !prompt.includes(help)) prompt += ' ' + help;

    if (submitted && !output && !body.trim() && this.multiple && err != null) {
      prompt += this.styles.danger(err);
    }

    this.clear(size);
    this.write([header, prompt, key, body, footer].filter(Boolean).join('\n'));
    if (!this.state.submitted) {
      this.write(this.margin[2]);
    }
    this.restore();
  }

  submit() {
    this.value = {};
    for (let choice of this.choices) {
      this.value[choice.name] = choice.scaleIndex;
    }
    return this.base.submit.call(this);
  }
}

module.exports = LikertScale;


/***/ }),
/* 592 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const colors = __webpack_require__(558);
const interpolate = __webpack_require__(593);
const Prompt = __webpack_require__(560);

class SnippetPrompt extends Prompt {
  constructor(options) {
    super(options);
    this.cursorHide();
    this.reset(true);
  }

  async initialize() {
    this.interpolate = await interpolate(this);
    await super.initialize();
  }

  async reset(first) {
    this.state.keys = [];
    this.state.invalid = new Map();
    this.state.missing = new Set();
    this.state.completed = 0;
    this.state.values = {};

    if (first !== true) {
      await this.initialize();
      await this.render();
    }
  }

  moveCursor(n) {
    let item = this.getItem();
    this.cursor += n;
    item.cursor += n;
  }

  dispatch(ch, key) {
    if (!key.code && !key.ctrl && ch != null && this.getItem()) {
      this.append(ch, key);
      return;
    }
    this.alert();
  }

  append(ch, key) {
    let item = this.getItem();
    let prefix = item.input.slice(0, this.cursor);
    let suffix = item.input.slice(this.cursor);
    this.input = item.input = `${prefix}${ch}${suffix}`;
    this.moveCursor(1);
    this.render();
  }

  delete() {
    let item = this.getItem();
    if (this.cursor <= 0 || !item.input) return this.alert();
    let suffix = item.input.slice(this.cursor);
    let prefix = item.input.slice(0, this.cursor - 1);
    this.input = item.input = `${prefix}${suffix}`;
    this.moveCursor(-1);
    this.render();
  }

  increment(i) {
    return i >= this.state.keys.length - 1 ? 0 : i + 1;
  }

  decrement(i) {
    return i <= 0 ? this.state.keys.length - 1 : i - 1;
  }

  first() {
    this.state.index = 0;
    this.render();
  }

  last() {
    this.state.index = this.state.keys.length - 1;
    this.render();
  }

  right() {
    if (this.cursor >= this.input.length) return this.alert();
    this.moveCursor(1);
    this.render();
  }

  left() {
    if (this.cursor <= 0) return this.alert();
    this.moveCursor(-1);
    this.render();
  }

  prev() {
    this.state.index = this.decrement(this.state.index);
    this.getItem();
    this.render();
  }

  next() {
    this.state.index = this.increment(this.state.index);
    this.getItem();
    this.render();
  }

  up() {
    this.prev();
  }

  down() {
    this.next();
  }

  format(value) {
    let color = this.state.completed < 100 ? this.styles.warning : this.styles.success;
    if (this.state.submitted === true && this.state.completed !== 100) {
      color = this.styles.danger;
    }
    return color(`${this.state.completed}% completed`);
  }

  async render() {
    let { index, keys = [], submitted, size } = this.state;

    let newline = [this.options.newline, '\n'].find(v => v != null);
    let prefix = await this.prefix();
    let separator = await this.separator();
    let message = await this.message();

    let prompt = [prefix, message, separator].filter(Boolean).join(' ');
    this.state.prompt = prompt;

    let header = await this.header();
    let error = (await this.error()) || '';
    let hint = (await this.hint()) || '';
    let body = submitted ? '' : await this.interpolate(this.state);

    let key = this.state.key = keys[index] || '';
    let input = await this.format(key);
    let footer = await this.footer();
    if (input) prompt += ' ' + input;
    if (hint && !input && this.state.completed === 0) prompt += ' ' + hint;

    this.clear(size);
    let lines = [header, prompt, body, footer, error.trim()];
    this.write(lines.filter(Boolean).join(newline));
    this.restore();
  }

  getItem(name) {
    let { items, keys, index } = this.state;
    let item = items.find(ch => ch.name === keys[index]);
    if (item && item.input != null) {
      this.input = item.input;
      this.cursor = item.cursor;
    }
    return item;
  }

  async submit() {
    if (typeof this.interpolate !== 'function') await this.initialize();
    await this.interpolate(this.state, true);

    let { invalid, missing, output, values } = this.state;
    if (invalid.size) {
      let err = '';
      for (let [key, value] of invalid) err += `Invalid ${key}: ${value}\n`;
      this.state.error = err;
      return super.submit();
    }

    if (missing.size) {
      this.state.error = 'Required: ' + [...missing.keys()].join(', ');
      return super.submit();
    }

    let lines = colors.unstyle(output).split('\n');
    let result = lines.map(v => v.slice(1)).join('\n');
    this.value = { values, result };
    return super.submit();
  }
}

module.exports = SnippetPrompt;


/***/ }),
/* 593 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const colors = __webpack_require__(558);
const clean = (str = '') => {
  return typeof str === 'string' ? str.replace(/^['"]|['"]$/g, '') : '';
};

/**
 * This file contains the interpolation and rendering logic for
 * the Snippet prompt.
 */

class Item {
  constructor(token) {
    this.name = token.key;
    this.field = token.field || {};
    this.value = clean(token.initial || this.field.initial || '');
    this.message = token.message || this.name;
    this.cursor = 0;
    this.input = '';
    this.lines = [];
  }
}

const tokenize = async(options = {}, defaults = {}, fn = token => token) => {
  let unique = new Set();
  let fields = options.fields || [];
  let input = options.template;
  let tabstops = [];
  let items = [];
  let keys = [];
  let line = 1;

  if (typeof input === 'function') {
    input = await input();
  }

  let i = -1;
  let next = () => input[++i];
  let peek = () => input[i + 1];
  let push = token => {
    token.line = line;
    tabstops.push(token);
  };

  push({ type: 'bos', value: '' });

  while (i < input.length - 1) {
    let value = next();

    if (/^[^\S\n ]$/.test(value)) {
      push({ type: 'text', value });
      continue;
    }

    if (value === '\n') {
      push({ type: 'newline', value });
      line++;
      continue;
    }

    if (value === '\\') {
      value += next();
      push({ type: 'text', value });
      continue;
    }

    if ((value === '$' || value === '#' || value === '{') && peek() === '{') {
      let n = next();
      value += n;

      let token = { type: 'template', open: value, inner: '', close: '', value };
      let ch;

      while ((ch = next())) {
        if (ch === '}') {
          if (peek() === '}') ch += next();
          token.value += ch;
          token.close = ch;
          break;
        }

        if (ch === ':') {
          token.initial = '';
          token.key = token.inner;
        } else if (token.initial !== void 0) {
          token.initial += ch;
        }

        token.value += ch;
        token.inner += ch;
      }

      token.template = token.open + (token.initial || token.inner) + token.close;
      token.key = token.key || token.inner;

      if (defaults.hasOwnProperty(token.key)) {
        token.initial = defaults[token.key];
      }

      token = fn(token);
      push(token);

      keys.push(token.key);
      unique.add(token.key);

      let item = items.find(item => item.name === token.key);
      token.field = fields.find(ch => ch.name === token.key);

      if (!item) {
        item = new Item(token);
        items.push(item);
      }

      item.lines.push(token.line - 1);
      continue;
    }

    let last = tabstops[tabstops.length - 1];
    if (last.type === 'text' && last.line === line) {
      last.value += value;
    } else {
      push({ type: 'text', value });
    }
  }

  push({ type: 'eos', value: '' });
  return { input, tabstops, unique, keys, items };
};

module.exports = async prompt => {
  let options = prompt.options;
  let required = new Set(options.required === true ? [] : (options.required || []));
  let defaults = { ...options.values, ...options.initial };
  let { tabstops, items, keys } = await tokenize(options, defaults);

  let result = createFn('result', prompt, options);
  let format = createFn('format', prompt, options);
  let isValid = createFn('validate', prompt, options, true);
  let isVal = prompt.isValue.bind(prompt);

  return async(state = {}, submitted = false) => {
    let index = 0;

    state.required = required;
    state.items = items;
    state.keys = keys;
    state.output = '';

    let validate = async(value, state, item, index) => {
      let error = await isValid(value, state, item, index);
      if (error === false) {
        return 'Invalid field ' + item.name;
      }
      return error;
    };

    for (let token of tabstops) {
      let value = token.value;
      let key = token.key;

      if (token.type !== 'template') {
        if (value) state.output += value;
        continue;
      }

      if (token.type === 'template') {
        let item = items.find(ch => ch.name === key);

        if (options.required === true) {
          state.required.add(item.name);
        }

        let val = [item.input, state.values[item.value], item.value, value].find(isVal);
        let field = item.field || {};
        let message = field.message || token.inner;

        if (submitted) {
          let error = await validate(state.values[key], state, item, index);
          if ((error && typeof error === 'string') || error === false) {
            state.invalid.set(key, error);
            continue;
          }

          state.invalid.delete(key);
          let res = await result(state.values[key], state, item, index);
          state.output += colors.unstyle(res);
          continue;
        }

        item.placeholder = false;

        let before = value;
        value = await format(value, state, item, index);

        if (val !== value) {
          state.values[key] = val;
          value = prompt.styles.typing(val);
          state.missing.delete(message);

        } else {
          state.values[key] = void 0;
          val = `<${message}>`;
          value = prompt.styles.primary(val);
          item.placeholder = true;

          if (state.required.has(key)) {
            state.missing.add(message);
          }
        }

        if (state.missing.has(message) && state.validating) {
          value = prompt.styles.warning(val);
        }

        if (state.invalid.has(key) && state.validating) {
          value = prompt.styles.danger(val);
        }

        if (index === state.index) {
          if (before !== value) {
            value = prompt.styles.underline(value);
          } else {
            value = prompt.styles.heading(colors.unstyle(value));
          }
        }

        index++;
      }

      if (value) {
        state.output += value;
      }
    }

    let lines = state.output.split('\n').map(l => ' ' + l);
    let len = items.length;
    let done = 0;

    for (let item of items) {
      if (state.invalid.has(item.name)) {
        item.lines.forEach(i => {
          if (lines[i][0] !== ' ') return;
          lines[i] = state.styles.danger(state.symbols.bullet) + lines[i].slice(1);
        });
      }

      if (prompt.isValue(state.values[item.name])) {
        done++;
      }
    }

    state.completed = ((done / len) * 100).toFixed(0);
    state.output = lines.join('\n');
    return state.output;
  };
};

function createFn(prop, prompt, options, fallback) {
  return (value, state, item, index) => {
    if (typeof item.field[prop] === 'function') {
      return item.field[prop].call(prompt, value, state, item, index);
    }
    return [fallback, value].find(v => prompt.isValue(v));
  };
}


/***/ }),
/* 594 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const hint = '(Use <shift>+<up/down> to sort)';
const Prompt = __webpack_require__(572);

class Sort extends Prompt {
  constructor(options) {
    super({ ...options, reorder: false, sort: true, multiple: true });
    this.state.hint = [this.options.hint, hint].find(this.isValue.bind(this));
  }

  indicator() {
    return '';
  }

  async renderChoice(choice, i) {
    let str = await super.renderChoice(choice, i);
    let sym = this.symbols.identicalTo + ' ';
    let pre = (this.index === i && this.sorting) ? this.styles.muted(sym) : '  ';
    if (this.options.drag === false) pre = '';
    if (this.options.numbered === true) {
      return pre + `${i + 1} - ` + str;
    }
    return pre + str;
  }

  get selected() {
    return this.choices;
  }

  submit() {
    this.value = this.choices.map(choice => choice.value);
    return super.submit();
  }
}

module.exports = Sort;


/***/ }),
/* 595 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ArrayPrompt = __webpack_require__(573);

class Survey extends ArrayPrompt {
  constructor(options = {}) {
    super(options);
    this.emptyError = options.emptyError || 'No items were selected';
    this.term = process.env.TERM_PROGRAM;

    if (!this.options.header) {
      let header = ['', '4 - Strongly Agree', '3 - Agree', '2 - Neutral', '1 - Disagree', '0 - Strongly Disagree', ''];
      header = header.map(ele => this.styles.muted(ele));
      this.state.header = header.join('\n   ');
    }
  }

  async toChoices(...args) {
    if (this.createdScales) return false;
    this.createdScales = true;
    let choices = await super.toChoices(...args);
    for (let choice of choices) {
      choice.scale = createScale(5, this.options);
      choice.scaleIdx = 2;
    }
    return choices;
  }

  dispatch() {
    this.alert();
  }

  space() {
    let choice = this.focused;
    let ele = choice.scale[choice.scaleIdx];
    let selected = ele.selected;
    choice.scale.forEach(e => (e.selected = false));
    ele.selected = !selected;
    return this.render();
  }

  indicator() {
    return '';
  }

  pointer() {
    return '';
  }

  separator() {
    return this.styles.muted(this.symbols.ellipsis);
  }

  right() {
    let choice = this.focused;
    if (choice.scaleIdx >= choice.scale.length - 1) return this.alert();
    choice.scaleIdx++;
    return this.render();
  }

  left() {
    let choice = this.focused;
    if (choice.scaleIdx <= 0) return this.alert();
    choice.scaleIdx--;
    return this.render();
  }

  indent() {
    return '   ';
  }

  async renderChoice(item, i) {
    await this.onChoice(item, i);
    let focused = this.index === i;
    let isHyper = this.term === 'Hyper';
    let n = !isHyper ? 8 : 9;
    let s = !isHyper ? ' ' : '';
    let ln = this.symbols.line.repeat(n);
    let sp = ' '.repeat(n + (isHyper ? 0 : 1));
    let dot = enabled => (enabled ? this.styles.success('') : '') + s;

    let num = i + 1 + '.';
    let color = focused ? this.styles.heading : this.styles.noop;
    let msg = await this.resolve(item.message, this.state, item, i);
    let indent = this.indent(item);
    let scale = indent + item.scale.map((e, i) => dot(i === item.scaleIdx)).join(ln);
    let val = i => i === item.scaleIdx ? color(i) : i;
    let next = indent + item.scale.map((e, i) => val(i)).join(sp);

    let line = () => [num, msg].filter(Boolean).join(' ');
    let lines = () => [line(), scale, next, ' '].filter(Boolean).join('\n');

    if (focused) {
      scale = this.styles.cyan(scale);
      next = this.styles.cyan(next);
    }

    return lines();
  }

  async renderChoices() {
    if (this.state.submitted) return '';
    let choices = this.visible.map(async(ch, i) => await this.renderChoice(ch, i));
    let visible = await Promise.all(choices);
    if (!visible.length) visible.push(this.styles.danger('No matching choices'));
    return visible.join('\n');
  }

  format() {
    if (this.state.submitted) {
      let values = this.choices.map(ch => this.styles.info(ch.scaleIdx));
      return values.join(', ');
    }
    return '';
  }

  async render() {
    let { submitted, size } = this.state;

    let prefix = await this.prefix();
    let separator = await this.separator();
    let message = await this.message();

    let prompt = [prefix, message, separator].filter(Boolean).join(' ');
    this.state.prompt = prompt;

    let header = await this.header();
    let output = await this.format();
    let help = await this.error() || await this.hint();
    let body = await this.renderChoices();
    let footer = await this.footer();

    if (output || !help) prompt += ' ' + output;
    if (help && !prompt.includes(help)) prompt += ' ' + help;

    if (submitted && !output && !body && this.multiple && this.type !== 'form') {
      prompt += this.styles.danger(this.emptyError);
    }

    this.clear(size);
    this.write([prompt, header, body, footer].filter(Boolean).join('\n'));
    this.restore();
  }

  submit() {
    this.value = {};
    for (let choice of this.choices) {
      this.value[choice.name] = choice.scaleIdx;
    }
    return this.base.submit.call(this);
  }
}

function createScale(n, options = {}) {
  if (Array.isArray(options.scale)) {
    return options.scale.map(ele => ({ ...ele }));
  }
  let scale = [];
  for (let i = 1; i < n + 1; i++) scale.push({ i, selected: false });
  return scale;
}

module.exports = Survey;


/***/ }),
/* 596 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(582);


/***/ }),
/* 597 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BooleanPrompt = __webpack_require__(580);

class TogglePrompt extends BooleanPrompt {
  async initialize() {
    await super.initialize();
    this.value = this.initial = !!this.options.initial;
    this.disabled = this.options.disabled || 'no';
    this.enabled = this.options.enabled || 'yes';
    await this.render();
  }

  reset() {
    this.value = this.initial;
    this.render();
  }

  delete() {
    this.alert();
  }

  toggle() {
    this.value = !this.value;
    this.render();
  }

  enable() {
    if (this.value === true) return this.alert();
    this.value = true;
    this.render();
  }
  disable() {
    if (this.value === false) return this.alert();
    this.value = false;
    this.render();
  }

  up() {
    this.toggle();
  }
  down() {
    this.toggle();
  }
  right() {
    this.toggle();
  }
  left() {
    this.toggle();
  }
  next() {
    this.toggle();
  }
  prev() {
    this.toggle();
  }

  dispatch(ch = '', key) {
    switch (ch.toLowerCase()) {
      case ' ':
        return this.toggle();
      case '1':
      case 'y':
      case 't':
        return this.enable();
      case '0':
      case 'n':
      case 'f':
        return this.disable();
      default: {
        return this.alert();
      }
    }
  }

  format() {
    let active = str => this.styles.primary.underline(str);
    let value = [
      this.value ? this.disabled : active(this.disabled),
      this.value ? active(this.enabled) : this.enabled
    ];
    return value.join(this.styles.muted(' / '));
  }

  async render() {
    let { size } = this.state;

    let header = await this.header();
    let prefix = await this.prefix();
    let separator = await this.separator();
    let message = await this.message();

    let output = await this.format();
    let help = (await this.error()) || (await this.hint());
    let footer = await this.footer();

    let prompt = [prefix, message, separator, output].join(' ');
    this.state.prompt = prompt;

    if (help && !prompt.includes(help)) prompt += ' ' + help;

    this.clear(size);
    this.write([header, prompt, footer].filter(Boolean).join('\n'));
    this.write(this.margin[2]);
    this.restore();
  }
}

module.exports = TogglePrompt;


/***/ }),
/* 598 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const SelectPrompt = __webpack_require__(572);

class Quiz extends SelectPrompt {
  constructor(options) {
    super(options);
    if (typeof this.options.correctChoice !== 'number' || this.options.correctChoice < 0) {
      throw new Error('Please specify the index of the correct answer from the list of choices');
    }
  }

  async toChoices(value, parent) {
    let choices = await super.toChoices(value, parent);
    if (choices.length < 2) {
      throw new Error('Please give at least two choices to the user');
    }
    if (this.options.correctChoice > choices.length) {
      throw new Error('Please specify the index of the correct answer from the list of choices');
    }
    return choices;
  }

  check(state) {
    return state.index === this.options.correctChoice;
  }

  async result(selected) {
    return {
      selectedAnswer: selected,
      correctAnswer: this.options.choices[this.options.correctChoice].value,
      correct: await this.check(this.state)
    };
  }
}

module.exports = Quiz;


/***/ }),
/* 599 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  ArrayPrompt: __webpack_require__(573),
  AuthPrompt: __webpack_require__(576),
  BooleanPrompt: __webpack_require__(580),
  NumberPrompt: __webpack_require__(589),
  StringPrompt: __webpack_require__(583)
};


/***/ }),
/* 600 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Target": () => /* binding */ Target,
/* harmony export */   "Modifier": () => /* binding */ Modifier,
/* harmony export */   "Strategy": () => /* binding */ Strategy,
/* harmony export */   "getModifier": () => /* binding */ getModifier,
/* harmony export */   "extractRangeModifier": () => /* binding */ extractRangeModifier,
/* harmony export */   "applyModifier": () => /* binding */ applyModifier,
/* harmony export */   "findProjectDescriptors": () => /* binding */ findProjectDescriptors,
/* harmony export */   "extractDescriptorFromPath": () => /* binding */ extractDescriptorFromPath,
/* harmony export */   "getSuggestedDescriptors": () => /* binding */ getSuggestedDescriptors,
/* harmony export */   "fetchDescriptorFrom": () => /* binding */ fetchDescriptorFrom
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(335);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(155);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);




var Target;

(function (Target) {
  Target["REGULAR"] = "dependencies";
  Target["DEVELOPMENT"] = "devDependencies";
  Target["PEER"] = "peerDependencies";
})(Target || (Target = {}));

var Modifier;

(function (Modifier) {
  Modifier["CARET"] = "^";
  Modifier["TILDE"] = "~";
  Modifier["EXACT"] = "";
})(Modifier || (Modifier = {}));

var Strategy;

(function (Strategy) {
  /**
   * If set, the suggest engine will offer to keep the current version if the
   * local workspace already depends on it.
   */
  Strategy["KEEP"] = "keep";
  /**
   * If set, the suggest engine will offer to fulfill the request by looking at
   * the ranges currently used by the other workspaces in the project.
   */

  Strategy["REUSE"] = "reuse";
  /**
   * If set, the suggest engine will offer to fulfill the request by using any
   * workspace whose name would match the request.
   */

  Strategy["PROJECT"] = "project";
  /**
   * If set, the suggest engine will offer to fulfill the request by using
   * whatever `<request-name>@latest` would return.
   */

  Strategy["LATEST"] = "latest";
  /**
   * If set, the suggest engine will offer to fulfill the request based on the
   * versions of the package that are already within our cache.
   */

  Strategy["CACHE"] = "cache";
})(Strategy || (Strategy = {}));

function getModifier(flags, project) {
  if (flags.exact) return Modifier.EXACT;
  if (flags.caret) return Modifier.CARET;
  if (flags.tilde) return Modifier.TILDE;
  return project.configuration.get(`defaultSemverRangePrefix`);
}
const SIMPLE_SEMVER = /^([\^~]?)[0-9]+(?:\.[0-9]+){0,2}(?:-\S+)?$/;
function extractRangeModifier(range, {
  project
}) {
  const match = range.match(SIMPLE_SEMVER);
  return match ? match[1] : project.configuration.get(`defaultSemverRangePrefix`);
}
function applyModifier(descriptor, modifier) {
  let {
    protocol,
    source,
    params,
    selector
  } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.parseRange(descriptor.range);
  if (semver__WEBPACK_IMPORTED_MODULE_0___default().valid(selector)) selector = `${modifier}${descriptor.range}`;
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeDescriptor(descriptor, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeRange({
    protocol,
    source,
    params,
    selector
  }));
}
async function findProjectDescriptors(ident, {
  project,
  target
}) {
  const matches = new Map();

  const getDescriptorEntry = descriptor => {
    let entry = matches.get(descriptor.descriptorHash);

    if (!entry) {
      matches.set(descriptor.descriptorHash, entry = {
        descriptor,
        locators: []
      });
    }

    return entry;
  };

  for (const workspace of project.workspaces) {
    if (target === Target.PEER) {
      const peerDescriptor = workspace.manifest.peerDependencies.get(ident.identHash);

      if (peerDescriptor !== undefined) {
        getDescriptorEntry(peerDescriptor).locators.push(workspace.locator);
      }
    } else {
      const regularDescriptor = workspace.manifest.dependencies.get(ident.identHash);
      const developmentDescriptor = workspace.manifest.devDependencies.get(ident.identHash);

      if (target === Target.DEVELOPMENT) {
        if (developmentDescriptor !== undefined) {
          getDescriptorEntry(developmentDescriptor).locators.push(workspace.locator);
        } else if (regularDescriptor !== undefined) {
          getDescriptorEntry(regularDescriptor).locators.push(workspace.locator);
        }
      } else {
        if (regularDescriptor !== undefined) {
          getDescriptorEntry(regularDescriptor).locators.push(workspace.locator);
        } else if (developmentDescriptor !== undefined) {
          getDescriptorEntry(developmentDescriptor).locators.push(workspace.locator);
        }
      }
    }
  }

  return matches;
}
async function extractDescriptorFromPath(path, {
  cwd,
  workspace
}) {
  // We use a temporary cache so that we don't pollute the project cache with temporary archives
  return await makeTemporaryCache(async cache => {
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path)) {
      path = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.relative(workspace.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(cwd, path));

      if (!path.match(/^\.{0,2}\//)) {
        path = `./${path}`;
      }
    }

    const {
      project
    } = workspace;
    const descriptor = await fetchDescriptorFrom(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeIdent(null, `archive`), path, {
      project: workspace.project,
      cache,
      workspace
    });
    if (!descriptor) throw new Error(`Assertion failed: The descriptor should have been found`);
    const report = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ThrowReport();
    const resolver = project.configuration.makeResolver();
    const fetcher = project.configuration.makeFetcher();
    const resolverOptions = {
      checksums: project.storedChecksums,
      project,
      cache,
      fetcher,
      report,
      resolver
    }; // While not useful since it's an absolute path, descriptor always have to be bound before being sent to the fetchers

    const boundDescriptor = resolver.bindDescriptor(descriptor, workspace.anchoredLocator, resolverOptions); // Since it's a file, we assume the returned descriptor is a valid locator

    const locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.convertDescriptorToLocator(boundDescriptor);
    const fetchResult = await fetcher.fetch(locator, resolverOptions);
    const manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Manifest.find(fetchResult.prefixPath, {
      baseFs: fetchResult.packageFs
    });
    if (!manifest.name) throw new Error(`Target path doesn't have a name`);
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeDescriptor(manifest.name, path);
  });
}
async function getSuggestedDescriptors(request, {
  project,
  workspace,
  cache,
  target,
  modifier,
  strategies,
  maxResults = Infinity
}) {
  if (!(maxResults >= 0)) throw new Error(`Invalid maxResults (${maxResults})`);

  if (request.range !== `unknown`) {
    return {
      suggestions: [{
        descriptor: request,
        name: `Use ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.prettyDescriptor(project.configuration, request)}`,
        reason: `(unambiguous explicit request)`
      }],
      rejections: []
    };
  }

  const existing = typeof workspace !== `undefined` && workspace !== null ? workspace.manifest[target].get(request.identHash) || null : null;
  const suggested = [];
  const rejected = [];

  const trySuggest = async cb => {
    try {
      await cb();
    } catch (e) {
      rejected.push(e);
    }
  };

  for (const strategy of strategies) {
    if (suggested.length >= maxResults) break;

    switch (strategy) {
      case Strategy.KEEP:
        {
          await trySuggest(async () => {
            if (existing) {
              suggested.push({
                descriptor: existing,
                name: `Keep ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.prettyDescriptor(project.configuration, existing)}`,
                reason: `(no changes)`
              });
            }
          });
        }
        break;

      case Strategy.REUSE:
        {
          await trySuggest(async () => {
            for (const {
              descriptor,
              locators
            } of (await findProjectDescriptors(request, {
              project,
              target
            })).values()) {
              // We don't print the "reuse" key for the current workspace if the KEEP strategy is set since that would be redundant
              if (locators.length === 1 && locators[0].locatorHash === workspace.anchoredLocator.locatorHash) if (strategies.includes(Strategy.KEEP)) continue;
              let reason = `(originally used by ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.prettyLocator(project.configuration, locators[0])}`;
              reason += locators.length > 1 ? ` and ${locators.length - 1} other${locators.length > 2 ? `s` : ``})` : `)`;
              suggested.push({
                descriptor,
                name: `Reuse ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.prettyDescriptor(project.configuration, descriptor)}`,
                reason
              });
            }
          });
        }
        break;

      case Strategy.CACHE:
        {
          await trySuggest(async () => {
            for (const descriptor of project.storedDescriptors.values()) {
              if (descriptor.identHash === request.identHash) {
                suggested.push({
                  descriptor,
                  name: `Reuse ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.prettyDescriptor(project.configuration, descriptor)}`,
                  reason: `(already used somewhere in the lockfile)`
                });
              }
            }
          });
        }
        break;

      case Strategy.PROJECT:
        {
          await trySuggest(async () => {
            // Don't suggest a workspace to depend on itself
            if (workspace.manifest.name !== null && request.identHash === workspace.manifest.name.identHash) return;
            const candidateWorkspace = project.tryWorkspaceByIdent(request);
            if (candidateWorkspace === null) return;
            suggested.push({
              descriptor: candidateWorkspace.anchoredDescriptor,
              name: `Attach ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.prettyWorkspace(project.configuration, candidateWorkspace)}`,
              reason: `(local workspace at ${candidateWorkspace.cwd})`
            });
          });
        }
        break;

      case Strategy.LATEST:
        {
          await trySuggest(async () => {
            if (request.range !== `unknown`) {
              suggested.push({
                descriptor: request,
                name: `Use ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.prettyRange(project.configuration, request.range)}`,
                reason: `(explicit range requested)`
              });
            } else if (target === Target.PEER) {
              suggested.push({
                descriptor: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeDescriptor(request, `*`),
                name: `Use *`,
                reason: `(catch-all peer dependency pattern)`
              });
            } else if (!project.configuration.get(`enableNetwork`)) {
              suggested.push({
                descriptor: null,
                name: `Resolve from latest`,
                reason: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.pretty(project.configuration, `(unavailable because enableNetwork is toggled off)`, `grey`)
              });
            } else {
              let latest = await fetchDescriptorFrom(request, `latest`, {
                project,
                cache,
                workspace,
                preserveModifier: false
              });

              if (latest) {
                latest = applyModifier(latest, modifier);
                suggested.push({
                  descriptor: latest,
                  name: `Use ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.prettyDescriptor(project.configuration, latest)}`,
                  reason: `(resolved from latest)`
                });
              }
            }
          });
        }
        break;
    }
  }

  return {
    suggestions: suggested.slice(0, maxResults),
    rejections: rejected.slice(0, maxResults)
  };
}
async function fetchDescriptorFrom(ident, range, {
  project,
  cache,
  workspace,
  preserveModifier = true
}) {
  const latestDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeDescriptor(ident, range);
  const report = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ThrowReport();
  const fetcher = project.configuration.makeFetcher();
  const resolver = project.configuration.makeResolver();
  const fetchOptions = {
    project,
    fetcher,
    cache,
    checksums: project.storedChecksums,
    report,
    skipIntegrityCheck: true
  };
  const resolveOptions = { ...fetchOptions,
    resolver,
    fetchOptions
  }; // The descriptor has to be bound for the resolvers that need a parent locator. (e.g. FileResolver)
  // If we didn't bind it, `yarn add ./folder` wouldn't work.

  const boundDescriptor = resolver.bindDescriptor(latestDescriptor, workspace.anchoredLocator, resolveOptions);
  const candidateLocators = await resolver.getCandidates(boundDescriptor, new Map(), resolveOptions);
  if (candidateLocators.length === 0) return null; // Per the requirements exposed in Resolver.ts, the best is the first one

  const bestLocator = candidateLocators[0];
  let {
    protocol,
    source,
    params,
    selector
  } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.parseRange(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.convertToManifestRange(bestLocator.reference));
  if (protocol === project.configuration.get(`defaultProtocol`)) protocol = null;

  if (semver__WEBPACK_IMPORTED_MODULE_0___default().valid(selector) && preserveModifier !== false) {
    const referenceRange = typeof preserveModifier === `string` ? preserveModifier : latestDescriptor.range;
    const modifier = extractRangeModifier(referenceRange, {
      project
    });
    selector = modifier + selector;
  }

  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeDescriptor(bestLocator, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeRange({
    protocol,
    source,
    params,
    selector
  }));
}

async function makeTemporaryCache(cb) {
  return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mktempPromise(async cacheDir => {
    const configuration = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Configuration.create(cacheDir);
    configuration.useWithSource(cacheDir, {
      // Don't pollute the mirror with temporary archives
      enableMirror: false,
      // Don't spend time compressing what gets deleted later
      compressionLevel: 0
    }, cacheDir, {
      overwrite: true
    });
    return await cb(new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Cache(cacheDir, {
      configuration,
      check: false,
      immutable: false
    }));
  });
}

/***/ }),
/* 601 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ BinCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(340);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);




 // eslint-disable-next-line arca/no-default-export

class BinCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.verbose = false;
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      locator
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    await project.restoreInstallState();

    if (this.name) {
      const binaries = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.getPackageAccessibleBinaries(locator, {
        project
      });
      const binary = binaries.get(this.name);
      if (!binary) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a binary named "${this.name}" for package "${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.prettyLocator(configuration, locator)}"`);
      const [,
      /*pkg*/
      binaryFile] = binary;
      this.context.stdout.write(`${binaryFile}\n`);
      return 0;
    }

    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      const binaries = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.getPackageAccessibleBinaries(locator, {
        project
      });
      const keys = Array.from(binaries.keys());
      const maxKeyLength = keys.reduce((max, key) => Math.max(max, key.length), 0);

      for (const [name, [pkg, binaryFile]] of binaries) {
        report.reportJson({
          name,
          source: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.stringifyIdent(pkg),
          path: binaryFile
        });
      }

      if (this.verbose) {
        for (const [name, [pkg]] of binaries) {
          report.reportInfo(null, `${name.padEnd(maxKeyLength, ` `)}   ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.prettyLocator(configuration, pkg)}`);
        }
      } else {
        for (const name of binaries.keys()) {
          report.reportInfo(null, name);
        }
      }
    });
    return report.exitCode();
  }

}
BinCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `get the path to a binary script`,
  details: `
      When used without arguments, this command will print the list of all the binaries available in the current workspace. Adding the \`-v,--verbose\` flag will cause the output to contain both the binary name and the locator of the package that provides the binary.

      When an argument is specified, this command will just print the path to the binary on the standard output and exit. Note that the reported path may be stored within a zip archive.
    `,
  examples: [[`List all the available binaries`, `$0 bin`], [`Print the path to a specific binary`, `$0 bin eslint`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String({
  required: false
})], BinCommand.prototype, "name", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-v,--verbose`, {
  description: `Print both the binary name and the locator of the package that provides the binary`
})], BinCommand.prototype, "verbose", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], BinCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`bin`)], BinCommand.prototype, "execute", null);

/***/ }),
/* 602 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ CacheCleanCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(155);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);




 // eslint-disable-next-line arca/no-default-export

class CacheCleanCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.mirror = false;
    this.all = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Cache.find(configuration);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async () => {
      const cleanMirror = (this.all || this.mirror) && cache.mirrorCwd !== null;
      const cleanCache = !this.mirror;
      if (cleanMirror) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.removePromise(cache.mirrorCwd);

      if (cleanCache) {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.removePromise(cache.cwd);
      }
    });
    return report.exitCode();
  }

}
CacheCleanCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `remove the shared cache files`,
  details: `
      This command will remove all the files from the cache.
    `,
  examples: [[`Remove all the local archives`, `$0 cache clean`], [`Remove all the archives stored in the ~/.yarn directory`, `$0 cache clean --mirror`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--mirror`, {
  description: `Remove the global cache files instead of the local cache files`
})], CacheCleanCommand.prototype, "mirror", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--all`, {
  description: `Remove both the global cache files and the local cache files of the current project`
})], CacheCleanCommand.prototype, "all", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`cache`, `clean`)], CacheCleanCommand.prototype, "execute", null);

/***/ }),
/* 603 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ ConfigSetCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(374);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(517);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);





 // eslint-disable-next-line arca/no-default-export

class ConfigSetCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
    this.unsafe = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const name = this.name.replace(/[.[].*$/, ``);
    const path = this.name.replace(/^[^.[]*/, ``);
    const setting = configuration.settings.get(name);
    if (typeof setting === `undefined`) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a configuration settings named "${name}"`);
    const displayedValue = configuration.getSpecial(name, {
      hideSecrets: !this.unsafe,
      getNativePaths: true
    });
    const asObject = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.convertMapsToIndexableObjects(displayedValue);
    const requestedObject = path ? lodash_get__WEBPACK_IMPORTED_MODULE_2___default()(asObject, path) : asObject;
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.StreamReport.start({
      configuration,
      includeFooter: false,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      report.reportJson(requestedObject);
    });

    if (!this.json) {
      if (typeof requestedObject === `string`) {
        this.context.stdout.write(`${requestedObject}\n`);
        return report.exitCode();
      } // @ts-expect-error: The Node typings forgot one field


      util__WEBPACK_IMPORTED_MODULE_3__.inspect.styles.name = `cyan`;
      this.context.stdout.write(`${(0,util__WEBPACK_IMPORTED_MODULE_3__.inspect)(requestedObject, {
        depth: Infinity,
        colors: configuration.get(`enableColors`),
        compact: false
      })}\n`);
    }

    return report.exitCode();
  }

}
ConfigSetCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `read a configuration settings`,
  details: `
      This command will print a configuration setting.

      Secrets (such as tokens) will be redacted from the output by default. If this behavior isn't desired, set the \`--no-redacted\` to get the untransformed value.
    `,
  examples: [[`Print a simple configuration setting`, `yarn config get yarnPath`], [`Print a complex configuration setting`, `yarn config get packageExtensions`], [`Print a nested field from the configuration`, `yarn config get 'npmScopes["my-company"].npmRegistryServer'`], [`Print a token from the configuration`, `yarn config get npmAuthToken --no-redacted`], [`Print a configuration setting as JSON`, `yarn config get packageExtensions --json`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], ConfigSetCommand.prototype, "name", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], ConfigSetCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--no-redacted`, {
  description: `Don't redact secrets (such as tokens) from the output`
})], ConfigSetCommand.prototype, "unsafe", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`config`, `get`)], ConfigSetCommand.prototype, "execute", null);

/***/ }),
/* 604 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ ConfigSetCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(180);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(605);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(517);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(606);
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_set__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(90);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_5__);







 // eslint-disable-next-line arca/no-default-export

class ConfigSetCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
    this.home = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Configuration.find(this.context.cwd, this.context.plugins);
    if (!configuration.projectCwd) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`This command must be run from within a project folder`);
    const name = this.name.replace(/[.[].*$/, ``);
    const path = this.name.replace(/^[^.[]*\.?/, ``);
    const setting = configuration.settings.get(name);
    if (typeof setting === `undefined`) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a configuration settings named "${name}"`);
    const value = this.json ? JSON.parse(this.value) : this.value;
    const updateConfiguration = this.home ? patch => _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Configuration.updateHomeConfiguration(patch) : patch => _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Configuration.updateConfiguration(configuration.projectCwd, patch);
    await updateConfiguration(current => {
      if (path) {
        const clone = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_2___default()(current);
        lodash_set__WEBPACK_IMPORTED_MODULE_4___default()(clone, this.name, value);
        return clone;
      } else {
        return { ...current,
          [name]: value
        };
      }
    });
    const updatedConfiguration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Configuration.find(this.context.cwd, this.context.plugins);
    const displayedValue = updatedConfiguration.getSpecial(name, {
      hideSecrets: true,
      getNativePaths: true
    });
    const asObject = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.convertMapsToIndexableObjects(displayedValue);
    const requestedObject = path ? lodash_get__WEBPACK_IMPORTED_MODULE_3___default()(asObject, path) : asObject;
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.StreamReport.start({
      configuration,
      includeFooter: false,
      stdout: this.context.stdout
    }, async report => {
      // @ts-expect-error: The Node typings forgot one field
      util__WEBPACK_IMPORTED_MODULE_5__.inspect.styles.name = `cyan`;
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Successfully set ${this.name} to ${(0,util__WEBPACK_IMPORTED_MODULE_5__.inspect)(requestedObject, {
        depth: Infinity,
        colors: configuration.get(`enableColors`),
        compact: false
      })}`);
    });
    return report.exitCode();
  }

}
ConfigSetCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `change a configuration settings`,
  details: `
      This command will set a configuration setting.

      When used without the \`--json\` flag, it can only set a simple configuration setting (a string, a number, or a boolean).

      When used with the \`--json\` flag, it can set both simple and complex configuration settings, including Arrays and Objects.
    `,
  examples: [[`Set a simple configuration setting (a string, a number, or a boolean)`, `yarn config set initScope myScope`], [`Set a simple configuration setting (a string, a number, or a boolean) using the \`--json\` flag`, `yarn config set initScope --json \\"myScope\\"`], [`Set a complex configuration setting (an Array) using the \`--json\` flag`, `yarn config set unsafeHttpWhitelist --json '["*.example.com", "example.com"]'`], [`Set a complex configuration setting (an Object) using the \`--json\` flag`, `yarn config set packageExtensions --json '{ "@babel/parser@*": { "dependencies": { "@babel/types": "*" } } }'`], [`Set a nested configuration setting`, `yarn config set npmScopes.company.npmRegistryServer "https://npm.example.com"`], [`Set a nested configuration setting using indexed access for non-simple keys`, `yarn config set 'npmRegistries["//npm.example.com"].npmAuthToken' "ffffffff-ffff-ffff-ffff-ffffffffffff"`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], ConfigSetCommand.prototype, "name", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], ConfigSetCommand.prototype, "value", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`, {
  description: `Set complex configuration settings to JSON values`
})], ConfigSetCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-H,--home`, {
  description: `Update the home configuration instead of the project configuration`
})], ConfigSetCommand.prototype, "home", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`config`, `set`)], ConfigSetCommand.prototype, "execute", null);

/***/ }),
/* 605 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(420);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),
/* 606 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSet = __webpack_require__(310);

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;


/***/ }),
/* 607 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ ConfigCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(177);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);





 // eslint-disable-next-line arca/no-default-export

class ConfigCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.verbose = false;
    this.why = false;
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins, {
      strict: false
    });
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      if (configuration.invalid.size > 0 && !this.json) {
        for (const [key, source] of configuration.invalid) report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.INVALID_CONFIGURATION_KEY, `Invalid configuration key "${key}" in ${source}`);

        report.reportSeparator();
      }

      if (this.json) {
        const keys = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.sortMap(configuration.settings.keys(), key => key);

        for (const key of keys) {
          const data = configuration.settings.get(key);
          const effective = configuration.getSpecial(key, {
            hideSecrets: true,
            getNativePaths: true
          });
          const source = configuration.sources.get(key);

          if (this.verbose) {
            report.reportJson({
              key,
              effective,
              source
            });
          } else {
            report.reportJson({
              key,
              effective,
              source,
              ...data
            });
          }
        }
      } else {
        const keys = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.sortMap(configuration.settings.keys(), key => key);
        const maxKeyLength = keys.reduce((max, key) => Math.max(max, key.length), 0);
        const inspectConfig = {
          breakLength: Infinity,
          colors: configuration.get(`enableColors`),
          maxArrayLength: 2
        };

        if (this.why || this.verbose) {
          const keysAndDescriptions = keys.map(key => {
            const setting = configuration.settings.get(key);
            if (!setting) throw new Error(`Assertion failed: This settings ("${key}") should have been registered`);
            const description = this.why ? configuration.sources.get(key) || `<default>` : setting.description;
            return [key, description];
          });
          const maxDescriptionLength = keysAndDescriptions.reduce((max, [, description]) => {
            return Math.max(max, description.length);
          }, 0);

          for (const [key, description] of keysAndDescriptions) {
            report.reportInfo(null, `${key.padEnd(maxKeyLength, ` `)}   ${description.padEnd(maxDescriptionLength, ` `)}   ${(0,util__WEBPACK_IMPORTED_MODULE_2__.inspect)(configuration.getSpecial(key, {
              hideSecrets: true,
              getNativePaths: true
            }), inspectConfig)}`);
          }
        } else {
          for (const key of keys) {
            report.reportInfo(null, `${key.padEnd(maxKeyLength, ` `)}   ${(0,util__WEBPACK_IMPORTED_MODULE_2__.inspect)(configuration.getSpecial(key, {
              hideSecrets: true,
              getNativePaths: true
            }), inspectConfig)}`);
          }
        }
      }
    });
    return report.exitCode();
  }

}
ConfigCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `display the current configuration`,
  details: `
      This command prints the current active configuration settings.
    `,
  examples: [[`Print the active configuration settings`, `$0 config`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-v,--verbose`, {
  description: `Print the setting description on top of the regular key/value information`
})], ConfigCommand.prototype, "verbose", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--why`, {
  description: `Print the reason why a setting is set a particular way`
})], ConfigCommand.prototype, "why", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], ConfigCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`config`)], ConfigCommand.prototype, "execute", null);

/***/ }),
/* 608 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ DedupeCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(374);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var yup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(413);
/* harmony import */ var _dedupeUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(609);
/**
 * Prior work:
 * - https://github.com/atlassian/yarn-deduplicate
 * - https://github.com/eps1lon/yarn-plugin-deduplicate
 *
 * Goals of the `dedupe` command:
 * - the deduplication algorithms shouldn't depend on semver; they should instead use the resolver `getSatisfying` system
 * - the deduplication should happen concurrently
 *
 * Note: We don't restore the install state because we already have everything we need inside the
 * lockfile. Because of this, we use `project.originalPackages` instead of `project.storedPackages`
 * (which also provides a safe-guard in case virtual descriptors ever make their way into the dedupe algorithm).
 */





 // eslint-disable-next-line arca/no-default-export

class DedupeCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.patterns = [];
    this.strategy = _dedupeUtils__WEBPACK_IMPORTED_MODULE_3__.Strategy.HIGHEST;
    this.check = false;
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Cache.find(configuration);
    let dedupedPackageCount = 0;
    const dedupeReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.StreamReport.start({
      configuration,
      includeFooter: false,
      stdout: this.context.stdout,
      json: this.json
    }, async report => {
      dedupedPackageCount = await _dedupeUtils__WEBPACK_IMPORTED_MODULE_3__.dedupe(project, {
        strategy: this.strategy,
        patterns: this.patterns,
        cache,
        report
      });
    });
    if (dedupeReport.hasErrors()) return dedupeReport.exitCode();

    if (this.check) {
      return dedupedPackageCount ? 1 : 0;
    } else {
      const installReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.StreamReport.start({
        configuration,
        stdout: this.context.stdout,
        json: this.json
      }, async report => {
        await project.install({
          cache,
          report
        });
      });
      return installReport.exitCode();
    }
  }

}
DedupeCommand.schema = yup__WEBPACK_IMPORTED_MODULE_2__.object().shape({
  strategy: yup__WEBPACK_IMPORTED_MODULE_2__.string().test({
    name: `strategy`,
    message: `\${path} must be one of \${strategies}`,
    params: {
      strategies: [..._dedupeUtils__WEBPACK_IMPORTED_MODULE_3__.acceptedStrategies].join(`, `)
    },
    test: strategy => {
      return _dedupeUtils__WEBPACK_IMPORTED_MODULE_3__.acceptedStrategies.has(strategy);
    }
  })
});
DedupeCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `deduplicate dependencies with overlapping ranges`,
  details: `
      Duplicates are defined as descriptors with overlapping ranges being resolved and locked to different locators. They are a natural consequence of Yarn's deterministic installs, but they can sometimes pile up and unnecessarily increase the size of your project.

      This command dedupes dependencies in the current project using different strategies (only one is implemented at the moment):

      - \`highest\`: Reuses (where possible) the locators with the highest versions. This means that dependencies can only be upgraded, never downgraded. It's also guaranteed that it never takes more than a single pass to dedupe the entire dependency tree.

      **Note:** Even though it never produces a wrong dependency tree, this command should be used with caution, as it modifies the dependency tree, which can sometimes cause problems when packages don't strictly follow semver recommendations. Because of this, it is recommended to also review the changes manually.

      If set, the \`-c,--check\` flag will only report the found duplicates, without persisting the modified dependency tree. If changes are found, the command will exit with a non-zero exit code, making it suitable for CI purposes.

      This command accepts glob patterns as arguments (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.

      ### In-depth explanation:

      Yarn doesn't deduplicate dependencies by default, otherwise installs wouldn't be deterministic and the lockfile would be useless. What it actually does is that it tries to not duplicate dependencies in the first place.

      **Example:** If \`foo@^2.3.4\` (a dependency of a dependency) has already been resolved to \`foo@2.3.4\`, running \`yarn add foo@*\`will cause Yarn to reuse \`foo@2.3.4\`, even if the latest \`foo\` is actually \`foo@2.10.14\`, thus preventing unnecessary duplication.

      Duplication happens when Yarn can't unlock dependencies that have already been locked inside the lockfile.

      **Example:** If \`foo@^2.3.4\` (a dependency of a dependency) has already been resolved to \`foo@2.3.4\`, running \`yarn add foo@2.10.14\` will cause Yarn to install \`foo@2.10.14\` because the existing resolution doesn't satisfy the range \`2.10.14\`. This behavior can lead to (sometimes) unwanted duplication, since now the lockfile contains 2 separate resolutions for the 2 \`foo\` descriptors, even though they have overlapping ranges, which means that the lockfile can be simplified so that both descriptors resolve to \`foo@2.10.14\`.
    `,
  examples: [[`Dedupe all packages`, `$0 dedupe`], [`Dedupe all packages using a specific strategy`, `$0 dedupe --strategy highest`], [`Dedupe a specific package`, `$0 dedupe lodash`], [`Dedupe all packages with the \`@babel/*\` scope`, `$0 dedupe '@babel/*'`], [`Check for duplicates (can be used as a CI step)`, `$0 dedupe --check`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Rest()], DedupeCommand.prototype, "patterns", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`-s,--strategy`, {
  description: `The strategy to use when deduping dependencies`
})], DedupeCommand.prototype, "strategy", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-c,--check`, {
  description: `Exit with exit code 1 when duplicates are found, without persisting the dependency tree`
})], DedupeCommand.prototype, "check", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], DedupeCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`dedupe`)], DedupeCommand.prototype, "execute", null);

/***/ }),
/* 609 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Strategy": () => /* binding */ Strategy,
/* harmony export */   "acceptedStrategies": () => /* binding */ acceptedStrategies,
/* harmony export */   "dedupe": () => /* binding */ dedupe
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(335);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(13);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_0__);



var Strategy;

(function (Strategy) {
  /**
   * This strategy dedupes a locator to the best candidate already installed in the project.
   *
   * Because of this, it's guaranteed that:
   * - it never takes more than a single pass to dedupe all dependencies
   * - dependencies are never downgraded
   */
  Strategy["HIGHEST"] = "highest";
})(Strategy || (Strategy = {}));

const acceptedStrategies = new Set(Object.values(Strategy));
const DEDUPE_ALGORITHMS = {
  highest: async (project, patterns, {
    resolver,
    fetcher,
    resolveOptions,
    fetchOptions
  }) => {
    const locatorsByIdent = new Map();

    for (const [descriptorHash, locatorHash] of project.storedResolutions) {
      const descriptor = project.storedDescriptors.get(descriptorHash);
      if (typeof descriptor === `undefined`) throw new Error(`Assertion failed: The descriptor (${descriptorHash}) should have been registered`);
      _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.getSetWithDefault(locatorsByIdent, descriptor.identHash).add(locatorHash);
    }

    return Array.from(project.storedDescriptors.values(), async descriptor => {
      if (patterns.length && !micromatch__WEBPACK_IMPORTED_MODULE_0___default().isMatch(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyIdent(descriptor), patterns)) return null;
      const currentResolution = project.storedResolutions.get(descriptor.descriptorHash);
      if (typeof currentResolution === `undefined`) throw new Error(`Assertion failed: The resolution (${descriptor.descriptorHash}) should have been registered`); // We only care about resolutions that are stored in the lockfile
      // (we shouldn't accidentally try deduping virtual packages)

      const currentPackage = project.originalPackages.get(currentResolution);
      if (typeof currentPackage === `undefined`) return null; // No need to try deduping packages that are not persisted,
      // they will be resolved again anyways

      if (!resolver.shouldPersistResolution(currentPackage, resolveOptions)) return null;
      const locators = locatorsByIdent.get(descriptor.identHash);
      if (typeof locators === `undefined`) throw new Error(`Assertion failed: The resolutions (${descriptor.identHash}) should have been registered`); // No need to choose when there's only one possibility

      if (locators.size === 1) return null;
      const references = [...locators].map(locatorHash => {
        const pkg = project.originalPackages.get(locatorHash);
        if (typeof pkg === `undefined`) throw new Error(`Assertion failed: The package (${locatorHash}) should have been registered`);
        return pkg.reference;
      });
      const candidates = await resolver.getSatisfying(descriptor, references, resolveOptions);
      const bestCandidate = candidates === null || candidates === void 0 ? void 0 : candidates[0];
      if (typeof bestCandidate === `undefined`) return null;
      const updatedResolution = bestCandidate.locatorHash;
      const updatedPackage = project.originalPackages.get(updatedResolution);
      if (typeof updatedPackage === `undefined`) throw new Error(`Assertion failed: The package (${updatedResolution}) should have been registered`);
      if (updatedResolution === currentResolution) return null;
      return {
        descriptor,
        currentPackage,
        updatedPackage
      };
    });
  }
};
async function dedupe(project, {
  strategy,
  patterns,
  cache,
  report
}) {
  const {
    configuration
  } = project;
  const throwReport = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ThrowReport();
  const resolver = configuration.makeResolver();
  const fetcher = configuration.makeFetcher();
  const fetchOptions = {
    cache,
    checksums: project.storedChecksums,
    fetcher,
    project,
    report: throwReport,
    skipIntegrityCheck: true
  };
  const resolveOptions = {
    project,
    resolver,
    report: throwReport,
    fetchOptions
  };
  return await report.startTimerPromise(`Deduplication step`, async () => {
    const algorithm = DEDUPE_ALGORITHMS[strategy];
    const dedupePromises = await algorithm(project, patterns, {
      resolver,
      resolveOptions,
      fetcher,
      fetchOptions
    });
    const progress = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Report.progressViaCounter(dedupePromises.length);
    report.reportProgress(progress);
    let dedupedPackageCount = 0;
    await Promise.all(dedupePromises.map(dedupePromise => dedupePromise.then(dedupe => {
      if (dedupe === null) return;
      dedupedPackageCount++;
      const {
        descriptor,
        currentPackage,
        updatedPackage
      } = dedupe;
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.UNNAMED, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.prettyDescriptor(configuration, descriptor)} can be deduped from ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.prettyLocator(configuration, currentPackage)} to ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.prettyLocator(configuration, updatedPackage)}`);
      report.reportJson({
        descriptor: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyDescriptor(descriptor),
        currentResolution: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyLocator(currentPackage),
        updatedResolution: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyLocator(updatedPackage)
      });
      project.storedResolutions.set(descriptor.descriptorHash, updatedPackage.locatorHash);
    }).finally(() => progress.tick())));
    let packages;

    switch (dedupedPackageCount) {
      case 0:
        {
          packages = `No packages`;
        }
        break;

      case 1:
        {
          packages = `One package`;
        }
        break;

      default:
        {
          packages = `${dedupedPackageCount} packages`;
        }
    }

    const prettyStrategy = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.pretty(configuration, strategy, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Type.CODE);
    report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.UNNAMED, `${packages} can be deduped using the ${prettyStrategy} strategy`);
    return dedupedPackageCount;
  });
}

/***/ }),
/* 610 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ ClipanionCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(181);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);


 // eslint-disable-next-line arca/no-default-export

class ClipanionCommand extends clipanion__WEBPACK_IMPORTED_MODULE_0__.Command {
  async execute() {
    const {
      plugins
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.Configuration.find(this.context.cwd, this.context.plugins);
    const pluginDefinitions = [];

    for (const plugin of plugins) {
      const {
        commands
      } = plugin[1];

      if (commands) {
        const cli = clipanion__WEBPACK_IMPORTED_MODULE_0__.Cli.from(commands);
        const definitions = cli.definitions();
        pluginDefinitions.push([plugin[0], definitions]);
      }
    }

    const clipanionDefinitions = this.cli.definitions();

    const arePathsEqual = (path1, path2) => path1.split(` `).slice(1).join() === path2.split(` `).slice(1).join();

    const defaultPlugins = __webpack_require__(611)[`@yarnpkg/builder`].bundles.standard;

    for (const pluginDefinition of pluginDefinitions) {
      const definitions = pluginDefinition[1];

      for (const definition of definitions) {
        clipanionDefinitions.find(clipanionDefinition => arePathsEqual(clipanionDefinition.path, definition.path)).plugin = {
          name: pluginDefinition[0],
          isDefault: defaultPlugins.includes(pluginDefinition[0])
        };
      }
    }

    this.context.stdout.write(`${JSON.stringify({
      commands: clipanionDefinitions
    }, null, 2)}\n`);
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`--clipanion=definitions`)], ClipanionCommand.prototype, "execute", null);

/***/ }),
/* 611 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"name\":\"@yarnpkg/cli\",\"version\":\"2.3.3\",\"license\":\"BSD-2-Clause\",\"main\":\"./sources/index.ts\",\"dependencies\":{\"@yarnpkg/core\":\"workspace:^2.3.1\",\"@yarnpkg/fslib\":\"workspace:^2.3.0\",\"@yarnpkg/libzip\":\"workspace:^2.2.1\",\"@yarnpkg/parsers\":\"workspace:^2.3.0\",\"@yarnpkg/plugin-compat\":\"workspace:^2.1.2\",\"@yarnpkg/plugin-dlx\":\"workspace:^2.1.3\",\"@yarnpkg/plugin-essentials\":\"workspace:^2.3.2\",\"@yarnpkg/plugin-file\":\"workspace:^2.2.0\",\"@yarnpkg/plugin-git\":\"workspace:^2.2.0\",\"@yarnpkg/plugin-github\":\"workspace:^2.1.1\",\"@yarnpkg/plugin-http\":\"workspace:^2.1.1\",\"@yarnpkg/plugin-init\":\"workspace:^2.2.1\",\"@yarnpkg/plugin-link\":\"workspace:^2.1.1\",\"@yarnpkg/plugin-node-modules\":\"workspace:^2.2.2\",\"@yarnpkg/plugin-npm\":\"workspace:^2.3.0\",\"@yarnpkg/plugin-npm-cli\":\"workspace:^2.2.0\",\"@yarnpkg/plugin-pack\":\"workspace:^2.2.2\",\"@yarnpkg/plugin-patch\":\"workspace:^2.1.2\",\"@yarnpkg/plugin-pnp\":\"workspace:^2.3.1\",\"@yarnpkg/shell\":\"workspace:^2.4.0\",\"chalk\":\"^3.0.0\",\"ci-info\":\"^2.0.0\",\"clipanion\":\"^2.6.2\",\"fromentries\":\"^1.2.0\",\"semver\":\"^7.1.2\",\"tslib\":\"^1.13.0\",\"yup\":\"^0.27.0\"},\"devDependencies\":{\"@types/ci-info\":\"^2\",\"@types/yup\":\"0.26.12\",\"@yarnpkg/builder\":\"workspace:^2.1.2\",\"@yarnpkg/monorepo\":\"workspace:0.0.0\",\"@yarnpkg/pnpify\":\"workspace:^2.3.3\",\"micromatch\":\"^4.0.2\",\"typescript\":\"4.1.0-beta\"},\"peerDependencies\":{\"@yarnpkg/core\":\"^2.3.1\"},\"scripts\":{\"postpack\":\"rm -rf lib\",\"prepack\":\"run build:compile \\\"$(pwd)\\\"\",\"build:cli+hook\":\"run build:pnp:hook && builder build bundle\",\"build:cli\":\"builder build bundle\",\"run:cli\":\"builder run\",\"update-local\":\"run build:cli --no-git-hash && rsync -a --delete bundles/ bin/\"},\"publishConfig\":{\"main\":\"./lib/index.js\",\"types\":\"./lib/index.d.ts\",\"bin\":null},\"files\":[\"/lib/**/*\",\"!/lib/pluginConfiguration.*\",\"!/lib/cli.*\"],\"@yarnpkg/builder\":{\"bundles\":{\"standard\":[\"@yarnpkg/plugin-essentials\",\"@yarnpkg/plugin-compat\",\"@yarnpkg/plugin-dlx\",\"@yarnpkg/plugin-file\",\"@yarnpkg/plugin-git\",\"@yarnpkg/plugin-github\",\"@yarnpkg/plugin-http\",\"@yarnpkg/plugin-init\",\"@yarnpkg/plugin-link\",\"@yarnpkg/plugin-node-modules\",\"@yarnpkg/plugin-npm\",\"@yarnpkg/plugin-npm-cli\",\"@yarnpkg/plugin-pack\",\"@yarnpkg/plugin-patch\",\"@yarnpkg/plugin-pnp\"]}},\"repository\":{\"type\":\"git\",\"url\":\"ssh://git@github.com/yarnpkg/berry.git\"},\"engines\":{\"node\":\">=10.19.0\"}}");

/***/ }),
/* 612 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ HelpCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);

 // eslint-disable-next-line arca/no-default-export

class HelpCommand extends clipanion__WEBPACK_IMPORTED_MODULE_0__.Command {
  async execute() {
    this.context.stdout.write(this.cli.usage(null));
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`help`), clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`--help`), clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`-h`)], HelpCommand.prototype, "execute", null);

/***/ }),
/* 613 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ EntryCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);



 // eslint-disable-next-line arca/no-default-export

class EntryCommand extends clipanion__WEBPACK_IMPORTED_MODULE_0__.Command {
  constructor() {
    super(...arguments);
    this.args = [];
  }

  async execute() {
    if (this.leadingArgument.match(/[\\/]/) && !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.tryParseIdent(this.leadingArgument)) {
      const newCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(this.leadingArgument));
      return await this.cli.run(this.args, {
        cwd: newCwd
      });
    } else {
      return await this.cli.run([`run`, this.leadingArgument, ...this.args]);
    }
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.String()], EntryCommand.prototype, "leadingArgument", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Proxy()], EntryCommand.prototype, "args", void 0);

/***/ }),
/* 614 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ VersionCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(372);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);


 // eslint-disable-next-line arca/no-default-export

class VersionCommand extends clipanion__WEBPACK_IMPORTED_MODULE_0__.Command {
  async execute() {
    this.context.stdout.write(`${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.YarnVersion || `<unknown>`}\n`);
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`-v`), clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`--version`)], VersionCommand.prototype, "execute", null);

/***/ }),
/* 615 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ ExecCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(373);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(340);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(155);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);





 // eslint-disable-next-line arca/no-default-export

class ExecCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.args = [];
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mktempPromise(async binFolder => {
      const {
        code
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.pipevp(this.commandName, this.args, {
        cwd: this.context.cwd,
        stdin: this.context.stdin,
        stdout: this.context.stdout,
        stderr: this.context.stderr,
        env: await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.makeScriptEnv({
          project,
          binFolder
        })
      });
      return code;
    });
  }

}
ExecCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `execute a shell command`,
  details: `
      This command simply executes a shell binary within the context of the root directory of the active workspace.

      It also makes sure to call it in a way that's compatible with the current project (for example, on PnP projects the environment will be setup in such a way that PnP will be correctly injected into the environment).
    `,
  examples: [[`Execute a shell command`, `$0 exec echo Hello World`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], ExecCommand.prototype, "commandName", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Proxy()], ExecCommand.prototype, "args", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`exec`)], ExecCommand.prototype, "execute", null);

/***/ }),
/* 616 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ InfoCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(335);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(411);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(155);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_2__);





 // eslint-disable-next-line arca/no-default-export

class InfoCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.all = false;
    this.recursive = false;
    this.extra = [];
    this.cache = false;
    this.dependents = false;
    this.manifest = false;
    this.nameOnly = false;
    this.virtuals = false;
    this.json = false;
    this.patterns = [];
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Cache.find(configuration);
    if (!workspace && !this.all) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    await project.restoreInstallState();
    const extraSet = new Set(this.extra);
    if (this.cache) extraSet.add(`cache`);
    if (this.dependents) extraSet.add(`dependents`);
    if (this.manifest) extraSet.add(`manifest`);

    const traverseWorkspace = (workspace, {
      recursive
    }) => {
      const initialHash = workspace.anchoredLocator.locatorHash;
      const seen = new Map();
      const pass = [initialHash];

      while (pass.length > 0) {
        const hash = pass.shift();
        if (seen.has(hash)) continue;
        const pkg = project.storedPackages.get(hash);
        if (typeof pkg === `undefined`) throw new Error(`Assertion failed: Expected the package to be registered`);
        seen.set(hash, pkg);
        if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.isVirtualLocator(pkg)) pass.push(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.devirtualizeLocator(pkg).locatorHash);
        if (!recursive && hash !== initialHash) continue;

        for (const dependency of pkg.dependencies.values()) {
          const resolution = project.storedResolutions.get(dependency.descriptorHash);
          if (typeof resolution === `undefined`) throw new Error(`Assertion failed: Expected the resolution to be registered`);
          pass.push(resolution);
        }
      }

      return seen.values();
    };

    const traverseAllWorkspaces = ({
      recursive
    }) => {
      const aggregate = new Map();

      for (const workspace of project.workspaces) for (const pkg of traverseWorkspace(workspace, {
        recursive
      })) aggregate.set(pkg.locatorHash, pkg);

      return aggregate.values();
    };

    const getLookupSet = ({
      all,
      recursive
    }) => {
      // Optimization: if both -A and -R are set, it means we care about the
      // whole set of packages, no need for filtering
      if (all && recursive) return project.storedPackages.values();

      if (all) {
        return traverseAllWorkspaces({
          recursive
        });
      } else {
        return traverseWorkspace(workspace, {
          recursive
        });
      }
    };

    const findSelectedSet = ({
      all,
      recursive
    }) => {
      const lookupSet = getLookupSet({
        all,
        recursive
      });
      const matchers = this.patterns.map(pattern => {
        const patternLocator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.parseLocator(pattern);
        const identRegex = micromatch__WEBPACK_IMPORTED_MODULE_2___default().makeRe(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyIdent(patternLocator));
        const patternIsVirtual = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.isVirtualLocator(patternLocator);
        const uvPatternLocator = patternIsVirtual ? _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.devirtualizeLocator(patternLocator) : patternLocator;
        return pkg => {
          const stringifiedIdent = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyIdent(pkg);
          if (!identRegex.test(stringifiedIdent)) return false;
          if (patternLocator.reference === `unknown`) return true;
          const pkgIsVirtual = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.isVirtualLocator(pkg);
          const uvPkgLocator = pkgIsVirtual ? _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.devirtualizeLocator(pkg) : pkg; // If the pattern is explicitly virtual, we only accept this one virtual package, never the others

          if (patternIsVirtual && pkgIsVirtual && patternLocator.reference !== pkg.reference) return false; // We only accept that belong to the current reference (or its base if it's a virtual package)

          if (uvPatternLocator.reference !== uvPkgLocator.reference) return false;
          return true;
        };
      });
      const sortedLookup = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.sortMap([...lookupSet], pkg => {
        return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyLocator(pkg);
      });
      const selection = sortedLookup.filter(pkg => {
        return matchers.length === 0 || matchers.some(matcher => matcher(pkg));
      });
      return {
        selection,
        sortedLookup
      };
    };

    const {
      selection,
      sortedLookup
    } = findSelectedSet({
      all: this.all,
      recursive: this.recursive
    });
    if (selection.length === 0) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`No package matched your request`);
    const dependentMap = new Map();

    if (this.dependents) {
      for (const pkg of sortedLookup) {
        for (const dependency of pkg.dependencies.values()) {
          const resolution = project.storedResolutions.get(dependency.descriptorHash);
          if (typeof resolution === `undefined`) throw new Error(`Assertion failed: Expected the resolution to be registered`);
          _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.getArrayWithDefault(dependentMap, resolution).push(pkg);
        }
      }
    }

    const allInstances = new Map();

    for (const pkg of sortedLookup) {
      if (!_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.isVirtualLocator(pkg)) continue;
      const base = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.devirtualizeLocator(pkg);
      _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.getArrayWithDefault(allInstances, base.locatorHash).push(pkg);
    }

    const infoTreeChildren = {};
    const infoTree = {
      children: infoTreeChildren
    };
    const fetcher = configuration.makeFetcher();
    const fetcherOptions = {
      project,
      fetcher,
      cache,
      checksums: project.storedChecksums,
      report: new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.ThrowReport(),
      skipIntegrityCheck: true
    };
    const builtinInfoBuilders = [// Manifest fields
    async (pkg, extra, registerData) => {
      var _a, _b;

      if (!extra.has(`manifest`)) return;
      const fetchResult = await fetcher.fetch(pkg, fetcherOptions);
      let manifest;

      try {
        manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.Manifest.find(fetchResult.prefixPath, {
          baseFs: fetchResult.packageFs
        });
      } finally {
        (_a = fetchResult.releaseFs) === null || _a === void 0 ? void 0 : _a.call(fetchResult);
      }

      registerData(`Manifest`, {
        [`License`]: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.NO_HINT, manifest.license),
        [`Homepage`]: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.URL, (_b = manifest.raw.homepage) !== null && _b !== void 0 ? _b : null)
      });
    }, // Cache info
    async (pkg, extra, registerData) => {
      var _a;

      if (!extra.has(`cache`)) return;
      const checksum = (_a = project.storedChecksums.get(pkg.locatorHash)) !== null && _a !== void 0 ? _a : null;
      const cachePath = cache.getLocatorPath(pkg, checksum);
      let stat;

      if (cachePath !== null) {
        try {
          stat = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.statSync(cachePath);
        } catch (_b) {}
      }

      const size = typeof stat !== `undefined` ? [stat.size, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.SIZE] : undefined;
      registerData(`Cache`, {
        [`Checksum`]: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.NO_HINT, checksum),
        [`Path`]: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.PATH, cachePath),
        [`Size`]: size
      });
    }];

    for (const pkg of selection) {
      const isVirtual = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.isVirtualLocator(pkg);
      if (!this.virtuals && isVirtual) continue;
      const nodeChildren = {};
      const node = {
        value: [pkg, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.LOCATOR],
        children: nodeChildren
      };
      infoTreeChildren[_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyLocator(pkg)] = node;

      if (this.nameOnly) {
        delete node.children;
        continue;
      }

      const instances = allInstances.get(pkg.locatorHash);

      if (typeof instances !== `undefined`) {
        nodeChildren.Instances = {
          label: `Instances`,
          value: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.NUMBER, instances.length)
        };
      }

      nodeChildren.Version = {
        label: `Version`,
        value: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.NO_HINT, pkg.version)
      };

      const registerData = (namespace, info) => {
        const namespaceNode = {};
        nodeChildren[namespace] = namespaceNode;

        if (Array.isArray(info)) {
          namespaceNode.children = info.map(value => ({
            value
          }));
        } else {
          const namespaceChildren = {};
          namespaceNode.children = namespaceChildren;

          for (const [key, value] of Object.entries(info)) {
            if (typeof value === `undefined`) continue;
            namespaceChildren[key] = {
              label: key,
              value
            };
          }
        }
      };

      if (!isVirtual) {
        for (const infoBuilder of builtinInfoBuilders) await infoBuilder(pkg, extraSet, registerData);

        await configuration.triggerHook(hooks => {
          return hooks.fetchPackageInfo;
        }, pkg, extraSet, registerData);
      }

      if (pkg.bin.size > 0 && !isVirtual) {
        registerData(`Exported Binaries`, [...pkg.bin.keys()].map(name => {
          return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.PATH, name);
        }));
      }

      const dependents = dependentMap.get(pkg.locatorHash);

      if (typeof dependents !== `undefined` && dependents.length > 0) {
        registerData(`Dependents`, dependents.map(dependent => {
          return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.LOCATOR, dependent);
        }));
      }

      if (pkg.dependencies.size > 0 && !isVirtual) {
        registerData(`Dependencies`, [...pkg.dependencies.values()].map(dependency => {
          var _a;

          const resolutionHash = project.storedResolutions.get(dependency.descriptorHash);
          const resolution = typeof resolutionHash !== `undefined` ? (_a = project.storedPackages.get(resolutionHash)) !== null && _a !== void 0 ? _a : null : null;
          return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.RESOLUTION, {
            descriptor: dependency,
            locator: resolution
          });
        }));
      }

      if (pkg.peerDependencies.size > 0 && isVirtual) {
        registerData(`Peer dependencies`, [...pkg.peerDependencies.values()].map(peerDependency => {
          var _a, _b;

          const dependency = pkg.dependencies.get(peerDependency.identHash);
          const resolutionHash = typeof dependency !== `undefined` ? (_a = project.storedResolutions.get(dependency.descriptorHash)) !== null && _a !== void 0 ? _a : null : null;
          const resolution = resolutionHash !== null ? (_b = project.storedPackages.get(resolutionHash)) !== null && _b !== void 0 ? _b : null : null;
          return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.RESOLUTION, {
            descriptor: peerDependency,
            locator: resolution
          });
        }));
      }
    }

    _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.emitTree(infoTree, {
      configuration,
      json: this.json,
      stdout: this.context.stdout,
      separators: this.nameOnly ? 0 : 2
    });
  }

}
InfoCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `see information related to packages`,
  details: `
      This command prints various information related to the specified packages, accepting glob patterns.

      By default, if the locator reference is missing, Yarn will default to print the information about all the matching direct dependencies of the package for the active workspace. To instead print all versions of the package that are direct dependencies of any of your workspaces, use the \`-A,--all\` flag. Adding the \`-R,--recursive\` flag will also report transitive dependencies.

      Some fields will be hidden by default in order to keep the output readable, but can be selectively displayed by using additional options (\`--dependents\`, \`--manifest\`, \`--virtuals\`, ...) described in the option descriptions.

      Note that this command will only print the information directly related to the selected packages - if you wish to know why the package is there in the first place, use \`yarn why\` which will do just that (it also provides a \`-R,--recursive\` flag that may be of some help).
    `,
  examples: [[`Show information about Lodash`, `$0 info lodash`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-A,--all`, {
  description: `Print versions of a package from the whole project`
})], InfoCommand.prototype, "all", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-R,--recursive`, {
  description: `Print information for all packages, including transitive dependencies`
})], InfoCommand.prototype, "recursive", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Array(`-X,--extra`, {
  description: `An array of requests of extra data provided by plugins`
})], InfoCommand.prototype, "extra", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--cache`, {
  description: `Print information about the cache entry of a package (path, size, checksum)`
})], InfoCommand.prototype, "cache", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--dependents`, {
  description: `Print all dependents for each matching package`
})], InfoCommand.prototype, "dependents", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--manifest`, {
  description: `Print data obtained by looking at the package archive (license, homepage, ...)`
})], InfoCommand.prototype, "manifest", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--name-only`, {
  description: `Only print the name for the matching packages`
})], InfoCommand.prototype, "nameOnly", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--virtuals`, {
  description: `Print each instance of the virtual packages`
})], InfoCommand.prototype, "virtuals", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], InfoCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Rest()], InfoCommand.prototype, "patterns", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`info`)], InfoCommand.prototype, "execute", null);

/***/ }),
/* 617 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ YarnCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(182);
/* harmony import */ var ci_info__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var ci_info__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ci_info__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);






 // eslint-disable-next-line arca/no-default-export

class YarnCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
    this.checkCache = false;
    this.skipBuilds = false;
    this.silent = false;
  }

  async execute() {
    var _a, _b, _c;

    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    if (typeof this.inlineBuilds !== `undefined`) configuration.useWithSource(`<cli>`, {
      enableInlineBuilds: this.inlineBuilds
    }, configuration.startingCwd, {
      overwrite: true
    });
    const isZeitNow = !!process.env.NOW_BUILDER;
    const isNetlify = !!process.env.NETLIFY; // These variables are used in Google Cloud Platform environment
    // in process of deploying Google Cloud Functions and
    // Google App Engine

    const isGCP = !!process.env.FUNCTION_TARGET || !!process.env.GOOGLE_RUNTIME;

    const reportDeprecation = async (message, {
      error
    }) => {
      const deprecationReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
        configuration,
        stdout: this.context.stdout,
        includeFooter: false
      }, async report => {
        if (error) {
          report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.DEPRECATED_CLI_SETTINGS, message);
        } else {
          report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.DEPRECATED_CLI_SETTINGS, message);
        }
      });

      if (deprecationReport.hasErrors()) {
        return deprecationReport.exitCode();
      } else {
        return null;
      }
    }; // The ignoreEngines flag isn't implemented at the moment. I'm still
    // considering how it should work in the context of plugins - would it
    // make sense to allow them (or direct dependencies) to define new
    // "engine check"? Since it has implications regarding the architecture,
    // I prefer to postpone the decision to later. Also it wouldn't be a flag,
    // it would definitely be a configuration setting.


    if (typeof this.ignoreEngines !== `undefined`) {
      const exitCode = await reportDeprecation(`The --ignore-engines option is deprecated; engine checking isn't a core feature anymore`, {
        error: !isZeitNow
      });

      if (exitCode !== null) {
        return exitCode;
      }
    } // The registry flag isn't supported anymore because it makes little sense
    // to use a registry for a single install. You instead want to configure it
    // for all installs inside a project, so through the .yarnrc.yml file. Note
    // that if absolutely necessary, the old behavior can be emulated by adding
    // the YARN_NPM_REGISTRY_SERVER variable to the environment.


    if (typeof this.registry !== `undefined`) {
      const exitCode = await reportDeprecation(`The --registry option is deprecated; prefer setting npmRegistryServer in your .yarnrc.yml file`, {
        error: false
      });

      if (exitCode !== null) {
        return exitCode;
      }
    } // The preferOffline flag doesn't make much sense with our architecture.
    // It would require the fetchers to also act as resolvers, which is
    // doable but quirky. Since a similar behavior is available via the
    // --cached flag in yarn add, I prefer to move it outside of the core and
    // let someone implement this "resolver-that-reads-the-cache" logic.


    if (typeof this.preferOffline !== `undefined`) {
      const exitCode = await reportDeprecation(`The --prefer-offline flag is deprecated; use the --cached flag with 'yarn add' instead`, {
        error: !isZeitNow
      });

      if (exitCode !== null) {
        return exitCode;
      }
    } // Since the production flag would yield a different lockfile than the
    // regular installs, it's not part of the regular `install` command anymore.
    // Instead, we expect users to use it with `yarn workspaces focus` (which can
    // be used even outside of monorepos).


    if (typeof this.production !== `undefined`) {
      const exitCode = await reportDeprecation(`The --production option is deprecated on 'install'; use 'yarn workspaces focus' instead`, {
        error: true
      });

      if (exitCode !== null) {
        return exitCode;
      }
    } // Yarn 2 isn't interactive during installs anyway, so there's no real point
    // to this flag at the moment.


    if (typeof this.nonInteractive !== `undefined`) {
      const exitCode = await reportDeprecation(`The --non-interactive option is deprecated`, {
        error: !isGCP
      });

      if (exitCode !== null) {
        return exitCode;
      }
    } // We want to prevent people from using --frozen-lockfile
    // Note: it's been deprecated because we're now locking more than just the
    // lockfile - for example the PnP artifacts will also be locked.


    if (typeof this.frozenLockfile !== `undefined`) {
      const exitCode = await reportDeprecation(`The --frozen-lockfile option is deprecated; use --immutable and/or --immutable-cache instead`, {
        error: !isGCP && !ci_info__WEBPACK_IMPORTED_MODULE_2__.TRAVIS
      });

      if (exitCode !== null) {
        return exitCode;
      }
    } // We also want to prevent them from using --cache-folder
    // Note: it's been deprecated because the cache folder should be set from
    // the settings. Otherwise there would be a very high chance that multiple
    // Yarn commands would use different caches, causing unexpected behaviors.


    if (typeof this.cacheFolder !== `undefined`) {
      const exitCode = await reportDeprecation(`The cache-folder option has been deprecated; use rc settings instead`, {
        error: !isNetlify
      });

      if (exitCode !== null) {
        return exitCode;
      }
    }

    const immutable = typeof this.immutable === `undefined` && typeof this.frozenLockfile === `undefined` ? (_a = configuration.get(`enableImmutableInstalls`)) !== null && _a !== void 0 ? _a : false : (_c = (_b = this.immutable) !== null && _b !== void 0 ? _b : this.frozenLockfile) !== null && _c !== void 0 ? _c : false;

    if (configuration.projectCwd !== null) {
      const fixReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout,
        includeFooter: false
      }, async report => {
        if (await autofixMergeConflicts(configuration, immutable)) {
          report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.AUTOMERGE_SUCCESS, `Automatically fixed merge conflicts `);
          report.reportSeparator();
        }
      });

      if (fixReport.hasErrors()) {
        return fixReport.exitCode();
      }
    }

    if (configuration.projectCwd !== null) {
      const telemetryReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout,
        includeFooter: false
      }, async report => {
        var _a;

        if ((_a = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.telemetry) === null || _a === void 0 ? void 0 : _a.isNew) {
          report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.TELEMETRY_NOTICE, `Yarn will periodically gather anonymous telemetry: https://yarnpkg.com/advanced/telemetry`);
          report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.TELEMETRY_NOTICE, `Run ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.pretty(configuration, `yarn config set --home enableTelemetry 0`, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Type.CODE)} to disable`);
          report.reportSeparator();
        }
      });

      if (telemetryReport.hasErrors()) {
        return telemetryReport.exitCode();
      }
    }

    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.Cache.find(configuration, {
      immutable: this.immutableCache,
      check: this.checkCache
    });
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    await project.restoreInstallState({
      restoreResolutions: false
    }); // Important: Because other commands also need to run installs, if you
    // get in a situation where you need to change this file in order to
    // customize the install it's very likely you're doing something wrong.
    // This file should stay super super simple, and the configuration and
    // install logic should be implemented elsewhere (probably in either of
    // the Configuration and Install classes). Feel free to open an issue
    // in order to ask for design feedback before writing features.

    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout,
      includeLogs: true
    }, async report => {
      await project.install({
        cache,
        report,
        immutable,
        skipBuild: this.skipBuilds
      });
    });
    return report.exitCode();
  }

}
YarnCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Usage({
  description: `install the project dependencies`,
  details: `
      This command setup your project if needed. The installation is splitted in four different steps that each have their own characteristics:

      - **Resolution:** First the package manager will resolve your dependencies. The exact way a dependency version is privileged over another isn't standardized outside of the regular semver guarantees. If a package doesn't resolve to what you would expect, check that all dependencies are correctly declared (also check our website for more information: ).

      - **Fetch:** Then we download all the dependencies if needed, and make sure that they're all stored within our cache (check the value of \`cacheFolder\` in \`yarn config\` to see where are stored the cache files).

      - **Link:** Then we send the dependency tree information to internal plugins tasked from writing them on the disk in some form (for example by generating the .pnp.js file you might know).

      - **Build:** Once the dependency tree has been written on the disk, the package manager will now be free to run the build scripts for all packages that might need it, in a topological order compatible with the way they depend on one another.

      Note that running this command is not part of the recommended workflow. Yarn supports zero-installs, which means that as long as you store your cache and your .pnp.js file inside your repository, everything will work without requiring any install right after cloning your repository or switching branches.

      If the \`--immutable\` option is set, Yarn will abort with an error exit code if the lockfile was to be modified (other paths can be added using the \`immutablePaths\` configuration setting). For backward compatibility we offer an alias under the name of \`--frozen-lockfile\`, but it will be removed in a later release.

      If the \`--immutable-cache\` option is set, Yarn will abort with an error exit code if the cache folder was to be modified (either because files would be added, or because they'd be removed).

      If the \`--check-cache\` option is set, Yarn will always refetch the packages and will ensure that their checksum matches what's 1/ described in the lockfile 2/ inside the existing cache files (if present). This is recommended as part of your CI workflow if you're both following the Zero-Installs model and accepting PRs from third-parties, as they'd otherwise have the ability to alter the checked-in packages before submitting them.

      If the \`--inline-builds\` option is set, Yarn will verbosely print the output of the build steps of your dependencies (instead of writing them into individual files). This is likely useful mostly for debug purposes only when using Docker-like environments.

      If the \`--skip-builds\` option is set, Yarn will not run the build scripts at all. Note that this is different from setting \`enableScripts\` to false because the later will disable build scripts, and thus affect the content of the artifacts generated on disk, whereas the former will just disable the build step - but not the scripts themselves, which just won't run.
    `,
  examples: [[`Install the project`, `$0 install`], [`Validate a project when using Zero-Installs`, `$0 install --immutable --immutable-cache`], [`Validate a project when using Zero-Installs (slightly safer if you accept external PRs)`, `$0 install --immutable --immutable-cache --check-cache`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], YarnCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--immutable`, {
  description: `Abort with an error exit code if the lockfile was to be modified`
})], YarnCommand.prototype, "immutable", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--immutable-cache`, {
  description: `Abort with an error exit code if the cache folder was to be modified`
})], YarnCommand.prototype, "immutableCache", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--check-cache`, {
  description: `Always refetch the packages and ensure that their checksums are consistent`
})], YarnCommand.prototype, "checkCache", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--production`, {
  hidden: true
})], YarnCommand.prototype, "production", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--non-interactive`, {
  hidden: true
})], YarnCommand.prototype, "nonInteractive", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--frozen-lockfile`, {
  hidden: true
})], YarnCommand.prototype, "frozenLockfile", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--prefer-offline`, {
  hidden: true
})], YarnCommand.prototype, "preferOffline", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--ignore-engines`, {
  hidden: true
})], YarnCommand.prototype, "ignoreEngines", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.String(`--registry`, {
  hidden: true
})], YarnCommand.prototype, "registry", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--inline-builds`, {
  description: `Verbosely print the output of the build steps of dependencies`
})], YarnCommand.prototype, "inlineBuilds", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--skip-builds`, {
  description: `Skip the build step altogether`
})], YarnCommand.prototype, "skipBuilds", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.String(`--cache-folder`, {
  hidden: true
})], YarnCommand.prototype, "cacheFolder", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--silent`, {
  hidden: true
})], YarnCommand.prototype, "silent", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Path(), clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Path(`install`)], YarnCommand.prototype, "execute", null);

const MERGE_CONFLICT_ANCESTOR = `|||||||`;
const MERGE_CONFLICT_END = `>>>>>>>`;
const MERGE_CONFLICT_SEP = `=======`;
const MERGE_CONFLICT_START = `<<<<<<<`;

async function autofixMergeConflicts(configuration, immutable) {
  if (!configuration.projectCwd) return false;
  const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(configuration.projectCwd, configuration.get(`lockfileFilename`));
  if (!(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__.xfs.existsPromise(lockfilePath))) return false;
  const file = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__.xfs.readFilePromise(lockfilePath, `utf8`);
  if (!file.includes(MERGE_CONFLICT_START)) return false;
  if (immutable) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.AUTOMERGE_IMMUTABLE, `Cannot autofix a lockfile when running an immutable install`);
  const [left, right] = getVariants(file);
  let parsedLeft;
  let parsedRight;

  try {
    parsedLeft = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__.parseSyml)(left);
    parsedRight = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__.parseSyml)(right);
  } catch (error) {
    console.log(error.stack)
    require(`fs`).writeFileSync('/tmp/left', left);
    require(`fs`).writeFileSync('/tmp/right', right);
    throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.AUTOMERGE_FAILED_TO_PARSE, `The individual variants of the lockfile failed to parse`);
  }

  const merged = { ...parsedLeft,
    ...parsedRight
  }; // Old-style lockfiles should be filtered out (for example when switching
  // from a Yarn 2 branch to a Yarn 1 branch). Fortunately (?), they actually
  // parse as valid YAML except that the objects become strings. We can use
  // that to detect them. Damn, it's really ugly though.

  for (const [key, value] of Object.entries(merged)) if (typeof value === `string`) delete merged[key];

  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__.xfs.changeFilePromise(lockfilePath, (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__.stringifySyml)(merged), {
    automaticNewlines: true
  });
  return true;
}

function getVariants(file) {
  const variants = [[], []];
  const lines = file.split(/\r?\n/g);
  let skip = false;

  while (lines.length > 0) {
    const line = lines.shift();
    if (typeof line === `undefined`) throw new Error(`Assertion failed: Some lines should remain`);

    if (line.startsWith(MERGE_CONFLICT_START)) {
      // get the first variant
      while (lines.length > 0) {
        const conflictLine = lines.shift();
        if (typeof conflictLine === `undefined`) throw new Error(`Assertion failed: Some lines should remain`);

        if (conflictLine === MERGE_CONFLICT_SEP) {
          skip = false;
          break;
        } else if (skip || conflictLine.startsWith(MERGE_CONFLICT_ANCESTOR)) {
          skip = true;
          continue;
        } else {
          variants[0].push(conflictLine);
        }
      } // get the second variant


      while (lines.length > 0) {
        const conflictLine = lines.shift();
        if (typeof conflictLine === `undefined`) throw new Error(`Assertion failed: Some lines should remain`);

        if (conflictLine.startsWith(MERGE_CONFLICT_END)) {
          break;
        } else {
          variants[1].push(conflictLine);
        }
      }
    } else {
      variants[0].push(line);
      variants[1].push(line);
    }
  }

  return [variants[0].join(`\n`), variants[1].join(`\n`)];
}

/***/ }),
/* 618 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ LinkCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(162);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);




 // eslint-disable-next-line arca/no-default-export

class LinkCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.all = false;
    this.private = false;
    this.relative = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const absoluteDestination = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.resolve(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.toPortablePath(this.destination));
    const configuration2 = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(absoluteDestination, this.context.plugins);
    const {
      project: project2,
      workspace: workspace2
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration2, absoluteDestination);
    if (!workspace2) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project2.cwd, absoluteDestination);
    const topLevelWorkspace = project.topLevelWorkspace;
    const linkedWorkspaces = [];

    if (this.all) {
      for (const workspace of project2.workspaces) if (workspace.manifest.name && (!workspace.manifest.private || this.private)) linkedWorkspaces.push(workspace);

      if (linkedWorkspaces.length === 0) {
        throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`No workspace found to be linked in the target project`);
      }
    } else {
      if (!workspace2.manifest.name) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The target workspace doesn't have a name and thus cannot be linked`);
      if (workspace2.manifest.private && !this.private) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The target workspace is marked private - use the --private flag to link it anyway`);
      linkedWorkspaces.push(workspace2);
    }

    for (const workspace of linkedWorkspaces) {
      const fullName = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyIdent(workspace.locator);
      const target = this.relative ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.relative(project.cwd, workspace.cwd) : workspace.cwd;
      topLevelWorkspace.manifest.resolutions.push({
        pattern: {
          descriptor: {
            fullName
          }
        },
        reference: `portal:${target}`
      });
    }

    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      await project.install({
        cache,
        report
      });
    });
    return report.exitCode();
  }

}
LinkCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `connect the local project to another one`,
  details: `
      This command will set a new \`resolutions\` field in the project-level manifest and point it to the workspace at the specified location (even if part of another project).

      There is no \`yarn unlink\` command. To unlink the workspaces from the current project one must revert the changes made to the \`resolutions\` field.
    `,
  examples: [[`Register a remote workspace for use in the current project`, `$0 link ~/ts-loader`], [`Register all workspaces from a remote project for use in the current project`, `$0 link ~/jest --all`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], LinkCommand.prototype, "destination", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-A,--all`, {
  description: `Link all workspaces belonging to the target project to the current one`
})], LinkCommand.prototype, "all", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-p,--private`, {
  description: `Also link private workspaces belonging to the target project to the current one`
})], LinkCommand.prototype, "private", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-r,--relative`, {
  description: `Link workspaces using relative paths instead of absolute paths`
})], LinkCommand.prototype, "relative", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`link`)], LinkCommand.prototype, "execute", null);

/***/ }),
/* 619 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NodeCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);


 // eslint-disable-next-line arca/no-default-export

class NodeCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.args = [];
  }

  async execute() {
    return this.cli.run([`exec`, `node`, ...this.args]);
  }

}
NodeCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `run node with the hook already setup`,
  details: `
      This command simply runs Node. It also makes sure to call it in a way that's compatible with the current project (for example, on PnP projects the environment will be setup in such a way that PnP will be correctly injected into the environment).

      The Node process will use the exact same version of Node as the one used to run Yarn itself, which might be a good way to ensure that your commands always use a consistent Node version.
    `,
  examples: [[`Run a Node script`, `$0 node ./my-script.js`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Proxy()], NodeCommand.prototype, "args", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`node`)], NodeCommand.prototype, "execute", null);

/***/ }),
/* 620 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PluginDlSourcesCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(71);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(155);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _set_version_sources__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(621);
/* harmony import */ var _import__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(623);
/* harmony import */ var _list__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(625);











const buildWorkflow = ({
  pluginName,
  noMinify
}, target) => [[`yarn`, `build:${pluginName}`, ...(noMinify ? [`--no-minify`] : []), `|`]]; // eslint-disable-next-line arca/no-default-export


class PluginDlSourcesCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.repository = `https://github.com/yarnpkg/berry.git`;
    this.branch = `master`;
    this.noMinify = false;
    this.force = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Configuration.find(this.context.cwd, this.context.plugins);
    const target = typeof this.installPath !== `undefined` ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath(this.installPath)) : _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath((0,os__WEBPACK_IMPORTED_MODULE_2__.tmpdir)()), `yarnpkg-sources`, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.makeHash(this.repository).slice(0, 6));
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const {
        project
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Project.find(configuration, this.context.cwd);
      const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.parseIdent(this.name.replace(/^((@yarnpkg\/)?plugin-)?/, `@yarnpkg/plugin-`));
      const identStr = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.stringifyIdent(ident);
      const data = await (0,_list__WEBPACK_IMPORTED_MODULE_5__.getAvailablePlugins)(configuration);
      if (!Object.prototype.hasOwnProperty.call(data, identStr)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.MessageName.PLUGIN_NAME_NOT_FOUND, `Couldn't find a plugin named "${identStr}" on the remote registry. Note that only the plugins referenced on our website (https://github.com/yarnpkg/berry/blob/master/plugins.yml) can be built and imported from sources.`);
      const pluginSpec = identStr;
      const pluginName = pluginSpec.replace(/@yarnpkg\//, ``);
      await (0,_set_version_sources__WEBPACK_IMPORTED_MODULE_3__.prepareRepo)(this, {
        configuration,
        report,
        target
      });
      report.reportSeparator();
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.MessageName.UNNAMED, `Building a fresh ${pluginName}`);
      report.reportSeparator();
      await (0,_set_version_sources__WEBPACK_IMPORTED_MODULE_3__.runWorkflow)(buildWorkflow({
        pluginName,
        noMinify: this.noMinify
      }, target), {
        configuration,
        context: this.context,
        target
      });
      report.reportSeparator();
      const pluginPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(target, `packages/${pluginName}/bundles/${pluginSpec}.js`);
      const pluginBuffer = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_14__.xfs.readFilePromise(pluginPath);
      await (0,_import__WEBPACK_IMPORTED_MODULE_4__.savePlugin)(pluginSpec, pluginBuffer, {
        project,
        report
      });
    });
    return report.exitCode();
  }

}
PluginDlSourcesCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Plugin-related commands`,
  description: `build a plugin from sources`,
  details: `
      This command clones the Yarn repository into a temporary folder, builds the specified contrib plugin and updates the configuration to reference it in further CLI invocations.

      The plugins can be referenced by their short name if sourced from the official Yarn repository.
    `,
  examples: [[`Build and activate the "@yarnpkg/plugin-exec" plugin`, `$0 plugin import from sources @yarnpkg/plugin-exec`], [`Build and activate the "@yarnpkg/plugin-exec" plugin (shorthand)`, `$0 plugin import from sources exec`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_15__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], PluginDlSourcesCommand.prototype, "name", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_15__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--path`, {
  description: `The path where the repository should be cloned to`
})], PluginDlSourcesCommand.prototype, "installPath", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_15__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--repository`, {
  description: `The repository that should be cloned`
})], PluginDlSourcesCommand.prototype, "repository", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_15__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--branch`, {
  description: `The branch of the repository that should be cloned`
})], PluginDlSourcesCommand.prototype, "branch", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_15__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--no-minify`, {
  description: `Build a plugin for development (debugging) - non-minified and non-mangled`
})], PluginDlSourcesCommand.prototype, "noMinify", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_15__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-f,--force`, {
  description: `Always clone the repository instead of trying to fetch the latest commits`
})], PluginDlSourcesCommand.prototype, "force", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_15__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`plugin`, `import`, `from`, `sources`)], PluginDlSourcesCommand.prototype, "execute", null);

/***/ }),
/* 621 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ SetVersionSourcesCommand,
/* harmony export */   "runWorkflow": () => /* binding */ runWorkflow,
/* harmony export */   "prepareRepo": () => /* binding */ prepareRepo
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(71);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(373);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(155);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(84);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(622);








const PR_REGEXP = /^[0-9]+$/;

function getBranchRef(branch) {
  if (PR_REGEXP.test(branch)) {
    return `pull/${branch}/head`;
  } else {
    return branch;
  }
}

const cloneWorkflow = ({
  repository,
  branch
}, target) => [[`git`, `init`, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.fromPortablePath(target)], [`git`, `remote`, `add`, `origin`, repository], [`git`, `fetch`, `origin`, getBranchRef(branch)], [`git`, `reset`, `--hard`, `FETCH_HEAD`]];

const updateWorkflow = ({
  branch
}) => [[`git`, `fetch`, `origin`, getBranchRef(branch), `--force`], [`git`, `reset`, `--hard`, `FETCH_HEAD`], [`git`, `clean`, `-dfx`]];

const buildWorkflow = ({
  plugins,
  noMinify
}, target) => [[`yarn`, `build:cli`, ...new Array().concat(...plugins.map(plugin => [`--plugin`, path__WEBPACK_IMPORTED_MODULE_3___default().resolve(target, plugin)])), ...(noMinify ? [`--no-minify`] : []), `|`]]; // eslint-disable-next-line arca/no-default-export


class SetVersionSourcesCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.repository = `https://github.com/yarnpkg/berry.git`;
    this.branch = `master`;
    this.plugins = [];
    this.noMinify = false;
    this.force = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Configuration.find(this.context.cwd, this.context.plugins);
    const target = typeof this.installPath !== `undefined` ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.resolve(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.toPortablePath(this.installPath)) : _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.toPortablePath((0,os__WEBPACK_IMPORTED_MODULE_2__.tmpdir)()), `yarnpkg-sources`, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.makeHash(this.repository).slice(0, 6));
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      await prepareRepo(this, {
        configuration,
        report,
        target
      });
      report.reportSeparator();
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Building a fresh bundle`);
      report.reportSeparator();
      await runWorkflow(buildWorkflow(this, target), {
        configuration,
        context: this.context,
        target
      });
      report.reportSeparator();
      const bundlePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.resolve(target, `packages/yarnpkg-cli/bundles/yarn.js`);
      const bundleBuffer = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readFilePromise(bundlePath);
      await (0,_version__WEBPACK_IMPORTED_MODULE_4__.setVersion)(configuration, `sources`, bundleBuffer, {
        report
      });
    });
    return report.exitCode();
  }

}
SetVersionSourcesCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `build Yarn from master`,
  details: `
      This command will clone the Yarn repository into a temporary folder, then build it. The resulting bundle will then be copied into the local project.
    `,
  examples: [[`Build Yarn from master`, `$0 set version from sources`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--path`, {
  description: `The path where the repository should be cloned to`
})], SetVersionSourcesCommand.prototype, "installPath", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--repository`, {
  description: `The repository that should be cloned`
})], SetVersionSourcesCommand.prototype, "repository", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--branch`, {
  description: `The branch of the repository that should be cloned`
})], SetVersionSourcesCommand.prototype, "branch", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Array(`--plugin`, {
  description: `An array of additional plugins that should be included in the bundle`
})], SetVersionSourcesCommand.prototype, "plugins", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--no-minify`, {
  description: `Build a bundle for development (debugging) - non-minified and non-mangled`
})], SetVersionSourcesCommand.prototype, "noMinify", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-f,--force`, {
  description: `Always clone the repository instead of trying to fetch the latest commits`
})], SetVersionSourcesCommand.prototype, "force", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`set`, `version`, `from`, `sources`)], SetVersionSourcesCommand.prototype, "execute", null);

async function runWorkflow(workflow, {
  configuration,
  context,
  target
}) {
  for (const [fileName, ...args] of workflow) {
    const usePipe = args[args.length - 1] === `|`;
    if (usePipe) args.pop();

    if (usePipe) {
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.pipevp(fileName, args, {
        cwd: target,
        stdin: context.stdin,
        stdout: context.stdout,
        stderr: context.stderr,
        strict: true
      });
    } else {
      context.stdout.write(`${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.pretty(configuration, `  $ ${[fileName, ...args].join(` `)}`, `grey`)}\n`);

      try {
        await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.execvp(fileName, args, {
          cwd: target,
          strict: true
        });
      } catch (error) {
        context.stdout.write(error.stdout || error.stack);
        throw error;
      }
    }
  }
}
async function prepareRepo(spec, {
  configuration,
  report,
  target
}) {
  let ready = false;

  if (!spec.force && _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(target, `.git`))) {
    report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Fetching the latest commits`);
    report.reportSeparator();

    try {
      await runWorkflow(updateWorkflow(spec), {
        configuration,
        context: spec.context,
        target
      });
      ready = true;
    } catch (error) {
      report.reportSeparator();
      report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Repository update failed; we'll try to regenerate it`);
    }
  }

  if (!ready) {
    report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Cloning the remote repository`);
    report.reportSeparator();
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.removePromise(target);
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.mkdirPromise(target, {
      recursive: true
    });
    await runWorkflow(cloneWorkflow(spec, target), {
      configuration,
      context: spec.context,
      target
    });
  }
}

/***/ }),
/* 622 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ SetVersionCommand,
/* harmony export */   "setVersion": () => /* binding */ setVersion
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(231);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(373);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(162);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_2__);






 // eslint-disable-next-line arca/no-default-export

class SetVersionCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.onlyIfNeeded = false;
  } // TODO: Remove alias in next major


  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    if (configuration.get(`yarnPath`) && this.onlyIfNeeded) return 0;
    let bundleUrl;
    if (this.version === `latest` || this.version === `berry`) bundleUrl = `https://github.com/yarnpkg/berry/raw/master/packages/yarnpkg-cli/bin/yarn.js`;else if (this.version === `classic`) bundleUrl = `https://nightly.yarnpkg.com/latest.js`;else if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.satisfiesWithPrereleases(this.version, `>=2.0.0`)) bundleUrl = `https://github.com/yarnpkg/berry/raw/%40yarnpkg/cli/${this.version}/packages/yarnpkg-cli/bin/yarn.js`;else if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.satisfiesWithPrereleases(this.version, `^0.x || ^1.x`)) bundleUrl = `https://github.com/yarnpkg/yarn/releases/download/v${this.version}/yarn-${this.version}.js`;else if (semver__WEBPACK_IMPORTED_MODULE_2___default().validRange(this.version)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Support for ranges got removed - please use the exact version you want to install, or 'latest' to get the latest build available`);else throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Invalid version descriptor "${this.version}"`);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.UNNAMED, `Downloading ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.pretty(configuration, bundleUrl, `green`)}`);
      const bundleBuffer = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.get(bundleUrl, {
        configuration
      });
      await setVersion(configuration, null, bundleBuffer, {
        report
      });
    });
    return report.exitCode();
  }

}
SetVersionCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `lock the Yarn version used by the project`,
  details: `
      This command will download a specific release of Yarn directly from the Yarn GitHub repository, will store it inside your project, and will change the \`yarnPath\` settings from your project \`.yarnrc.yml\` file to point to the new file.

      A very good use case for this command is to enforce the version of Yarn used by the any single member of your team inside a same project - by doing this you ensure that you have control on Yarn upgrades and downgrades (including on your deployment servers), and get rid of most of the headaches related to someone using a slightly different version and getting a different behavior than you.
    `,
  examples: [[`Download the latest release from the Yarn repository`, `$0 set version latest`], [`Download the latest classic release from the Yarn repository`, `$0 set version classic`], [`Download a specific Yarn 2 build`, `$0 set version 2.0.0-rc.30`], [`Switch back to a specific Yarn 1 release`, `$0 set version 1.22.1`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_9__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--only-if-needed`, {
  description: `Only lock the Yarn version if it isn't already locked`
})], SetVersionCommand.prototype, "onlyIfNeeded", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_9__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], SetVersionCommand.prototype, "version", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_9__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`policies`, `set-version`), clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`set`, `version`)], SetVersionCommand.prototype, "execute", null);

async function setVersion(configuration, bundleVersion, bundleBuffer, {
  report
}) {
  const projectCwd = configuration.projectCwd ? configuration.projectCwd : configuration.startingCwd;

  if (bundleVersion === null) {
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.mktempPromise(async tmpDir => {
      const temporaryPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(tmpDir, `yarn.cjs`);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.writeFilePromise(temporaryPath, bundleBuffer);
      const {
        stdout
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.execvp(process.execPath, [_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.fromPortablePath(temporaryPath), `--version`], {
        cwd: projectCwd,
        env: { ...process.env,
          YARN_IGNORE_PATH: `1`
        }
      });
      bundleVersion = stdout.trim();

      if (!semver__WEBPACK_IMPORTED_MODULE_2___default().valid(bundleVersion)) {
        throw new Error(`Invalid semver version`);
      }
    });
  }

  const releaseFolder = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(projectCwd, `.yarn/releases`);
  const absolutePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(releaseFolder, `yarn-${bundleVersion}.cjs`);
  const displayPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.relative(configuration.startingCwd, absolutePath);
  const projectPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.relative(projectCwd, absolutePath);
  const yarnPath = configuration.get(`yarnPath`);
  const updateConfig = yarnPath === null || yarnPath.startsWith(`${releaseFolder}/`);
  report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.UNNAMED, `Saving the new release in ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.pretty(configuration, displayPath, `magenta`)}`);
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.removePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.dirname(absolutePath));
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.dirname(absolutePath), {
    recursive: true
  });
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.writeFilePromise(absolutePath, bundleBuffer);
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.chmodPromise(absolutePath, 0o755);

  if (updateConfig) {
    await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.updateConfiguration(projectCwd, {
      yarnPath: projectPath
    });
  }
}

/***/ }),
/* 623 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PluginDlCommand,
/* harmony export */   "savePlugin": () => /* binding */ savePlugin
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(155);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(247);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var vm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(624);
/* harmony import */ var vm__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(vm__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(625);








 // eslint-disable-next-line arca/no-default-export

class PluginDlCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Configuration.find(this.context.cwd, this.context.plugins);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const {
        project
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Project.find(configuration, this.context.cwd);
      let pluginSpec;
      let pluginBuffer;

      if (this.name.match(/^\.{0,2}[\\/]/) || _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.npath.isAbsolute(this.name)) {
        const candidatePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.resolve(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.npath.toPortablePath(this.name));
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Reading ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.pretty(configuration, candidatePath, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.PATH)}`);
        pluginSpec = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.relative(project.cwd, candidatePath);
        pluginBuffer = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.readFilePromise(candidatePath);
      } else {
        let pluginUrl;

        if (this.name.match(/^https?:/)) {
          try {
            new url__WEBPACK_IMPORTED_MODULE_2__.URL(this.name);
          } catch (_a) {
            throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.INVALID_PLUGIN_REFERENCE, `Plugin specifier "${this.name}" is neither a plugin name nor a valid url`);
          }

          pluginSpec = this.name;
          pluginUrl = this.name;
        } else {
          const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.parseIdent(this.name.replace(/^((@yarnpkg\/)?plugin-)?/, `@yarnpkg/plugin-`));
          const identStr = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.stringifyIdent(ident);
          const data = await (0,_list__WEBPACK_IMPORTED_MODULE_4__.getAvailablePlugins)(configuration);
          if (!Object.prototype.hasOwnProperty.call(data, identStr)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.PLUGIN_NAME_NOT_FOUND, `Couldn't find a plugin named "${identStr}" on the remote registry. Note that only the plugins referenced on our website (https://github.com/yarnpkg/berry/blob/master/plugins.yml) can be referenced by their name; any other plugin will have to be referenced through its public url (for example https://github.com/yarnpkg/berry/raw/master/packages/plugin-typescript/bin/%40yarnpkg/plugin-typescript.js).`);
          pluginSpec = identStr;
          pluginUrl = data[identStr].url;
        }

        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Downloading ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.pretty(configuration, pluginUrl, `green`)}`);
        pluginBuffer = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__.get(pluginUrl, {
          configuration
        });
      }

      await savePlugin(pluginSpec, pluginBuffer, {
        project,
        report
      });
    });
    return report.exitCode();
  }

}
PluginDlCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Plugin-related commands`,
  description: `download a plugin`,
  details: `
      This command downloads the specified plugin from its remote location and updates the configuration to reference it in further CLI invocations.

      Three types of plugin references are accepted:

      - If the plugin is stored within the Yarn repository, it can be referenced by name.
      - Third-party plugins can be referenced directly through their public urls.
      - Local plugins can be referenced by their path on the disk.

      Plugins cannot be downloaded from the npm registry, and aren't allowed to have dependencies (they need to be bundled into a single file, possibly thanks to the \`@yarnpkg/builder\` package).
    `,
  examples: [[`Download and activate the "@yarnpkg/plugin-exec" plugin`, `$0 plugin import @yarnpkg/plugin-exec`], [`Download and activate the "@yarnpkg/plugin-exec" plugin (shorthand)`, `$0 plugin import exec`], [`Download and activate a community plugin`, `$0 plugin import https://example.org/path/to/plugin.js`], [`Activate a local plugin`, `$0 plugin import ./path/to/plugin.js`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_15__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], PluginDlCommand.prototype, "name", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_15__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`plugin`, `import`)], PluginDlCommand.prototype, "execute", null);

async function savePlugin(pluginSpec, pluginBuffer, {
  project,
  report
}) {
  const {
    configuration
  } = project;
  const vmExports = {};
  const vmModule = {
    exports: vmExports
  };
  (0,vm__WEBPACK_IMPORTED_MODULE_3__.runInNewContext)(pluginBuffer.toString(), {
    module: vmModule,
    exports: vmExports
  });
  const pluginName = vmModule.exports.name;
  const relativePath = `.yarn/plugins/${pluginName}.cjs`;
  const absolutePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.resolve(project.cwd, relativePath);
  report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Saving the new plugin in ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.pretty(configuration, relativePath, `magenta`)}`);
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.dirname(absolutePath), {
    recursive: true
  });
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.writeFilePromise(absolutePath, pluginBuffer);
  const pluginMeta = {
    path: relativePath,
    spec: pluginSpec
  };
  await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Configuration.updateConfiguration(project.cwd, current => {
    const plugins = [];
    let hasBeenReplaced = false;

    for (const entry of current.plugins || []) {
      const userProvidedPath = typeof entry !== `string` ? entry.path : entry;
      const pluginPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.resolve(project.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.npath.toPortablePath(userProvidedPath));
      const {
        name
      } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_16__.dynamicRequire(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.npath.fromPortablePath(pluginPath));

      if (name !== pluginName) {
        plugins.push(entry);
      } else {
        plugins.push(pluginMeta);
        hasBeenReplaced = true;
      }
    }

    if (!hasBeenReplaced) plugins.push(pluginMeta);
    return { ...current,
      plugins
    };
  });
}

/***/ }),
/* 624 */
/***/ ((module) => {

"use strict";
module.exports = require("vm");;

/***/ }),
/* 625 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAvailablePlugins": () => /* binding */ getAvailablePlugins,
/* harmony export */   "default": () => /* binding */ PluginDlCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(182);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);





const REMOTE_REGISTRY = `https://raw.githubusercontent.com/yarnpkg/berry/master/plugins.yml`;
async function getAvailablePlugins(configuration) {
  const raw = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.get(REMOTE_REGISTRY, {
    configuration
  });
  const data = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__.parseSyml)(raw.toString());
  return data;
} // eslint-disable-next-line arca/no-default-export

class PluginDlCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      const data = await getAvailablePlugins(configuration);

      for (const [name, {
        experimental,
        ...rest
      }] of Object.entries(data)) {
        let label = name;
        if (experimental) label += ` [experimental]`;
        report.reportJson({
          name,
          experimental,
          ...rest
        });
        report.reportInfo(null, label);
      }
    });
    return report.exitCode();
  }

}
PluginDlCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  category: `Plugin-related commands`,
  description: `list the available official plugins`,
  details: `
      This command prints the plugins available directly from the Yarn repository. Only those plugins can be referenced by name in \`yarn plugin import\`.
    `,
  examples: [[`List the official plugins`, `$0 plugin list`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], PluginDlCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`plugin`, `list`)], PluginDlCommand.prototype, "execute", null);

/***/ }),
/* 626 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PluginRemoveCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(155);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);




 // eslint-disable-next-line arca/no-default-export

class PluginRemoveCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const pluginName = this.name;
      const pluginIdent = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.parseIdent(pluginName);
      if (!configuration.plugins.has(pluginName)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.prettyIdent(configuration, pluginIdent)} isn't referenced by the current configuration`);
      const relativePath = `.yarn/plugins/${pluginName}.cjs`;
      const absolutePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(project.cwd, relativePath);

      if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.xfs.existsSync(absolutePath)) {
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.UNNAMED, `Removing ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.pretty(configuration, relativePath, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.Type.PATH)}...`);
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.xfs.removePromise(absolutePath);
      }

      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.UNNAMED, `Updating the configuration...`);
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.updateConfiguration(project.cwd, current => {
        if (!Array.isArray(current.plugins)) return current;
        const plugins = current.plugins.filter(plugin => {
          return plugin.path !== relativePath;
        });
        if (current.plugins.length === plugins.length) return current;
        return { ...current,
          plugins
        };
      });
    });
    return report.exitCode();
  }

}
PluginRemoveCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Plugin-related commands`,
  description: `remove a plugin`,
  details: `
      This command deletes the specified plugin from the .yarn/plugins folder and removes it from the configuration.

      **Note:** The plugins have to be referenced by their name property, which can be obtained using the \`yarn plugin runtime\` command. Shorthands are not allowed.
   `,
  examples: [[`Remove a plugin imported from the Yarn repository`, `$0 plugin remove @yarnpkg/plugin-typescript`], [`Remove a plugin imported from a local file`, `$0 plugin remove my-local-plugin`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], PluginRemoveCommand.prototype, "name", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`plugin`, `remove`)], PluginRemoveCommand.prototype, "execute", null);

/***/ }),
/* 627 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PluginListCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(374);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);



 // eslint-disable-next-line arca/no-default-export

class PluginListCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      for (const name of configuration.plugins.keys()) {
        const builtin = this.context.plugins.plugins.has(name);
        let label = name;
        if (builtin) label += ` [builtin]`;
        report.reportJson({
          name,
          builtin
        });
        report.reportInfo(null, `${label}`);
      }
    });
    return report.exitCode();
  }

}
PluginListCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Plugin-related commands`,
  description: `list the active plugins`,
  details: `
      This command prints the currently active plugins. Will be displayed both builtin plugins and external plugins.
    `,
  examples: [[`List the currently active plugins`, `$0 plugin runtime`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], PluginListCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`plugin`, `runtime`)], PluginListCommand.prototype, "execute", null);

/***/ }),
/* 628 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ RunCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(335);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(182);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);






 // eslint-disable-next-line arca/no-default-export

class RunCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.idents = [];
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const filteredIdents = new Set();

    for (const identStr of this.idents) filteredIdents.add(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.parseIdent(identStr).identHash);

    await project.resolveEverything({
      cache,
      report: new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.ThrowReport()
    });
    const bstatePath = configuration.get(`bstatePath`);
    const bstate = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.existsSync(bstatePath) ? (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__.parseSyml)(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.readFilePromise(bstatePath, `utf8`)) : {};
    const nextBState = new Map();

    for (const pkg of project.storedPackages.values()) {
      if (!Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash)) continue;
      if (filteredIdents.size === 0 || filteredIdents.has(pkg.identHash)) continue;
      const buildHash = bstate[pkg.locatorHash];
      nextBState.set(pkg.locatorHash, buildHash);
    }

    if (nextBState.size > 0) {
      const bstatePath = configuration.get(`bstatePath`);
      const bstateFile = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.generateBuildStateFile(nextBState, project.storedPackages);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.dirname(bstatePath), {
        recursive: true
      });
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.changeFilePromise(bstatePath, bstateFile, {
        automaticNewlines: true
      });
    } else {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.removePromise(bstatePath);
    }

    const installReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.StreamReport.start({
      configuration,
      stdout: this.context.stdout,
      includeLogs: !this.context.quiet
    }, async report => {
      await project.install({
        cache,
        report
      });
    });
    return installReport.exitCode();
  }

}
RunCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  description: `rebuild the project's native packages`,
  details: `
      This command will automatically cause Yarn to forget about previous compilations of the given packages and to run them again.

      Note that while Yarn forgets the compilation, the previous artifacts aren't erased from the filesystem and may affect the next builds (in good or bad). To avoid this, you may remove the .yarn/unplugged folder, or any other relevant location where packages might have been stored (Yarn may offer a way to do that automatically in the future).

      By default all packages will be rebuilt, but you can filter the list by specifying the names of the packages you want to clear from memory.
    `,
  examples: [[`Rebuild all packages`, `$0 rebuild`], [`Rebuild fsevents only`, `$0 rebuild fsevents`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Rest()], RunCommand.prototype, "idents", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`rebuild`)], RunCommand.prototype, "execute", null);

/***/ }),
/* 629 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ RemoveCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _suggestUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(600);







 // eslint-disable-next-line arca/no-default-export

class RemoveCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.all = false;
    this.patterns = [];
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    await project.restoreInstallState({
      restoreResolutions: false
    });
    const affectedWorkspaces = this.all ? project.workspaces : [workspace];
    const targets = [_suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.REGULAR, _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.DEVELOPMENT, _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.PEER];
    const unreferencedPatterns = [];
    let hasChanged = false;
    const afterWorkspaceDependencyRemovalList = [];

    for (const pattern of this.patterns) {
      let isReferenced = false; // This isn't really needed - It's just for consistency:
      // All patterns are either valid or not for all commands (e.g. remove, up)

      const pseudoIdent = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.parseIdent(pattern);

      for (const workspace of affectedWorkspaces) {
        const peerDependenciesMeta = [...workspace.manifest.peerDependenciesMeta.keys()];

        for (const stringifiedIdent of micromatch__WEBPACK_IMPORTED_MODULE_2___default()(peerDependenciesMeta, pattern)) {
          workspace.manifest.peerDependenciesMeta.delete(stringifiedIdent);
          hasChanged = true;
          isReferenced = true;
        }

        for (const target of targets) {
          const descriptors = workspace.manifest.getForScope(target);
          const stringifiedIdents = [...descriptors.values()].map(descriptor => {
            return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.stringifyIdent(descriptor);
          });

          for (const stringifiedIdent of micromatch__WEBPACK_IMPORTED_MODULE_2___default()(stringifiedIdents, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.stringifyIdent(pseudoIdent))) {
            const {
              identHash
            } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.parseIdent(stringifiedIdent);
            const removedDescriptor = descriptors.get(identHash);
            if (typeof removedDescriptor === `undefined`) throw new Error(`Assertion failed: Expected the descriptor to be registered`);
            workspace.manifest[target].delete(identHash);
            afterWorkspaceDependencyRemovalList.push([workspace, target, removedDescriptor]);
            hasChanged = true;
            isReferenced = true;
          }
        }
      }

      if (!isReferenced) {
        unreferencedPatterns.push(pattern);
      }
    }

    const patterns = unreferencedPatterns.length > 1 ? `Patterns` : `Pattern`;
    const dont = unreferencedPatterns.length > 1 ? `don't` : `doesn't`;
    const which = this.all ? `any` : `this`;
    if (unreferencedPatterns.length > 0) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`${patterns} ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.prettyList(configuration, unreferencedPatterns, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.FormatType.CODE)} ${dont} match any packages referenced by ${which} workspace`);

    if (hasChanged) {
      await configuration.triggerMultipleHooks(hooks => hooks.afterWorkspaceDependencyRemoval, afterWorkspaceDependencyRemovalList);
      const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async report => {
        await project.install({
          cache,
          report
        });
      });
      return report.exitCode();
    }

    return 0;
  }

}
RemoveCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `remove dependencies from the project`,
  details: `
      This command will remove the packages matching the specified patterns from the current workspace.

      This command accepts glob patterns as arguments (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.
    `,
  examples: [[`Remove a dependency from the current project`, `$0 remove lodash`], [`Remove a dependency from all workspaces at once`, `$0 remove lodash --all`], [`Remove all dependencies starting with \`eslint-\``, `$0 remove 'eslint-*'`], [`Remove all dependencies with the \`@babel\` scope`, `$0 remove '@babel/*'`], [`Remove all dependencies matching \`react-dom\` or \`react-helmet\``, `$0 remove 'react-{dom,helmet}'`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-A,--all`, {
  description: `Apply the operation to all workspaces from the current project`
})], RemoveCommand.prototype, "all", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Rest()], RemoveCommand.prototype, "patterns", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`remove`)], RemoveCommand.prototype, "execute", null);

/***/ }),
/* 630 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ RunCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(177);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);





 // eslint-disable-next-line arca/no-default-export

class RunCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const scripts = workspace.manifest.scripts;
      const keys = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.sortMap(scripts.keys(), key => key);
      const inspectConfig = {
        breakLength: Infinity,
        colors: configuration.get(`enableColors`),
        maxArrayLength: 2
      };
      const maxKeyLength = keys.reduce((max, key) => {
        return Math.max(max, key.length);
      }, 0);

      for (const [key, value] of scripts.entries()) {
        report.reportInfo(null, `${key.padEnd(maxKeyLength, ` `)}   ${(0,util__WEBPACK_IMPORTED_MODULE_2__.inspect)(value, inspectConfig)}`);
      }
    });
    return report.exitCode();
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`run`)], RunCommand.prototype, "execute", null);

/***/ }),
/* 631 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ RunCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(340);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);




 // eslint-disable-next-line arca/no-default-export

class RunCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.inspect = false;
    this.inspectBrk = false; // This flag is mostly used to give users a way to configure node-gyp. They
    // just have to add it as a top-level workspace.

    this.topLevel = false; // Some tools (for example text editors) want to call the real binaries, not
    // what their users might have remapped them to in their `scripts` field.

    this.binariesOnly = false;
    this.args = [];
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace,
      locator
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    await project.restoreInstallState();
    const effectiveLocator = this.topLevel ? project.topLevelWorkspace.anchoredLocator : locator; // First we check to see whether a script exist inside the current package
    // for the given name

    if (!this.binariesOnly && (await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.hasPackageScript(effectiveLocator, this.scriptName, {
      project
    }))) return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.executePackageScript(effectiveLocator, this.scriptName, this.args, {
      project,
      stdin: this.context.stdin,
      stdout: this.context.stdout,
      stderr: this.context.stderr
    }); // If we can't find it, we then check whether one of the dependencies of the
    // current package exports a binary with the requested name

    const binaries = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.getPackageAccessibleBinaries(effectiveLocator, {
      project
    });
    const binary = binaries.get(this.scriptName);

    if (binary) {
      const nodeArgs = [];

      if (this.inspect) {
        if (typeof this.inspect === `string`) {
          nodeArgs.push(`--inspect=${this.inspect}`);
        } else {
          nodeArgs.push(`--inspect`);
        }
      }

      if (this.inspectBrk) {
        if (typeof this.inspectBrk === `string`) {
          nodeArgs.push(`--inspect-brk=${this.inspectBrk}`);
        } else {
          nodeArgs.push(`--inspect-brk`);
        }
      }

      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.executePackageAccessibleBinary(effectiveLocator, this.scriptName, this.args, {
        cwd: this.context.cwd,
        project,
        stdin: this.context.stdin,
        stdout: this.context.stdout,
        stderr: this.context.stderr,
        nodeArgs
      });
    } // When it fails, we try to check whether it's a global script (ie we look
    // into all the workspaces to find one that exports this script). We only do
    // this if the script name contains a colon character (":"), and we skip
    // this logic if multiple workspaces share the same script name.
    //
    // We also disable this logic for packages coming from third-parties (ie
    // not workspaces). No particular reason except maybe security concerns.


    if (!this.topLevel && !this.binariesOnly && workspace && this.scriptName.includes(`:`)) {
      const candidateWorkspaces = await Promise.all(project.workspaces.map(async workspace => {
        return workspace.manifest.scripts.has(this.scriptName) ? workspace : null;
      }));
      const filteredWorkspaces = candidateWorkspaces.filter(workspace => {
        return workspace !== null;
      });

      if (filteredWorkspaces.length === 1) {
        return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.executeWorkspaceScript(filteredWorkspaces[0], this.scriptName, this.args, {
          stdin: this.context.stdin,
          stdout: this.context.stdout,
          stderr: this.context.stderr
        });
      }
    }

    if (this.topLevel) {
      if (this.scriptName === `node-gyp`) {
        throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a script name "${this.scriptName}" in the top-level (used by ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.prettyLocator(configuration, locator)}). This typically happens because some package depends on "node-gyp" to build itself, but didn't list it in their dependencies. To fix that, please run "yarn add node-gyp" into your top-level workspace. You also can open an issue on the repository of the specified package to suggest them to use an optional peer dependency.`);
      } else {
        throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a script name "${this.scriptName}" in the top-level (used by ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.prettyLocator(configuration, locator)}).`);
      }
    } else {
      if (this.scriptName === `global`) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The 'yarn global' commands have been removed in 2.x - consider using 'yarn dlx' or a third-party plugin instead`);
      const userCommand = [this.scriptName].concat(this.args);

      for (const [pluginName, candidates] of _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.pluginCommands) for (const candidate of candidates) if (userCommand.length >= candidate.length && JSON.stringify(userCommand.slice(0, candidate.length)) === JSON.stringify(candidate)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a script named "${this.scriptName}", but a matching command can be found in the ${pluginName} plugin. You can install it with "yarn plugin import ${pluginName}".`);

      throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a script named "${this.scriptName}".`);
    }
  }

}
RunCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `run a script defined in the package.json`,
  details: `
      This command will run a tool. The exact tool that will be executed will depend on the current state of your workspace:

      - If the \`scripts\` field from your local package.json contains a matching script name, its definition will get executed.

      - Otherwise, if one of the local workspace's dependencies exposes a binary with a matching name, this binary will get executed.

      - Otherwise, if the specified name contains a colon character and if one of the workspaces in the project contains exactly one script with a matching name, then this script will get executed.

      Whatever happens, the cwd of the spawned process will be the workspace that declares the script (which makes it possible to call commands cross-workspaces using the third syntax).
    `,
  examples: [[`Run the tests from the local workspace`, `$0 run test`], [`Same thing, but without the "run" keyword`, `$0 test`], [`Inspect Webpack while running`, `$0 run --inspect-brk webpack`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--inspect`, {
  tolerateBoolean: true,
  description: `Forwarded to the underlying Node process when executing a binary`
})], RunCommand.prototype, "inspect", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--inspect-brk`, {
  tolerateBoolean: true,
  description: `Forwarded to the underlying Node process when executing a binary`
})], RunCommand.prototype, "inspectBrk", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-T,--top-level`, {
  hidden: true
})], RunCommand.prototype, "topLevel", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-B,--binaries-only`, {
  hidden: true
})], RunCommand.prototype, "binariesOnly", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--silent`, {
  hidden: true
})], RunCommand.prototype, "silent", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], RunCommand.prototype, "scriptName", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Proxy()], RunCommand.prototype, "args", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`run`)], RunCommand.prototype, "execute", null);

/***/ }),
/* 632 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ SetResolutionCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);




 // eslint-disable-next-line arca/no-default-export

class SetResolutionCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.save = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const fromDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.parseDescriptor(this.descriptor, true);
    const toDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.makeDescriptor(fromDescriptor, this.resolution);
    project.storedDescriptors.set(fromDescriptor.descriptorHash, fromDescriptor);
    project.storedDescriptors.set(toDescriptor.descriptorHash, toDescriptor);
    project.resolutionAliases.set(fromDescriptor.descriptorHash, toDescriptor.descriptorHash);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      await project.install({
        cache,
        report
      });
    });
    return report.exitCode();
  }

}
SetResolutionCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `enforce a package resolution`,
  details: `
      This command updates the resolution table so that \`descriptor\` is resolved by \`resolution\`.

      Note that by default this command only affect the current resolution table - meaning that this "manual override" will disappear if you remove the lockfile, or if the package disappear from the table. If you wish to make the enforced resolution persist whatever happens, add the \`-s,--save\` flag which will also edit the \`resolutions\` field from your top-level manifest.

      Note that no attempt is made at validating that \`resolution\` is a valid resolution entry for \`descriptor\`.
    `,
  examples: [[`Force all instances of lodash@npm:^1.2.3 to resolve to 1.5.0`, `$0 set resolution lodash@npm:^1.2.3 1.5.0`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], SetResolutionCommand.prototype, "descriptor", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], SetResolutionCommand.prototype, "resolution", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-s,--save`, {
  description: `Persist the resolution inside the top-level manifest`
})], SetResolutionCommand.prototype, "save", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`set`, `resolution`)], SetResolutionCommand.prototype, "execute", null);

/***/ }),
/* 633 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ UpCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(379);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(26);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(556);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(enquirer__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _suggestUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(600);








 // eslint-disable-next-line arca/no-default-export

class UpCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.patterns = [];
    this.interactive = null;
    this.exact = false;
    this.tilde = false;
    this.caret = false;
  }

  async execute() {
    var _a;

    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const interactive = (_a = this.interactive) !== null && _a !== void 0 ? _a : configuration.get(`preferInteractive`);
    const modifier = _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.getModifier(this, project);
    const strategies = interactive ? [_suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Strategy.KEEP, _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Strategy.REUSE, _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Strategy.PROJECT, _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Strategy.LATEST] : [_suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Strategy.PROJECT, _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Strategy.LATEST];
    const allSuggestionsPromises = [];
    const unreferencedPatterns = [];

    for (const pattern of this.patterns) {
      let isReferenced = false; // The range has to be static

      const pseudoDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.parseDescriptor(pattern);

      for (const workspace of project.workspaces) {
        for (const target of [_suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Target.REGULAR, _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Target.DEVELOPMENT]) {
          const descriptors = workspace.manifest.getForScope(target);
          const stringifiedIdents = [...descriptors.values()].map(descriptor => {
            return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.stringifyIdent(descriptor);
          });

          for (const stringifiedIdent of micromatch__WEBPACK_IMPORTED_MODULE_3___default()(stringifiedIdents, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.stringifyIdent(pseudoDescriptor))) {
            const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.parseIdent(stringifiedIdent);
            const existingDescriptor = workspace.manifest[target].get(ident.identHash);
            if (typeof existingDescriptor === `undefined`) throw new Error(`Assertion failed: Expected the descriptor to be registered`);
            const request = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.makeDescriptor(ident, pseudoDescriptor.range);
            allSuggestionsPromises.push(Promise.resolve().then(async () => {
              return [workspace, target, existingDescriptor, await _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.getSuggestedDescriptors(request, {
                project,
                workspace,
                cache,
                target,
                modifier,
                strategies
              })];
            }));
            isReferenced = true;
          }
        }
      }

      if (!isReferenced) {
        unreferencedPatterns.push(pattern);
      }
    }

    if (unreferencedPatterns.length > 1) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Patterns ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.prettyList(configuration, unreferencedPatterns, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.FormatType.CODE)} don't match any packages referenced by any workspace`);
    if (unreferencedPatterns.length > 0) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Pattern ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.prettyList(configuration, unreferencedPatterns, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.FormatType.CODE)} doesn't match any packages referenced by any workspace`);
    const allSuggestions = await Promise.all(allSuggestionsPromises);
    const checkReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.LightReport.start({
      configuration,
      stdout: this.context.stdout,
      suggestInstall: false
    }, async report => {
      for (const [,,
      /*workspace*/

      /*target*/
      existing, {
        suggestions,
        rejections
      }] of allSuggestions) {
        const nonNullSuggestions = suggestions.filter(suggestion => {
          return suggestion.descriptor !== null;
        });

        if (nonNullSuggestions.length === 0) {
          const [firstError] = rejections;
          if (typeof firstError === `undefined`) throw new Error(`Assertion failed: Expected an error to have been set`);
          const prettyError = this.cli.error(firstError);

          if (!project.configuration.get(`enableNetwork`)) {
            report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.CANT_SUGGEST_RESOLUTIONS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.prettyDescriptor(configuration, existing)} can't be resolved to a satisfying range (note: network resolution has been disabled)\n\n${prettyError}`);
          } else {
            report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.CANT_SUGGEST_RESOLUTIONS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.prettyDescriptor(configuration, existing)} can't be resolved to a satisfying range\n\n${prettyError}`);
          }
        } else if (nonNullSuggestions.length > 1 && !interactive) {
          report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.CANT_SUGGEST_RESOLUTIONS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.prettyDescriptor(configuration, existing)} has multiple possible upgrade strategies; use -i to disambiguate manually`);
        }
      }
    });
    if (checkReport.hasErrors()) return checkReport.exitCode();
    let askedQuestions = false;
    const afterWorkspaceDependencyReplacementList = [];

    for (const [workspace, target,,
    /*existing*/
    {
      suggestions
    }] of allSuggestions) {
      let selected;
      const nonNullSuggestions = suggestions.filter(suggestion => {
        return suggestion.descriptor !== null;
      });
      const firstSuggestedDescriptor = nonNullSuggestions[0].descriptor;
      const areAllTheSame = nonNullSuggestions.every(suggestion => _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.areDescriptorsEqual(suggestion.descriptor, firstSuggestedDescriptor));

      if (nonNullSuggestions.length === 1 || areAllTheSame) {
        selected = firstSuggestedDescriptor;
      } else {
        askedQuestions = true;
        ({
          answer: selected
        } = await (0,enquirer__WEBPACK_IMPORTED_MODULE_2__.prompt)({
          type: `select`,
          name: `answer`,
          message: `Which range to you want to use in ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.prettyWorkspace(configuration, workspace)}  ${target}?`,
          choices: suggestions.map(({
            descriptor,
            name,
            reason
          }) => descriptor ? {
            name,
            hint: reason,
            descriptor
          } : {
            name,
            hint: reason,
            disabled: true
          }),
          onCancel: () => process.exit(130),

          result(name) {
            // @ts-expect-error: The enquirer types don't include find
            return this.find(name, `descriptor`);
          },

          stdin: this.context.stdin,
          stdout: this.context.stdout
        }));
      }

      const current = workspace.manifest[target].get(selected.identHash);
      if (typeof current === `undefined`) throw new Error(`Assertion failed: This descriptor should have a matching entry`);

      if (current.descriptorHash !== selected.descriptorHash) {
        workspace.manifest[target].set(selected.identHash, selected);
        afterWorkspaceDependencyReplacementList.push([workspace, target, current, selected]);
      } else {
        const resolver = configuration.makeResolver();
        const resolveOptions = {
          project,
          resolver
        };
        const bound = resolver.bindDescriptor(current, workspace.anchoredLocator, resolveOptions);
        project.forgetResolution(bound);
      }
    }

    await configuration.triggerMultipleHooks(hooks => hooks.afterWorkspaceDependencyReplacement, afterWorkspaceDependencyReplacementList);
    if (askedQuestions) this.context.stdout.write(`\n`);
    const installReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      await project.install({
        cache,
        report
      });
    });
    return installReport.exitCode();
  }

}
UpCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `upgrade dependencies across the project`,
  details: `
      This command upgrades the packages matching the list of specified patterns to their latest available version across the whole project (regardless of whether they're part of \`dependencies\` or \`devDependencies\` - \`peerDependencies\` won't be affected). This is a project-wide command: all workspaces will be upgraded in the process.

      If \`-i,--interactive\` is set (or if the \`preferInteractive\` settings is toggled on) the command will offer various choices, depending on the detected upgrade paths. Some upgrades require this flag in order to resolve ambiguities.

      The, \`-C,--caret\`, \`-E,--exact\` and  \`-T,--tilde\` options have the same meaning as in the \`add\` command (they change the modifier used when the range is missing or a tag, and are ignored when the range is explicitly set).

      Generally you can see \`yarn up\` as a counterpart to what was \`yarn upgrade --latest\` in Yarn 1 (ie it ignores the ranges previously listed in your manifests), but unlike \`yarn upgrade\` which only upgraded dependencies in the current workspace, \`yarn up\` will upgrade all workspaces at the same time.

      This command accepts glob patterns as arguments (if valid Descriptors and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.

      **Note:** The ranges have to be static, only the package scopes and names can contain glob patterns.
    `,
  examples: [[`Upgrade all instances of lodash to the latest release`, `$0 up lodash`], [`Upgrade all instances of lodash to the latest release, but ask confirmation for each`, `$0 up lodash -i`], [`Upgrade all instances of lodash to 1.2.3`, `$0 up lodash@1.2.3`], [`Upgrade all instances of packages with the \`@babel\` scope to the latest release`, `$0 up '@babel/*'`], [`Upgrade all instances of packages containing the word \`jest\` to the latest release`, `$0 up '*jest*'`], [`Upgrade all instances of packages with the \`@babel\` scope to 7.0.0`, `$0 up '@babel/*@7.0.0'`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Rest()], UpCommand.prototype, "patterns", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-i,--interactive`, {
  description: `Offer various choices, depending on the detected upgrade paths`
})], UpCommand.prototype, "interactive", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-E,--exact`, {
  description: `Don't use any semver modifier on the resolved range`
})], UpCommand.prototype, "exact", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-T,--tilde`, {
  description: `Use the \`~\` semver modifier on the resolved range`
})], UpCommand.prototype, "tilde", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-C,--caret`, {
  description: `Use the \`^\` semver modifier on the resolved range`
})], UpCommand.prototype, "caret", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_13__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`up`)], UpCommand.prototype, "execute", null);

/***/ }),
/* 634 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ WhyCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(411);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(177);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);





 // eslint-disable-next-line arca/no-default-export

class WhyCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.recursive = false;
    this.json = false;
    this.peers = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    await project.restoreInstallState();
    const identHash = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.parseIdent(this.package).identHash;
    const whyTree = this.recursive ? whyRecursive(project, identHash, {
      configuration,
      peers: this.peers
    }) : whySimple(project, identHash, {
      configuration,
      peers: this.peers
    });
    _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.emitTree(whyTree, {
      configuration,
      stdout: this.context.stdout,
      json: this.json,
      separators: 1
    });
  }

}
WhyCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `display the reason why a package is needed`,
  details: `
      This command prints the exact reasons why a package appears in the dependency tree.

      If \`-R,--recursive\` is set, the listing will go in depth and will list, for each workspaces, what are all the paths that lead to the dependency. Note that the display is somewhat optimized in that it will not print the package listing twice for a single package, so if you see a leaf named "Foo" when looking for "Bar", it means that "Foo" already got printed higher in the tree.
    `,
  examples: [[`Explain why lodash is used in your project`, `$0 why lodash`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], WhyCommand.prototype, "package", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-R,--recursive`, {
  description: `List, for each workspace, what are all the paths that lead to the dependency`
})], WhyCommand.prototype, "recursive", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], WhyCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--peers`, {
  description: `Also print the peer dependencies that match the specified name`
})], WhyCommand.prototype, "peers", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`why`)], WhyCommand.prototype, "execute", null);

function whySimple(project, identHash, {
  configuration,
  peers
}) {
  const sortedPackages = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.sortMap(project.storedPackages.values(), pkg => {
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.stringifyLocator(pkg);
  });
  const rootChildren = {};
  const root = {
    children: rootChildren
  };

  for (const pkg of sortedPackages) {
    const nodeChildren = {};
    const node = null;

    for (const dependency of pkg.dependencies.values()) {
      if (!peers && pkg.peerDependencies.has(dependency.identHash)) continue;
      const resolution = project.storedResolutions.get(dependency.descriptorHash);
      if (!resolution) throw new Error(`Assertion failed: The resolution should have been registered`);
      const nextPkg = project.storedPackages.get(resolution);
      if (!nextPkg) throw new Error(`Assertion failed: The package should have been registered`);
      if (nextPkg.identHash !== identHash) continue;

      if (node === null) {
        const key = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.stringifyLocator(pkg);
        rootChildren[key] = {
          value: [pkg, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Type.LOCATOR],
          children: nodeChildren
        };
      }

      const key = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.stringifyLocator(nextPkg);
      nodeChildren[key] = {
        value: [{
          descriptor: dependency,
          locator: nextPkg
        }, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Type.DEPENDENT]
      };
    }
  }

  return root;
}

function whyRecursive(project, identHash, {
  configuration,
  peers
}) {
  const sortedWorkspaces = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.sortMap(project.workspaces, workspace => {
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.stringifyLocator(workspace.anchoredLocator);
  });
  const seen = new Set();
  const dependents = new Set();

  const markAllDependents = pkg => {
    if (seen.has(pkg.locatorHash)) return dependents.has(pkg.locatorHash);
    seen.add(pkg.locatorHash);

    if (pkg.identHash === identHash) {
      dependents.add(pkg.locatorHash);
      return true;
    }

    let depends = false;
    if (pkg.identHash === identHash) depends = true;

    for (const dependency of pkg.dependencies.values()) {
      if (!peers && pkg.peerDependencies.has(dependency.identHash)) continue;
      const resolution = project.storedResolutions.get(dependency.descriptorHash);
      if (!resolution) throw new Error(`Assertion failed: The resolution should have been registered`);
      const nextPkg = project.storedPackages.get(resolution);
      if (!nextPkg) throw new Error(`Assertion failed: The package should have been registered`);

      if (markAllDependents(nextPkg)) {
        depends = true;
      }
    }

    if (depends) dependents.add(pkg.locatorHash);
    return depends;
  };

  for (const workspace of sortedWorkspaces) {
    const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
    if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
    markAllDependents(pkg);
  }

  const printed = new Set();
  const rootChildren = {};
  const root = {
    children: rootChildren
  };

  const printAllDependents = (pkg, parentChildren, dependency) => {
    if (!dependents.has(pkg.locatorHash)) return;
    const nodeValue = dependency !== null ? _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Type.DEPENDENT, {
      locator: pkg,
      descriptor: dependency
    }) : _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Type.LOCATOR, pkg);
    const nodeChildren = {};
    const node = {
      value: nodeValue,
      children: nodeChildren
    };
    const key = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.stringifyLocator(pkg);
    parentChildren[key] = node; // We don't want to reprint the children for a package that already got
    // printed as part of another branch

    if (printed.has(pkg.locatorHash)) return;
    printed.add(pkg.locatorHash); // We don't want to print the children of our transitive workspace
    // dependencies, as they will be printed in their own top-level branch

    if (dependency !== null && project.tryWorkspaceByLocator(pkg)) return;

    for (const dependency of pkg.dependencies.values()) {
      if (!peers && pkg.peerDependencies.has(dependency.identHash)) continue;
      const resolution = project.storedResolutions.get(dependency.descriptorHash);
      if (!resolution) throw new Error(`Assertion failed: The resolution should have been registered`);
      const nextPkg = project.storedPackages.get(resolution);
      if (!nextPkg) throw new Error(`Assertion failed: The package should have been registered`);
      printAllDependents(nextPkg, nodeChildren, dependency);
    }
  };

  for (const workspace of sortedWorkspaces) {
    const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
    if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
    printAllDependents(pkg, rootChildren, null);
  }

  return root;
}

/***/ }),
/* 635 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ WorkspacesListCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);



 // eslint-disable-next-line arca/no-default-export

class WorkspacesListCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.verbose = false;
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      for (const workspace of project.workspaces) {
        const {
          manifest
        } = workspace;
        let extra;

        if (this.verbose) {
          const workspaceDependencies = new Set();
          const mismatchedWorkspaceDependencies = new Set();

          for (const dependencyType of _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Manifest.hardDependencies) {
            for (const [identHash, descriptor] of manifest.getForScope(dependencyType)) {
              const matchingWorkspace = project.tryWorkspaceByDescriptor(descriptor);

              if (matchingWorkspace === null) {
                if (project.workspacesByIdent.has(identHash)) {
                  mismatchedWorkspaceDependencies.add(descriptor);
                }
              } else {
                workspaceDependencies.add(matchingWorkspace);
              }
            }
          }

          extra = {
            workspaceDependencies: Array.from(workspaceDependencies).map(workspace => {
              return workspace.relativeCwd;
            }),
            mismatchedWorkspaceDependencies: Array.from(mismatchedWorkspaceDependencies).map(descriptor => {
              return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyDescriptor(descriptor);
            })
          };
        }

        report.reportInfo(null, `${workspace.relativeCwd}`);
        report.reportJson({
          location: workspace.relativeCwd,
          name: manifest.name ? _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyIdent(manifest.name) : null,
          ...extra
        });
      }
    });
    return report.exitCode();
  }

}
WorkspacesListCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Workspace-related commands`,
  description: `list all available workspaces`,
  details: `
      This command will print the list of all workspaces in the project. If both the \`-v,--verbose\` and \`--json\` options are set, Yarn will also return the cross-dependencies between each workspaces (useful when you wish to automatically generate Buck / Bazel rules).
    `
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-v,--verbose`, {
  description: `Also return the cross-dependencies between workspaces`
})], WorkspacesListCommand.prototype, "verbose", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], WorkspacesListCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`workspaces`, `list`)], WorkspacesListCommand.prototype, "execute", null);

/***/ }),
/* 636 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ WorkspaceCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);




 // eslint-disable-next-line arca/no-default-export

class WorkspaceCommand extends clipanion__WEBPACK_IMPORTED_MODULE_1__.Command {
  constructor() {
    super(...arguments);
    this.args = [];
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace: cwdWorkspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    if (!cwdWorkspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const candidates = project.workspaces;
    const candidatesByName = new Map(candidates.map(workspace => {
      const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.convertToIdent(workspace.locator);
      return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(ident), workspace];
    }));
    const workspace = candidatesByName.get(this.workspaceName);

    if (workspace === undefined) {
      const otherNames = Array.from(candidatesByName.keys()).sort();
      throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Workspace '${this.workspaceName}' not found. Did you mean any of the following:\n  - ${otherNames.join(`\n  - `)}?`);
    }

    return this.cli.run([this.commandName, ...this.args], {
      cwd: workspace.cwd
    });
  }

}
WorkspaceCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Workspace-related commands`,
  description: `run a command within the specified workspace`,
  details: `
      This command will run a given sub-command on a single workspace.
    `,
  examples: [[`Add a package to a single workspace`, `yarn workspace components add -D react`], [`Run build script on a single workspace`, `yarn workspace components run build`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], WorkspaceCommand.prototype, "workspaceName", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], WorkspaceCommand.prototype, "commandName", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Proxy()], WorkspaceCommand.prototype, "args", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`workspace`)], WorkspaceCommand.prototype, "execute", null);

/***/ }),
/* 637 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);
/* harmony import */ var _extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(638);
/* harmony import */ var _patches_fsevents_patch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(639);
/* harmony import */ var _patches_resolve_patch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(640);
/* harmony import */ var _patches_typescript_patch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(641);





const PATCHES = new Map([[_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.makeIdent(null, `fsevents`).identHash, _patches_fsevents_patch__WEBPACK_IMPORTED_MODULE_1__.getPatch], [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.makeIdent(null, `resolve`).identHash, _patches_resolve_patch__WEBPACK_IMPORTED_MODULE_2__.getPatch], [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.makeIdent(null, `typescript`).identHash, _patches_typescript_patch__WEBPACK_IMPORTED_MODULE_3__.getPatch]]);
const plugin = {
  hooks: {
    registerPackageExtensions: async (configuration, registerPackageExtension) => {
      for (const [descriptorStr, extensionData] of _extensions__WEBPACK_IMPORTED_MODULE_0__.packageExtensions) {
        registerPackageExtension(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.parseDescriptor(descriptorStr, true), extensionData);
      }
    },
    getBuiltinPatch: async (project, name) => {
      var _a;

      const TAG = `compat/`;
      if (!name.startsWith(TAG)) return undefined;
      const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.parseIdent(name.slice(TAG.length));
      const patch = (_a = PATCHES.get(ident.identHash)) === null || _a === void 0 ? void 0 : _a();
      return typeof patch !== `undefined` ? patch : null;
    },
    reduceDependency: async (dependency, project, locator, initialDescriptor) => {
      const patch = PATCHES.get(dependency.identHash);
      if (typeof patch === `undefined`) return dependency;
      return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(dependency, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.makeRange({
        protocol: `patch:`,
        source: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.stringifyDescriptor(dependency),
        selector: `builtin<compat/${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(dependency)}>`,
        params: null
      }));
    }
  }
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 638 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "packageExtensions": () => /* binding */ packageExtensions
/* harmony export */ });
// To extend this list, please open a PR on the relevant repository that adds
// the same fields as you add here and prefix your changes with the relevant
// PR url.
const optionalPeerDep = {
  optional: true
};
const packageExtensions = [// https://github.com/SamVerschueren/stream-to-observable/pull/5
[`@samverschueren/stream-to-observable@*`, {
  peerDependenciesMeta: {
    [`rxjs`]: optionalPeerDep,
    [`zenObservable`]: optionalPeerDep
  }
}], // https://github.com/sindresorhus/any-observable/pull/25
[`any-observable@<0.5.1`, {
  peerDependenciesMeta: {
    [`rxjs`]: optionalPeerDep,
    [`zenObservable`]: optionalPeerDep
  }
}], // https://github.com/keymetrics/pm2-io-agent/pull/125
[`@pm2/agent@<1.0.4`, {
  dependencies: {
    [`debug`]: `*`
  }
}], // https://github.com/visionmedia/debug/pull/727
[`debug@*`, {
  peerDependenciesMeta: {
    [`supports-color`]: optionalPeerDep
  }
}], // https://github.com/sindresorhus/got/pull/1125
[`got@<11`, {
  dependencies: {
    [`@types/responselike`]: `^1.0.0`,
    [`@types/keyv`]: `^3.1.1`
  }
}], // https://github.com/szmarczak/cacheable-lookup/pull/12
[`cacheable-lookup@<4.1.2`, {
  dependencies: {
    [`@types/keyv`]: `^3.1.1`
  }
}], // https://github.com/prisma-labs/http-link-dataloader/pull/22
[`http-link-dataloader@*`, {
  peerDependencies: {
    [`graphql`]: `^0.13.1 || ^14.0.0`
  }
}], // https://github.com/theia-ide/typescript-language-server/issues/144
[`typescript-language-server@*`, {
  dependencies: {
    [`vscode-jsonrpc`]: `^5.0.1`,
    [`vscode-languageserver-protocol`]: `^3.15.0`
  }
}], // https://github.com/gucong3000/postcss-syntax/pull/46
[`postcss-syntax@*`, {
  peerDependenciesMeta: {
    [`postcss-html`]: optionalPeerDep,
    [`postcss-jsx`]: optionalPeerDep,
    [`postcss-less`]: optionalPeerDep,
    [`postcss-markdown`]: optionalPeerDep,
    [`postcss-scss`]: optionalPeerDep
  }
}], // https://github.com/cssinjs/jss/pull/1315
[`jss-plugin-rule-value-function@<=10.1.1`, {
  dependencies: {
    [`tiny-warning`]: `^1.0.2`
  }
}], // https://github.com/vadimdemedes/ink-select-input/pull/26
[`ink-select-input@*`, {
  peerDependencies: {
    react: `^16.8.2`
  }
}], // https://github.com/iarna/promise-inflight/pull/4
[`promise-inflight@*`, {
  peerDependenciesMeta: {
    [`bluebird`]: optionalPeerDep
  }
}], // https://github.com/casesandberg/reactcss/pull/153
[`reactcss@*`, {
  peerDependencies: {
    react: `*`
  }
}], // https://github.com/casesandberg/react-color/pull/746
[`react-color@<=2.19.0`, {
  peerDependencies: {
    react: `*`
  }
}], // https://github.com/angeloocana/gatsby-plugin-i18n/pull/145
[`gatsby-plugin-i18n@*`, {
  dependencies: {
    ramda: `^0.24.1`
  }
}], // https://github.com/3rd-Eden/useragent/pull/159
[`useragent@^2.0.0`, {
  dependencies: {
    request: `^2.88.0`,
    yamlparser: `0.0.x`,
    semver: `5.5.x`
  }
}], // https://github.com/apollographql/apollo-tooling/pull/2049
[`@apollographql/apollo-tools@*`, {
  peerDependencies: {
    graphql: `^14.2.1 || ^15.0.0`
  }
}], // https://github.com/mbrn/material-table/pull/2374
[`material-table@^2.0.0`, {
  dependencies: {
    "@babel/runtime": `^7.11.2`
  }
}], // https://github.com/babel/babel/pull/11118
[`@babel/parser@*`, {
  dependencies: {
    "@babel/types": `^7.8.3`
  }
}], // https://github.com/TypeStrong/fork-ts-checker-webpack-plugin/pull/507
[`fork-ts-checker-webpack-plugin@*`, {
  peerDependencies: {
    eslint: `>= 6`,
    typescript: `>= 2.7`,
    webpack: `>= 4`
  },
  peerDependenciesMeta: {
    eslint: optionalPeerDep
  }
}], // https://github.com/react-component/animate/pull/89
[`rc-animate@*`, {
  peerDependencies: {
    react: `^15.0.0 || ^16.0.0`,
    "react-dom": `^15.0.0 || ^16.0.0`
  }
}], // https://github.com/react-bootstrap-table/react-bootstrap-table2/pull/1491
[`react-bootstrap-table2-paginator@*`, {
  dependencies: {
    classnames: `^2.2.6`
  }
}], // https://github.com/STRML/react-draggable/pull/525
[`react-draggable@<=4.4.3`, {
  peerDependencies: {
    react: `>= 16.3.0`,
    'react-dom': `>= 16.3.0`
  }
}], // https://github.com/jaydenseric/apollo-upload-client/commit/336691cec6698661ab404649e4e8435750255803
[`apollo-upload-client@<14`, {
  peerDependencies: {
    graphql: `14 - 15`
  }
}]];

/***/ }),
/* 639 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPatch": () => /* binding */ getPatch
/* harmony export */ });
let patch;
function getPatch() {
  if (typeof patch === `undefined`) patch = __webpack_require__(164).brotliDecompressSync(Buffer.from(`G7weAByFTVk3Vs7UfHhq4yykgEM7pbW7TI43SG2S5tvGrwHBAzdz+s/npQ6tgEvobvxisrPIadkXeUAJotBn5bDZ5kAhcRqsIHe3F75Walet5hNalwgFDtxb0BiDUjiUQkjG0yW2hto9HPgiCkm316d6bC0kST72YN7D7rfkhCE9x4J0XwB0yavalxpUu2t9xszHrmtwalOxT7VslsxWcB1qpqZwERUra4psWhTV8BgwWeizurec82Caf1ABL11YMfbf8FJ9JBceZOkgmvrQPbC9DUldX/yMbmX06UQluCEjSwUoyO+EZPIjofr+/oAZUck2enraRD+oWLlnlYnj8xB+gwSo9lmmks4fXv574qSqcWA6z21uYkzMu3EWj+K23RxeQlLqiE35/rC8GcS4CGkKHKKq+zAIQwD9iRDNfiAqueLLpicFFrNsAI4zeTD/eO9MHcnRa5m8UT+M2+V+AkFST4BlKneiAQRSdST8KEAIyFlULt6wa9EBd0Ds28VmpaxquJdVt+nwdEs5xUskI13OVtFyY0UrQIRAlCuvvWivvlSKQfTO+2Q8OyUR1W5RvetaPz4jD27hdtwHFFA1Ptx6Ee/t2cY2rg2G46M1pNDRf2pWhvpy8pqMnuI3++4OF3+7OFIWXGjh+o7Nr2jNvbiYcQdQS1h903/jVFgOpA0yJ78z+x759bFA0rq+6aY5qPB4FzS3oYoLupDUhD9nDz6F6H7hpnlMf18KNKDu4IKjTWwrAnY6MFQw1W6ymOALHlFyCZmQhldg1MQHaMVVQTVgDC60TfaBqG++Y8PEoFhN/PBTZT175KNP/BlHDYGOOBmnBdzqJKplZ/ljiVG0ZBzfqeBRrrUkn6rA54462SgiliKoYVnbeptMdXNfAuaupIEi0bApF10TlgHfmEJAPUVidRVFyDupSem5po5vErPqWKhKbUIp0LozpYsIKK57dM/HKr+nguF+7924IIWMICkQ8JUigs9D+W+c4LnNoRtPPKNRUiCYmP+Jfo2lfKCKw8qpraEeWU3uiNRO6zcyKQoXPR5htmzzLznke7b4YbXW3I1lIRzmgG02Udb58U+7TpwyN7XymCgH+wuPDthZVQvRZuEP+SnLtMicz9m5zASWOBiAcLmkuFlTKuHspSIhCBD0yUPKcxu81A+4YD78rA2vtwsUEday9WNyrShyrl60rWmA+SmbYZkQOwFJWArxRYYc5jGhA5ikxYw1rx3ei4NmeX/lKiwpZ9Ln1tV2Ae7sArvxuVLbJjqJRjW1vFXAyHpvLG+8MJ6T2Ubx5M2KDa2SN6vuIGxJ9WQM9Mk3Q7aCNiZONXllhqq24DmoLbQfW2rYWsOgHWjtOmIQMyMKdiHZDjoyIq5+U700nZ6odJAoYXPQBvFNiQ78d5jaXliBqLTJEqUCwi+LiH2mx92EmNKDsJL74Z613+3lf20pxkV1+erOrjj8pW00vsPaahKUM+05ssd5uwM7K482KWEf3TCwlg/o3e5ngto7qSMz7YteIgCsF1UOcsLk7F7MxWbvrPMY473ew0G+noVL8EPbkmEMftMSeL6HFub/zy+2JQ==`, `base64`)).toString();
  return patch;
}

/***/ }),
/* 640 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPatch": () => /* binding */ getPatch
/* harmony export */ });
let patch;
function getPatch() {
  if (typeof patch === `undefined`) patch = __webpack_require__(164).brotliDecompressSync(Buffer.from(`G1QTIIzURnVBnGa0VPvr81orV8AFIqdU0sqrdcVgCdukgAZwi8a50gLk9+19Z2NcUILjmzXkzt4dzm5a6Yoys+/9qnKiaApXukOiuoyUaMcynG4X7X4vBaIE/PL30gwG6HSGJkLxb9PnLjfMr+748n7sM6C/NycK6ber/bX1reVVxta6W/31tZIhfrS+upoE/TPRHj0S/l0T59gTGdtKOp1OmMOJt9rhfucDdLJ2tgyfnO+u4YMkQAcYq/nebTcDmbXhqhgo6iQA4M3m4xya4Cos3p6klmkmQT+S4DLDZfwfMF+sUCx36KleOtaHLQfEIz0Bmncj/Ngi3lqOl4391EWEfIss6gVp3oDUGwsSZJKeOVONJWZg+Mue3KUMV3aMqYJ+7b2219D+GFDi8EV5y/Y+5J+He0oNjKAgqLsJziEsS9uIaCu3BHBKSXxNKKa2ShbfglcWoiiVT2kfGI7Gw+YJ/Sqy1H6wdFWtyVUQIa82JPwbeV25YKLzc5ZIFM6GCPSA+J9dTvJbs5LuuKnLP3f09gCu2jxqsAv6CA+ZySVaUJr2d3A70BC/uBCKr2OVrWgC3fSwb7NlfkgSEEiejrMGvhya9lMbVI6lMsFKN330A1/FOaefHQdNGLEZ3IwFF87H3xVlM0Xxsmbi/7A60oymRcIe0tH90alG6ez/yA7jwYotxuHWZdR+1HlMcddGHAV6QD/gXYPV0wnNv47I+5FGevzZFMqWSO8GU4nQ3FjsdgdJcD+c1rvudERKuLyd7bxiBpnsMDHsvPP4nXdXkld/gUNks3GAE1Otmb90bavDyiw4Mrx496Iw+jbLTgsCZGZXSZ9vM55C7KGe4HyJAKXEk0iT/Cj/PFwLJBN7pcP7ZFfYtUApGTWKkYhI9IE2zt/5ByH72wdvH+88b71zuv/FMCX3w6x5nzhY44Cg5IYv9LeKwHuHIWgPbfgrAcUxOlKkPRdQOIDF/aBuLPJAXD+TgxCNXx4jQxeR/qlBWVikFPfEI4rXMUc4kZ2w9KbPKYRvFUag0dVlVoyUP4zfidbTXAdZF88jAckl+NHjLFCNdX7EQ1PbLSOl+P+MqgwEOCi6dxgWZ7NCwJBjWKpk1LaxwKrhZ4aEC/0lMPJYe5S8xAakDcmA2kSS86GjEMTrv3VEu0S0YGZcxToMV524G4WAc4CReePePdipvs4aXRL5p+aeN96yfMGjsiTbQNxgbdRKc+keQ+NxYIEm1mBtEO29WrcbrqNbQRMR66KpGG4aG0NtmRyZ2JhUvu0paCklRlID8PT3gSiwZrqr4XZXoBBzBMrveWCuOg7iTgGDXDdbGi8XHkQf5KXDGFUxWueu5wkSa6gMWY1599g2piQjwBKIAPt4N5cOZdFBidz2feGwEAy1j1UydGxDSCCUsh314cUIIRV/dWCheceubL2gU8CibewmP7UxmN5kN4I7zfQhPxkP0NCcei8GXQpw4c3krEzW7PR2hgi/hqqqR58UJ/ZVfWxfcH5ZKMo4itkmPK0FCGxzzIRP20lK/gz28Y03sY233KvSVWUKl9rcbX6MbHjpUG8MvNlw72p6FwTejv92zgpnCxVJnIHHZhCBxNcHF5RTveRp513hUtTHHq4BIndlytZT5xoTSYfHKqKNr4o9kcGINIz6tZSKRdtbON3Ydr9cgqxHIeisMNIsvPg/IFMZuBbSqqDLeSO5dak1cGr76FtH2PC7hs0S0Oq3GsmF1Ga4YABAMGcdPAWzTk26B7cKV91I2b0V/GYvnsEQ1YGntRqi5EQqTlgZszbV/32GuZtUF49JOA/r4jAdwUOsbPo6mNoBlJPYjM5axrZaWQf33bFsLWqiyvvDOM4x0Ng802T7cuP2a3q98GWq6yiq6q3M77hcZlOUnmryctRYmI4Hb2F5XixFohkBmySCjU+M7/WQVE5YAtnlxiUJDhFN0y1tNeMWY9E0MfZi2rQ4eC72WXjsAA==`, `base64`)).toString();
  return patch;
}

/***/ }),
/* 641 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPatch": () => /* binding */ getPatch
/* harmony export */ });
let patch;
function getPatch() {
  if (typeof patch === `undefined`) patch = __webpack_require__(164).brotliDecompressSync(Buffer.from(`W/FcOBIh6A6ch1ZVK40i2DgInvHffCZC2DiAvIWvCah18cYQrZVDa/kQEQ4XZxwaXi59suGHIFFfXWfmr0IJmQMP7OmW19PK0KsK5SYxdxHgNvEjYtHF8+nIpGt4SgFjJxzvMnPmcgWkZf/dcu8yBWrIo4GrcbzmZOymmo/mxEhL7W8rtb8/L6ULH2ZTGymt4QJec0PwjqSURuTYuiUt+jAODSoyTIZotkF6ZhSqYii2d5mCzodUEilSnPYHHo4Tw386mbIVBjAkKIFEHfCbXdLdW/o7Mf///Wlv60/gCRB0KbpPVHThNqmzlrXvOffMiPxjSfYayfYHpHPPvU+S9eT5gytjfwCoki5cJU2dpk2VtKmmq2X6AFAFqAP+32lKs1GkDN/Pkrt8XTAEBaB2E9z3JGVs2m6YogngJS8nobaQZWCeA6wnhjPsqkvPRLKI7U5fUV8BCfRuv51OsKkRPs2/oMdQa+XWahoDiIg4m/Z9NZsl7V2HF2xtMsTJCKicYjNJ7aJJ4eL1Eodhj8QXOXv+nKdTow0dTo7nN9/Z7UIU1SnAj1m2C3XH/DeYr1IN6y8IitfnlPmcAN+nnq/xq5/eO/1KqkT+0+r1PRB0Pvh+Ub5g8Pybvs7aHeWfKIpw3EgtDEM8P2M0gkZv1nqmv8K1tbyvLYTI6eql9WsDu5y8gNqUknZQ4Dwaet0UA9kGYNvvGQqHHH3luYI8lQ6oCLE7VfWzZX+0lqNBlmbNMMQjkOCis0UOf4FGjvIu5RdL8NSz+jZDQGOwKKKuTE/J+mguq593ldeIr4or+bYdB+QRhud2sws1L2vayvX5KOFfg/skZLX4TaK9VFUPtlHP2+LhgIgy0z8vkMf+C//KorgcXRrI+4CAnfe/ujwW3Mj/PyBD6onW8FCEe+peXk3X4ZJvg1mUTxBwsru4DUJPINKPzZo4K4uuy7qbP50yqA2OhihkP4UyfjXPaiXbEitEqr8t7SG5efEqvivbuxCunXXZVRML+WCKL77hHBIEzBLjy6yqalURyBM3ag9BZ66XVGEUGu2A46XgAePKR9ttVA8aQhhEFyHt+EttqQrZh9yJgSGDCHrXVxSVCdiUsn96jBQH7jbChqviu2fPOf58OQa6+HrcBiQx+Dw5QZp+Zt81Z1VMkht3EoZB5pAMmUI9+vldXjucFpbWmk/squdlnXsbuhMyRTKwH900D7j1+pzEMWtoDD5nQAUAmw7VFkGIMgmrFl6rfIVYyHc+32EPKQ0CMBaQPqHPFIgmBRKcAiWjeqDESwTMCbcFqKruw9giq4mqYUc7i3C9AEf94cLtWLIoOqiyK552po+xWCzAMimiHrMwGd5wbQ5qXJsT0HBTon46vyJ3WgJuVEPIUZqLFbAwkHUVviWrQB93Hd8D6iYMeaHsW1ybZLbjiEmQZG9gCxBJQiWsYWdyA9Hbk+irMysIVLgeRtQUFGSbnSzX4+WuFT9Z4smbUEe1T0UqysuJd6Y05HS1iW0TdZIfMMg310/loSTpcRLIYK5eEAKLmzCgvTw6G2wQWGSVcaNudsjm1mqvO3NyQLIh72PxETtQY3w0+J98q3SXXNVA311BZ7EA9KrIXEZvmamvvNq/mkMQgjwXXMeFwnlF1MLweCqhj5lZOEUXkfowsJDWBee5g7LJHpVQFM2x8rNQxJOCuPuep+cDsSvQDogt+5pzWEaV8/PEZitbZe6zxA6bgWfZcmy6+P92xgxnTNZclUMuuwznWlflqwiJhktYyiGgQqzr8TL98sOH3IWftey1510Sm3cphSZL9ep0yQ2a47L9CeqX85K2FlMUQsLTvZA95maPte32YAq6R23G1f0lFN70TFQOgdrPcfcZhVCiZ5wwfQNzNAIdaHSlKnFpXV7zshpE9hA+zpw58OSPPQnmn3gvbqEWXnL0kfseCAouvKEQRvXK6IuP8/zoG97OwxX7ZWvlUj/tgEKc5rXbCDtdqssmh/DzXll08hFbiyS3GlqbZhQAvn3CB67sL0NkqqoqiE2IkuOLAuPJul12fzZnUH0jDhQaW8w6npGBnijnAWJE2riJGVJaZTBOcV0XansNYvC4JCs63X5acLvOgVMxc1Xppm1y2K4Cd673zuT2b3kBY7ZT/BDPpzK3Xqu4ouvsIUCSr55SgnDQtKWZ0aHctitBD6gWgHjXXnAZ6JkHTINWpU1YSyhTUGQXeofkMgEBOoiGSGzEhviWhoVLirfjG5dVDuwBX+0CJxs6saCuWl4lcUDJtZUuhTokl+a2sn9xH5pZPQEgXrd2Sog/5bL9g/bw7YGKAQpBpuoD5DqT3IqhGi9wydUo950EipH9DzJbIuKEBGCyS0bE1xEJke8OSEmSpIhYCJJk0YiLR9rO2YtlgN4DTChrsFNc2SVezjBtsxZL1wxDfaF8SCXlxsBBVI0Qq9yhGiKp4VHnSjXPNnLinXj6V23yDdZ/AZpX3wlsqesJt5Bpcmk79QzhvsK1DXY+OlG9s32TGAQrp0AAF+ougTH0Xa18kH0pF6Vho3Aowqitr3B9h3Iwn6mNQYQQYR/UuE7nYMh5XIZ1TxQuxyDYBYsashrUu/FO/wmN8Fb2TF3VGOJQ3uM3716D6O7rWxZB5aBr8GoGMi/S90Slr/T6KYgQnGKWxjiMxUbjDDd+JxKFYqNiq1KcXoFVWxaYaKX1ZrDlvwbaXf/WVK+/KrEmRHCMZfyIYRuqm/txKMr6N6YNqKqtMw2V4DXEc6PLUyUN4fzFp4xA2T91nQrlSE4EvQxqccpXtmD/8K+7YODYDQ10dOeOXzjCE2m8WZpVSHiTuXVhPdzvJJyZu1oRlFGvV8d3bIiVWL9AVceaug6E5MKry/vAwff77Me6uw/cWW+91LN8fQdzbifF28uVdb1tzntRF02Bf4mibjahfCe7raRDybnAo3+7Ju5WUfNwGHwA3tycufPKDO9qCoe4x2Qt1OReQOrW/QGMH6plBLi+YFnXqqqumIHUo4Hz8BOd4J3uyWNCmu4miez92Tqx/8ZweI3NIv0u3AHQOFJMeaT+gcQr8e1lPKmg0xgdsL9u3O/Jx7vrXyAAgTNwVrhHGTl6dwiWCWXH6noXBn/uusJK2vMiwrq6cTxJyy11txwOPOrkXxMKFNTsdqOYFj7Q5bnq3rEi0NN0seR8yehzuY51fHDo2zSw2GDY6xee61g73DGhWmpWJtvKVozLtLpk7nkoVcr2RkmkLG+jd09k8YtIU99qeUCIMfRBxAVm2YLozKvCl7kFAEK844oF8WRhc3jnRe27eEdqCjxdIwCwRGmoCwsUiTlYX9TlbVy5954Jf/rm80bf10NB9l2EZXsz0ZRXTV7uFgCYYBh4sbAaw+0Xt9MY7n25RwCAB8nKTLTl2OaiMW9jO1Dvtw7+Bh/odHtnwj4U0Zrj23m4rwJAcz7u9/f9r32elLsc3VT05m1UVb1oIDyP2sCxywj2YUgf34b0q+yXuQUAbAys+a4o7DQQ5LQjCO7ERFojABBuL2HjNrOZJHfifrPP3jH480TXwWbv5OxI72J2TMsAAHAh5eN5AfQkl60xadHVz5YJMtWqsk9xQYaqzvXDDBTbXEr+JPowCJsfsNF4mu+ItnZ2TL8FAHArqSyemDyQSJV8QkJ1aZIVJK5Lld3dAfGe/9YIAFhTEJqqsWLwgMMvzj0ugc+ruyEry+t4JTMuem0BgCIGzhgWBi7Rnqcxo19plwBAc3pK9PW8bGcQ2r855VMrS+iIGMyOaWwBAEEZNnaFZ4Fso70KM6Ugb1ojAFCUkaSxIgB+gLwfut90kQgNCMzyOp1XASA4i83QuIuvRtN+1XTr33Z6yzQvNkvuiBjyNZ0tADCLbLwxhgcDTrY3lRVlwPpGAIDbSs94D1paZuL32gGugJbWDQP1rpP6jFxkCpkd0zIAADxpNqVxrYHiZ6vwbLYSNHbbF0DZDPscFHeaXkz1I3n0+pDcL6DK03xPXO7ZMf0WAMD4pCWNa+0tBk8Bz6xN0dhp1yG4XiZSMwGAUBEGNNHM7zv0T9q5kQjLMhvSGJc9twBAGTW3C8KeQmAtE0b7MbheRsolAHDcB/V1824R2U744UT7YIW4LP4f13puAYBaBG4xYQiHgUWG0W4G12SkbAIApiJowIS9+eyRJdkhFSkxy/rXfRUAkrNY7vHkJ6Bove3NGKW5V39r+ZbdisZBqfia9hYAmFF2v5zhDgZouBsDTGsEAIzmLU/RIouvUlKCnmtGbmPV4mwkcDrpbbDwQj3ObFkf4F3qViC0d5N36kWqxySsWDscFymZAAOTRkcWeadIiIG/v4kF2Zn/8hF42ihb5efkULxFNXCk12cf7DJPzb/Bam929Wb57xsFoQOGcjr4iMks/kBBnm3wgfGz346J1f7kG/vanr6DerdxwA+RkW7zO+V6gsK5fi2fU7vWYmW7Pqy56+wTMoIPRxBJZ2FMoBq5tQRvAn2Xy8HcC4zH7yHeTG8B4+Gdad8tSjtq05zy0AlhMpOhlq3CX1WXPYNlJz9xc/ni/14GuTHUMv9HjhIEXszSK/pB0YjgCIGqAg3xePZRMdoyBIZpRoZpxla7kvl1MmHdA9MfgTlIJ+U97thWk+IYrYV9xN7HpmrJJL2ptRJASRqiW8t6ioqJpUDOrQ3EtFgdV6nL6LqwyND5aCwGFEo6dk3v4C8t9xgbiBGVy+uoOC8B+XseGAKz5kCmdHTidAb8cSkwuzQ5nKPQ0/wcK1/1NHaTDkt3T4Lv8NnnrsMt3dt7ykXssMtPueKKaqJg6U65mwYK0l7IKT2FaWrx8z8hKkcguliG6Nz7AC30YGBSSwT61FQWVdj3XzLGAB/3UyKQvhV+a/pYJNVVgZBF25fZbgfYxErIWPWh+JuVQ6I8Ga96oBdXg0dCCBO5w4bn+BWb3870n59iNsgjO1vH5fojuOHnnO54jwdEhKutrDxeWbwRh/5d4412T6w9MANoF1osCYhwwSOl/4WKHP/FM0yTJsdcYkoeFRyKEvO6x9A+hdFieS725qEJ0n5X5vl4YgI171qxwRfJt7Br+0mRh0UyhOwhJluuBMbrx/tZ3v9F+hH76Ypps58XLdnD3SA5H7h5fOPOE+qz/dRdCfC7qJjF6hvjZlTCsGCJSVjOBW7U26imcAgA7P3eSOwsVQvPRVnexvXr1pdztnXHdpDlk0na/DTWMj5exJwae8NClgleOwUR9qsXe1NisBmhvjzZ35YndxpLIwpgzpJpLyp7I9SxXx0BpvfXoWm7eJ6TW6dI/jgr49IZ9gyjG4sKYlnCRt/JBUuLgekouBmU6q/MdkJms4SBEH8P6MRcd++yTZYMYj7dX2EyLOOZ8wNVjn2YCEp4HKxSHgfrfRG8DNDPAJX4iJcB+ulMyY8xI2UlsuXRhzYCrWYsQ8mOM7GIRUu7iPheK26FN880OZmO9XO4fejbSnPKSmI3P4XE3CTWw1TPr7CC4sR5psE3apN0dmKn7Gp6TjdN+Dm6R4AkwPZtmnyreHZlsvAAmZZ14XTcAGJ6nRKEU+F8OgYopE5hiarElqwxc8Tm+Vj7XBCXNauBHxNtbd6vbHG9omNwyUzasZiNsqHSoD792EG8/1QHlwq7m1b1I3zUZPSIjWADVrtE5tZoUzYNa+AkvPw5FJdloZhmLmEP2sLpnj0cTDz1C/dGtscnJsecHi1v7Zr9ri39/09oRUw2qdon+Qr0fOg4UtOeVF32TMUb5oyyivv8Z7VaJKJYjeH2oxWngBfOka98OwqV4I3C2WLlmekdmHZdGnnQXCu92bXZninOFYxxpb4TmmBp7iUwRuaB2ygBjo6QBRzKO5ix50nF1BoufK12rNI2I00bfN0sQWKm0smf2WU7NcCkwj8dS+cTinRq4iULpFxpfsfWrpg3jqfs/8ss3VdmoIuKnqFtKdcM1ez6EgGYUvjidNQkxWoyzYZoSciqwR4qoa5DNd3QMS0eBN7O90ppGzkjTd6PZnDGss6wqZdndMsAgI3NQWMKnw0a7bLRFE0AQCLFljsgI0vghrPkuaRvT5whk5Im9SK6YY1anFpvFbyjR8+IlveZGaxY1gp44l0GAEAamh/JOA5G++4YX6MeTQBg9UZnW34Fms4U6GPIyuzzgu+ynopIasitFu/oZn7T8hgaeeouFYAxNfIaDq7FYx9+RvfNeBo5Lo6lGay1rLVg27cMAPjY1LxySWEXddpZNujRBABSooUtF0DrbAAJUTvJsg+//rvXH7t2b0B/cR0xXfeNuN/bFFjDT8chEsRhylcGANxIWEY+wa5AmeNzEem2kxDeqWM+M+SJWEtiOQ3sxOMDXrITisFEBEpVmDU2aSMJMTAiI5Z9YhAU9tQqxC/ODrRpmW29kWZDVFFWMa5ptrMNgkz3i7iYTUu/YoxiNTUcmnlrJEl1ikC9kt0yRIZVylFtnv0SQkjzlj4Ip+Qpg9Q5EyyyigB3p82NTNAktJjqxyT5vei0Y5baBF1qOXsf+gkLz1mnHl+mKCxY5BKpRmLi1q4wKFRDmQuoZT90vl0lT66J3p4qOxCDcHq0K7g9d10c9hlxSZZ2XB+dy57miYO7dXnMBLJUEYa1OCMa5Ul+7B1TYD6LaqgJSXW5W3SWLtokcZDp5rgtswslQ2NGFVm2KrRwymHmER9ttY19Iz54lrKO636M0t6x+sxlERbmNLq9BT2d7myJ0Ex7JxbgLkjB6sRj63ZHAUlONO0IN2/4zrZ3keMMwyMOM2fmFlXcBfVRhUUTAKUDRjh09MgjcXx1DQNiA8i0ZuDCKzutc3Z8jDxadOL4DowZMSJkQox6cWIapim9/0r0xnhb2CN7XIticq7Ju4XxSiQ5SDcZzqHeLsBn2Z090wYvXSniHIWlUiQOpMiUb4H3XX5Qfzz64qQwcPN9oB02j1V7Etbw/1KWAQD3JFsqCGcp3OKp5FxlR9W0shmhePxfJgCA2tluo4tX9+EUdxcv4Xn4fYzVi6BsIB4z9foY5TOa5JQjgNdf/c6W9nHwDc8/jy+Dy22AL6iyC84B3mNQPtImC8vHBFaOQNyKStZwenxxDt1Li239jQ5kny1KlT/qiNK44eP4NWzlUQ6lSgKZSV7fF4d9krlxOQW1wFsdTe9hVjYfRa9PwlHVU8AoHA63ofvfPSlm75k8DmCz0I+OqFvOqWNDV36/0gF+Ao7qyyCJCUOvUXMYzy5PVddZbGUjtUjWNxrEaHfncPCj3uWzqlMDsIUSS4TqWAujopMdFFM70PHTqQ5YYSWHK5nC+Qr2xOoYkOStnASeQiWLXyWz5bPKX27O5321gJrerr9lKDDPXFw2S9XTNEH2K8sfJqS2GFgLs+Ey4vWKUDPhSVRWlg+gIjz4s0u/sA5+adYGgMtEyDS4Gst6VTQC73qXAYBdkNYQVhpKG6iGbnsbJPg0AQAZnC273yI4932UAGC7GDOrZPI8gHdKmlKNiL3kU0OHqXljSR5w/aMpVaUimldH5QAUiBC4cZpq2Gqf9OnwA4eMf9vWoCxerZQDUEBC7C7hKrI/v6LvrBz+vlNBtJ/iEeIdFZufjlf3MAKQ/t4yAIAIYNYQRsuhUpDltjdBhkcTAGgy7mzW/R1DI79JAEAjau+qP/BzlJ9l1c8hrc18rJ3R+73NyD4qNj8dg1hHrci/UsoAABuhtMcipugb7tj8FaFrjiWHXTBC000pzd+KTzCV7wtLOm/Goc/9qM/DXDRKbTDEaRE49rnia/0r+aig6OJu98nPtWL8D7poAExnVP9zrztM8KWD8I0V67r77SdxEb4ObIqSS2zJDlN6CPsCgZr8Rnm6yaqYINI/FbUEnBthfhyjqp/TjQnSIYg9I4lk16sSPgMXzenMoJmH2vvxZI+56SBa/kJpK9PuCvK6H09vUu9NDzrk2UWpboZR54HRtC7K/LpSDl2D8LllJ1Ari0Rx/VsIRDBRZ+DU9NAjjuvDj+ON/aevT0499ictH0uH+omcu/Q7nti1GSZ3GJ3lvhIriXjHxNnQwdBffpaINbFHk3c9O/dN5PB0capHMBvmmT6bIWMlMh/aIiCga8PFvLdpG8ZUNbK3hbPErumX956RUrU8zwAAIKudmSx5e6fUWYc4Ss9f2xsMG86uaUdaBVo6NT/Ihqf6nucPfTvgKneER0QY6w3G916EX16I+QzolTCEFhl0bw5D7M9hg4vYLyHuinEkb8pE/3pL/noFCwJldDApCB9UzzxVsivBeTF8jVkDUx0Drdic4NGtZnEaaZViqxN9mLIhkAc3MKUVnurfEd4XTS3TSdshMDo7JtNkkDpzYrOVBiHFOUdWZjonWbH9lW2Oy1HYSAbE1x3faZFPFDcjhrkwUNDQuLl0HJV2kCq5Wbttk6d9VCYaZPiFA/QDwuPVFvn3FpS4Y3ggY+ruB1eU4TD+rRFIKXgP41IQF/87cTrPPABh/BNbN99Ue2W4pdzgO7hi1hQ73CCr2bGmpNPZ+rxwjyzX7/dfqVrAOjGee2FCTlbMVRMsSnFICneBI0p0P7fiGgswtsGaIetoRBmul7PWTzuiJFKhLUFfu4RdnZIDpJvCcuZGyEArU8bO/uLHx2HIi6tc5Xwiany0e0HABk2MxyD/zrSKY95+9jSdhp9tIExP1IN4kl849mIpdioNxuQQ6hABjIPm6OtD+6e4gNg0WGxoj/NsQW++gQ0mtGicAbhTSTe0P+17N5SBOlHQC6/wl1SlQdlORugyBRhmsb23jf2lTNVL88eCFpMTziomFZwxo5Q6CQk/JqwyifxvmAJaxkCF5QwlVqC4z3jq+Lw08+hqj6pE2zrb5HIUTd6MYYjJ4NHpyzPL5lyncUQcV8YjotIL3MiK3nk3gM88mV9JfK4jMzYrywiw2bJojg/rQ7Vpl1YS4CtGkius6/cGdMW1xkSug0Dpz5mqyKUX4gUYPFtzOaEf4wpJQeWqw8G8qgPfyvt/DVlaycH0maKvYXGLrpkrZh8uUom6R5QlrURpW+ipEmb7UUjQ6A9TmEj4qUDrBxU76J6zevRY40Lbwn1osRM+CxLPIMz7vSBi/hFlD26WzreghT28j/FZhMYP7bw/4PADokSKSObb/FlPNH9iQPstfzG4+fKt4yq4D4KyqsHOaxbCGv6fZhkA6AnsYRFTHHZxiYq7CDe1LBntrFFNzjUUXyYAQNwb62xd7apH/NcrRVMHv+Y9M6wEn7UKGIunNrphT59H/UTC0T7g4TDwytGVTdKFPOHrga7gH3pCQeJysXXE0qUdAGvRMRW+qRoRmrn+Pgcan3oTGLMBGexXQ8UOgRChxIfoCAwvkkzCH/RGfyta6Qddx9/i0we0+n+6ZSs2V5Q4gf+he66gprH10gIxSkAjinQyYKx0OFTsQNezLsvOJW5jC0g0GtMrZ3yvzX4S2HaLtRjiQ25nsFrDWDEnu/jHBXfLGM1wrPi5ksyn1s3Ocqi/fx2cp7txkpD/Ws5rs2QK/wPsYA8aXPF0/y7MvpHHdfMkCNIPsh6/IGx9gjZWbW/87rOdMxdzx2Nkj4W4L0zNYiCJRKMeDVg9BoqX/1svOUcRbGA1p2JK6ZkZfR40qO2aHNt1+1hQbyLQ6R0UNiy+4e3yp6Od0wAOBMj4hyWxru6DIPYPImGTzsW/n2AY3nxGXgxoLoGWOJ+vriBIdw7sCf08pH50Wbv+qsFHJCbOAD4JKzvrWkeUp56C1Uk50iWcq3WqUc40flU/alss/yMZbnSpM7R8ltU1G9wX1hmtJBkEwwUlc+tCxqJuij63yvqz83pZt+goa4eZDVzxoBFppzc+4fzEdqfudBvewAsLYbbDY02WLBELcV0z9ObN403Jt7dm8d3VPKI5RGxl+YyGiWS4m8GM2hCWN+ZvkArN4YECTtiBTqBR0I1ibkBzI8IwbRmHftxJuINreGR/csqPD2tgE2A5NVwKI+voAqwo8uPCktOM/t6zVwVT7VGngF46hwsG2oHgx2HPXmAHZo1rAIPulTSCp5oilyjw2NrIl9PaitujpaHN7+jNaULD2AzkumRisjImr0RfPuJM98gx3f4y+6WsnoMd1Xf0Vh7Ff67pn23t86tGVEnuYSJs04jEPrSc0RltGtVpkYVmOMtHlc68iVXARONK+ayG+EYI67C6iYV5gbXEBB8AHn09O8+lT6S6WAbe2xrCgRl4Zyyv7L4dErOrfdETYn5K1xuwvGdkyW668O9kOkIFcW5p7H6ha4tqhZ0M2cpFgzu5hF75qA/E52nahIamua94cVeYpo+qvXoYtdqgSlYoMf41/GdNtpm6ghK+izIHHaom4BPpD05vX/0B5mzDZUlo1yhLKj6BwdI0roKYLYEPfRgm7LzAK2Oi3mbJZaxr5zFLjRG7uBKXBU1bt1HyjYbLIS8M5w4GBisqn6HtmpUed+jRy1Vx4jDpQr0c56QZkSh4BtZt8D9bzLjJEOlslW91s//RI04wc8Tz4ipVCo4xCStcAzthSKQHcdRaINJ10ZYw3Wz5mpaZn+LxXt/vmvgrrpdzIxLD0sEYNkETL5vd3IEQMBWezGcX5dsyelfviI+UuL2r0uKYYT86gNKsiB1DIADbwfbvWxzHTxDH4YZ9R/NxVG99oQJGRswhLSxcU/SDVCNXy9/lGYP58wtTcn76+Jv+NfJu+JNPzKgB/9CSkcSPUSX02ervznnjb/pgoPLEXLsT2Rj8TSZsCH+ZCA6ES3sx88LI1um3943hU9ljufH3EvqCCjJAGoz9nNDR7Of0OlI809V7Sa0GfVKHpJmMxb2r1659xum0U+EfBHxMm33CEyOARZkx7sWaX64v4kJWK4FhMYeCZ8OUA+rZRz6mkShmrwVmWyYd9C2c9q/zQShF/NsT9VAJ5zkdp65hqQ5fk3+lKwMAMYLTx+LbxH4JCiUsJn2oIXHZiSOzR6ld5M0EAIJuRWbAhQWbnAGnSvTulrHr/V4/ABAsQKoItQawnZxP28CCebFcwHILf7oBTLgEd4+yyQDv2e/UNS8k1VmSDROyajopsSVAd7nZeQAcc4tVAFYXs/cMcJx/qwGAW1a0ACKCblODHJ7XGFpH5mItwazRQJy6AgmgbP/hOPwSahh+f+uNT9+E/Cmzzz7ysnh1ChJAfUSxMaUqMmq/Z5orjrqpsrue2ojiDdKxqumDDBPCKqZSlgGAlsBuFmYwjXAdUlz2wa8ax0uc0vt67NEEADCM6eLa3IBvs/SuGOry9gMAKDDbidKBm7aPAk+ssRbMcv9sMM4x8IIWubciRKVw3CZKjdYv4n7bQP7AtAViAjieIm/YPA45OE4heshGWhkAsBI0yML8tBHaLYbDvm2E6Q0jMz/2KeVEgysuNC+AYxKLP1eOgFviJ4/YjbnnEhBn3kngeHEum8dY8kMvLk5HbHzX3GWLfa1Z//wfnusE/h/cYoshJBI+zPp+VD+Q49k/sY5uq1k/TeH7I/6fpxQ1MRxHKY6Z2zzAKEUOJRfeHZ+nuHeGMyYYpTRHRYHAiC9TIu4vN0HlHrpaVcH8a+dB77Jrf1sLT+B4yrX5xuojB1vHsYevaZYBgC60JLhtFobwSlJVFJMd53AxQpijfD8TAFjkfR/Yw99qDbg9W3+YscPAc7QG+Z8c5+jnbEk6r1bomKu28KorqLO4MRGOP9e9tMUAwIqGjnhtko2uZB5WWopPpZ2zv95V3bRYvWZ9Eh6k4ejxt2FdXDYw7PiZc/bXuwZLS4EAHrmE4S3rHTh777zE7mgdQ50lVwbhLi4jaf2F2jS3efBn+lZ5WbFiGQix6z8VMIcQa1ayYRUhVPXHGz4Rcmc6FdFdiM/huM2ItfzHq3kED0i7fwv5ERyPas1Px1a2CfW9j9B5v/F6j9N6ITd94ynPgj/EqoanEh2eZQCgW3LuyifOfPa9ZIUkHRruWZohiTJd0WgCAO1WFGJ3KjYQd8IHoLtUbiXGtvr7BQGAprnU1RgHarbpiigwtXYPkAIzZYmxUmDQrh8kBThxClZSgKQt33NMlZJJDQF1lShpxMud2jI3GxDwdm4RCLCumJ0l4DD/zhXgVllRiojI4LhN9O6gnD9+XGN+a4MMkfEb6w0kgLr9hyOE4zYh4db4k9Dj6W3ywyuCzPyN9QsSQIFEwT+6ENP9JfKq5D3AK1nB5F/kPT8BHPOb9XiQZ1l54OqUZQCgzgguA9WawfQhLs/5l9E+PVZOQWefJgAwB6ZdGxZYypRTMz6R1yAAaIHHTtQSXGX7MOBea7wNHrl/AnjoGKjBiPW+AQ==`, `base64`)).toString();
  return patch;
}

/***/ }),
/* 642 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _commands_create__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(643);
/* harmony import */ var _commands_dlx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(644);


const plugin = {
  commands: [_commands_create__WEBPACK_IMPORTED_MODULE_0__.default, _commands_dlx__WEBPACK_IMPORTED_MODULE_1__.default]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 643 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ CreateCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);



 // eslint-disable-next-line arca/no-default-export

class CreateCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.quiet = false;
    this.args = [];
  }

  async execute() {
    const flags = [];
    if (this.pkg) flags.push(`--package`, this.pkg);
    if (this.quiet) flags.push(`--quiet`);
    const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.parseIdent(this.command);
    const modified = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.makeIdent(ident.scope, `create-${ident.name}`);
    return this.cli.run([`dlx`, ...flags, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyIdent(modified), ...this.args]);
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`-p,--package`, {
  description: `The package to run the provided command from`
})], CreateCommand.prototype, "pkg", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-q,--quiet`, {
  description: `Only report critical errors instead of printing the full install logs`
})], CreateCommand.prototype, "quiet", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], CreateCommand.prototype, "command", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Proxy()], CreateCommand.prototype, "args", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`create`)], CreateCommand.prototype, "execute", null);

/***/ }),
/* 644 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ DlxCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(340);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(162);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);





 // eslint-disable-next-line arca/no-default-export

class DlxCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.quiet = false;
    this.args = [];
  }

  async execute() {
    // Disable telemetry to prevent each `dlx` call from counting as a project
    _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.telemetry = null;
    return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.mktempPromise(async baseDir => {
      const tmpDir = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(baseDir, `dlx-${process.pid}`);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.mkdirPromise(tmpDir);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.writeFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(tmpDir, `package.json`), `{}\n`);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.writeFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(tmpDir, `yarn.lock`), ``);
      const targetYarnrc = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(tmpDir, `.yarnrc.yml`);
      const projectCwd = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.findProjectCwd(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.Filename.lockfile);
      const sourceYarnrc = projectCwd !== null ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(projectCwd, `.yarnrc.yml`) : null;

      if (sourceYarnrc !== null && _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.existsSync(sourceYarnrc)) {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.copyFilePromise(sourceYarnrc, targetYarnrc);
        await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.updateConfiguration(tmpDir, current => {
          const nextConfiguration = { ...current,
            enableGlobalCache: true,
            enableTelemetry: false
          };

          if (Array.isArray(current.plugins)) {
            nextConfiguration.plugins = current.plugins.map(plugin => {
              const sourcePath = typeof plugin === `string` ? plugin : plugin.path;
              const remapPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.isAbsolute(sourcePath) ? sourcePath : _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.fromPortablePath(projectCwd), sourcePath);

              if (typeof plugin === `string`) {
                return remapPath;
              } else {
                return {
                  path: remapPath,
                  spec: plugin.spec
                };
              }
            });
          }

          return nextConfiguration;
        });
      } else {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.writeFilePromise(targetYarnrc, `enableGlobalCache: true\nenableTelemetry: false\n`);
      }

      const pkgs = typeof this.pkg !== `undefined` ? [this.pkg] : [this.command];
      const command = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.parseDescriptor(this.command).name;
      const addExitCode = await this.cli.run([`add`, `--`, ...pkgs], {
        cwd: tmpDir,
        quiet: this.quiet
      });
      if (addExitCode !== 0) return addExitCode;
      if (!this.quiet) this.context.stdout.write(`\n`);
      const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(tmpDir, this.context.plugins);
      const {
        project,
        workspace
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Project.find(configuration, tmpDir);
      if (workspace === null) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, tmpDir);
      await project.restoreInstallState();
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.executeWorkspaceAccessibleBinary(workspace, command, this.args, {
        cwd: this.context.cwd,
        stdin: this.context.stdin,
        stdout: this.context.stdout,
        stderr: this.context.stderr
      });
    });
  }

}
DlxCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `run a package in a temporary environment`,
  details: `
      This command will install a package within a temporary environment, and run its binary script if it contains any. The binary will run within the current cwd.

      By default Yarn will download the package named \`command\`, but this can be changed through the use of the \`-p,--package\` flag which will instruct Yarn to still run the same command but from a different package.

      Using \`yarn dlx\` as a replacement of \`yarn add\` isn't recommended, as it makes your project non-deterministic (Yarn doesn't keep track of the packages installed through \`dlx\` - neither their name, nor their version).
    `,
  examples: [[`Use create-react-app to create a new React app`, `yarn dlx create-react-app ./my-app`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`-p,--package`, {
  description: `The package to run the provided command from`
})], DlxCommand.prototype, "pkg", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-q,--quiet`, {
  description: `Only report critical errors instead of printing the full install logs`
})], DlxCommand.prototype, "quiet", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], DlxCommand.prototype, "command", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Proxy()], DlxCommand.prototype, "args", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`dlx`)], DlxCommand.prototype, "execute", null);

/***/ }),
/* 645 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fileUtils": () => /* reexport module object */ _fileUtils__WEBPACK_IMPORTED_MODULE_4__,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _FileFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(646);
/* harmony import */ var _FileResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(649);
/* harmony import */ var _TarballFileFetcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(650);
/* harmony import */ var _TarballFileResolver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(651);
/* harmony import */ var _fileUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(647);






const plugin = {
  fetchers: [_TarballFileFetcher__WEBPACK_IMPORTED_MODULE_2__.TarballFileFetcher, _FileFetcher__WEBPACK_IMPORTED_MODULE_0__.FileFetcher],
  resolvers: [_TarballFileResolver__WEBPACK_IMPORTED_MODULE_3__.TarballFileResolver, _FileResolver__WEBPACK_IMPORTED_MODULE_1__.FileResolver]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 646 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileFetcher": () => /* binding */ FileFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(648);
/* harmony import */ var _fileUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(647);




class FileFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL
    });
    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.isAbsolute(path)) return path;
    const parentLocalPath = opts.fetcher.getLocalPath(parentLocator, opts);
    if (parentLocalPath === null) return null;
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.resolve(parentLocalPath, path);
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
      loader: () => this.fetchFromDisk(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.getIdentVendorPath(locator),
      localPath: this.getLocalPath(locator, opts),
      checksum
    };
  }

  async fetchFromDisk(locator, opts) {
    return _fileUtils__WEBPACK_IMPORTED_MODULE_0__.makeArchiveFromLocator(locator, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL,
      fetchOptions: opts
    });
  }

}

/***/ }),
/* 647 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseSpec": () => /* binding */ parseSpec,
/* harmony export */   "makeSpec": () => /* binding */ makeSpec,
/* harmony export */   "makeLocator": () => /* binding */ makeLocator,
/* harmony export */   "makeArchiveFromLocator": () => /* binding */ makeArchiveFromLocator,
/* harmony export */   "makeBufferFromLocator": () => /* binding */ makeBufferFromLocator
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(380);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(170);


function parseSpec(spec) {
  const {
    params,
    selector
  } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.parseRange(spec);
  const path = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.toPortablePath(selector);
  const parentLocator = params && typeof params.locator === `string` ? _yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.parseLocator(params.locator) : null;
  return {
    parentLocator,
    path
  };
}
function makeSpec({
  parentLocator,
  path,
  folderHash,
  protocol
}) {
  const parentLocatorSpread = parentLocator !== null ? {
    locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.stringifyLocator(parentLocator)
  } : {};
  const folderHashSpread = typeof folderHash !== `undefined` ? {
    hash: folderHash
  } : {};
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.makeRange({
    protocol,
    source: path,
    selector: path,
    params: { ...folderHashSpread,
      ...parentLocatorSpread
    }
  });
}
function makeLocator(ident, {
  parentLocator,
  path,
  folderHash,
  protocol
}) {
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.makeLocator(ident, makeSpec({
    parentLocator,
    path,
    folderHash,
    protocol
  }));
}
async function makeArchiveFromLocator(locator, {
  protocol,
  fetchOptions,
  inMemory = false
}) {
  const {
    parentLocator,
    path
  } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.parseFileStyleRange(locator.reference, {
    protocol
  }); // If the file target is an absolute path we can directly access it via its
  // location on the disk. Otherwise we must go through the package fs.

  const parentFetch = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.isAbsolute(path) ? {
    packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.PortablePath.root),
    prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.PortablePath.dot,
    localPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.PortablePath.root
  } : await fetchOptions.fetcher.fetch(parentLocator, fetchOptions); // If the package fs publicized its "original location" (for example like
  // in the case of "file:" packages), we use it to derive the real location.

  const effectiveParentFetch = parentFetch.localPath ? {
    packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.PortablePath.root),
    prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.PortablePath.root, parentFetch.localPath)
  } : parentFetch; // Discard the parent fs unless we really need it to access the files

  if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs) parentFetch.releaseFs();
  const sourceFs = effectiveParentFetch.packageFs;
  const sourcePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.join(effectiveParentFetch.prefixPath, path);
  return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.releaseAfterUseAsync(async () => {
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.makeArchiveFromDirectory(sourcePath, {
      baseFs: sourceFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.getIdentVendorPath(locator),
      compressionLevel: fetchOptions.project.configuration.get(`compressionLevel`),
      inMemory
    });
  }, effectiveParentFetch.releaseFs);
}
async function makeBufferFromLocator(locator, {
  protocol,
  fetchOptions
}) {
  const folderFs = await makeArchiveFromLocator(locator, {
    protocol,
    fetchOptions,
    inMemory: true
  });
  return folderFs.getBufferAndClose();
}

/***/ }),
/* 648 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FILE_REGEXP": () => /* binding */ FILE_REGEXP,
/* harmony export */   "TARBALL_REGEXP": () => /* binding */ TARBALL_REGEXP,
/* harmony export */   "PROTOCOL": () => /* binding */ PROTOCOL
/* harmony export */ });
const FILE_REGEXP = /^(?:[a-zA-Z]:[\\/]|\.{0,2}\/)/;
const TARBALL_REGEXP = /^[^?]*\.(?:tar\.gz|tgz)(?:::.*)?$/;
const PROTOCOL = `file:`;

/***/ }),
/* 649 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileResolver": () => /* binding */ FileResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(71);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(179);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(237);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(648);
/* harmony import */ var _fileUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(647);




 // We use this for the folders to be regenerated without bumping the whole cache

const CACHE_VERSION = 1;
class FileResolver {
  supportsDescriptor(descriptor, opts) {
    if (descriptor.range.match(_constants__WEBPACK_IMPORTED_MODULE_1__.FILE_REGEXP)) return true;
    if (!descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL)) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    if (_constants__WEBPACK_IMPORTED_MODULE_1__.FILE_REGEXP.test(descriptor.range)) descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.makeDescriptor(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL}${descriptor.range}`);
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.bindDescriptor(descriptor, {
      locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyLocator(fromLocator)
    });
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const {
      path,
      parentLocator
    } = _fileUtils__WEBPACK_IMPORTED_MODULE_0__.parseSpec(descriptor.range);
    if (parentLocator === null) throw new Error(`Assertion failed: The descriptor should have been bound`);
    const archiveBuffer = await _fileUtils__WEBPACK_IMPORTED_MODULE_0__.makeBufferFromLocator(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.makeLocator(descriptor, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.makeRange({
      protocol: _constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL,
      source: path,
      selector: path,
      params: {
        locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyLocator(parentLocator)
      }
    })), {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL,
      fetchOptions: opts.fetchOptions
    });
    const folderHash = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.makeHash(`${CACHE_VERSION}`, archiveBuffer).slice(0, 6);
    return [_fileUtils__WEBPACK_IMPORTED_MODULE_0__.makeLocator(descriptor, {
      parentLocator,
      path,
      folderHash,
      protocol: _constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL
    })];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
    const manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Manifest.find(packageFetch.prefixPath, {
        baseFs: packageFetch.packageFs
      });
    }, packageFetch.releaseFs);
    return { ...locator,
      version: manifest.version || `0.0.0`,
      languageName: opts.project.configuration.get(`defaultLanguageName`),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.LinkType.HARD,
      dependencies: manifest.dependencies,
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

/***/ }),
/* 650 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TarballFileFetcher": () => /* binding */ TarballFileFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(380);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(170);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(648);



class TarballFileFetcher {
  supports(locator, opts) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.TARBALL_REGEXP.test(locator.reference)) return false;
    if (locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) return true;
    return false;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
      loader: () => this.fetchFromDisk(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.getIdentVendorPath(locator),
      checksum
    };
  }

  async fetchFromDisk(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL
    }); // If the file target is an absolute path we can directly access it via its
    // location on the disk. Otherwise we must go through the package fs.

    const parentFetch = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path) ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
      localPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root
    } : await opts.fetcher.fetch(parentLocator, opts); // If the package fs publicized its "original location" (for example like
    // in the case of "file:" packages), we use it to derive the real location.

    const effectiveParentFetch = parentFetch.localPath ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root, parentFetch.localPath)
    } : parentFetch; // Discard the parent fs unless we really need it to access the files

    if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs) parentFetch.releaseFs();
    const sourceFs = effectiveParentFetch.packageFs;
    const sourcePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(effectiveParentFetch.prefixPath, path);
    const sourceBuffer = await sourceFs.readFilePromise(sourcePath);
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.convertToZip(sourceBuffer, {
        compressionLevel: opts.project.configuration.get(`compressionLevel`),
        prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.getIdentVendorPath(locator),
        stripComponents: 1
      });
    }, effectiveParentFetch.releaseFs);
  }

}

/***/ }),
/* 651 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TarballFileResolver": () => /* binding */ TarballFileResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(179);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(648);





class TarballFileResolver {
  supportsDescriptor(descriptor, opts) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.TARBALL_REGEXP.test(descriptor.range)) return false;
    if (descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) return true;
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.FILE_REGEXP.test(descriptor.range)) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.TARBALL_REGEXP.test(locator.reference)) return false;
    if (locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) return true;
    return false;
  }

  shouldPersistResolution(locator, opts) {
    return true;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.FILE_REGEXP.test(descriptor.range)) descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeDescriptor(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL}${descriptor.range}`);
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.bindDescriptor(descriptor, {
      locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.stringifyLocator(fromLocator)
    });
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    let path = descriptor.range;
    if (path.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) path = path.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL.length);
    return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeLocator(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path)}`)];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
    const manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Manifest.find(packageFetch.prefixPath, {
        baseFs: packageFetch.packageFs
      });
    }, packageFetch.releaseFs);
    return { ...locator,
      version: manifest.version || `0.0.0`,
      languageName: opts.project.configuration.get(`defaultLanguageName`),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.LinkType.HARD,
      dependencies: manifest.dependencies,
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

/***/ }),
/* 652 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gitUtils": () => /* reexport module object */ _gitUtils__WEBPACK_IMPORTED_MODULE_2__,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var _GitFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(653);
/* harmony import */ var _GitResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(655);
/* harmony import */ var _gitUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(654);




const plugin = {
  configuration: {
    cloneConcurrency: {
      description: `Maximal number of concurrent clones`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.SettingsType.NUMBER,
      default: 2
    }
  },
  fetchers: [_GitFetcher__WEBPACK_IMPORTED_MODULE_0__.GitFetcher],
  resolvers: [_GitResolver__WEBPACK_IMPORTED_MODULE_1__.GitResolver]
};
 // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 653 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GitFetcher": () => /* binding */ GitFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(340);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(380);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(155);
/* harmony import */ var _gitUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(654);



class GitFetcher {
  supports(locator, opts) {
    return _gitUtils__WEBPACK_IMPORTED_MODULE_0__.isGitUrl(locator.reference);
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const normalizedLocator = _gitUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeLocator(locator);
    const checksums = new Map(opts.checksums);
    checksums.set(normalizedLocator.locatorHash, expectedChecksum);
    const nextOpts = { ...opts,
      checksums
    };
    const result = await this.downloadHosted(normalizedLocator, nextOpts);
    if (result !== null) return result;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote repository`),
      loader: () => this.cloneFromRemote(normalizedLocator, nextOpts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.getIdentVendorPath(locator),
      checksum
    };
  }

  async downloadHosted(locator, opts) {
    return opts.project.configuration.reduceHook(hooks => {
      return hooks.fetchHostedRepository;
    }, null, locator, opts);
  }

  async cloneFromRemote(locator, opts) {
    const cloneTarget = await _gitUtils__WEBPACK_IMPORTED_MODULE_0__.clone(locator.reference, opts.project.configuration);
    const repoUrlParts = _gitUtils__WEBPACK_IMPORTED_MODULE_0__.splitRepoUrl(locator.reference);
    const packagePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(cloneTarget, `package.tgz`);
    await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.prepareExternalProject(cloneTarget, packagePath, {
      configuration: opts.project.configuration,
      report: opts.report,
      workspace: repoUrlParts.extra.workspace
    });
    const sourceBuffer = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.readFilePromise(packagePath);
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.convertToZip(sourceBuffer, {
        compressionLevel: opts.project.configuration.get(`compressionLevel`),
        prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.getIdentVendorPath(locator),
        stripComponents: 1
      });
    });
  }

}

/***/ }),
/* 654 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TreeishProtocols": () => /* binding */ TreeishProtocols,
/* harmony export */   "isGitUrl": () => /* binding */ isGitUrl,
/* harmony export */   "splitRepoUrl": () => /* binding */ splitRepoUrl,
/* harmony export */   "normalizeRepoUrl": () => /* binding */ normalizeRepoUrl,
/* harmony export */   "normalizeLocator": () => /* binding */ normalizeLocator,
/* harmony export */   "lsRemote": () => /* binding */ lsRemote,
/* harmony export */   "resolveUrl": () => /* binding */ resolveUrl,
/* harmony export */   "clone": () => /* binding */ clone
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(373);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(162);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(247);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_2__);






function makeGitEnvironment() {
  return { ...process.env,
    // An option passed to SSH by Git to prevent SSH from asking for data (which would cause installs to hang when the SSH keys are missing)
    GIT_SSH_COMMAND: `ssh -o BatchMode=yes`
  };
}

const gitPatterns = [/^ssh:/, /^git(?:\+[^:]+)?:/, // `git+` is optional, `.git` is required
/^(?:git\+)?https?:[^#]+\/[^#]+(?:\.git)(?:#.*)?$/, /^git@[^#]+\/[^#]+\.git(?:#.*)?$/, /^(?:github:|https:\/\/github\.com\/)?(?!\.{1,2}\/)([a-zA-Z._0-9-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z._0-9-]+?)(?:\.git)?(?:#.*)?$/, // GitHub `/tarball/` URLs
/^https:\/\/github\.com\/(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)\/tarball\/(.+)?$/];
var TreeishProtocols;

(function (TreeishProtocols) {
  TreeishProtocols["Commit"] = "commit";
  TreeishProtocols["Head"] = "head";
  TreeishProtocols["Tag"] = "tag";
  TreeishProtocols["Semver"] = "semver";
})(TreeishProtocols || (TreeishProtocols = {}));
/**
 * Determines whether a given url is a valid github git url via regex
 */


function isGitUrl(url) {
  return url ? gitPatterns.some(pattern => !!url.match(pattern)) : false;
}
function splitRepoUrl(url) {
  url = normalizeRepoUrl(url);
  const hashIndex = url.indexOf(`#`);

  if (hashIndex === -1) {
    return {
      repo: url,
      treeish: {
        protocol: TreeishProtocols.Head,
        request: `master`
      },
      extra: {}
    };
  }

  const repo = url.slice(0, hashIndex);
  const subsequent = url.slice(hashIndex + 1); // New-style: "#commit=abcdef&workspace=foobar"

  if (subsequent.match(/^[a-z]+=/)) {
    const extra = querystring__WEBPACK_IMPORTED_MODULE_0___default().parse(subsequent);

    for (const [key, value] of Object.entries(extra)) if (typeof value !== `string`) throw new Error(`Assertion failed: The ${key} parameter must be a literal string`);

    const requestedProtocol = Object.values(TreeishProtocols).find(protocol => {
      return Object.prototype.hasOwnProperty.call(extra, protocol);
    });
    let protocol;
    let request;

    if (typeof requestedProtocol !== `undefined`) {
      protocol = requestedProtocol;
      request = extra[requestedProtocol];
    } else {
      protocol = TreeishProtocols.Head;
      request = `master`;
    }

    for (const key of Object.values(TreeishProtocols)) delete extra[key];

    return {
      repo,
      treeish: {
        protocol,
        request
      },
      extra: extra
    };
  } // Old-style: "#commit:abcdef" or "#abcdef"
  else {
      const colonIndex = subsequent.indexOf(`:`);
      let protocol;
      let request;

      if (colonIndex === -1) {
        protocol = null;
        request = subsequent;
      } else {
        protocol = subsequent.slice(0, colonIndex);
        request = subsequent.slice(colonIndex + 1);
      }

      return {
        repo,
        treeish: {
          protocol,
          request
        },
        extra: {}
      };
    }
}
function normalizeRepoUrl(url, {
  git = false
} = {}) {
  var _a; // "git+https://" isn't an actual Git protocol. It's just a way to
  // disambiguate that this URL points to a Git repository.


  url = url.replace(/^git\+https:/, `https:`); // We support this as an alias to GitHub repositories

  url = url.replace(/^(?:github:|https:\/\/github\.com\/)?(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)(?:\.git)?(#.*)?$/, `https://github.com/$1/$2.git$3`); // We support GitHub `/tarball/` URLs

  url = url.replace(/^https:\/\/github\.com\/(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)\/tarball\/(.+)?$/, `https://github.com/$1/$2.git#$3`);

  if (git) {
    // The `git+` prefix doesn't mean anything at all for Git
    url = url.replace(/^git\+([^:]+):/, `$1:`); // The `ssh://` prefix should be removed because so URLs won't work in Git:
    //   ssh://git@github.com:yarnpkg/berry.git
    //   git@github.com/yarnpkg/berry.git
    // Git only allows:
    //   git@github.com:yarnpkg/berry.git (no ssh)
    //   ssh://git@github.com/yarnpkg/berry.git (no colon)
    // So we should cut `ssh://`, but only in URLs that contain colon after the hostname

    let parsedUrl;

    try {
      parsedUrl = url__WEBPACK_IMPORTED_MODULE_2___default().parse(url);
    } catch (_b) {
      parsedUrl = null;
    }

    if (parsedUrl && parsedUrl.protocol === `ssh:` && ((_a = parsedUrl.path) === null || _a === void 0 ? void 0 : _a.startsWith(`/:`))) {
      url = url.replace(/^ssh:\/\//, ``);
    }
  }

  return url;
}
function normalizeLocator(locator) {
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.makeLocator(locator, normalizeRepoUrl(locator.reference));
}
async function lsRemote(repo, configuration) {
  const normalizedRepoUrl = normalizeRepoUrl(repo, {
    git: true
  });
  const networkSettings = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.getNetworkSettings(normalizedRepoUrl, {
    configuration
  });
  if (!networkSettings.enableNetwork) throw new Error(`Request to '${normalizedRepoUrl}' has been blocked because of your configuration settings`);
  let res;

  try {
    res = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.execvp(`git`, [`ls-remote`, `--refs`, normalizedRepoUrl], {
      cwd: configuration.startingCwd,
      env: makeGitEnvironment(),
      strict: true
    });
  } catch (error) {
    error.message = `Listing the refs for ${repo} failed`;
    throw error;
  }

  const refs = new Map();
  const matcher = /^([a-f0-9]{40})\t(refs\/[^\n]+)/gm;
  let match;

  while ((match = matcher.exec(res.stdout)) !== null) refs.set(match[2], match[1]);

  return refs;
}
async function resolveUrl(url, configuration) {
  const {
    repo,
    treeish: {
      protocol,
      request
    },
    extra
  } = splitRepoUrl(url);
  const refs = await lsRemote(repo, configuration);

  const resolve = (protocol, request) => {
    switch (protocol) {
      case TreeishProtocols.Commit:
        {
          if (!request.match(/^[a-f0-9]{40}$/)) throw new Error(`Invalid commit hash`);
          return querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify({ ...extra,
            commit: request
          });
        }

      case TreeishProtocols.Head:
        {
          const head = refs.get(`refs/heads/${request}`);
          if (typeof head === `undefined`) throw new Error(`Unknown head ("${request}")`);
          return querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify({ ...extra,
            commit: head
          });
        }

      case TreeishProtocols.Tag:
        {
          const tag = refs.get(`refs/tags/${request}`);
          if (typeof tag === `undefined`) throw new Error(`Unknown tag ("${request}")`);
          return querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify({ ...extra,
            commit: tag
          });
        }

      case TreeishProtocols.Semver:
        {
          if (!semver__WEBPACK_IMPORTED_MODULE_1___default().validRange(request)) throw new Error(`Invalid range ("${request}")`);
          const semverTags = new Map([...refs.entries()].filter(([ref]) => {
            return ref.startsWith(`refs/tags/`);
          }).map(([ref, hash]) => {
            return [semver__WEBPACK_IMPORTED_MODULE_1___default().parse(ref.slice(10)), hash];
          }).filter(entry => {
            return entry[0] !== null;
          }));
          const bestVersion = semver__WEBPACK_IMPORTED_MODULE_1___default().maxSatisfying([...semverTags.keys()], request);
          if (bestVersion === null) throw new Error(`No matching range ("${request}")`);
          return querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify({ ...extra,
            commit: semverTags.get(bestVersion)
          });
        }

      case null:
        {
          let result;
          if ((result = tryResolve(TreeishProtocols.Commit, request)) !== null) return result;
          if ((result = tryResolve(TreeishProtocols.Tag, request)) !== null) return result;
          if ((result = tryResolve(TreeishProtocols.Head, request)) !== null) return result;

          if (request.match(/^[a-f0-9]+$/)) {
            throw new Error(`Couldn't resolve "${request}" as either a commit, a tag, or a head - if a commit, use the 40-characters commit hash`);
          } else {
            throw new Error(`Couldn't resolve "${request}" as either a commit, a tag, or a head`);
          }
        }

      default:
        {
          throw new Error(`Invalid Git resolution protocol ("${protocol}")`);
        }
    }
  };

  const tryResolve = (protocol, request) => {
    try {
      return resolve(protocol, request);
    } catch (err) {
      return null;
    }
  };

  return `${repo}#${resolve(protocol, request)}`;
}
async function clone(url, configuration) {
  return await configuration.getLimit(`cloneConcurrency`)(async () => {
    const {
      repo,
      treeish: {
        protocol,
        request
      }
    } = splitRepoUrl(url);
    if (protocol !== `commit`) throw new Error(`Invalid treeish protocol when cloning`);
    const normalizedRepoUrl = normalizeRepoUrl(repo, {
      git: true
    });
    if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.getNetworkSettings(normalizedRepoUrl, {
      configuration
    }).enableNetwork === false) throw new Error(`Request to '${normalizedRepoUrl}' has been blocked because of your configuration settings`);
    const directory = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mktempPromise();
    const execOpts = {
      cwd: directory,
      env: makeGitEnvironment(),
      strict: true
    };

    try {
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.execvp(`git`, [`clone`, `-c core.autocrlf=false`, normalizedRepoUrl, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(directory)], execOpts);
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.execvp(`git`, [`checkout`, `${request}`], execOpts);
    } catch (error) {
      error.message = `Repository clone failed: ${error.message}`;
      throw error;
    }

    return directory;
  });
}

/***/ }),
/* 655 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GitResolver": () => /* binding */ GitResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(179);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(237);
/* harmony import */ var _gitUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(654);




class GitResolver {
  supportsDescriptor(descriptor, opts) {
    return _gitUtils__WEBPACK_IMPORTED_MODULE_0__.isGitUrl(descriptor.range);
  }

  supportsLocator(locator, opts) {
    return _gitUtils__WEBPACK_IMPORTED_MODULE_0__.isGitUrl(locator.reference);
  }

  shouldPersistResolution(locator, opts) {
    return true;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const reference = await _gitUtils__WEBPACK_IMPORTED_MODULE_0__.resolveUrl(descriptor.range, opts.project.configuration);
    const locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeLocator(descriptor, reference);
    return [locator];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
    const manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Manifest.find(packageFetch.prefixPath, {
        baseFs: packageFetch.packageFs
      });
    }, packageFetch.releaseFs);
    return { ...locator,
      version: manifest.version || `0.0.0`,
      languageName: opts.project.configuration.get(`defaultLanguageName`),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.LinkType.HARD,
      dependencies: manifest.dependencies,
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

/***/ }),
/* 656 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _GithubFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(657);

const plugin = {
  hooks: {
    async fetchHostedRepository(previous, locator, opts) {
      if (previous !== null) return previous;
      const fetcher = new _GithubFetcher__WEBPACK_IMPORTED_MODULE_0__.GithubFetcher();
      if (!fetcher.supports(locator, opts)) return null;

      try {
        return await fetcher.fetch(locator, opts);
      } catch (error) {
        return null;
      }
    }

  }
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 657 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GithubFetcher": () => /* binding */ GithubFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(380);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(340);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(170);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_plugin_git__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(652);
/* harmony import */ var _githubUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(658);




class GithubFetcher {
  supports(locator, opts) {
    if (!_githubUtils__WEBPACK_IMPORTED_MODULE_1__.isGithubUrl(locator.reference)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from GitHub`),
      loader: () => this.fetchFromNetwork(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.getIdentVendorPath(locator),
      checksum
    };
  }

  async fetchFromNetwork(locator, opts) {
    const sourceBuffer = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.get(this.getLocatorUrl(locator, opts), {
      configuration: opts.project.configuration
    });
    return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mktempPromise(async extractPath => {
      const extractTarget = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.CwdFS(extractPath);
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.extractArchiveTo(sourceBuffer, extractTarget, {
        stripComponents: 1
      });
      const repoUrlParts = _yarnpkg_plugin_git__WEBPACK_IMPORTED_MODULE_0__.gitUtils.splitRepoUrl(locator.reference);
      const packagePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(extractPath, `package.tgz`);
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.prepareExternalProject(extractPath, packagePath, {
        configuration: opts.project.configuration,
        report: opts.report,
        workspace: repoUrlParts.extra.workspace
      });
      const packedBuffer = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.readFilePromise(packagePath);
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.convertToZip(packedBuffer, {
        compressionLevel: opts.project.configuration.get(`compressionLevel`),
        prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.getIdentVendorPath(locator),
        stripComponents: 1
      });
    });
  }

  getLocatorUrl(locator, opts) {
    const {
      auth,
      username,
      reponame,
      treeish
    } = _githubUtils__WEBPACK_IMPORTED_MODULE_1__.parseGithubUrl(locator.reference);
    return `https://${auth ? `${auth}@` : ``}github.com/${username}/${reponame}/archive/${treeish}.tar.gz`;
  }

}

/***/ }),
/* 658 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isGithubUrl": () => /* binding */ isGithubUrl,
/* harmony export */   "parseGithubUrl": () => /* binding */ parseGithubUrl,
/* harmony export */   "invalidGithubUrlMessage": () => /* binding */ invalidGithubUrlMessage
/* harmony export */ });
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_0__);

const githubPatterns = [/^https?:\/\/(?:([^/]+?)@)?github.com\/([^/#]+)\/([^/#]+)\/tarball\/([^/#]+)(?:#(.*))?$/, /^https?:\/\/(?:([^/]+?)@)?github.com\/([^/#]+)\/([^/#]+?)(?:\.git)?(?:#(.*))?$/];
/**
 * Determines whether a given url is a valid github git url via regex
 */

function isGithubUrl(url) {
  return url ? githubPatterns.some(pattern => !!url.match(pattern)) : false;
}
/**
 * Takes a valid github repository url and parses it, returning
 * an object of type `ParsedGithubUrl`
 */

function parseGithubUrl(urlStr) {
  let match;

  for (const pattern of githubPatterns) {
    match = urlStr.match(pattern);

    if (match) {
      break;
    }
  }

  if (!match) throw new Error(invalidGithubUrlMessage(urlStr));
  let [, auth, username, reponame, treeish = `master`] = match;
  const {
    commit
  } = querystring__WEBPACK_IMPORTED_MODULE_0___default().parse(treeish);
  treeish = // New style:
  // The URLs have already been normalized by `gitUtils.resolveUrl`,
  // so it's certain in the context of the `GithubFetcher`
  // that the `commit` querystring parameter exists
  commit // Old style:
  // Shouldn't ever be needed by the GithubFetcher
  || treeish.replace(/[^:]*:/, ``);
  return {
    auth,
    username,
    reponame,
    treeish
  };
}
function invalidGithubUrlMessage(url) {
  return `Input cannot be parsed as a valid GitHub URL ('${url}').`;
}

/***/ }),
/* 659 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _TarballHttpFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(660);
/* harmony import */ var _TarballHttpResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(662);


const plugin = {
  fetchers: [_TarballHttpFetcher__WEBPACK_IMPORTED_MODULE_0__.TarballHttpFetcher],
  resolvers: [_TarballHttpResolver__WEBPACK_IMPORTED_MODULE_1__.TarballHttpResolver]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 660 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TarballHttpFetcher": () => /* binding */ TarballHttpFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(380);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(661);


class TarballHttpFetcher {
  supports(locator, opts) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.TARBALL_REGEXP.test(locator.reference)) return false;
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL_REGEXP.test(locator.reference)) return true;
    return false;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote server`),
      loader: () => this.fetchFromNetwork(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.getIdentVendorPath(locator),
      checksum
    };
  }

  async fetchFromNetwork(locator, opts) {
    const sourceBuffer = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.get(locator.reference, {
      configuration: opts.project.configuration
    });
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.convertToZip(sourceBuffer, {
      compressionLevel: opts.project.configuration.get(`compressionLevel`),
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.getIdentVendorPath(locator),
      stripComponents: 1
    });
  }

}

/***/ }),
/* 661 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TARBALL_REGEXP": () => /* binding */ TARBALL_REGEXP,
/* harmony export */   "PROTOCOL_REGEXP": () => /* binding */ PROTOCOL_REGEXP
/* harmony export */ });
const TARBALL_REGEXP = /^[^?]*\.(?:tar\.gz|tgz)(?:\?.*)?$/;
const PROTOCOL_REGEXP = /^https?:/;

/***/ }),
/* 662 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TarballHttpResolver": () => /* binding */ TarballHttpResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(179);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(177);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(661);




class TarballHttpResolver {
  supportsDescriptor(descriptor, opts) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.TARBALL_REGEXP.test(descriptor.range)) return false;
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL_REGEXP.test(descriptor.range)) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.TARBALL_REGEXP.test(locator.reference)) return false;
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL_REGEXP.test(locator.reference)) return true;
    return false;
  }

  shouldPersistResolution(locator, opts) {
    return true;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.convertDescriptorToLocator(descriptor)];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
    const manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Manifest.find(packageFetch.prefixPath, {
        baseFs: packageFetch.packageFs
      });
    }, packageFetch.releaseFs);
    return { ...locator,
      version: manifest.version || `0.0.0`,
      languageName: opts.project.configuration.get(`defaultLanguageName`),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.LinkType.HARD,
      dependencies: manifest.dependencies,
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

/***/ }),
/* 663 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(181);
/* harmony import */ var _commands_init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(664);


const plugin = {
  configuration: {
    initLicense: {
      description: `License used when creating packages via the init command`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.STRING,
      default: null
    },
    initScope: {
      description: `Scope used when creating packages via the init command`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.STRING,
      default: null
    },
    initVersion: {
      description: `Version used when creating packages via the init command`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.STRING,
      default: null
    },
    initFields: {
      description: `Additional fields to set when creating packages via the init command`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.MAP,
      valueDefinition: {
        description: ``,
        type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.ANY
      }
    },
    initEditorConfig: {
      description: `Extra rules to define in the generator editorconfig`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.MAP,
      valueDefinition: {
        description: ``,
        type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.ANY
      }
    }
  },
  commands: [_commands_init__WEBPACK_IMPORTED_MODULE_0__.default]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 664 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ InitCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(373);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(340);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(162);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(665);
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);







 // eslint-disable-next-line arca/no-default-export

class InitCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.usev2 = false;
    this.assumeFreshProject = false;
    this.yes = false;
    this.private = false;
    this.workspace = false;
    this.install = false;
  }

  async execute() {
    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Manifest.fileName))) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`A package.json already exists in the specified directory`);
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Configuration.find(this.context.cwd, this.context.plugins);
    const install = this.install ? this.install === true ? `latest` : this.install : null;

    if (install !== null) {
      return await this.executeProxy(configuration, install);
    } else {
      return await this.executeRegular(configuration);
    }
  }

  async executeProxy(configuration, version) {
    if (configuration.get(`yarnPath`) !== null) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Cannot use the --install flag when the current directory already uses yarnPath (from ${configuration.sources.get(`yarnPath`)})`);
    if (configuration.projectCwd !== null) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Cannot use the --install flag when the current directory is already part of a project`);
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(this.context.cwd)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mkdirPromise(this.context.cwd, {
      recursive: true
    });
    const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, configuration.get(`lockfileFilename`));
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(lockfilePath)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(lockfilePath, ``);
    const versionExitCode = await this.cli.run([`set`, `version`, version]);
    if (versionExitCode !== 0) return versionExitCode;
    this.context.stdout.write(`\n`);
    const args = [`--assume-fresh-project`];
    if (this.private) args.push(`-p`);
    if (this.workspace) args.push(`-w`);
    if (this.yes) args.push(`-y`);
    return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mktempPromise(async binFolder => {
      const {
        code
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.pipevp(`yarn`, [`init`, ...args], {
        cwd: this.context.cwd,
        stdin: this.context.stdin,
        stdout: this.context.stdout,
        stderr: this.context.stderr,
        env: await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.makeScriptEnv({
          binFolder
        })
      });
      return code;
    });
  }

  async executeRegular(configuration) {
    let existingProject = null;

    if (!this.assumeFreshProject) {
      try {
        existingProject = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Project.find(configuration, this.context.cwd);
      } catch (_a) {
        existingProject = null;
      }
    }

    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(this.context.cwd)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mkdirPromise(this.context.cwd, {
      recursive: true
    });
    const manifest = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Manifest();
    const fields = Object.fromEntries(configuration.get(`initFields`).entries());
    manifest.load(fields);
    manifest.name = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.makeIdent(configuration.get(`initScope`), _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.basename(this.context.cwd));
    manifest.version = configuration.get(`initVersion`);
    manifest.private = this.private || this.workspace;
    manifest.license = configuration.get(`initLicense`);

    if (this.workspace) {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, `packages`), {
        recursive: true
      });
      manifest.workspaceDefinitions = [{
        pattern: `packages/*`
      }];
    }

    const serialized = {};
    manifest.exportTo(serialized); // @ts-expect-error: The Node typings forgot one field

    util__WEBPACK_IMPORTED_MODULE_3__.inspect.styles.name = `cyan`;
    this.context.stdout.write(`${(0,util__WEBPACK_IMPORTED_MODULE_3__.inspect)(serialized, {
      depth: Infinity,
      colors: true,
      compact: false
    })}\n`);
    const manifestPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Manifest.fileName);
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.changeFilePromise(manifestPath, `${JSON.stringify(serialized, null, 2)}\n`);
    const readmePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, `README.md`);
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(readmePath)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(readmePath, `# ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.stringifyIdent(manifest.name)}\n`);

    if (!existingProject) {
      const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.Filename.lockfile);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(lockfilePath, ``);
      const gitattributesLines = [`/.yarn/** linguist-vendored`];
      const gitattributesBody = gitattributesLines.map(line => {
        return `${line}\n`;
      }).join(``);
      const gitattributesPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, `.gitattributes`);
      if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(gitattributesPath)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(gitattributesPath, gitattributesBody);
      const gitignoreLines = [`/.yarn/*`, `!/.yarn/releases`, `!/.yarn/plugins`, `!/.yarn/sdks`, ``, `# Swap the comments on the following lines if you don't wish to use zero-installs`, `# Documentation here: https://yarnpkg.com/features/zero-installs`, `!/.yarn/cache`, `#/.pnp.*`];
      const gitignoreBody = gitignoreLines.map(line => {
        return `${line}\n`;
      }).join(``);
      const gitignorePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, `.gitignore`);
      if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(gitignorePath)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(gitignorePath, gitignoreBody);
      const editorConfigProperties = {
        [`*`]: {
          endOfLine: `lf`,
          insertFinalNewline: true
        },
        [`*.{js,json,.yml}`]: {
          charset: `utf-8`,
          indentStyle: `space`,
          indentSize: 2
        }
      };
      lodash_merge__WEBPACK_IMPORTED_MODULE_2___default()(editorConfigProperties, configuration.get(`initEditorConfig`));
      let editorConfigBody = `root = true\n`;

      for (const [selector, props] of Object.entries(editorConfigProperties)) {
        editorConfigBody += `\n[${selector}]\n`;

        for (const [propName, propValue] of Object.entries(props)) {
          const snakeCaseName = propName.replace(/[A-Z]/g, $0 => `_${$0.toLowerCase()}`);
          editorConfigBody += `${snakeCaseName} = ${propValue}\n`;
        }
      }

      const editorConfigPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, `.editorconfig`);
      if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(editorConfigPath)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(editorConfigPath, editorConfigBody);
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.execvp(`git`, [`init`], {
        cwd: this.context.cwd
      });
    }
  }

}
InitCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `create a new package`,
  details: `
      This command will setup a new package in your local directory.

      If the \`-p,--private\` or \`-w,--workspace\` options are set, the package will be private by default.

      If the \`-w,--workspace\` option is set, the package will be configured to accept a set of workspaces in the \`packages/\` directory.

      If the \`-i,--install\` option is given a value, Yarn will first download it using \`yarn set version\` and only then forward the init call to the newly downloaded bundle. Without arguments, the downloaded bundle will be \`latest\`.

      The initial settings of the manifest can be changed by using the \`initScope\` and \`initFields\` configuration values. Additionally, Yarn will generate an EditorConfig file whose rules can be altered via \`initEditorConfig\`, and will initialize a Git repository in the current directory.
    `,
  examples: [[`Create a new package in the local directory`, `yarn init`], [`Create a new private package in the local directory`, `yarn init -p`], [`Create a new package and store the Yarn release inside`, `yarn init -i latest`], [`Create a new private package and defines it as a workspace root`, `yarn init -w`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-2`, {
  hidden: true
})], InitCommand.prototype, "usev2", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--assume-fresh-project`, {
  hidden: true
})], InitCommand.prototype, "assumeFreshProject", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-y,--yes`, {
  hidden: true
})], InitCommand.prototype, "yes", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-p,--private`, {
  description: `Initialize a private package`
})], InitCommand.prototype, "private", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-w,--workspace`, {
  description: `Initialize a private workspace root with a \`packages/\` directory`
})], InitCommand.prototype, "workspace", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`-i,--install`, {
  tolerateBoolean: true,
  description: `Initialize a package with a specific bundle that will be locked in the project`
})], InitCommand.prototype, "install", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`init`)], InitCommand.prototype, "execute", null);

/***/ }),
/* 665 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMerge = __webpack_require__(666),
    createAssigner = __webpack_require__(673);

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),
/* 666 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(421),
    assignMergeValue = __webpack_require__(667),
    baseFor = __webpack_require__(498),
    baseMergeDeep = __webpack_require__(668),
    isObject = __webpack_require__(282),
    keysIn = __webpack_require__(445),
    safeGet = __webpack_require__(671);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),
/* 667 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(312),
    eq = __webpack_require__(295);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 668 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignMergeValue = __webpack_require__(667),
    cloneBuffer = __webpack_require__(448),
    cloneTypedArray = __webpack_require__(472),
    copyArray = __webpack_require__(449),
    initCloneObject = __webpack_require__(473),
    isArguments = __webpack_require__(318),
    isArray = __webpack_require__(261),
    isArrayLikeObject = __webpack_require__(669),
    isBuffer = __webpack_require__(433),
    isFunction = __webpack_require__(281),
    isObject = __webpack_require__(282),
    isPlainObject = __webpack_require__(670),
    isTypedArray = __webpack_require__(435),
    safeGet = __webpack_require__(671),
    toPlainObject = __webpack_require__(672);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 669 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(443),
    isObjectLike = __webpack_require__(270);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 670 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(264),
    getPrototype = __webpack_require__(456),
    isObjectLike = __webpack_require__(270);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 671 */
/***/ ((module) => {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),
/* 672 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(429),
    keysIn = __webpack_require__(445);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 673 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(674),
    isIterateeCall = __webpack_require__(675);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 674 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(331),
    overRest = __webpack_require__(326),
    setToString = __webpack_require__(328);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 675 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(295),
    isArrayLike = __webpack_require__(443),
    isIndex = __webpack_require__(314),
    isObject = __webpack_require__(282);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 676 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _LinkFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(677);
/* harmony import */ var _LinkResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(679);
/* harmony import */ var _RawLinkFetcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(680);
/* harmony import */ var _RawLinkResolver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(681);




const plugin = {
  fetchers: [_RawLinkFetcher__WEBPACK_IMPORTED_MODULE_2__.RawLinkFetcher, _LinkFetcher__WEBPACK_IMPORTED_MODULE_0__.LinkFetcher],
  resolvers: [_RawLinkResolver__WEBPACK_IMPORTED_MODULE_3__.RawLinkResolver, _LinkResolver__WEBPACK_IMPORTED_MODULE_1__.LinkResolver]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 677 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkFetcher": () => /* binding */ LinkFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(170);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(171);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(678);



class LinkFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL
    });
    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path)) return path;
    const parentLocalPath = opts.fetcher.getLocalPath(parentLocator, opts);
    if (parentLocalPath === null) return null;
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(parentLocalPath, path);
  }

  async fetch(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL
    }); // If the link target is an absolute path we can directly access it via its
    // location on the disk. Otherwise we must go through the package fs.

    const parentFetch = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path) ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
      localPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root
    } : await opts.fetcher.fetch(parentLocator, opts); // If the package fs publicized its "original location" (for example like
    // in the case of "file:" packages), we use it to derive the real location.

    const effectiveParentFetch = parentFetch.localPath ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root, parentFetch.localPath)
    } : parentFetch; // Discard the parent fs unless we really need it to access the files

    if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs) parentFetch.releaseFs();
    const sourceFs = effectiveParentFetch.packageFs;
    const sourcePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(effectiveParentFetch.prefixPath, path);

    if (parentFetch.localPath) {
      return {
        packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(sourcePath, {
          baseFs: sourceFs
        }),
        releaseFs: effectiveParentFetch.releaseFs,
        prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
        localPath: sourcePath
      };
    } else {
      return {
        packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.JailFS(sourcePath, {
          baseFs: sourceFs
        }),
        releaseFs: effectiveParentFetch.releaseFs,
        prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot
      };
    }
  }

}

/***/ }),
/* 678 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LINK_PROTOCOL": () => /* binding */ LINK_PROTOCOL,
/* harmony export */   "RAW_LINK_PROTOCOL": () => /* binding */ RAW_LINK_PROTOCOL
/* harmony export */ });
const LINK_PROTOCOL = `portal:`;
const RAW_LINK_PROTOCOL = `link:`;

/***/ }),
/* 679 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkResolver": () => /* binding */ LinkResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(179);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(678);





class LinkResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL)) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.bindDescriptor(descriptor, {
      locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.stringifyLocator(fromLocator)
    });
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const path = descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL.length);
    return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeLocator(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path)}`)];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
    const manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Manifest.find(packageFetch.prefixPath, {
        baseFs: packageFetch.packageFs
      });
    }, packageFetch.releaseFs);
    return { ...locator,
      version: manifest.version || `0.0.0`,
      languageName: opts.project.configuration.get(`defaultLanguageName`),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.LinkType.SOFT,
      dependencies: new Map([...manifest.dependencies, ...manifest.devDependencies]),
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

/***/ }),
/* 680 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RawLinkFetcher": () => /* binding */ RawLinkFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(170);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(171);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(678);



class RawLinkFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL
    });
    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path)) return path;
    const parentLocalPath = opts.fetcher.getLocalPath(parentLocator, opts);
    if (parentLocalPath === null) return null;
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(parentLocalPath, path);
  }

  async fetch(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL
    }); // If the link target is an absolute path we can directly access it via its
    // location on the disk. Otherwise we must go through the package fs.

    const parentFetch = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path) ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
      localPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root
    } : await opts.fetcher.fetch(parentLocator, opts); // If the package fs publicized its "original location" (for example like
    // in the case of "file:" packages), we use it to derive the real location.

    const effectiveParentFetch = parentFetch.localPath ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root, parentFetch.localPath)
    } : parentFetch; // Discard the parent fs unless we really need it to access the files

    if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs) parentFetch.releaseFs();
    const sourceFs = effectiveParentFetch.packageFs;
    const sourcePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(effectiveParentFetch.prefixPath, path);

    if (parentFetch.localPath) {
      return {
        packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(sourcePath, {
          baseFs: sourceFs
        }),
        releaseFs: effectiveParentFetch.releaseFs,
        prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
        discardFromLookup: true,
        localPath: sourcePath
      };
    } else {
      return {
        packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.JailFS(sourcePath, {
          baseFs: sourceFs
        }),
        releaseFs: effectiveParentFetch.releaseFs,
        prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
        discardFromLookup: true
      };
    }
  }

}

/***/ }),
/* 681 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RawLinkResolver": () => /* binding */ RawLinkResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(179);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(678);




class RawLinkResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL)) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.bindDescriptor(descriptor, {
      locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.stringifyLocator(fromLocator)
    });
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const path = descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL.length);
    return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.makeLocator(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path)}`)];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    return { ...locator,
      version: `0.0.0`,
      languageName: opts.project.configuration.get(`defaultLanguageName`),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.LinkType.SOFT,
      dependencies: new Map(),
      peerDependencies: new Map(),
      dependenciesMeta: new Map(),
      peerDependenciesMeta: new Map(),
      bin: new Map()
    };
  }

}

/***/ }),
/* 682 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPnpPath": () => /* binding */ getPnpPath,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(704);
/* harmony import */ var _NodeModulesLinker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(683);
/* harmony import */ var _PnpLooseLinker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(706);





const getPnpPath = project => _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(project.cwd, `.pnp.js`);
const plugin = {
  configuration: {
    nmHoistingLimits: {
      description: `Prevent packages can be hoisted past specific levels`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.SettingsType.STRING,
      values: [_yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_4__.NodeModulesHoistingLimits.WORKSPACES, _yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_4__.NodeModulesHoistingLimits.DEPENDENCIES, _yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_4__.NodeModulesHoistingLimits.NONE],
      default: `none`
    }
  },
  linkers: [_NodeModulesLinker__WEBPACK_IMPORTED_MODULE_0__.NodeModulesLinker, _PnpLooseLinker__WEBPACK_IMPORTED_MODULE_1__.PnpLooseLinker]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 683 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodeModulesLinker": () => /* binding */ NodeModulesLinker
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(179);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(175);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(176);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(341);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(182);
/* harmony import */ var _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(684);
/* harmony import */ var _yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(704);
/* harmony import */ var _zkochan_cmd_shim__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(700);
/* harmony import */ var _zkochan_cmd_shim__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_zkochan_cmd_shim__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_5__);













const STATE_FILE_VERSION = 1;
const NODE_MODULES = `node_modules`;
const DOT_BIN = `.bin`;
const INSTALL_STATE_FILE = `.yarn-state.yml`;
class NodeModulesLinker {
  supportsPackage(pkg, opts) {
    return opts.project.configuration.get(`nodeLinker`) === `node-modules`;
  }

  async findPackageLocation(locator, opts) {
    const workspace = opts.project.tryWorkspaceByLocator(locator);
    if (workspace) return workspace.cwd;
    const installState = await findInstallState(opts.project, {
      unrollAliases: true
    });
    if (installState === null) throw new clipanion__WEBPACK_IMPORTED_MODULE_4__.UsageError(`Couldn't find the node_modules state file - running an install might help (findPackageLocation)`);
    const locatorInfo = installState.locatorMap.get(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyLocator(locator));

    if (!locatorInfo) {
      const err = new clipanion__WEBPACK_IMPORTED_MODULE_4__.UsageError(`Couldn't find ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.prettyLocator(opts.project.configuration, locator)} in the currently installed node_modules map - running an install might help`);
      err.code = `LOCATOR_NOT_INSTALLED`;
      throw err;
    }

    return locatorInfo.locations[0];
  }

  async findPackageLocator(location, opts) {
    const installState = await findInstallState(opts.project, {
      unrollAliases: true
    });
    if (installState === null) return null;
    const {
      locationRoot,
      segments
    } = parseLocation(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(location), {
      skipPrefix: opts.project.cwd
    });
    let locationNode = installState.locationTree.get(locationRoot);
    if (!locationNode) return null;
    let locator = locationNode.locator;

    for (const segment of segments) {
      locationNode = locationNode.children.get(segment);
      if (!locationNode) break;
      locator = locationNode.locator || locator;
    }

    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.parseLocator(locator);
  }

  makeInstaller(opts) {
    return new NodeModulesInstaller(opts);
  }

}

class NodeModulesInstaller {
  constructor(opts) {
    this.opts = opts; // Stores data that we need to extract in the `installPackage` step but use
    // in the `finalizeInstall` step. Contrary to custom data this isn't persisted
    // anywhere - we literally just use it for the lifetime of the installer then
    // discard it.

    this.localStore = new Map();
    this.customData = {
      store: new Map()
    }; // Nothing to do
  }

  getCustomDataKey() {
    return JSON.stringify({
      name: `NodeModulesInstaller`,
      version: 1
    });
  }

  attachCustomData(customData) {
    this.customData = customData;
  }

  async installPackage(pkg, fetchResult) {
    var _a;

    const packageLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(fetchResult.packageFs.getRealPath(), fetchResult.prefixPath);
    let customPackageData = this.customData.store.get(pkg.locatorHash);

    if (typeof customPackageData === `undefined`) {
      customPackageData = await extractCustomPackageData(pkg, fetchResult);

      if (pkg.linkType === _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LinkType.HARD) {
        this.customData.store.set(pkg.locatorHash, customPackageData);
      }
    } // We don't link the package at all if it's for an unsupported platform


    if (!_yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_2__.jsInstallUtils.checkAndReportManifestCompatibility(pkg, customPackageData, `link`, {
      configuration: this.opts.project.configuration,
      report: this.opts.report
    })) return {
      packageLocation: null,
      buildDirective: null
    };
    const packageDependencies = new Map();
    const packagePeers = new Set();
    if (!packageDependencies.has(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyIdent(pkg))) packageDependencies.set(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyIdent(pkg), pkg.reference); // Only virtual packages should have effective peer dependencies, but the
    // workspaces are a special case because the original packages are kept in
    // the dependency tree even after being virtualized; so in their case we
    // just ignore their declared peer dependencies.

    if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.isVirtualLocator(pkg)) {
      for (const descriptor of pkg.peerDependencies.values()) {
        packageDependencies.set(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyIdent(descriptor), null);
        packagePeers.add(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyIdent(descriptor));
      }
    }

    const pnpNode = {
      packageLocation: `${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(packageLocation)}/`,
      packageDependencies,
      packagePeers,
      linkType: pkg.linkType,
      discardFromLookup: (_a = fetchResult.discardFromLookup) !== null && _a !== void 0 ? _a : false
    };
    this.localStore.set(pkg.locatorHash, {
      pkg,
      customPackageData,
      dependencyMeta: this.opts.project.getDependencyMeta(pkg, pkg.version),
      pnpNode
    });
    return {
      packageLocation,
      buildDirective: null
    };
  }

  async attachInternalDependencies(locator, dependencies) {
    const slot = this.localStore.get(locator.locatorHash);
    if (typeof slot === `undefined`) throw new Error(`Assertion failed: Expected information object to have been registered`);

    for (const [descriptor, locator] of dependencies) {
      const target = !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.areIdentsEqual(descriptor, locator) ? [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.requirableIdent(locator), locator.reference] : locator.reference;
      slot.pnpNode.packageDependencies.set(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.requirableIdent(descriptor), target);
    }
  }

  async attachExternalDependents(locator, dependentPaths) {
    throw new Error(`External dependencies haven't been implemented for the node-modules linker`);
  }

  async finalizeInstall() {
    if (this.opts.project.configuration.get(`nodeLinker`) !== `node-modules`) return undefined;
    const defaultFsLayer = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.VirtualFS({
      baseFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.ZipOpenFS({
        libzip: await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)(),
        maxOpenFiles: 80,
        readOnlyArchives: true
      })
    });
    let preinstallState = await findInstallState(this.opts.project); // Remove build state as well, to force rebuild of all the packages

    if (preinstallState === null) {
      const bstatePath = this.opts.project.configuration.get(`bstatePath`);
      if (await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.existsPromise(bstatePath)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.unlinkPromise(bstatePath);
      preinstallState = {
        locatorMap: new Map(),
        binSymlinks: new Map(),
        locationTree: new Map()
      };
    }

    const hoistingLimitsByCwd = new Map(this.opts.project.workspaces.map(workspace => {
      var _a, _b;

      let hoistingLimits = this.opts.project.configuration.get(`nmHoistingLimits`);

      try {
        hoistingLimits = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.validateEnum(_yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_13__.NodeModulesHoistingLimits, (_b = (_a = workspace.manifest.installConfig) === null || _a === void 0 ? void 0 : _a.hoistingLimits) !== null && _b !== void 0 ? _b : hoistingLimits);
      } catch (e) {
        const workspaceName = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.prettyWorkspace(this.opts.project.configuration, workspace);
        this.opts.report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__.MessageName.INVALID_MANIFEST, `${workspaceName}: Invalid 'installConfig.hoistingLimits' value. Expected one of ${Object.values(_yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_13__.NodeModulesHoistingLimits).join(`, `)}, using default: "${hoistingLimits}"`);
      }

      return [workspace.relativeCwd, hoistingLimits];
    }));
    const pnpApi = {
      VERSIONS: {
        std: 1
      },
      topLevel: {
        name: null,
        reference: null
      },
      getLocator: (name, referencish) => {
        if (Array.isArray(referencish)) {
          return {
            name: referencish[0],
            reference: referencish[1]
          };
        } else {
          return {
            name,
            reference: referencish
          };
        }
      },
      getDependencyTreeRoots: () => {
        return this.opts.project.workspaces.map(workspace => {
          const anchoredLocator = workspace.anchoredLocator;
          return {
            name: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyIdent(workspace.locator),
            reference: anchoredLocator.reference
          };
        });
      },
      getPackageInformation: pnpLocator => {
        const locator = pnpLocator.reference === null ? this.opts.project.topLevelWorkspace.anchoredLocator : _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.makeLocator(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.parseIdent(pnpLocator.name), pnpLocator.reference);
        const slot = this.localStore.get(locator.locatorHash);
        if (typeof slot === `undefined`) throw new Error(`Assertion failed: Expected the package reference to have been registered`);
        return slot.pnpNode;
      },
      findPackageLocator: location => {
        const workspace = this.opts.project.tryWorkspaceByCwd(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath(location));

        if (workspace !== null) {
          const anchoredLocator = workspace.anchoredLocator;
          return {
            name: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyIdent(anchoredLocator),
            reference: anchoredLocator.reference
          };
        }

        throw new Error(`Assertion failed: Unimplemented`);
      },
      resolveToUnqualified: () => {
        throw new Error(`Assertion failed: Unimplemented`);
      },
      resolveUnqualified: () => {
        throw new Error(`Assertion failed: Unimplemented`);
      },
      resolveRequest: () => {
        throw new Error(`Assertion failed: Unimplemented`);
      },
      resolveVirtual: path => {
        return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.VirtualFS.resolveVirtual(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath(path)));
      }
    };
    const nmTree = (0,_yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_13__.buildNodeModulesTree)(pnpApi, {
      pnpifyFs: false,
      hoistingLimitsByCwd,
      project: this.opts.project
    });
    const locatorMap = (0,_yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_13__.buildLocatorMap)(nmTree);
    await persistNodeModules(preinstallState, locatorMap, {
      baseFs: defaultFsLayer,
      project: this.opts.project,
      report: this.opts.report,
      loadManifest: async locatorKey => {
        const locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.parseLocator(locatorKey);
        const slot = this.localStore.get(locator.locatorHash);
        if (typeof slot === `undefined`) throw new Error(`Assertion failed: Expected the slot to exist`);
        return slot.customPackageData.manifest;
      }
    });
    const installStatuses = [];

    for (const [locatorKey, installRecord] of locatorMap.entries()) {
      if (isLinkLocator(locatorKey)) continue;
      const locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.parseLocator(locatorKey);
      const slot = this.localStore.get(locator.locatorHash);
      if (typeof slot === `undefined`) throw new Error(`Assertion failed: Expected the slot to exist`);
      const buildScripts = _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_2__.jsInstallUtils.extractBuildScripts(slot.pkg, slot.customPackageData, slot.dependencyMeta, {
        configuration: this.opts.project.configuration,
        report: this.opts.report
      });
      if (buildScripts.length === 0) continue;
      installStatuses.push({
        buildLocations: installRecord.locations,
        locatorHash: locator.locatorHash,
        buildDirective: buildScripts
      });
    }

    return {
      customData: this.customData,
      records: installStatuses
    };
  }

}

async function extractCustomPackageData(pkg, fetchResult) {
  var _a;

  const manifest = (_a = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_15__.Manifest.tryFind(fetchResult.prefixPath, {
    baseFs: fetchResult.packageFs
  })) !== null && _a !== void 0 ? _a : new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_15__.Manifest();
  const preservedScripts = new Set([`preinstall`, `install`, `postinstall`]);

  for (const scriptName of manifest.scripts.keys()) if (!preservedScripts.has(scriptName)) manifest.scripts.delete(scriptName);

  return {
    manifest: {
      bin: manifest.bin,
      os: manifest.os,
      cpu: manifest.cpu,
      scripts: manifest.scripts
    },
    misc: {
      extractHint: _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_2__.jsInstallUtils.getExtractHint(fetchResult),
      hasBindingGyp: _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_2__.jsInstallUtils.hasBindingGyp(fetchResult)
    }
  };
}

async function writeInstallState(project, locatorMap, binSymlinks) {
  let locatorState = ``;
  locatorState += `# Warning: This file is automatically generated. Removing it is fine, but will\n`;
  locatorState += `# cause your node_modules installation to become invalidated.\n`;
  locatorState += `\n`;
  locatorState += `__metadata:\n`;
  locatorState += `  version: ${STATE_FILE_VERSION}\n`;
  const locators = Array.from(locatorMap.keys()).sort();
  const topLevelLocator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyLocator(project.topLevelWorkspace.anchoredLocator);

  for (const locator of locators) {
    const installRecord = locatorMap.get(locator);
    locatorState += `\n`;
    locatorState += `${JSON.stringify(locator)}:\n`;
    locatorState += `  locations:\n`;

    for (const location of installRecord.locations) {
      const internalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.contains(project.cwd, location);
      if (internalPath === null) throw new Error(`Assertion failed: Expected the path to be within the project (${location})`);
      locatorState += `    - ${JSON.stringify(internalPath)}\n`;
    }

    if (installRecord.aliases.length > 0) {
      locatorState += `  aliases:\n`;

      for (const alias of installRecord.aliases) {
        locatorState += `    - ${JSON.stringify(alias)}\n`;
      }
    }

    if (locator === topLevelLocator && binSymlinks.size > 0) {
      locatorState += `  bin:\n`;

      for (const [location, symlinks] of binSymlinks) {
        const internalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.contains(project.cwd, location);
        if (internalPath === null) throw new Error(`Assertion failed: Expected the path to be within the project (${location})`);
        locatorState += `    ${JSON.stringify(internalPath)}:\n`;

        for (const [name, target] of symlinks) {
          const relativePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, NODE_MODULES), target);
          locatorState += `      ${JSON.stringify(name)}: ${JSON.stringify(relativePath)}\n`;
        }
      }
    }
  }

  const rootPath = project.cwd;
  const installStatePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(rootPath, NODE_MODULES, INSTALL_STATE_FILE);
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.changeFilePromise(installStatePath, locatorState, {
    automaticNewlines: true
  });
}

async function findInstallState(project, {
  unrollAliases = false
} = {}) {
  const rootPath = project.cwd;
  const installStatePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(rootPath, NODE_MODULES, INSTALL_STATE_FILE);
  if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.existsSync(installStatePath)) return null;
  const locatorState = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__.parseSyml)(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.readFilePromise(installStatePath, `utf8`)); // If we have a higher serialized version than we can handle, ignore the state alltogether

  if (locatorState.__metadata.version > STATE_FILE_VERSION) return null;
  const locatorMap = new Map();
  const binSymlinks = new Map();
  delete locatorState.__metadata;

  for (const [locatorStr, installRecord] of Object.entries(locatorState)) {
    const locations = installRecord.locations.map(location => {
      return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(rootPath, location);
    });
    const recordSymlinks = installRecord.bin;

    if (recordSymlinks) {
      for (const [relativeLocation, locationSymlinks] of Object.entries(recordSymlinks)) {
        const location = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(rootPath, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath(relativeLocation));
        const symlinks = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.getMapWithDefault(binSymlinks, location);

        for (const [name, target] of Object.entries(locationSymlinks)) {
          symlinks.set((0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.toFilename)(name), _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath([location, NODE_MODULES, target].join(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.delimiter)));
        }
      }
    }

    locatorMap.set(locatorStr, {
      target: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.dot,
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LinkType.HARD,
      locations,
      aliases: installRecord.aliases || []
    });

    if (unrollAliases && installRecord.aliases) {
      for (const reference of installRecord.aliases) {
        const {
          scope,
          name
        } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.parseLocator(locatorStr);
        const alias = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.makeLocator(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.makeIdent(scope, name), reference);
        const aliasStr = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyLocator(alias);
        locatorMap.set(aliasStr, {
          target: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.dot,
          linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LinkType.HARD,
          locations,
          aliases: []
        });
      }
    }
  }

  return {
    locatorMap,
    binSymlinks,
    locationTree: buildLocationTree(locatorMap, {
      skipPrefix: project.cwd
    })
  };
}

const removeDir = async (dir, options) => {
  if (dir.split(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.sep).indexOf(NODE_MODULES) < 0) throw new Error(`Assertion failed: trying to remove dir that doesn't contain node_modules: ${dir}`);

  try {
    if (!options.innerLoop) {
      const stats = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.lstatPromise(dir);

      if (stats.isSymbolicLink()) {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.unlinkPromise(dir);
        return;
      }
    }

    const entries = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.readdirPromise(dir, {
      withFileTypes: true
    });

    for (const entry of entries) {
      const targetPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(dir, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.toFilename)(entry.name));

      if (entry.isDirectory()) {
        if (entry.name !== NODE_MODULES || options && options.innerLoop) {
          await removeDir(targetPath, {
            innerLoop: true,
            contentsOnly: false
          });
        }
      } else {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.unlinkPromise(targetPath);
      }
    }

    if (!options.contentsOnly) {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.rmdirPromise(dir);
    }
  } catch (e) {
    if (e.code !== `ENOENT` && e.code !== `ENOTEMPTY`) {
      throw e;
    }
  }
};

const CONCURRENT_OPERATION_LIMIT = 4;

const parseLocation = (location, {
  skipPrefix
}) => {
  const projectRelativePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.contains(skipPrefix, location);
  if (projectRelativePath === null) throw new Error(`Assertion failed: Cannot process a path that isn't part of the requested prefix (${location} isn't within ${skipPrefix})`);
  const allSegments = projectRelativePath.split(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.sep) // Ignore empty segments (after trailing slashes)
  .filter(segment => segment !== ``);
  const nmIndex = allSegments.indexOf(NODE_MODULES); // Project path, up until the first node_modules segment

  const relativeRoot = allSegments.slice(0, nmIndex).join(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.sep);
  const locationRoot = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(skipPrefix, relativeRoot); // All segments that follow

  const segments = allSegments.slice(nmIndex);
  return {
    locationRoot,
    segments
  };
};

const buildLocationTree = (locatorMap, {
  skipPrefix
}) => {
  const locationTree = new Map();
  if (locatorMap === null) return locationTree;

  const makeNode = () => ({
    children: new Map(),
    linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LinkType.HARD
  });

  for (const [locator, info] of locatorMap.entries()) {
    if (info.linkType === _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LinkType.SOFT) {
      const internalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.contains(skipPrefix, info.target);

      if (internalPath !== null) {
        const node = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.getFactoryWithDefault(locationTree, info.target, makeNode);
        node.locator = locator;
        node.linkType = info.linkType;
      }
    }

    for (const location of info.locations) {
      const {
        locationRoot,
        segments
      } = parseLocation(location, {
        skipPrefix
      });
      let node = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.getFactoryWithDefault(locationTree, locationRoot, makeNode);

      for (let idx = 0; idx < segments.length; ++idx) {
        const segment = segments[idx]; // '.' segment exists only for top-level locator, skip it

        if (segment !== `.`) {
          const nextNode = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.getFactoryWithDefault(node.children, segment, makeNode);
          node.children.set(segment, nextNode);
          node = nextNode;
        }

        if (idx === segments.length - 1) {
          node.locator = locator;
          node.linkType = info.linkType;
        }
      }
    }
  }

  return locationTree;
};

const symlinkPromise = async (srcPath, dstPath) => {
  let stats;

  try {
    if (process.platform === `win32`) {
      stats = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.lstatSync(srcPath);
    }
  } catch (e) {}

  if (process.platform == `win32` && (!stats || stats.isDirectory())) {
    _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.symlinkPromise(srcPath, dstPath, `junction`);
  } else {
    _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.symlinkPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.dirname(dstPath), srcPath), dstPath);
  }
};

const copyPromise = async (dstDir, srcDir, {
  baseFs,
  innerLoop
}) => {
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(dstDir, {
    recursive: true
  });
  const entries = await baseFs.readdirPromise(srcDir, {
    withFileTypes: true
  });

  const copy = async (dstPath, srcPath, srcType) => {
    if (srcType.isFile()) {
      const stat = await baseFs.lstatPromise(srcPath);
      await baseFs.copyFilePromise(srcPath, dstPath);
      const mode = stat.mode & 0o777; // An optimization - files will have rw-r-r permissions (0o644) by default, we can skip chmod for them

      if (mode !== 0o644) {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.chmodPromise(dstPath, mode);
      }
    } else if (srcType.isSymbolicLink()) {
      const target = await baseFs.readlinkPromise(srcPath);
      await symlinkPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.dirname(dstPath), target), dstPath);
    } else {
      throw new Error(`Unsupported file type (file: ${srcPath}, mode: 0o${await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.statSync(srcPath).mode.toString(8).padStart(6, `0`)})`);
    }
  };

  for (const entry of entries) {
    const srcPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(srcDir, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.toFilename)(entry.name));
    const dstPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(dstDir, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.toFilename)(entry.name));

    if (entry.isDirectory()) {
      if (entry.name !== NODE_MODULES || innerLoop) {
        await copyPromise(dstPath, srcPath, {
          baseFs,
          innerLoop: true
        });
      }
    } else {
      await copy(dstPath, srcPath, entry);
    }
  }
};
/**
 * This function removes node_modules roots that do not exist on the filesystem from the location tree.
 *
 * This is needed to transparently support workflows on CI systems. When
 * user caches only top-level node_modules and forgets to cache node_modules
 * from deeper workspaces. By removing non-existent node_modules roots
 * we make our location tree to represent the real tree on the file system.
 *
 * Please note, that this function doesn't help with any other inconsistency
 * on a deeper level inside node_modules tree, it helps only when some node_modules roots
 * do not exist at all
 *
 * @param locationTree location tree
 *
 * @returns location tree with non-existent node_modules roots stripped
 */


function refineNodeModulesRoots(locationTree, binSymlinks) {
  const refinedLocationTree = new Map([...locationTree]);
  const refinedBinSymlinks = new Map([...binSymlinks]);

  for (const [workspaceRoot, node] of locationTree) {
    const nodeModulesRoot = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(workspaceRoot, NODE_MODULES);

    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.existsSync(nodeModulesRoot)) {
      node.children.delete(NODE_MODULES); // O(m^2) complexity algorithm, but on a very few values, so not worth the trouble to optimize it

      for (const location of refinedBinSymlinks.keys()) {
        if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.contains(nodeModulesRoot, location) !== null) {
          refinedBinSymlinks.delete(location);
        }
      }
    }
  }

  return {
    locationTree: refinedLocationTree,
    binSymlinks: refinedBinSymlinks
  };
}

function isLinkLocator(locatorKey) {
  let descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.parseDescriptor(locatorKey);
  if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.isVirtualDescriptor(descriptor)) descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.devirtualizeDescriptor(descriptor);
  return descriptor.range.startsWith(`link:`);
}

async function createBinSymlinkMap(installState, locationTree, projectRoot, {
  loadManifest
}) {
  const locatorScriptMap = new Map();

  for (const [locatorKey, {
    locations
  }] of installState) {
    const manifest = !isLinkLocator(locatorKey) ? await loadManifest(locatorKey, locations[0]) : null;
    const bin = new Map();

    if (manifest) {
      for (const [name, value] of manifest.bin) {
        const target = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(locations[0], value);

        if (value !== `` && _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.existsSync(target)) {
          bin.set(name, value);
        }
      }
    }

    locatorScriptMap.set(locatorKey, bin);
  }

  const binSymlinks = new Map();

  const getBinSymlinks = (location, parentLocatorLocation, node) => {
    const symlinks = new Map();
    const internalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.contains(projectRoot, location);

    if (node.locator && internalPath !== null) {
      const binScripts = locatorScriptMap.get(node.locator);

      for (const [filename, scriptPath] of binScripts) {
        const symlinkTarget = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath(scriptPath));
        symlinks.set((0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.toFilename)(filename), symlinkTarget);
      }

      for (const [childLocation, childNode] of node.children) {
        const absChildLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, childLocation);
        const childSymlinks = getBinSymlinks(absChildLocation, absChildLocation, childNode);

        if (childSymlinks.size > 0) {
          binSymlinks.set(location, new Map([...(binSymlinks.get(location) || new Map()), ...childSymlinks]));
        }
      }
    } else {
      for (const [childLocation, childNode] of node.children) {
        const childSymlinks = getBinSymlinks(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, childLocation), parentLocatorLocation, childNode);

        for (const [name, symlinkTarget] of childSymlinks) {
          symlinks.set(name, symlinkTarget);
        }
      }
    }

    return symlinks;
  };

  for (const [location, node] of locationTree) {
    const symlinks = getBinSymlinks(location, location, node);

    if (symlinks.size > 0) {
      binSymlinks.set(location, new Map([...(binSymlinks.get(location) || new Map()), ...symlinks]));
    }
  }

  return binSymlinks;
}

const areRealLocatorsEqual = (locatorKey1, locatorKey2) => {
  if (!locatorKey1 || !locatorKey2) return locatorKey1 === locatorKey2;
  let locator1 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.parseLocator(locatorKey1);
  if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.isVirtualLocator(locator1)) locator1 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.devirtualizeLocator(locator1);
  let locator2 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.parseLocator(locatorKey2);
  if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.isVirtualLocator(locator2)) locator2 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.devirtualizeLocator(locator2);
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.areLocatorsEqual(locator1, locator2);
};

async function persistNodeModules(preinstallState, installState, {
  baseFs,
  project,
  report,
  loadManifest
}) {
  const rootNmDirPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(project.cwd, NODE_MODULES);
  const {
    locationTree: prevLocationTree,
    binSymlinks: prevBinSymlinks
  } = refineNodeModulesRoots(preinstallState.locationTree, preinstallState.binSymlinks);
  const locationTree = buildLocationTree(installState, {
    skipPrefix: project.cwd
  });
  const addQueue = [];

  const addModule = async ({
    srcDir,
    dstDir,
    linkType
  }) => {
    const promise = (async () => {
      try {
        if (linkType === _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LinkType.SOFT) {
          await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.dirname(dstDir), {
            recursive: true
          });
          await symlinkPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(srcDir), dstDir);
        } else {
          await copyPromise(dstDir, srcDir, {
            baseFs
          });
        }
      } catch (e) {
        e.message = `While persisting ${srcDir} -> ${dstDir} ${e.message}`;
        throw e;
      } finally {
        progress.tick();
      }
    })().then(() => addQueue.splice(addQueue.indexOf(promise), 1));

    addQueue.push(promise);

    if (addQueue.length > CONCURRENT_OPERATION_LIMIT) {
      await Promise.race(addQueue);
    }
  };

  const cloneModule = async (srcDir, dstDir, options) => {
    const promise = (async () => {
      const cloneDir = async (srcDir, dstDir, options) => {
        try {
          if (!options || !options.innerLoop) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(dstDir, {
            recursive: true
          });
          const entries = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.readdirPromise(srcDir, {
            withFileTypes: true
          });

          for (const entry of entries) {
            if ((!options || !options.innerLoop) && entry.name === DOT_BIN) continue;
            const src = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(srcDir, entry.name);
            const dst = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(dstDir, entry.name);

            if (entry.isDirectory()) {
              if (entry.name !== NODE_MODULES || options && options.innerLoop) {
                await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(dst, {
                  recursive: true
                });
                await cloneDir(src, dst, {
                  innerLoop: true
                });
              }
            } else {
              await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.copyFilePromise(src, dst, (fs__WEBPACK_IMPORTED_MODULE_5___default().constants.COPYFILE_FICLONE));
            }
          }
        } catch (e) {
          if (!options || !options.innerLoop) e.message = `While cloning ${srcDir} -> ${dstDir} ${e.message}`;
          throw e;
        } finally {
          if (!options || !options.innerLoop) {
            progress.tick();
          }
        }
      };

      await cloneDir(srcDir, dstDir, options);
    })().then(() => addQueue.splice(addQueue.indexOf(promise), 1));

    addQueue.push(promise);

    if (addQueue.length > CONCURRENT_OPERATION_LIMIT) {
      await Promise.race(addQueue);
    }
  };

  const removeOutdatedDirs = async (location, prevNode, node) => {
    if (!node) {
      if (prevNode.children.has(NODE_MODULES)) await removeDir(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, NODE_MODULES), {
        contentsOnly: false
      });
      await removeDir(location, {
        contentsOnly: location === rootNmDirPath
      });
    } else {
      for (const [segment, prevChildNode] of prevNode.children) {
        const childNode = node.children.get(segment);
        await removeOutdatedDirs(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, segment), prevChildNode, childNode);
      }
    }
  }; // Find locations that existed previously, but no longer exist


  for (const [location, prevNode] of prevLocationTree) {
    const node = locationTree.get(location);

    for (const [segment, prevChildNode] of prevNode.children) {
      // '.' segment exists only for top-level locator, skip it
      if (segment === `.`) continue;
      const childNode = node ? node.children.get(segment) : node;
      await removeOutdatedDirs(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, segment), prevChildNode, childNode);
    }
  }

  const cleanNewDirs = async (location, node, prevNode) => {
    if (!prevNode) {
      // We want to clean only contents of top-level node_modules dir, since we need these dirs to be present
      if (node.children.has(NODE_MODULES)) await removeDir(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, NODE_MODULES), {
        contentsOnly: true
      }); // 1. If old directory is a symlink removeDir will remove it, regardless contentsOnly value
      // 2. If old and new directories are hardlinks - we pass contentsOnly: true
      // so that removeDir cleared only contents
      // 3. If new directory is a symlink - we pass contentsOnly: false
      // so that removeDir removed the whole directory

      await removeDir(location, {
        contentsOnly: node.linkType === _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LinkType.HARD
      });
    } else {
      if (!areRealLocatorsEqual(node.locator, prevNode.locator)) await removeDir(location, {
        contentsOnly: node.linkType === _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LinkType.HARD
      });

      for (const [segment, childNode] of node.children) {
        const prevChildNode = prevNode.children.get(segment);
        await cleanNewDirs(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, segment), childNode, prevChildNode);
      }
    }
  }; // Find new locations that are being added/changed and need to be cleaned up first


  for (const [location, node] of locationTree) {
    const prevNode = prevLocationTree.get(location);

    for (const [segment, childNode] of node.children) {
      // '.' segment exists only for top-level locator, skip it
      if (segment === `.`) continue;
      const prevChildNode = prevNode ? prevNode.children.get(segment) : prevNode;
      await cleanNewDirs(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, segment), childNode, prevChildNode);
    }
  } // Update changed locations


  const addList = [];

  for (const [prevLocator, {
    locations
  }] of preinstallState.locatorMap.entries()) {
    for (const location of locations) {
      const {
        locationRoot,
        segments
      } = parseLocation(location, {
        skipPrefix: project.cwd
      });
      let node = locationTree.get(locationRoot);
      let curLocation = locationRoot;

      if (node) {
        for (const segment of segments) {
          curLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(curLocation, segment);
          node = node.children.get(segment);

          if (!node) {
            break;
          }
        }

        if (node && !areRealLocatorsEqual(node.locator, prevLocator)) {
          const info = installState.get(node.locator);
          const srcDir = info.target;
          const dstDir = curLocation;
          const linkType = info.linkType;

          if (srcDir !== dstDir) {
            addList.push({
              srcDir,
              dstDir,
              linkType
            });
          }
        }
      }
    }
  } // Add new locations


  for (const [locator, {
    locations
  }] of installState.entries()) {
    for (const location of locations) {
      const {
        locationRoot,
        segments
      } = parseLocation(location, {
        skipPrefix: project.cwd
      });
      let prevTreeNode = prevLocationTree.get(locationRoot);
      let node = locationTree.get(locationRoot);
      let curLocation = locationRoot;
      const info = installState.get(locator);
      const srcDir = info.target;
      const dstDir = location;
      if (srcDir === dstDir) continue;
      const linkType = info.linkType;

      for (const segment of segments) node = node.children.get(segment);

      if (!prevTreeNode) {
        addList.push({
          srcDir,
          dstDir,
          linkType
        });
      } else {
        for (const segment of segments) {
          curLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(curLocation, segment);
          prevTreeNode = prevTreeNode.children.get(segment);

          if (!prevTreeNode) {
            addList.push({
              srcDir,
              dstDir,
              linkType
            });
            break;
          }
        }
      }
    }
  }

  const progress = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_16__.Report.progressViaCounter(addList.length);
  const reportedProgress = report.reportProgress(progress);

  try {
    const persistedLocations = new Map(); // For the first pass we'll only want to install a single copy for each
    // source directory. We'll later use the resulting install directories for
    // the other instances of the same package (this will avoid us having to
    // crawl the zip archives for each package).

    for (const entry of addList) {
      if (entry.linkType === _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LinkType.SOFT || !persistedLocations.has(entry.srcDir)) {
        persistedLocations.set(entry.srcDir, entry.dstDir);
        await addModule({ ...entry
        });
      }
    }

    await Promise.all(addQueue);
    addQueue.length = 0; // Second pass: clone module duplicates

    for (const entry of addList) {
      const persistedDir = persistedLocations.get(entry.srcDir);

      if (entry.linkType !== _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LinkType.SOFT && entry.dstDir !== persistedDir) {
        await cloneModule(persistedDir, entry.dstDir);
      }
    }

    await Promise.all(addQueue);
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(rootNmDirPath, {
      recursive: true
    });
    const binSymlinks = await createBinSymlinkMap(installState, locationTree, project.cwd, {
      loadManifest
    });
    await persistBinSymlinks(prevBinSymlinks, binSymlinks);
    await writeInstallState(project, installState, binSymlinks);
  } finally {
    reportedProgress.stop();
  }
}

async function persistBinSymlinks(previousBinSymlinks, binSymlinks) {
  // Delete outdated .bin folders
  for (const location of previousBinSymlinks.keys()) {
    if (!binSymlinks.has(location)) {
      const binDir = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, NODE_MODULES, DOT_BIN);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.removePromise(binDir);
    }
  }

  for (const [location, symlinks] of binSymlinks) {
    const binDir = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(location, NODE_MODULES, DOT_BIN);
    const prevSymlinks = previousBinSymlinks.get(location) || new Map();
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(binDir, {
      recursive: true
    });

    for (const name of prevSymlinks.keys()) {
      if (!symlinks.has(name)) {
        // Remove outdated symlinks
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.removePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(binDir, name));

        if (process.platform === `win32`) {
          await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.removePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(binDir, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.toFilename)(`${name}.cmd`)));
        }
      }
    }

    for (const [name, target] of symlinks) {
      const prevTarget = prevSymlinks.get(name);
      const symlinkPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(binDir, name); // Skip unchanged .bin symlinks

      if (prevTarget === target) continue;

      if (process.platform === `win32`) {
        await _zkochan_cmd_shim__WEBPACK_IMPORTED_MODULE_3___default()(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(target), _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(symlinkPath), {
          createPwshFile: false
        });
      } else {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.removePromise(symlinkPath);
        await symlinkPromise(target, symlinkPath);
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.chmodPromise(target, 0o755);
      }
    }
  }
}

/***/ }),
/* 684 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "jsInstallUtils": () => /* reexport module object */ _jsInstallUtils__WEBPACK_IMPORTED_MODULE_3__,
/* harmony export */   "pnpUtils": () => /* reexport module object */ _pnpUtils__WEBPACK_IMPORTED_MODULE_4__,
/* harmony export */   "getPnpPath": () => /* binding */ getPnpPath,
/* harmony export */   "quotePathIfNeeded": () => /* binding */ quotePathIfNeeded,
/* harmony export */   "PnpInstaller": () => /* reexport safe */ _PnpLinker__WEBPACK_IMPORTED_MODULE_1__.PnpInstaller,
/* harmony export */   "PnpLinker": () => /* reexport safe */ _PnpLinker__WEBPACK_IMPORTED_MODULE_1__.PnpLinker,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(155);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _PnpLinker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(685);
/* harmony import */ var _commands_unplug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(699);
/* harmony import */ var _jsInstallUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(697);
/* harmony import */ var _pnpUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(698);









const getPnpPath = project => {
  let mainFilename;
  let otherFilename;

  if (project.topLevelWorkspace.manifest.type === `module`) {
    mainFilename = `.pnp.cjs`;
    otherFilename = `.pnp.js`;
  } else {
    mainFilename = `.pnp.js`;
    otherFilename = `.pnp.cjs`;
  }

  return {
    main: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(project.cwd, mainFilename),
    other: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(project.cwd, otherFilename)
  };
};
const quotePathIfNeeded = path => {
  return /\s/.test(path) ? JSON.stringify(path) : path;
};

async function setupScriptEnvironment(project, env, makePathWrapper) {
  const pnpPath = getPnpPath(project).main;
  const pnpRequire = `--require ${quotePathIfNeeded(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.fromPortablePath(pnpPath))}`;
  if (pnpPath.includes(` `) && semver__WEBPACK_IMPORTED_MODULE_0___default().lt(process.versions.node, `12.0.0`)) throw new Error(`Expected the build location to not include spaces when using Node < 12.0.0 (${process.versions.node})`);

  if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.existsSync(pnpPath)) {
    let nodeOptions = env.NODE_OPTIONS || ``;
    const pnpRegularExpression = /\s*--require\s+\S*\.pnp\.c?js\s*/g;
    nodeOptions = nodeOptions.replace(pnpRegularExpression, ` `).trim();
    nodeOptions = nodeOptions ? `${pnpRequire} ${nodeOptions}` : pnpRequire;
    env.NODE_OPTIONS = nodeOptions;
  }
}

async function populateYarnPaths(project, definePath) {
  definePath(getPnpPath(project).main);
  definePath(getPnpPath(project).other);
  definePath(project.configuration.get(`pnpDataPath`));
  definePath(project.configuration.get(`pnpUnpluggedFolder`));
}

const plugin = {
  hooks: {
    populateYarnPaths,
    setupScriptEnvironment
  },
  configuration: {
    nodeLinker: {
      description: `The linker used for installing Node packages, one of: "pnp", "node-modules"`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.STRING,
      default: `pnp`
    },
    pnpMode: {
      description: `If 'strict', generates standard PnP maps. If 'loose', merges them with the n_m resolution.`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.STRING,
      default: `strict`
    },
    pnpShebang: {
      description: `String to prepend to the generated PnP script`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.STRING,
      default: `#!/usr/bin/env node`
    },
    pnpIgnorePatterns: {
      description: `Array of glob patterns; files matching them will use the classic resolution`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.STRING,
      default: [],
      isArray: true
    },
    pnpEnableInlining: {
      description: `If true, the PnP data will be inlined along with the generated loader`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.BOOLEAN,
      default: true
    },
    pnpFallbackMode: {
      description: `If true, the generated PnP loader will follow the top-level fallback rule`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.STRING,
      default: `dependencies-only`
    },
    pnpUnpluggedFolder: {
      description: `Folder where the unplugged packages must be stored`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.ABSOLUTE_PATH,
      default: `./.yarn/unplugged`
    },
    pnpDataPath: {
      description: `Path of the file where the PnP data (used by the loader) must be written`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.ABSOLUTE_PATH,
      default: `./.pnp.data.json`
    }
  },
  linkers: [_PnpLinker__WEBPACK_IMPORTED_MODULE_1__.PnpLinker],
  commands: [_commands_unplug__WEBPACK_IMPORTED_MODULE_2__.default]
};
 // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 685 */
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PnpLinker": () => /* binding */ PnpLinker,
/* harmony export */   "PnpInstaller": () => /* binding */ PnpInstaller
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(179);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(170);
/* harmony import */ var _yarnpkg_pnp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(686);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(684);
/* harmony import */ var _jsInstallUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(697);
/* harmony import */ var _pnpUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(698);








const FORCED_UNPLUG_PACKAGES = new Set([// Some packages do weird stuff and MUST be unplugged. I don't like them.
_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.makeIdent(null, `nan`).identHash, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.makeIdent(null, `node-gyp`).identHash, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.makeIdent(null, `node-pre-gyp`).identHash, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.makeIdent(null, `node-addon-api`).identHash, // Those ones contain native builds (*.node), and Node loads them through dlopen
_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.makeIdent(null, `fsevents`).identHash]);
class PnpLinker {
  constructor() {
    this.mode = `strict`;
  }

  supportsPackage(pkg, opts) {
    if (opts.project.configuration.get(`nodeLinker`) !== `pnp`) return false;
    if (opts.project.configuration.get(`pnpMode`) !== this.mode) return false;
    return true;
  }

  async findPackageLocation(locator, opts) {
    const pnpPath = (0,_index__WEBPACK_IMPORTED_MODULE_2__.getPnpPath)(opts.project).main;
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.existsSync(pnpPath)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The project in ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.pretty(opts.project.configuration, `${opts.project.cwd}/package.json`, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Type.PATH)} doesn't seem to have been installed - running an install there might help`);
    const pnpFile = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.dynamicRequireNoCache(pnpPath);
    const packageLocator = {
      name: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.requirableIdent(locator),
      reference: locator.reference
    };
    const packageInformation = pnpFile.getPackageInformation(packageLocator);
    if (!packageInformation) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.prettyLocator(opts.project.configuration, locator)} in the currently installed PnP map - running an install might help`);
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.npath.toPortablePath(packageInformation.packageLocation);
  }

  async findPackageLocator(location, opts) {
    const pnpPath = (0,_index__WEBPACK_IMPORTED_MODULE_2__.getPnpPath)(opts.project).main;
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.existsSync(pnpPath)) return null;
    const physicalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.npath.fromPortablePath(pnpPath);
    const pnpFile = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.dynamicRequire(physicalPath);
    delete __webpack_require__.c[physicalPath];
    const locator = pnpFile.findPackageLocator(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.npath.fromPortablePath(location));
    if (!locator) return null;
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.makeLocator(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.parseIdent(locator.name), locator.reference);
  }

  makeInstaller(opts) {
    return new PnpInstaller(opts);
  }

}
class PnpInstaller {
  constructor(opts) {
    this.opts = opts;
    this.mode = `strict`;
    this.packageRegistry = new Map();
    this.blacklistedPaths = new Set();
    this.customData = {
      store: new Map()
    };
    this.unpluggedPaths = new Set();
    this.opts = opts;
  }

  getCustomDataKey() {
    return JSON.stringify({
      name: `PnpInstaller`,
      version: 1
    });
  }

  attachCustomData(customData) {
    this.customData = customData;
  }

  async installPackage(pkg, fetchResult) {
    const key1 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.requirableIdent(pkg);
    const key2 = pkg.reference;
    const isWorkspace = !!this.opts.project.tryWorkspaceByLocator(pkg);
    const hasVirtualInstances = // Only packages with peer dependencies have virtual instances
    pkg.peerDependencies.size > 0 && // Only packages with peer dependencies have virtual instances
    !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.isVirtualLocator(pkg);
    const mayNeedToBeBuilt = // Virtual instance templates don't need to be built, since they don't truly exist
    !hasVirtualInstances && // Workspaces aren't built by the linkers; they are managed by the core itself
    !isWorkspace;
    const mayNeedToBeUnplugged = // Virtual instance templates don't need to be unplugged, since they don't truly exist
    !hasVirtualInstances && // We never need to unplug soft links, since we don't control them
    pkg.linkType !== _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.LinkType.SOFT;
    let customPackageData = this.customData.store.get(pkg.locatorHash);

    if (typeof customPackageData === `undefined`) {
      customPackageData = await extractCustomPackageData(pkg, fetchResult);

      if (pkg.linkType === _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.LinkType.HARD) {
        this.customData.store.set(pkg.locatorHash, customPackageData);
      }
    }

    const dependencyMeta = this.opts.project.getDependencyMeta(pkg, pkg.version);
    const buildScripts = mayNeedToBeBuilt ? _jsInstallUtils__WEBPACK_IMPORTED_MODULE_3__.extractBuildScripts(pkg, customPackageData, dependencyMeta, {
      configuration: this.opts.project.configuration,
      report: this.opts.report
    }) : [];
    const packageFs = mayNeedToBeUnplugged ? await this.unplugPackageIfNeeded(pkg, customPackageData, fetchResult, dependencyMeta) : fetchResult.packageFs;
    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.isAbsolute(fetchResult.prefixPath)) throw new Error(`Assertion failed: Expected the prefix path (${fetchResult.prefixPath}) to be relative to the parent`);
    const packageRawLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.resolve(packageFs.getRealPath(), fetchResult.prefixPath);
    const packageLocation = normalizeDirectoryPath(this.opts.project.cwd, packageRawLocation);
    const packageDependencies = new Map();
    const packagePeers = new Set(); // Only virtual packages should have effective peer dependencies, but the
    // workspaces are a special case because the original packages are kept in
    // the dependency tree even after being virtualized; so in their case we
    // just ignore their declared peer dependencies.

    if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.isVirtualLocator(pkg)) {
      for (const descriptor of pkg.peerDependencies.values()) {
        packageDependencies.set(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.requirableIdent(descriptor), null);
        packagePeers.add(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.stringifyIdent(descriptor));
      }
    }

    _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.getMapWithDefault(this.packageRegistry, key1).set(key2, {
      packageLocation,
      packageDependencies,
      packagePeers,
      linkType: pkg.linkType,
      discardFromLookup: fetchResult.discardFromLookup || false
    });
    if (hasVirtualInstances && !isWorkspace) this.blacklistedPaths.add(packageLocation);
    return {
      packageLocation: packageRawLocation,
      buildDirective: buildScripts.length > 0 ? buildScripts : null
    };
  }

  async attachInternalDependencies(locator, dependencies) {
    const packageInformation = this.getPackageInformation(locator);

    for (const [descriptor, locator] of dependencies) {
      const target = !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.areIdentsEqual(descriptor, locator) ? [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.requirableIdent(locator), locator.reference] : locator.reference;
      packageInformation.packageDependencies.set(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.requirableIdent(descriptor), target);
    }
  }

  async attachExternalDependents(locator, dependentPaths) {
    for (const dependentPath of dependentPaths) {
      const packageInformation = this.getDiskInformation(dependentPath);
      packageInformation.packageDependencies.set(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.requirableIdent(locator), locator.reference);
    }
  }

  async finalizeInstall() {
    this.trimBlacklistedPackages();
    this.packageRegistry.set(null, new Map([[null, this.getPackageInformation(this.opts.project.topLevelWorkspace.anchoredLocator)]]));
    const pnpFallbackMode = this.opts.project.configuration.get(`pnpFallbackMode`);
    const blacklistedLocations = this.blacklistedPaths;
    const dependencyTreeRoots = this.opts.project.workspaces.map(({
      anchoredLocator
    }) => ({
      name: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.requirableIdent(anchoredLocator),
      reference: anchoredLocator.reference
    }));
    const enableTopLevelFallback = pnpFallbackMode !== `none`;
    const fallbackExclusionList = [];
    const fallbackPool = new Map();
    const ignorePattern = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.buildIgnorePattern([`.yarn/sdks/**`, ...this.opts.project.configuration.get(`pnpIgnorePatterns`)]);
    const packageRegistry = this.packageRegistry;
    const shebang = this.opts.project.configuration.get(`pnpShebang`);
    if (pnpFallbackMode === `dependencies-only`) for (const pkg of this.opts.project.storedPackages.values()) if (this.opts.project.tryWorkspaceByLocator(pkg)) fallbackExclusionList.push({
      name: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.requirableIdent(pkg),
      reference: pkg.reference
    });
    await this.finalizeInstallWithPnp({
      blacklistedLocations,
      dependencyTreeRoots,
      enableTopLevelFallback,
      fallbackExclusionList,
      fallbackPool,
      ignorePattern,
      packageRegistry,
      shebang
    });
    return {
      customData: this.customData
    };
  }

  async finalizeInstallWithPnp(pnpSettings) {
    if (this.opts.project.configuration.get(`pnpMode`) !== this.mode) return;
    const pnpPath = (0,_index__WEBPACK_IMPORTED_MODULE_2__.getPnpPath)(this.opts.project);
    const pnpDataPath = this.opts.project.configuration.get(`pnpDataPath`);
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(pnpPath.other);

    if (this.opts.project.configuration.get(`nodeLinker`) !== `pnp`) {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(pnpPath.main);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(pnpDataPath);
      return;
    }

    const nodeModules = await this.locateNodeModules(pnpSettings.ignorePattern);

    if (nodeModules.length > 0) {
      this.opts.report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.DANGEROUS_NODE_MODULES, `One or more node_modules have been detected and will be removed. This operation may take some time.`);

      for (const nodeModulesPath of nodeModules) {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(nodeModulesPath);
      }
    }

    if (this.opts.project.configuration.get(`pnpEnableInlining`)) {
      const loaderFile = (0,_yarnpkg_pnp__WEBPACK_IMPORTED_MODULE_0__.generateInlinedScript)(pnpSettings);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.changeFilePromise(pnpPath.main, loaderFile, {
        automaticNewlines: true
      });
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.chmodPromise(pnpPath.main, 0o755);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(pnpDataPath);
    } else {
      const dataLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.dirname(pnpPath.main), pnpDataPath);
      const {
        dataFile,
        loaderFile
      } = (0,_yarnpkg_pnp__WEBPACK_IMPORTED_MODULE_0__.generateSplitScript)({ ...pnpSettings,
        dataLocation
      });
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.changeFilePromise(pnpPath.main, loaderFile, {
        automaticNewlines: true
      });
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.chmodPromise(pnpPath.main, 0o755);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.changeFilePromise(pnpDataPath, dataFile, {
        automaticNewlines: true
      });
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.chmodPromise(pnpDataPath, 0o644);
    }

    const pnpUnpluggedFolder = this.opts.project.configuration.get(`pnpUnpluggedFolder`);

    if (this.unpluggedPaths.size === 0) {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(pnpUnpluggedFolder);
    } else {
      for (const entry of await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.readdirPromise(pnpUnpluggedFolder)) {
        const unpluggedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.resolve(pnpUnpluggedFolder, entry);

        if (!this.unpluggedPaths.has(unpluggedPath)) {
          await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(unpluggedPath);
        }
      }
    }
  }

  async locateNodeModules(ignorePattern) {
    const nodeModules = [];
    const ignoreRegExp = ignorePattern ? new RegExp(ignorePattern) : null;

    for (const workspace of this.opts.project.workspaces) {
      const nodeModulesPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.join(workspace.cwd, `node_modules`);
      if (ignoreRegExp && ignoreRegExp.test(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.relative(this.opts.project.cwd, workspace.cwd)) || !_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.existsSync(nodeModulesPath)) continue;
      const directoryListing = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.readdirPromise(nodeModulesPath, {
        withFileTypes: true
      });
      const nonCacheEntries = directoryListing.filter(entry => {
        return !entry.isDirectory() || entry.name === `.bin` || !entry.name.startsWith(`.`);
      });

      if (nonCacheEntries.length === directoryListing.length) {
        nodeModules.push(nodeModulesPath);
      } else {
        for (const entry of nonCacheEntries) {
          nodeModules.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.join(nodeModulesPath, entry.name));
        }
      }
    }

    return nodeModules;
  }

  async unplugPackageIfNeeded(pkg, customPackageData, fetchResult, dependencyMeta) {
    if (this.shouldBeUnplugged(pkg, customPackageData, dependencyMeta)) {
      return this.unplugPackage(pkg, fetchResult);
    } else {
      return fetchResult.packageFs;
    }
  }

  shouldBeUnplugged(pkg, customPackageData, dependencyMeta) {
    if (typeof dependencyMeta.unplugged !== `undefined`) return dependencyMeta.unplugged;
    if (FORCED_UNPLUG_PACKAGES.has(pkg.identHash)) return true;
    if (customPackageData.manifest.preferUnplugged !== null) return customPackageData.manifest.preferUnplugged;
    if (_jsInstallUtils__WEBPACK_IMPORTED_MODULE_3__.extractBuildScripts(pkg, customPackageData, dependencyMeta, {
      configuration: this.opts.project.configuration
    }).length > 0 || customPackageData.misc.extractHint) return true;
    return false;
  }

  async unplugPackage(locator, fetchResult) {
    const unplugPath = _pnpUtils__WEBPACK_IMPORTED_MODULE_4__.getUnpluggedPath(locator, {
      configuration: this.opts.project.configuration
    });
    this.unpluggedPaths.add(unplugPath);
    const readyFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.join(unplugPath, fetchResult.prefixPath, `.ready`);
    if (await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.existsPromise(readyFile)) return new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__.CwdFS(unplugPath);
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mkdirPromise(unplugPath, {
      recursive: true
    });
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.copyPromise(unplugPath, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.PortablePath.dot, {
      baseFs: fetchResult.packageFs,
      overwrite: false
    });
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.writeFilePromise(readyFile, ``);
    return new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__.CwdFS(unplugPath);
  }

  getPackageInformation(locator) {
    const key1 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.requirableIdent(locator);
    const key2 = locator.reference;
    const packageInformationStore = this.packageRegistry.get(key1);
    if (!packageInformationStore) throw new Error(`Assertion failed: The package information store should have been available (for ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.prettyIdent(this.opts.project.configuration, locator)})`);
    const packageInformation = packageInformationStore.get(key2);
    if (!packageInformation) throw new Error(`Assertion failed: The package information should have been available (for ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.prettyLocator(this.opts.project.configuration, locator)})`);
    return packageInformation;
  }

  getDiskInformation(path) {
    const packageStore = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.getMapWithDefault(this.packageRegistry, `@@disk`);
    const normalizedPath = normalizeDirectoryPath(this.opts.project.cwd, path);
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.getFactoryWithDefault(packageStore, normalizedPath, () => ({
      packageLocation: normalizedPath,
      packageDependencies: new Map(),
      packagePeers: new Set(),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.LinkType.SOFT,
      discardFromLookup: false
    }));
  }

  trimBlacklistedPackages() {
    for (const packageStore of this.packageRegistry.values()) {
      for (const [key2, packageInformation] of packageStore) {
        if (packageInformation.packageLocation && this.blacklistedPaths.has(packageInformation.packageLocation)) {
          packageStore.delete(key2);
        }
      }
    }
  }

}

function normalizeDirectoryPath(root, folder) {
  let relativeFolder = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.relative(root, folder);
  if (!relativeFolder.match(/^\.{0,2}\//)) // Don't use ppath.join here, it ignores the `.`
    relativeFolder = `./${relativeFolder}`;
  return relativeFolder.replace(/\/?$/, `/`);
}

async function extractCustomPackageData(pkg, fetchResult) {
  var _a;

  const manifest = (_a = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.Manifest.tryFind(fetchResult.prefixPath, {
    baseFs: fetchResult.packageFs
  })) !== null && _a !== void 0 ? _a : new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.Manifest();
  const preservedScripts = new Set([`preinstall`, `install`, `postinstall`]);

  for (const scriptName of manifest.scripts.keys()) if (!preservedScripts.has(scriptName)) manifest.scripts.delete(scriptName);

  return {
    manifest: {
      os: manifest.os,
      cpu: manifest.cpu,
      scripts: manifest.scripts,
      preferUnplugged: manifest.preferUnplugged
    },
    misc: {
      extractHint: _jsInstallUtils__WEBPACK_IMPORTED_MODULE_3__.getExtractHint(fetchResult),
      hasBindingGyp: _jsInstallUtils__WEBPACK_IMPORTED_MODULE_3__.hasBindingGyp(fetchResult)
    }
  };
}

/***/ }),
/* 686 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkType": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.LinkType,
/* harmony export */   "generateInlinedScript": () => /* reexport safe */ _generatePnpScript__WEBPACK_IMPORTED_MODULE_1__.generateInlinedScript,
/* harmony export */   "generateSplitScript": () => /* reexport safe */ _generatePnpScript__WEBPACK_IMPORTED_MODULE_1__.generateSplitScript,
/* harmony export */   "hydratePnpFile": () => /* reexport safe */ _hydratePnpApi__WEBPACK_IMPORTED_MODULE_2__.hydratePnpFile,
/* harmony export */   "hydratePnpSource": () => /* reexport safe */ _hydratePnpApi__WEBPACK_IMPORTED_MODULE_2__.hydratePnpSource,
/* harmony export */   "makeRuntimeApi": () => /* reexport safe */ _makeRuntimeApi__WEBPACK_IMPORTED_MODULE_3__.makeRuntimeApi
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(687);
/* harmony import */ var _generatePnpScript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(688);
/* harmony import */ var _hydratePnpApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(692);
/* harmony import */ var _makeRuntimeApi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(696);





/***/ }),
/* 687 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkType": () => /* binding */ LinkType
/* harmony export */ });
// Note: most of those types are useless for most users. Just check the
// PnpSettings and PnpApi types at the end and you'll be fine.
//
// Apart from that, note that the "Data"-suffixed types are the ones stored
// within the state files (hence why they only use JSON datatypes).
var LinkType;

(function (LinkType) {
  LinkType["HARD"] = "HARD";
  LinkType["SOFT"] = "SOFT";
})(LinkType || (LinkType = {}));

/***/ }),
/* 688 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateInlinedScript": () => /* binding */ generateInlinedScript,
/* harmony export */   "generateSplitScript": () => /* binding */ generateSplitScript
/* harmony export */ });
/* harmony import */ var _generatePrettyJson__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(689);
/* harmony import */ var _generateSerializedState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(691);
/* harmony import */ var _hook__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(690);
/* harmony import */ var _hook__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_hook__WEBPACK_IMPORTED_MODULE_1__);

 // @ts-expect-error



function generateLoader(shebang, loader) {
  return [shebang ? `${shebang}\n` : ``, `/* eslint-disable */\n\n`, `try {\n`, `  Object.freeze({}).detectStrictMode = true;\n`, `} catch (error) {\n`, `  throw new Error(\`The whole PnP file got strict-mode-ified, which is known to break (Emscripten libraries aren't strict mode). This usually happens when the file goes through Babel.\`);\n`, `}\n`, `\n`, `var __non_webpack_module__ = module;\n`, `\n`, `function $$SETUP_STATE(hydrateRuntimeState, basePath) {\n`, loader.replace(/^/gm, `  `), `}\n`, `\n`, _hook__WEBPACK_IMPORTED_MODULE_1___default()()].join(``);
}

function generateJsonString(data) {
  return JSON.stringify(data, null, 2);
}

function generateInlinedSetup(data) {
  return [`return hydrateRuntimeState(${(0,_generatePrettyJson__WEBPACK_IMPORTED_MODULE_0__.generatePrettyJson)(data)}, {basePath: basePath || __dirname});\n`].join(``);
}

function generateSplitSetup(dataLocation) {
  return [`var path = require('path');\n`, `var dataLocation = path.resolve(__dirname, ${JSON.stringify(dataLocation)});\n`, `return hydrateRuntimeState(require(dataLocation), {basePath: basePath || path.dirname(dataLocation)});\n`].join(``);
}

function generateInlinedScript(settings) {
  const data = (0,_generateSerializedState__WEBPACK_IMPORTED_MODULE_2__.generateSerializedState)(settings);
  const setup = generateInlinedSetup(data);
  const loaderFile = generateLoader(settings.shebang, setup);
  return loaderFile;
}
function generateSplitScript(settings) {
  const data = (0,_generateSerializedState__WEBPACK_IMPORTED_MODULE_2__.generateSerializedState)(settings);
  const setup = generateSplitSetup(settings.dataLocation);
  const loaderFile = generateLoader(settings.shebang, setup);
  return {
    dataFile: generateJsonString(data),
    loaderFile
  };
}

/***/ }),
/* 689 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generatePrettyJson": () => /* binding */ generatePrettyJson
/* harmony export */ });
var PrettyJsonState;

(function (PrettyJsonState) {
  PrettyJsonState["DEFAULT"] = "DEFAULT";
  PrettyJsonState["TOP_LEVEL"] = "TOP_LEVEL";
  PrettyJsonState["FALLBACK_EXCLUSION_LIST"] = "FALLBACK_EXCLUSION_LIST";
  PrettyJsonState["FALLBACK_EXCLUSION_ENTRIES"] = "FALLBACK_EXCLUSION_ENTRIES";
  PrettyJsonState["FALLBACK_EXCLUSION_DATA"] = "FALLBACK_EXCLUSION_DATA";
  PrettyJsonState["PACKAGE_REGISTRY_DATA"] = "PACKAGE_REGISTRY_DATA";
  PrettyJsonState["PACKAGE_REGISTRY_ENTRIES"] = "PACKAGE_REGISTRY_ENTRIES";
  PrettyJsonState["PACKAGE_STORE_DATA"] = "PACKAGE_STORE_DATA";
  PrettyJsonState["PACKAGE_STORE_ENTRIES"] = "PACKAGE_STORE_ENTRIES";
  PrettyJsonState["PACKAGE_INFORMATION_DATA"] = "PACKAGE_INFORMATION_DATA";
  PrettyJsonState["PACKAGE_DEPENDENCIES"] = "PACKAGE_DEPENDENCIES";
  PrettyJsonState["PACKAGE_DEPENDENCY"] = "PACKAGE_DEPENDENCY";
})(PrettyJsonState || (PrettyJsonState = {}));

const prettyJsonMachine = {
  [PrettyJsonState.DEFAULT]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  // {
  //   "fallbackExclusionList": ...
  // }
  [PrettyJsonState.TOP_LEVEL]: {
    collapsed: false,
    next: {
      [`fallbackExclusionList`]: PrettyJsonState.FALLBACK_EXCLUSION_LIST,
      [`packageRegistryData`]: PrettyJsonState.PACKAGE_REGISTRY_DATA,
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  // "fallbackExclusionList": [
  //   ...
  // ]
  [PrettyJsonState.FALLBACK_EXCLUSION_LIST]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.FALLBACK_EXCLUSION_ENTRIES
    }
  },
  // "fallbackExclusionList": [
  //   [...]
  // ]
  [PrettyJsonState.FALLBACK_EXCLUSION_ENTRIES]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.FALLBACK_EXCLUSION_DATA
    }
  },
  // "fallbackExclusionList": [
  //   [..., [...]]
  // ]
  [PrettyJsonState.FALLBACK_EXCLUSION_DATA]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  // "packageRegistryData": [
  //   ...
  // ]
  [PrettyJsonState.PACKAGE_REGISTRY_DATA]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_REGISTRY_ENTRIES
    }
  },
  // "packageRegistryData": [
  //   [...]
  // ]
  [PrettyJsonState.PACKAGE_REGISTRY_ENTRIES]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_STORE_DATA
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     ...
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_STORE_DATA]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_STORE_ENTRIES
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     [...]
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_STORE_ENTRIES]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_INFORMATION_DATA
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     [..., {
  //       ...
  //     }]
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_INFORMATION_DATA]: {
    collapsed: false,
    next: {
      [`packageDependencies`]: PrettyJsonState.PACKAGE_DEPENDENCIES,
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     [..., {
  //       "packagePeers": [
  //         ...
  //       ]
  //     }]
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_DEPENDENCIES]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_DEPENDENCY
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     [..., {
  //       "packageDependencies": [
  //         [...]
  //       ]
  //     }]
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_DEPENDENCY]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.DEFAULT
    }
  }
};

function generateCollapsedArray(data, state, indent) {
  let result = ``;
  result += `[`;

  for (let t = 0, T = data.length; t < T; ++t) {
    result += generateNext(String(t), data[t], state, indent).replace(/^ +/g, ``);

    if (t + 1 < T) {
      result += `, `;
    }
  }

  result += `]`;
  return result;
}

function generateExpandedArray(data, state, indent) {
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `[\n`;

  for (let t = 0, T = data.length; t < T; ++t) {
    result += nextIndent + generateNext(String(t), data[t], state, nextIndent).replace(/^ +/, ``);
    if (t + 1 < T) result += `,`;
    result += `\n`;
  }

  result += indent;
  result += `]`;
  return result;
}

function generateCollapsedObject(data, state, indent) {
  const keys = Object.keys(data);
  let result = ``;
  result += `{`;

  for (let t = 0, T = keys.length; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`) continue;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, indent).replace(/^ +/g, ``);

    if (t + 1 < T) {
      result += `, `;
    }
  }

  result += `}`;
  return result;
}

function generateExpandedObject(data, state, indent) {
  const keys = Object.keys(data);
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `{\n`;

  for (let t = 0, T = keys.length; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`) continue;
    result += nextIndent;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, nextIndent).replace(/^ +/g, ``);
    if (t + 1 < T) result += `,`;
    result += `\n`;
  }

  result += indent;
  result += `}`;
  return result;
}

function generateNext(key, data, state, indent) {
  const {
    next
  } = prettyJsonMachine[state];
  const nextState = next[key] || next[`*`];
  return generate(data, nextState, indent);
}

function generate(data, state, indent) {
  const {
    collapsed
  } = prettyJsonMachine[state];

  if (Array.isArray(data)) {
    if (collapsed) {
      return generateCollapsedArray(data, state, indent);
    } else {
      return generateExpandedArray(data, state, indent);
    }
  }

  if (typeof data === `object` && data !== null) {
    if (collapsed) {
      return generateCollapsedObject(data, state, indent);
    } else {
      return generateExpandedObject(data, state, indent);
    }
  }

  return JSON.stringify(data);
}

function generatePrettyJson(data) {
  return generate(data, PrettyJsonState.TOP_LEVEL, ``);
}

/***/ }),
/* 690 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

let hook;

module.exports = () => {
  if (typeof hook === `undefined`)
    hook = __webpack_require__(164).brotliDecompressSync(Buffer.from('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', 'base64')).toString();

  return hook;
};


/***/ }),
/* 691 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sortMap": () => /* binding */ sortMap,
/* harmony export */   "generateSerializedState": () => /* binding */ generateSerializedState
/* harmony export */ });
// Keep this function is sync with its implementation in:
// @yarnpkg/core/sources/miscUtils.ts
function sortMap(values, mappers) {
  const asArray = Array.from(values);
  if (!Array.isArray(mappers)) mappers = [mappers];
  const stringified = [];

  for (const mapper of mappers) stringified.push(asArray.map(value => mapper(value)));

  const indices = asArray.map((_, index) => index);
  indices.sort((a, b) => {
    for (const layer of stringified) {
      const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? +1 : 0;

      if (comparison !== 0) {
        return comparison;
      }
    }

    return 0;
  });
  return indices.map(index => {
    return asArray[index];
  });
}

function generateFallbackExclusionList(settings) {
  const fallbackExclusionList = new Map();
  const sortedData = sortMap(settings.fallbackExclusionList || [], [({
    name,
    reference
  }) => name, ({
    name,
    reference
  }) => reference]);

  for (const {
    name,
    reference
  } of sortedData) {
    let references = fallbackExclusionList.get(name);
    if (typeof references === `undefined`) fallbackExclusionList.set(name, references = new Set());
    references.add(reference);
  }

  return Array.from(fallbackExclusionList).map(([name, references]) => {
    return [name, Array.from(references)];
  });
}

function generateFallbackPoolData(settings) {
  return sortMap(settings.fallbackPool || [], ([name]) => name);
}

function generatePackageRegistryData(settings) {
  const packageRegistryData = [];

  for (const [packageName, packageStore] of sortMap(settings.packageRegistry, ([packageName]) => packageName === null ? `0` : `1${packageName}`)) {
    const packageStoreData = [];
    packageRegistryData.push([packageName, packageStoreData]);

    for (const [packageReference, {
      packageLocation,
      packageDependencies,
      packagePeers,
      linkType,
      discardFromLookup
    }] of sortMap(packageStore, ([packageReference]) => packageReference === null ? `0` : `1${packageReference}`)) {
      const normalizedDependencies = [];
      if (packageName !== null && packageReference !== null && !packageDependencies.has(packageName)) normalizedDependencies.push([packageName, packageReference]);

      for (const [dependencyName, dependencyReference] of sortMap(packageDependencies.entries(), ([dependencyName]) => dependencyName)) normalizedDependencies.push([dependencyName, dependencyReference]);

      const normalizedPeers = packagePeers && packagePeers.size > 0 ? Array.from(packagePeers) : undefined;
      const normalizedDiscardFromLookup = discardFromLookup ? discardFromLookup : undefined;
      packageStoreData.push([packageReference, {
        packageLocation,
        packageDependencies: normalizedDependencies,
        packagePeers: normalizedPeers,
        linkType,
        discardFromLookup: normalizedDiscardFromLookup
      }]);
    }
  }

  return packageRegistryData;
}

function generateLocationBlacklistData(settings) {
  return sortMap(settings.blacklistedLocations || [], location => location);
}

function generateSerializedState(settings) {
  return {
    // @eslint-ignore-next-line @typescript-eslint/naming-convention
    __info: [`This file is automatically generated. Do not touch it, or risk`, `your modifications being lost. We also recommend you not to read`, `it either without using the @yarnpkg/pnp package, as the data layout`, `is entirely unspecified and WILL change from a version to another.`],
    dependencyTreeRoots: settings.dependencyTreeRoots,
    enableTopLevelFallback: settings.enableTopLevelFallback || false,
    ignorePatternData: settings.ignorePattern || null,
    fallbackExclusionList: generateFallbackExclusionList(settings),
    fallbackPool: generateFallbackPoolData(settings),
    locationBlacklistData: generateLocationBlacklistData(settings),
    packageRegistryData: generatePackageRegistryData(settings)
  };
}

/***/ }),
/* 692 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hydratePnpFile": () => /* binding */ hydratePnpFile,
/* harmony export */   "hydratePnpSource": () => /* binding */ hydratePnpSource
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _loader_hydrateRuntimeState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(693);
/* harmony import */ var _loader_makeApi__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(694);





const readFileP = (0,util__WEBPACK_IMPORTED_MODULE_2__.promisify)(fs__WEBPACK_IMPORTED_MODULE_0__.readFile); // Note that using those functions is typically NOT needed! The PnP API is
// designed to be consumed directly from within Node - meaning that depending
// on your situation you probably should use one of those two alternatives
// instead:
//
//   - If your script is executing within a PnP environment, you'll be able to
//     simply `require("pnpapi")` in order to get a reference to the running
//     API. You can also simply check whether you're actually running within a
//     PnP environment by checking `process.versions.pnp`.
//
//   - Or if you're not running within a PnP environment, or wish to interact
//     with a different one than the current one, then you can directly require
//     its `.pnp.js` file.
//
// The function exported in this file only work when the PnP data are kept
// outside of the loader (pnpEnableInlining = false in Yarn), and their only
// real use case is to access the PnP API without running the risk of executing
// third-party Javascript code.

async function hydratePnpFile(location, {
  fakeFs,
  pnpapiResolution
}) {
  const source = await readFileP(location, `utf8`);
  return hydratePnpSource(source, {
    basePath: (0,path__WEBPACK_IMPORTED_MODULE_1__.dirname)(location),
    fakeFs,
    pnpapiResolution
  });
}
function hydratePnpSource(source, {
  basePath,
  fakeFs,
  pnpapiResolution
}) {
  const data = JSON.parse(source);
  const runtimeState = (0,_loader_hydrateRuntimeState__WEBPACK_IMPORTED_MODULE_3__.hydrateRuntimeState)(data, {
    basePath
  });
  return (0,_loader_makeApi__WEBPACK_IMPORTED_MODULE_4__.makeApi)(runtimeState, {
    compatibilityMode: true,
    fakeFs,
    pnpapiResolution
  });
}

/***/ }),
/* 693 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hydrateRuntimeState": () => /* binding */ hydrateRuntimeState
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(162);

function hydrateRuntimeState(data, {
  basePath
}) {
  const portablePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.toPortablePath(basePath);
  const absolutePortablePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.resolve(portablePath);
  const ignorePattern = data.ignorePatternData !== null ? new RegExp(data.ignorePatternData) : null;
  const packageRegistry = new Map(data.packageRegistryData.map(([packageName, packageStoreData]) => {
    return [packageName, new Map(packageStoreData.map(([packageReference, packageInformationData]) => {
      return [packageReference, {
        // We use ppath.join instead of ppath.resolve because:
        // 1) packageInformationData.packageLocation is a relative path when part of the SerializedState
        // 2) ppath.join preserves trailing slashes
        packageLocation: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.join(absolutePortablePath, packageInformationData.packageLocation),
        packageDependencies: new Map(packageInformationData.packageDependencies),
        packagePeers: new Set(packageInformationData.packagePeers),
        linkType: packageInformationData.linkType,
        discardFromLookup: packageInformationData.discardFromLookup || false
      }];
    }))];
  }));
  const packageLocatorsByLocations = new Map();
  const packageLocationLengths = new Set();

  for (const [packageName, storeData] of data.packageRegistryData) {
    for (const [packageReference, packageInformationData] of storeData) {
      if (packageName === null !== (packageReference === null)) throw new Error(`Assertion failed: The name and reference should be null, or neither should`);
      if (packageInformationData.discardFromLookup) continue; // @ts-expect-error: TypeScript isn't smart enough to understand the type assertion

      const packageLocator = {
        name: packageName,
        reference: packageReference
      };
      packageLocatorsByLocations.set(packageInformationData.packageLocation, packageLocator);
      packageLocationLengths.add(packageInformationData.packageLocation.length);
    }
  }

  for (const location of data.locationBlacklistData) packageLocatorsByLocations.set(location, null);

  const fallbackExclusionList = new Map(data.fallbackExclusionList.map(([packageName, packageReferences]) => {
    return [packageName, new Set(packageReferences)];
  }));
  const fallbackPool = new Map(data.fallbackPool);
  const dependencyTreeRoots = data.dependencyTreeRoots;
  const enableTopLevelFallback = data.enableTopLevelFallback;
  return {
    basePath: portablePath,
    dependencyTreeRoots,
    enableTopLevelFallback,
    fallbackExclusionList,
    fallbackPool,
    ignorePattern,
    packageLocationLengths: [...packageLocationLengths].sort((a, b) => b - a),
    packageLocatorsByLocations,
    packageRegistry
  };
}

/***/ }),
/* 694 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeApi": () => /* binding */ makeApi
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(175);
/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(226);
/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(module__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _internalTools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(695);




function makeApi(runtimeState, opts) {
  const alwaysWarnOnFallback = Number(process.env.PNP_ALWAYS_WARN_ON_FALLBACK) > 0;
  const debugLevel = Number(process.env.PNP_DEBUG_LEVEL); // @ts-expect-error

  const builtinModules = new Set(module__WEBPACK_IMPORTED_MODULE_0__.Module.builtinModules || Object.keys(process.binding(`natives`))); // Splits a require request into its components, or return null if the request is a file path

  const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:@[^/]+\/)?[^/]+)\/*(.*|)$/; // Matches if the path starts with a valid path qualifier (./, ../, /)
  // eslint-disable-next-line no-unused-vars

  const isStrictRegExp = /^(\/|\.{1,2}(\/|$))/; // Matches if the path must point to a directory (ie ends with /)

  const isDirRegExp = /\/$/; // We only instantiate one of those so that we can use strict-equal comparisons

  const topLevelLocator = {
    name: null,
    reference: null
  }; // Used for compatibility purposes - cf setupCompatibilityLayer

  const fallbackLocators = []; // To avoid emitting the same warning multiple times

  const emittedWarnings = new Set();
  if (runtimeState.enableTopLevelFallback === true) fallbackLocators.push(topLevelLocator);

  if (opts.compatibilityMode !== false) {
    // ESLint currently doesn't have any portable way for shared configs to
    // specify their own plugins that should be used (cf issue #10125). This
    // will likely get fixed at some point but it'll take time, so in the
    // meantime we'll just add additional fallback entries for common shared
    // configs.
    // Similarly, Gatsby generates files within the `public` folder located
    // within the project, but doesn't pre-resolve the `require` calls to use
    // its own dependencies. Meaning that when PnP see a file from the `public`
    // folder making a require, it thinks that your project forgot to list one
    // of your dependencies.
    for (const name of [`react-scripts`, `gatsby`]) {
      const packageStore = runtimeState.packageRegistry.get(name);

      if (packageStore) {
        for (const reference of packageStore.keys()) {
          if (reference === null) {
            throw new Error(`Assertion failed: This reference shouldn't be null`);
          } else {
            fallbackLocators.push({
              name,
              reference
            });
          }
        }
      }
    }
  }
  /**
   * The setup code will be injected here. The tables listed below are guaranteed to be filled after the call to
   * the $$DYNAMICALLY_GENERATED_CODE function.
   */


  const {
    ignorePattern,
    packageRegistry,
    packageLocatorsByLocations,
    packageLocationLengths
  } = runtimeState;
  /**
   * Allows to print useful logs just be setting a value in the environment
   */

  function makeLogEntry(name, args) {
    return {
      fn: name,
      args,
      error: null,
      result: null
    };
  }

  function maybeLog(name, fn) {
    if (opts.allowDebug === false) return fn;

    if (Number.isFinite(debugLevel)) {
      if (debugLevel >= 2) {
        return (...args) => {
          const logEntry = makeLogEntry(name, args);

          try {
            return logEntry.result = fn(...args);
          } catch (error) {
            throw logEntry.error = error;
          } finally {
            console.trace(logEntry);
          }
        };
      } else if (debugLevel >= 1) {
        return (...args) => {
          try {
            return fn(...args);
          } catch (error) {
            const logEntry = makeLogEntry(name, args);
            logEntry.error = error;
            console.trace(logEntry);
            throw error;
          }
        };
      }
    }

    return fn;
  }
  /**
   * Returns information about a package in a safe way (will throw if they cannot be retrieved)
   */


  function getPackageInformationSafe(packageLocator) {
    const packageInformation = getPackageInformation(packageLocator);

    if (!packageInformation) {
      throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.INTERNAL, `Couldn't find a matching entry in the dependency tree for the specified parent (this is probably an internal error)`);
    }

    return packageInformation;
  }
  /**
   * Returns whether the specified locator is a dependency tree root (in which case it's part of the project) or not
   */


  function isDependencyTreeRoot(packageLocator) {
    if (packageLocator.name === null) return true;

    for (const dependencyTreeRoot of runtimeState.dependencyTreeRoots) if (dependencyTreeRoot.name === packageLocator.name && dependencyTreeRoot.reference === packageLocator.reference) return true;

    return false;
  }
  /**
   * Implements the node resolution for folder access and extension selection
   */


  function applyNodeExtensionResolution(unqualifiedPath, candidates, {
    extensions
  }) {
    let stat;

    try {
      candidates.push(unqualifiedPath);
      stat = opts.fakeFs.statSync(unqualifiedPath);
    } catch (error) {} // If the file exists and is a file, we can stop right there


    if (stat && !stat.isDirectory()) return opts.fakeFs.realpathSync(unqualifiedPath); // If the file is a directory, we must check if it contains a package.json with a "main" entry

    if (stat && stat.isDirectory()) {
      let pkgJson;

      try {
        pkgJson = JSON.parse(opts.fakeFs.readFileSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(unqualifiedPath, `package.json`), `utf8`));
      } catch (error) {}

      let nextUnqualifiedPath;
      if (pkgJson && pkgJson.main) nextUnqualifiedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(unqualifiedPath, pkgJson.main); // If the "main" field changed the path, we start again from this new location

      if (nextUnqualifiedPath && nextUnqualifiedPath !== unqualifiedPath) {
        const resolution = applyNodeExtensionResolution(nextUnqualifiedPath, candidates, {
          extensions
        });

        if (resolution !== null) {
          return resolution;
        }
      }
    } // Otherwise we check if we find a file that match one of the supported extensions


    for (let i = 0, length = extensions.length; i < length; i++) {
      const candidateFile = `${unqualifiedPath}${extensions[i]}`;
      candidates.push(candidateFile);

      if (opts.fakeFs.existsSync(candidateFile)) {
        return candidateFile;
      }
    } // Otherwise, we check if the path is a folder - in such a case, we try to use its index


    if (stat && stat.isDirectory()) {
      for (let i = 0, length = extensions.length; i < length; i++) {
        const candidateFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.format({
          dir: unqualifiedPath,
          name: `index`,
          ext: extensions[i]
        });
        candidates.push(candidateFile);

        if (opts.fakeFs.existsSync(candidateFile)) {
          return candidateFile;
        }
      }
    } // Otherwise there's nothing else we can do :(


    return null;
  }
  /**
   * This function creates fake modules that can be used with the _resolveFilename function.
   * Ideally it would be nice to be able to avoid this, since it causes useless allocations
   * and cannot be cached efficiently (we recompute the nodeModulePaths every time).
   *
   * Fortunately, this should only affect the fallback, and there hopefully shouldn't have a
   * lot of them.
   */


  function makeFakeModule(path) {
    // @ts-expect-error
    const fakeModule = new module__WEBPACK_IMPORTED_MODULE_0__.Module(path, null);
    fakeModule.filename = path;
    fakeModule.paths = module__WEBPACK_IMPORTED_MODULE_0__.Module._nodeModulePaths(path);
    return fakeModule;
  }
  /**
   * Normalize path to posix format.
   */


  function normalizePath(p) {
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(p);
  }
  /**
   * Forward the resolution to the next resolver (usually the native one)
   */


  function callNativeResolution(request, issuer) {
    if (issuer.endsWith(`/`)) issuer = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(issuer, `internal.js`); // Since we would need to create a fake module anyway (to call _resolveLookupPath that
    // would give us the paths to give to _resolveFilename), we can as well not use
    // the {paths} option at all, since it internally makes _resolveFilename create another
    // fake module anyway.

    return module__WEBPACK_IMPORTED_MODULE_0__.Module._resolveFilename(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(request), makeFakeModule(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(issuer)), false, {
      plugnplay: false
    });
  }
  /**
   *
   */


  function isPathIgnored(path) {
    if (ignorePattern === null) return false;
    const subPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.contains(runtimeState.basePath, path);
    if (subPath === null) return false;

    if (ignorePattern.test(subPath.replace(/\/$/, ``))) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * This key indicates which version of the standard is implemented by this resolver. The `std` key is the
   * Plug'n'Play standard, and any other key are third-party extensions. Third-party extensions are not allowed
   * to override the standard, and can only offer new methods.
   *
   * If a new version of the Plug'n'Play standard is released and some extensions conflict with newly added
   * functions, they'll just have to fix the conflicts and bump their own version number.
   */


  const VERSIONS = {
    std: 3,
    resolveVirtual: 1,
    getAllLocators: 1
  };
  /**
   * We export a special symbol for easy access to the top level locator.
   */

  const topLevel = topLevelLocator;
  /**
   * Gets the package information for a given locator. Returns null if they cannot be retrieved.
   */

  function getPackageInformation({
    name,
    reference
  }) {
    const packageInformationStore = packageRegistry.get(name);
    if (!packageInformationStore) return null;
    const packageInformation = packageInformationStore.get(reference);
    if (!packageInformation) return null;
    return packageInformation;
  }
  /**
   * Find all packages that depend on the specified one.
   *
   * Note: This is a private function; we expect consumers to implement it
   * themselves. We keep it that way because this implementation isn't
   * optimized at all, since we only need it when printing errors.
   */


  function findPackageDependents({
    name,
    reference
  }) {
    const dependents = [];

    for (const [dependentName, packageInformationStore] of packageRegistry) {
      if (dependentName === null) continue;

      for (const [dependentReference, packageInformation] of packageInformationStore) {
        if (dependentReference === null) continue;
        const dependencyReference = packageInformation.packageDependencies.get(name);
        if (dependencyReference !== reference) continue; // Don't forget that all packages depend on themselves

        if (dependentName === name && dependentReference === reference) continue;
        dependents.push({
          name: dependentName,
          reference: dependentReference
        });
      }
    }

    return dependents;
  }
  /**
   * Find all packages that broke the peer dependency on X, starting from Y.
   *
   * Note: This is a private function; we expect consumers to implement it
   * themselves. We keep it that way because this implementation isn't
   * optimized at all, since we only need it when printing errors.
   */


  function findBrokenPeerDependencies(dependency, initialPackage) {
    const brokenPackages = new Map();
    const alreadyVisited = new Set();

    const traversal = currentPackage => {
      const identifier = JSON.stringify(currentPackage.name);
      if (alreadyVisited.has(identifier)) return;
      alreadyVisited.add(identifier);
      const dependents = findPackageDependents(currentPackage);

      for (const dependent of dependents) {
        const dependentInformation = getPackageInformationSafe(dependent);

        if (dependentInformation.packagePeers.has(dependency)) {
          traversal(dependent);
        } else {
          let brokenSet = brokenPackages.get(dependent.name);
          if (typeof brokenSet === `undefined`) brokenPackages.set(dependent.name, brokenSet = new Set());
          brokenSet.add(dependent.reference);
        }
      }
    };

    traversal(initialPackage);
    const brokenList = [];

    for (const name of [...brokenPackages.keys()].sort()) for (const reference of [...brokenPackages.get(name)].sort()) brokenList.push({
      name,
      reference
    });

    return brokenList;
  }
  /**
   * Finds the package locator that owns the specified path. If none is found, returns null instead.
   */


  function findPackageLocator(location) {
    if (isPathIgnored(location)) return null;
    let relativeLocation = normalizePath(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.relative(runtimeState.basePath, location));
    if (!relativeLocation.match(isStrictRegExp)) relativeLocation = `./${relativeLocation}`;
    if (location.match(isDirRegExp) && !relativeLocation.endsWith(`/`)) relativeLocation = `${relativeLocation}/`;
    let from = 0; // If someone wants to use a binary search to go from O(n) to O(log n), be my guest

    while (from < packageLocationLengths.length && packageLocationLengths[from] > relativeLocation.length) from += 1;

    for (let t = from; t < packageLocationLengths.length; ++t) {
      const locator = packageLocatorsByLocations.get(relativeLocation.substr(0, packageLocationLengths[t]));
      if (typeof locator === `undefined`) continue; // Ensures that the returned locator isn't a blacklisted one.
      //
      // Blacklisted packages are packages that cannot be used because their dependencies cannot be deduced. This only
      // happens with peer dependencies, which effectively have different sets of dependencies depending on their
      // parents.
      //
      // In order to deambiguate those different sets of dependencies, the Yarn implementation of PnP will generate a
      // symlink for each combination of <package name>/<package version>/<dependent package> it will find, and will
      // blacklist the target of those symlinks. By doing this, we ensure that files loaded through a specific path
      // will always have the same set of dependencies, provided the symlinks are correctly preserved.
      //
      // Unfortunately, some tools do not preserve them, and when it happens PnP isn't able anymore to deduce the set of
      // dependencies based on the path of the file that makes the require calls. But since we've blacklisted those
      // paths, we're able to print a more helpful error message that points out that a third-party package is doing
      // something incompatible!

      if (locator === null) {
        const locationForDisplay = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(location);
        throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.BLACKLISTED, `A forbidden path has been used in the package resolution process - this is usually caused by one of your tools calling 'fs.realpath' on the return value of 'require.resolve'. Since we need to use symlinks to simultaneously provide valid filesystem paths and disambiguate peer dependencies, they must be passed untransformed to 'require'.\n\nForbidden path: ${locationForDisplay}`, {
          location: locationForDisplay
        });
      }

      return locator;
    }

    return null;
  }
  /**
   * Transforms a request (what's typically passed as argument to the require function) into an unqualified path.
   * This path is called "unqualified" because it only changes the package name to the package location on the disk,
   * which means that the end result still cannot be directly accessed (for example, it doesn't try to resolve the
   * file extension, or to resolve directories to their "index.js" content). Use the "resolveUnqualified" function
   * to convert them to fully-qualified paths, or just use "resolveRequest" that do both operations in one go.
   *
   * Note that it is extremely important that the `issuer` path ends with a forward slash if the issuer is to be
   * treated as a folder (ie. "/tmp/foo/" rather than "/tmp/foo" if "foo" is a directory). Otherwise relative
   * imports won't be computed correctly (they'll get resolved relative to "/tmp/" instead of "/tmp/foo/").
   */


  function resolveToUnqualified(request, issuer, {
    considerBuiltins = true
  } = {}) {
    // The 'pnpapi' request is reserved and will always return the path to the PnP file, from everywhere
    if (request === `pnpapi`) return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(opts.pnpapiResolution); // Bailout if the request is a native module

    if (considerBuiltins && builtinModules.has(request)) return null;
    const requestForDisplay = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(request);
    const issuerForDisplay = issuer && (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(issuer); // We allow disabling the pnp resolution for some subpaths.
    // This is because some projects, often legacy, contain multiple
    // levels of dependencies (ie. a yarn.lock inside a subfolder of
    // a yarn.lock). This is typically solved using workspaces, but
    // not all of them have been converted already.

    if (issuer && isPathIgnored(issuer)) {
      // Absolute paths that seem to belong to a PnP tree are still
      // handled by our runtime even if the issuer isn't. This is
      // because the native Node resolution uses a special version
      // of the `stat` syscall which would otherwise bypass the
      // filesystem layer we require to access the files.
      if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(request) || findPackageLocator(request) === null) {
        const result = callNativeResolution(request, issuer);

        if (result === false) {
          throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer was explicitely ignored by the regexp)\n\nRequire request: "${requestForDisplay}"\nRequired by: ${issuerForDisplay}\n`, {
            request: requestForDisplay,
            issuer: issuerForDisplay
          });
        }

        return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(result);
      }
    }

    let unqualifiedPath; // If the request is a relative or absolute path, we just return it normalized

    const dependencyNameMatch = request.match(pathRegExp);

    if (!dependencyNameMatch) {
      if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(request)) {
        unqualifiedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(request);
      } else {
        if (!issuer) {
          throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.API_ERROR, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {
            request: requestForDisplay,
            issuer: issuerForDisplay
          });
        } // We use ppath.join instead of ppath.resolve because:
        // 1) The request is a relative path in this branch
        // 2) ppath.join preserves trailing slashes


        const absoluteIssuer = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(issuer);

        if (issuer.match(isDirRegExp)) {
          unqualifiedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(absoluteIssuer, request));
        } else {
          unqualifiedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(absoluteIssuer), request));
        }
      } // No need to use the return value; we just want to check the blacklist status


      findPackageLocator(unqualifiedPath);
    } // Things are more hairy if it's a package require - we then need to figure out which package is needed, and in
    // particular the exact version for the given location on the dependency tree
    else {
        if (!issuer) {
          throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.API_ERROR, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {
            request: requestForDisplay,
            issuer: issuerForDisplay
          });
        }

        const [, dependencyName, subPath] = dependencyNameMatch;
        const issuerLocator = findPackageLocator(issuer); // If the issuer file doesn't seem to be owned by a package managed through pnp, then we resort to using the next
        // resolution algorithm in the chain, usually the native Node resolution one

        if (!issuerLocator) {
          const result = callNativeResolution(request, issuer);

          if (result === false) {
            throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer doesn't seem to be part of the Yarn-managed dependency tree).\n\nRequire path: "${requestForDisplay}"\nRequired by: ${issuerForDisplay}\n`, {
              request: requestForDisplay,
              issuer: issuerForDisplay
            });
          }

          return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(result);
        }

        const issuerInformation = getPackageInformationSafe(issuerLocator); // We obtain the dependency reference in regard to the package that request it

        let dependencyReference = issuerInformation.packageDependencies.get(dependencyName);
        let fallbackReference = null; // If we can't find it, we check if we can potentially load it from the packages that have been defined as potential fallbacks.
        // It's a bit of a hack, but it improves compatibility with the existing Node ecosystem. Hopefully we should eventually be able
        // to kill this logic and become stricter once pnp gets enough traction and the affected packages fix themselves.

        if (dependencyReference == null) {
          if (issuerLocator.name !== null) {
            // To allow programs to become gradually stricter, starting from the v2 we enforce that workspaces cannot depend on fallbacks.
            // This works by having a list containing all their locators, and checking when a fallback is required whether it's one of them.
            const exclusionEntry = runtimeState.fallbackExclusionList.get(issuerLocator.name);
            const canUseFallbacks = !exclusionEntry || !exclusionEntry.has(issuerLocator.reference);

            if (canUseFallbacks) {
              for (let t = 0, T = fallbackLocators.length; t < T; ++t) {
                const fallbackInformation = getPackageInformationSafe(fallbackLocators[t]);
                const reference = fallbackInformation.packageDependencies.get(dependencyName);
                if (reference == null) continue;
                if (alwaysWarnOnFallback) fallbackReference = reference;else dependencyReference = reference;
                break;
              }

              if (runtimeState.enableTopLevelFallback) {
                if (dependencyReference == null && fallbackReference === null) {
                  const reference = runtimeState.fallbackPool.get(dependencyName);

                  if (reference != null) {
                    fallbackReference = reference;
                  }
                }
              }
            }
          }
        } // If we can't find the path, and if the package making the request is the top-level, we can offer nicer error messages


        let error = null;

        if (dependencyReference === null) {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.MISSING_PEER_DEPENDENCY, `Your application tried to access ${dependencyName} (a peer dependency); this isn't allowed as there is no ancestor to satisfy the requirement. Use a devDependency if needed.\n\nRequired package: ${dependencyName} (via "${requestForDisplay}")\nRequired by: ${issuerForDisplay}\n`, {
              request: requestForDisplay,
              issuer: issuerForDisplay,
              dependencyName
            });
          } else {
            const brokenAncestors = findBrokenPeerDependencies(dependencyName, issuerLocator);

            if (brokenAncestors.every(ancestor => isDependencyTreeRoot(ancestor))) {
              error = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.MISSING_PEER_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by your application; this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName} (via "${requestForDisplay}")\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})\n${brokenAncestors.map(ancestorLocator => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}\n`).join(``)}\n`, {
                request: requestForDisplay,
                issuer: issuerForDisplay,
                issuerLocator: Object.assign({}, issuerLocator),
                dependencyName,
                brokenAncestors
              });
            } else {
              error = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.MISSING_PEER_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by its ancestors; this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName} (via "${requestForDisplay}")\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})\n${brokenAncestors.map(ancestorLocator => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}\n`).join(``)}\n`, {
                request: requestForDisplay,
                issuer: issuerForDisplay,
                issuerLocator: Object.assign({}, issuerLocator),
                dependencyName,
                brokenAncestors
              });
            }
          }
        } else if (dependencyReference === undefined) {
          if (!considerBuiltins && builtinModules.has(request)) {
            if (isDependencyTreeRoot(issuerLocator)) {
              error = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.UNDECLARED_DEPENDENCY, `Your application tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in your dependencies, this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName} (via "${requestForDisplay}")\nRequired by: ${issuerForDisplay}\n`, {
                request: requestForDisplay,
                issuer: issuerForDisplay,
                dependencyName
              });
            } else {
              error = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.UNDECLARED_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in ${issuerLocator.name}'s dependencies, this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName} (via "${requestForDisplay}")\nRequired by: ${issuerForDisplay}\n`, {
                request: requestForDisplay,
                issuer: issuerForDisplay,
                issuerLocator: Object.assign({}, issuerLocator),
                dependencyName
              });
            }
          } else {
            if (isDependencyTreeRoot(issuerLocator)) {
              error = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.UNDECLARED_DEPENDENCY, `Your application tried to access ${dependencyName}, but it isn't declared in your dependencies; this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName} (via "${requestForDisplay}")\nRequired by: ${issuerForDisplay}\n`, {
                request: requestForDisplay,
                issuer: issuerForDisplay,
                dependencyName
              });
            } else {
              error = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.UNDECLARED_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName}, but it isn't declared in its dependencies; this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName} (via "${requestForDisplay}")\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})\n`, {
                request: requestForDisplay,
                issuer: issuerForDisplay,
                issuerLocator: Object.assign({}, issuerLocator),
                dependencyName
              });
            }
          }
        }

        if (dependencyReference == null) {
          if (fallbackReference === null || error === null) throw error || new Error(`Assertion failed: Expected an error to have been set`);
          dependencyReference = fallbackReference;
          const message = error.message.replace(/\n.*/g, ``);
          error.message = message;

          if (!emittedWarnings.has(message)) {
            emittedWarnings.add(message);
            process.emitWarning(error);
          }
        } // We need to check that the package exists on the filesystem, because it might not have been installed


        const dependencyLocator = Array.isArray(dependencyReference) ? {
          name: dependencyReference[0],
          reference: dependencyReference[1]
        } : {
          name: dependencyName,
          reference: dependencyReference
        };
        const dependencyInformation = getPackageInformationSafe(dependencyLocator);

        if (!dependencyInformation.packageLocation) {
          throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.MISSING_DEPENDENCY, `A dependency seems valid but didn't get installed for some reason. This might be caused by a partial install, such as dev vs prod.\n\nRequired package: ${dependencyLocator.name}@${dependencyLocator.reference} (via "${requestForDisplay}")\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})\n`, {
            request: requestForDisplay,
            issuer: issuerForDisplay,
            dependencyLocator: Object.assign({}, dependencyLocator)
          });
        } // Now that we know which package we should resolve to, we only have to find out the file location
        // packageLocation is always absolute as it's returned by getPackageInformationSafe


        const dependencyLocation = dependencyInformation.packageLocation;

        if (subPath) {
          // We use ppath.join instead of ppath.resolve because:
          // 1) subPath is always a relative path
          // 2) ppath.join preserves trailing slashes
          unqualifiedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(dependencyLocation, subPath);
        } else {
          unqualifiedPath = dependencyLocation;
        }
      }

    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(unqualifiedPath);
  }
  /**
   * Transforms an unqualified path into a qualified path by using the Node resolution algorithm (which automatically
   * appends ".js" / ".json", and transforms directory accesses into "index.js").
   */


  function resolveUnqualified(unqualifiedPath, {
    extensions = Object.keys(module__WEBPACK_IMPORTED_MODULE_0__.Module._extensions)
  } = {}) {
    const candidates = [];
    const qualifiedPath = applyNodeExtensionResolution(unqualifiedPath, candidates, {
      extensions
    });

    if (qualifiedPath) {
      return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(qualifiedPath);
    } else {
      const unqualifiedPathForDisplay = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(unqualifiedPath);
      throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `Qualified path resolution failed - none of the candidates can be found on the disk.\n\nSource path: ${unqualifiedPathForDisplay}\n${candidates.map(candidate => `Rejected candidate: ${(0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(candidate)}\n`).join(``)}`, {
        unqualifiedPath: unqualifiedPathForDisplay
      });
    }
  }
  /**
   * Transforms a request into a fully qualified path.
   *
   * Note that it is extremely important that the `issuer` path ends with a forward slash if the issuer is to be
   * treated as a folder (ie. "/tmp/foo/" rather than "/tmp/foo" if "foo" is a directory). Otherwise relative
   * imports won't be computed correctly (they'll get resolved relative to "/tmp/" instead of "/tmp/foo/").
   */


  function resolveRequest(request, issuer, {
    considerBuiltins,
    extensions
  } = {}) {
    const unqualifiedPath = resolveToUnqualified(request, issuer, {
      considerBuiltins
    });
    if (unqualifiedPath === null) return null;

    try {
      return resolveUnqualified(unqualifiedPath, {
        extensions
      });
    } catch (resolutionError) {
      if (resolutionError.pnpCode === `QUALIFIED_PATH_RESOLUTION_FAILED`) Object.assign(resolutionError.data, {
        request: (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(request),
        issuer: issuer && (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(issuer)
      });
      throw resolutionError;
    }
  }

  function resolveVirtual(request) {
    const normalized = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(request);
    const resolved = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.VirtualFS.resolveVirtual(normalized);
    return resolved !== normalized ? resolved : null;
  }

  return {
    VERSIONS,
    topLevel,
    getLocator: (name, referencish) => {
      if (Array.isArray(referencish)) {
        return {
          name: referencish[0],
          reference: referencish[1]
        };
      } else {
        return {
          name,
          reference: referencish
        };
      }
    },
    getDependencyTreeRoots: () => {
      return [...runtimeState.dependencyTreeRoots];
    },

    getAllLocators() {
      const locators = [];

      for (const [name, entry] of packageRegistry) for (const reference of entry.keys()) if (name !== null && reference !== null) locators.push({
        name,
        reference
      });

      return locators;
    },

    getPackageInformation: locator => {
      const info = getPackageInformation(locator);
      if (info === null) return null;
      const packageLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(info.packageLocation);
      const nativeInfo = { ...info,
        packageLocation
      };
      return nativeInfo;
    },
    findPackageLocator: path => {
      return findPackageLocator(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path));
    },
    resolveToUnqualified: maybeLog(`resolveToUnqualified`, (request, issuer, opts) => {
      const portableIssuer = issuer !== null ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(issuer) : null;
      const resolution = resolveToUnqualified(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(request), portableIssuer, opts);
      if (resolution === null) return null;
      return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(resolution);
    }),
    resolveUnqualified: maybeLog(`resolveUnqualified`, (unqualifiedPath, opts) => {
      return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(resolveUnqualified(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(unqualifiedPath), opts));
    }),
    resolveRequest: maybeLog(`resolveRequest`, (request, issuer, opts) => {
      const portableIssuer = issuer !== null ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(issuer) : null;
      const resolution = resolveRequest(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(request), portableIssuer, opts);
      if (resolution === null) return null;
      return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(resolution);
    }),
    resolveVirtual: maybeLog(`resolveVirtual`, path => {
      const result = resolveVirtual(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path));

      if (result !== null) {
        return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(result);
      } else {
        return null;
      }
    })
  };
}

/***/ }),
/* 695 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorCode": () => /* binding */ ErrorCode,
/* harmony export */   "makeError": () => /* binding */ makeError,
/* harmony export */   "getIssuerModule": () => /* binding */ getIssuerModule,
/* harmony export */   "getPathForDisplay": () => /* binding */ getPathForDisplay
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(162);

var ErrorCode;

(function (ErrorCode) {
  ErrorCode["API_ERROR"] = "API_ERROR";
  ErrorCode["BLACKLISTED"] = "BLACKLISTED";
  ErrorCode["BUILTIN_NODE_RESOLUTION_FAILED"] = "BUILTIN_NODE_RESOLUTION_FAILED";
  ErrorCode["MISSING_DEPENDENCY"] = "MISSING_DEPENDENCY";
  ErrorCode["MISSING_PEER_DEPENDENCY"] = "MISSING_PEER_DEPENDENCY";
  ErrorCode["QUALIFIED_PATH_RESOLUTION_FAILED"] = "QUALIFIED_PATH_RESOLUTION_FAILED";
  ErrorCode["INTERNAL"] = "INTERNAL";
  ErrorCode["UNDECLARED_DEPENDENCY"] = "UNDECLARED_DEPENDENCY";
  ErrorCode["UNSUPPORTED"] = "UNSUPPORTED";
})(ErrorCode || (ErrorCode = {})); // Some errors are exposed as MODULE_NOT_FOUND for compatibility with packages
// that expect this umbrella error when the resolution fails


const MODULE_NOT_FOUND_ERRORS = new Set([ErrorCode.BLACKLISTED, ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, ErrorCode.MISSING_DEPENDENCY, ErrorCode.MISSING_PEER_DEPENDENCY, ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, ErrorCode.UNDECLARED_DEPENDENCY]);
/**
 * Simple helper function that assign an error code to an error, so that it can more easily be caught and used
 * by third-parties.
 */

function makeError(pnpCode, message, data = {}) {
  const code = MODULE_NOT_FOUND_ERRORS.has(pnpCode) ? `MODULE_NOT_FOUND` : pnpCode;
  const propertySpec = {
    configurable: true,
    writable: true,
    enumerable: false
  };
  return Object.defineProperties(new Error(message), {
    code: { ...propertySpec,
      value: code
    },
    pnpCode: { ...propertySpec,
      value: pnpCode
    },
    data: { ...propertySpec,
      value: data
    }
  });
}
/**
 * Returns the module that should be used to resolve require calls. It's usually the direct parent, except if we're
 * inside an eval expression.
 */

function getIssuerModule(parent) {
  let issuer = parent;

  while (issuer && (issuer.id === `[eval]` || issuer.id === `<repl>` || !issuer.filename)) issuer = issuer.parent;

  return issuer || null;
}
function getPathForDisplay(p) {
  return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.normalize(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.fromPortablePath(p));
}

/***/ }),
/* 696 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeRuntimeApi": () => /* binding */ makeRuntimeApi
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var _generateSerializedState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(691);
/* harmony import */ var _loader_hydrateRuntimeState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(693);
/* harmony import */ var _loader_makeApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(694);




const makeRuntimeApi = (settings, basePath, fakeFs) => {
  const data = (0,_generateSerializedState__WEBPACK_IMPORTED_MODULE_2__.generateSerializedState)(settings);
  const state = (0,_loader_hydrateRuntimeState__WEBPACK_IMPORTED_MODULE_0__.hydrateRuntimeState)(data, {
    basePath
  });
  const pnpapiResolution = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.join(basePath, `.pnp.js`);
  return (0,_loader_makeApi__WEBPACK_IMPORTED_MODULE_1__.makeApi)(state, {
    fakeFs,
    pnpapiResolution
  });
};

/***/ }),
/* 697 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkAndReportManifestCompatibility": () => /* binding */ checkAndReportManifestCompatibility,
/* harmony export */   "extractBuildScripts": () => /* binding */ extractBuildScripts,
/* harmony export */   "getExtractHint": () => /* binding */ getExtractHint,
/* harmony export */   "hasBindingGyp": () => /* binding */ hasBindingGyp
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(339);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(179);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(162);


function checkAndReportManifestCompatibility(pkg, requirements, label, {
  configuration,
  report
}) {
  if (!_yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.Manifest.isManifestFieldCompatible(requirements.manifest.os, process.platform)) {
    report === null || report === void 0 ? void 0 : report.reportWarningOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.MessageName.INCOMPATIBLE_OS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.prettyLocator(configuration, pkg)} The platform ${process.platform} is incompatible with this module, ${label} skipped.`);
    return false;
  }

  if (!_yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.Manifest.isManifestFieldCompatible(requirements.manifest.cpu, process.arch)) {
    report === null || report === void 0 ? void 0 : report.reportWarningOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.MessageName.INCOMPATIBLE_CPU, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.prettyLocator(configuration, pkg)} The CPU architecture ${process.arch} is incompatible with this module, ${label} skipped.`);
    return false;
  }

  return true;
}
function extractBuildScripts(pkg, requirements, dependencyMeta, {
  configuration,
  report
}) {
  const buildScripts = [];

  for (const scriptName of [`preinstall`, `install`, `postinstall`]) if (requirements.manifest.scripts.has(scriptName)) buildScripts.push([_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.BuildType.SCRIPT, scriptName]); // Detect cases where a package has a binding.gyp but no install script


  if (!requirements.manifest.scripts.has(`install`) && requirements.misc.hasBindingGyp) buildScripts.push([_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.BuildType.SHELLCODE, `node-gyp rebuild`]);
  if (buildScripts.length === 0) return [];

  if (!configuration.get(`enableScripts`) && !dependencyMeta.built) {
    report === null || report === void 0 ? void 0 : report.reportWarningOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.MessageName.DISABLED_BUILD_SCRIPTS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.prettyLocator(configuration, pkg)} lists build scripts, but all build scripts have been disabled.`);
    return [];
  }

  if (pkg.linkType !== _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.LinkType.HARD) {
    report === null || report === void 0 ? void 0 : report.reportWarningOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.MessageName.SOFT_LINK_BUILD, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.prettyLocator(configuration, pkg)} lists build scripts, but is referenced through a soft link. Soft links don't support build scripts, so they'll be ignored.`);
    return [];
  }

  if (dependencyMeta && dependencyMeta.built === false) {
    report === null || report === void 0 ? void 0 : report.reportInfoOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.MessageName.BUILD_DISABLED, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.prettyLocator(configuration, pkg)} lists build scripts, but its build has been explicitly disabled through configuration.`);
    return [];
  }

  const isManifestCompatible = checkAndReportManifestCompatibility(pkg, requirements, `build`, {
    configuration,
    report
  });
  if (!isManifestCompatible) return [];
  return buildScripts;
}
const FORCED_EXTRACT_FILETYPES = new Set([// Windows can't execute exe files inside zip archives
`.exe`, // The c/c++ compiler can't read files from zip archives
`.h`, `.hh`, `.hpp`, `.c`, `.cc`, `.cpp`, // The java runtime can't read files from zip archives
`.java`, `.jar`, // Node opens these through dlopen
`.node`]);
function getExtractHint(fetchResult) {
  return fetchResult.packageFs.getExtractHint({
    relevantExtensions: FORCED_EXTRACT_FILETYPES
  });
}
function hasBindingGyp(fetchResult) {
  const bindingFilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(fetchResult.prefixPath, `binding.gyp`);
  return fetchResult.packageFs.existsSync(bindingFilePath);
}

/***/ }),
/* 698 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getUnpluggedPath": () => /* binding */ getUnpluggedPath
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(162);


function getUnpluggedPath(locator, {
  configuration
}) {
  return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.resolve(configuration.get(`pnpUnpluggedFolder`), _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.slugifyLocator(locator));
}

/***/ }),
/* 699 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ UnplugCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(231);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _pnpUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(698);







 // eslint-disable-next-line arca/no-default-export

class UnplugCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.patterns = [];
    this.all = false;
    this.recursive = false;
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    if (configuration.get(`nodeLinker`) !== `pnp`) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`This command can only be used if the \`nodeLinker\` option is set to \`pnp\``);
    await project.restoreInstallState();
    const unreferencedPatterns = new Set(this.patterns);
    const matchers = this.patterns.map(pattern => {
      const patternDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.parseDescriptor(pattern);
      const pseudoDescriptor = patternDescriptor.range !== `unknown` ? patternDescriptor : _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.makeDescriptor(patternDescriptor, `*`);
      if (!semver__WEBPACK_IMPORTED_MODULE_3___default().validRange(pseudoDescriptor.range)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The range of the descriptor patterns must be a valid semver range (${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.prettyDescriptor(configuration, pseudoDescriptor)})`);
      return pkg => {
        const stringifiedIdent = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.stringifyIdent(pkg);
        if (!micromatch__WEBPACK_IMPORTED_MODULE_2___default().isMatch(stringifiedIdent, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.stringifyIdent(pseudoDescriptor))) return false;
        if (pkg.version && !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.satisfiesWithPrereleases(pkg.version, pseudoDescriptor.range)) return false;
        unreferencedPatterns.delete(pattern);
        return true;
      };
    });

    const getAllMatchingPackages = () => {
      const selection = [];

      for (const pkg of project.storedPackages.values()) // Note: We can safely skip virtual packages here, as the
      // devirtualized copy will always exist inside storedPackages.
      if (!project.tryWorkspaceByLocator(pkg) && !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.isVirtualLocator(pkg) && matchers.some(matcher => matcher(pkg))) selection.push(pkg);

      return selection;
    };

    const getSelectedPackages = roots => {
      const seen = new Set();
      const selection = [];

      const traverse = (pkg, depth) => {
        if (seen.has(pkg.locatorHash)) return;
        seen.add(pkg.locatorHash); // Note: We shouldn't skip virtual packages, as
        // we don't iterate over the devirtualized copies.

        if (!project.tryWorkspaceByLocator(pkg) && matchers.some(matcher => matcher(pkg))) selection.push(pkg); // Don't recurse unless requested

        if (depth > 0 && !this.recursive) return;

        for (const dependency of pkg.dependencies.values()) {
          const resolution = project.storedResolutions.get(dependency.descriptorHash);
          if (!resolution) throw new Error(`Assertion failed: The resolution should have been registered`);
          const nextPkg = project.storedPackages.get(resolution);
          if (!nextPkg) throw new Error(`Assertion failed: The package should have been registered`);
          traverse(nextPkg, depth + 1);
        }
      };

      for (const workspace of roots) {
        const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
        if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
        traverse(pkg, 0);
      }

      return selection;
    };

    let selection;
    let projectOrWorkspaces; // We can shortcut the execution if we want all the dependencies and
    // transitive dependencies of all the branches: it means we want everything!

    if (this.all && this.recursive) {
      selection = getAllMatchingPackages();
      projectOrWorkspaces = `the project`;
    } else if (this.all) {
      selection = getSelectedPackages(project.workspaces);
      projectOrWorkspaces = `any workspace`;
    } else {
      selection = getSelectedPackages([workspace]);
      projectOrWorkspaces = `this workspace`;
    }

    if (unreferencedPatterns.size > 1) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Patterns ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.prettyList(configuration, unreferencedPatterns, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.CODE)} don't match any packages referenced by ${projectOrWorkspaces}`);
    if (unreferencedPatterns.size > 0) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Pattern ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.prettyList(configuration, unreferencedPatterns, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.CODE)} doesn't match any packages referenced by ${projectOrWorkspaces}`);
    selection = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.sortMap(selection, pkg => {
      return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.stringifyLocator(pkg);
    });
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.StreamReport.start({
      configuration,
      stdout: this.context.stdout,
      json: this.json
    }, async report => {
      var _a;

      for (const pkg of selection) {
        const version = (_a = pkg.version) !== null && _a !== void 0 ? _a : `unknown`;
        const dependencyMeta = project.topLevelWorkspace.manifest.ensureDependencyMeta(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.makeDescriptor(pkg, version));
        dependencyMeta.unplugged = true;
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.MessageName.UNNAMED, `Will unpack ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.prettyLocator(configuration, pkg)} to ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.pretty(configuration, _pnpUtils__WEBPACK_IMPORTED_MODULE_4__.getUnpluggedPath(pkg, {
          configuration
        }), _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Type.PATH)}`);
        report.reportJson({
          locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.stringifyLocator(pkg),
          version
        });
      }

      await project.topLevelWorkspace.persistManifest();
      report.reportSeparator();
      await project.install({
        cache,
        report
      });
    });
    return report.exitCode();
  }

}
UnplugCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `force the unpacking of a list of packages`,
  details: `
      This command will add the selectors matching the specified patterns to the list of packages that must be unplugged when installed.

      A package being unplugged means that instead of being referenced directly through its archive, it will be unpacked at install time in the directory configured via \`pnpUnpluggedFolder\`. Note that unpacking packages this way is generally not recommended because it'll make it harder to store your packages within the repository. However, it's a good approach to quickly and safely debug some packages, and can even sometimes be required depending on the context (for example when the package contains shellscripts).

      Running the command will set a persistent flag inside your top-level \`package.json\`, in the \`dependenciesMeta\` field. As such, to undo its effects, you'll need to revert the changes made to the manifest and run \`yarn install\` to apply the modification.

      By default, only direct dependencies from the current workspace are affected. If \`-A,--all\` is set, direct dependencies from the entire project are affected. Using the \`-R,--recursive\` flag will affect transitive dependencies as well as direct ones.

      This command accepts glob patterns inside the scope and name components (not the range). Make sure to escape the patterns to prevent your own shell from trying to expand them.
    `,
  examples: [[`Unplug the lodash dependency from the active workspace`, `yarn unplug lodash`], [`Unplug all instances of lodash referenced by any workspace`, `yarn unplug lodash -A`], [`Unplug all instances of lodash referenced by the active workspace and its dependencies`, `yarn unplug lodash -R`], [`Unplug all instances of lodash, anywhere`, `yarn unplug lodash -AR`], [`Unplug one specific version of lodash`, `yarn unplug lodash@1.2.3`], [`Unplug all packages with the \`@babel\` scope`, `yarn unplug '@babel/*'`], [`Unplug all packages (only for testing, not recommended)`, `yarn unplug -R '*'`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_14__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Rest()], UnplugCommand.prototype, "patterns", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_14__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-A,--all`, {
  description: `Unplug direct dependencies from the entire project`
})], UnplugCommand.prototype, "all", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_14__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-R,--recursive`, {
  description: `Unplug both direct and transitive dependencies`
})], UnplugCommand.prototype, "recursive", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_14__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], UnplugCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_14__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`unplug`)], UnplugCommand.prototype, "execute", null);

/***/ }),
/* 700 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

cmdShim.ifExists = cmdShimIfExists;
const util_1 = __webpack_require__(90);
const makeDir = __webpack_require__(701);
const path = __webpack_require__(84);
const isWindows = __webpack_require__(703);
const shebangExpr = /^#!\s*(?:\/usr\/bin\/env)?\s*([^ \t]+)(.*)$/;
const DEFAULT_OPTIONS = {
    // Create PowerShell file by default if the option hasn't been specified
    createPwshFile: true,
    createCmdFile: isWindows(),
    fs: __webpack_require__(8)
};
/**
 * Map from extensions of files that this module is frequently used for to their runtime.
 * @type {Map<string, string>}
 */
const extensionToProgramMap = new Map([
    ['.js', 'node'],
    ['.cmd', 'cmd'],
    ['.bat', 'cmd'],
    ['.ps1', 'pwsh'],
    ['.sh', 'sh']
]);
function ingestOptions(opts) {
    const opts_ = { ...DEFAULT_OPTIONS, ...opts };
    const fs = opts_.fs;
    opts_.fs_ = {
        chmod: fs.chmod ? util_1.promisify(fs.chmod) : (async () => { }),
        stat: util_1.promisify(fs.stat),
        unlink: util_1.promisify(fs.unlink),
        readFile: util_1.promisify(fs.readFile),
        writeFile: util_1.promisify(fs.writeFile)
    };
    return opts_;
}
/**
 * Try to create shims.
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims.
 * Don't add an extension if you will create multiple types of shims.
 * @param opts Options.
 * @throws If `src` is missing.
 */
async function cmdShim(src, to, opts) {
    const opts_ = ingestOptions(opts);
    await opts_.fs_.stat(src);
    await cmdShim_(src, to, opts_);
}
/**
 * Try to create shims.
 *
 * Does nothing if `src` doesn't exist.
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims.
 * Don't add an extension if you will create multiple types of shims.
 * @param opts Options.
 */
function cmdShimIfExists(src, to, opts) {
    return cmdShim(src, to, opts).catch(() => { });
}
/**
 * Try to unlink, but ignore errors.
 * Any problems will surface later.
 *
 * @param path File to be removed.
 */
function rm(path, opts) {
    return opts.fs_.unlink(path).catch(() => { });
}
/**
 * Try to create shims **even if `src` is missing**.
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims.
 * Don't add an extension if you will create multiple types of shims.
 * @param opts Options.
 */
async function cmdShim_(src, to, opts) {
    const srcRuntimeInfo = await searchScriptRuntime(src, opts);
    // Always tries to create all types of shims by calling `writeAllShims` as of now.
    // Append your code here to change the behavior in response to `srcRuntimeInfo`.
    // Create 3 shims for (Ba)sh in Cygwin / MSYS, no extension) & CMD (.cmd) & PowerShell (.ps1)
    await writeShimsPreCommon(to, opts);
    return writeAllShims(src, to, srcRuntimeInfo, opts);
}
/**
 * Do processes before **all** shims are created.
 * This must be called **only once** for one call of `cmdShim(IfExists)`.
 *
 * @param target Path of shims that are going to be created.
 */
function writeShimsPreCommon(target, opts) {
    return makeDir(path.dirname(target), { fs: opts.fs });
}
/**
 * Write all types (sh & cmd & pwsh) of shims to files.
 * Extensions (`.cmd` and `.ps1`) are appended to cmd and pwsh shims.
 *
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims **without extensions**.
 * Extensions are added for CMD and PowerShell shims.
 * @param srcRuntimeInfo Return value of `await searchScriptRuntime(src)`.
 * @param opts Options.
 */
function writeAllShims(src, to, srcRuntimeInfo, opts) {
    const opts_ = ingestOptions(opts);
    const generatorAndExts = [{ generator: generateShShim, extension: '' }];
    if (opts_.createCmdFile) {
        generatorAndExts.push({ generator: generateCmdShim, extension: '.cmd' });
    }
    if (opts_.createPwshFile) {
        generatorAndExts.push({ generator: generatePwshShim, extension: '.ps1' });
    }
    return Promise.all(generatorAndExts.map((generatorAndExt) => writeShim(src, to + generatorAndExt.extension, srcRuntimeInfo, generatorAndExt.generator, opts_)));
}
/**
 * Do processes before writing shim.
 *
 * @param target Path to shim that is going to be created.
 */
function writeShimPre(target, opts) {
    return rm(target, opts);
}
/**
 * Do processes after writing the shim.
 *
 * @param target Path to just created shim.
 */
function writeShimPost(target, opts) {
    // Only chmoding shims as of now.
    // Some other processes may be appended.
    return chmodShim(target, opts);
}
/**
 * Look into runtime (e.g. `node` & `sh` & `pwsh`) and its arguments
 * of the target program (script or executable).
 *
 * @param target Path to the executable or script.
 * @return Promise of infomation of runtime of `target`.
 */
async function searchScriptRuntime(target, opts) {
    const data = await opts.fs_.readFile(target, 'utf8');
    // First, check if the bin is a #! of some sort.
    const firstLine = data.trim().split(/\r*\n/)[0];
    const shebang = firstLine.match(shebangExpr);
    if (!shebang) {
        // If not, infer script type from its extension.
        // If the inference fails, it's something that'll be compiled, or some other
        // sort of script, and just call it directly.
        const targetExtension = path.extname(target).toLowerCase();
        return {
            // undefined if extension is unknown but it's converted to null.
            program: extensionToProgramMap.get(targetExtension) || null,
            additionalArgs: ''
        };
    }
    return {
        program: shebang[1],
        additionalArgs: shebang[2]
    };
}
/**
 * Write shim to the file system while executing the pre- and post-processes
 * defined in `WriteShimPre` and `WriteShimPost`.
 *
 * @param src Path to the executable or script.
 * @param to Path to the (sh) shim(s) that is going to be created.
 * @param srcRuntimeInfo Result of `await searchScriptRuntime(src)`.
 * @param generateShimScript Generator of shim script.
 * @param opts Other options.
 */
async function writeShim(src, to, srcRuntimeInfo, generateShimScript, opts) {
    const defaultArgs = opts.preserveSymlinks ? '--preserve-symlinks' : '';
    // `Array.prototype.filter` removes ''.
    // ['--foo', '--bar'].join(' ') and [].join(' ') returns '--foo --bar' and '' respectively.
    const args = [srcRuntimeInfo.additionalArgs, defaultArgs].filter(arg => arg).join(' ');
    opts = Object.assign({}, opts, {
        prog: srcRuntimeInfo.program,
        args: args
    });
    await writeShimPre(to, opts);
    await opts.fs_.writeFile(to, generateShimScript(src, to, opts), 'utf8');
    return writeShimPost(to, opts);
}
/**
 * Generate the content of a shim for CMD.
 *
 * @param src Path to the executable or script.
 * @param to Path to the shim to be created.
 * It is highly recommended to end with `.cmd` (or `.bat`).
 * @param opts Options.
 * @return The content of shim.
 */
function generateCmdShim(src, to, opts) {
    // `shTarget` is not used to generate the content.
    const shTarget = path.relative(path.dirname(to), src);
    let target = shTarget.split('/').join('\\');
    const quotedPathToTarget = path.isAbsolute(target) ? `"${target}"` : `"%~dp0\\${target}"`;
    let longProg;
    let prog = opts.prog;
    let args = opts.args || '';
    const nodePath = normalizePathEnvVar(opts.nodePath).win32;
    if (!prog) {
        prog = quotedPathToTarget;
        args = '';
        target = '';
    }
    else {
        longProg = `"%~dp0\\${prog}.exe"`;
        target = quotedPathToTarget;
    }
    let progArgs = opts.progArgs ? `${opts.progArgs.join(` `)} ` : '';
    // @IF EXIST "%~dp0\node.exe" (
    //   "%~dp0\node.exe" "%~dp0\.\node_modules\npm\bin\npm-cli.js" %*
    // ) ELSE (
    //   SETLOCAL
    //   SET PATHEXT=%PATHEXT:;.JS;=;%
    //   node "%~dp0\.\node_modules\npm\bin\npm-cli.js" %*
    // )
    let cmd = nodePath ? `@SET NODE_PATH=${nodePath}\r\n` : '';
    if (longProg) {
        cmd += `@IF EXIST ${longProg} (\r\n` +
            `  ${longProg} ${args} ${target} ${progArgs}%*\r\n` +
            ') ELSE (\r\n' +
            '  @SETLOCAL\r\n' +
            '  @SET PATHEXT=%PATHEXT:;.JS;=;%\r\n' +
            `  ${prog} ${args} ${target} ${progArgs}%*\r\n` +
            ')';
    }
    else {
        cmd += `@${prog} ${args} ${target} ${progArgs}%*\r\n`;
    }
    return cmd;
}
/**
 * Generate the content of a shim for (Ba)sh in, for example, Cygwin and MSYS(2).
 *
 * @param src Path to the executable or script.
 * @param to Path to the shim to be created.
 * It is highly recommended to end with `.sh` or to contain no extension.
 * @param opts Options.
 * @return The content of shim.
 */
function generateShShim(src, to, opts) {
    let shTarget = path.relative(path.dirname(to), src);
    let shProg = opts.prog && opts.prog.split('\\').join('/');
    let shLongProg;
    shTarget = shTarget.split('\\').join('/');
    const quotedPathToTarget = path.isAbsolute(shTarget) ? `"${shTarget}"` : `"$basedir/${shTarget}"`;
    let args = opts.args || '';
    const shNodePath = normalizePathEnvVar(opts.nodePath).posix;
    if (!shProg) {
        shProg = quotedPathToTarget;
        args = '';
        shTarget = '';
    }
    else {
        shLongProg = `"$basedir/${opts.prog}"`;
        shTarget = quotedPathToTarget;
    }
    let progArgs = opts.progArgs ? `${opts.progArgs.join(` `)} ` : '';
    // #!/bin/sh
    // basedir=`dirname "$0"`
    //
    // case `uname` in
    //     *CYGWIN*) basedir=`cygpath -w "$basedir"`;;
    // esac
    //
    // export NODE_PATH="<nodepath>"
    //
    // if [ -x "$basedir/node.exe" ]; then
    //   exec "$basedir/node.exe" "$basedir/node_modules/npm/bin/npm-cli.js" "$@"
    // else
    //   exec node "$basedir/node_modules/npm/bin/npm-cli.js" "$@"
    // fi
    let sh = '#!/bin/sh\n';
    sh = sh +
        "basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\,/,g')\")\n" +
        '\n' +
        'case `uname` in\n' +
        '    *CYGWIN*) basedir=`cygpath -w "$basedir"`;;\n' +
        'esac\n' +
        '\n';
    const env = opts.nodePath ? `export NODE_PATH="${shNodePath}"\n` : '';
    if (shLongProg) {
        sh += env +
            `if [ -x ${shLongProg} ]; then\n` +
            `  exec ${shLongProg} ${args} ${shTarget} ${progArgs}"$@"\n` +
            'else \n' +
            `  exec ${shProg} ${args} ${shTarget} ${progArgs}"$@"\n` +
            'fi\n';
    }
    else {
        sh += `${env}${shProg} ${args} ${shTarget} ${progArgs}"$@"\n` +
            'exit $?\n';
    }
    return sh;
}
/**
 * Generate the content of a shim for PowerShell.
 *
 * @param src Path to the executable or script.
 * @param to Path to the shim to be created.
 * It is highly recommended to end with `.ps1`.
 * @param opts Options.
 * @return The content of shim.
 */
function generatePwshShim(src, to, opts) {
    let shTarget = path.relative(path.dirname(to), src);
    const shProg = opts.prog && opts.prog.split('\\').join('/');
    let pwshProg = shProg && `"${shProg}$exe"`;
    let pwshLongProg;
    shTarget = shTarget.split('\\').join('/');
    const quotedPathToTarget = path.isAbsolute(shTarget) ? `"${shTarget}"` : `"$basedir/${shTarget}"`;
    let args = opts.args || '';
    let normalizedPathEnvVar = normalizePathEnvVar(opts.nodePath);
    const nodePath = normalizedPathEnvVar.win32;
    const shNodePath = normalizedPathEnvVar.posix;
    if (!pwshProg) {
        pwshProg = quotedPathToTarget;
        args = '';
        shTarget = '';
    }
    else {
        pwshLongProg = `"$basedir/${opts.prog}$exe"`;
        shTarget = quotedPathToTarget;
    }
    let progArgs = opts.progArgs ? `${opts.progArgs.join(` `)} ` : '';
    // #!/usr/bin/env pwsh
    // $basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent
    //
    // $ret=0
    // $exe = ""
    // if ($PSVersionTable.PSVersion -lt "6.0" -or $IsWindows) {
    //   # Fix case when both the Windows and Linux builds of Node
    //   # are installed in the same directory
    //   $exe = ".exe"
    // }
    // if (Test-Path "$basedir/node") {
    //   # Support pipeline input
    //   if ($MyInvocation.ExpectingInput) {
    //     $input | & "$basedir/node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
    //   } else {
    //     & "$basedir/node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
    //   }
    //   $ret=$LASTEXITCODE
    // } else {
    //   # Support pipeline input
    //   if ($MyInvocation.ExpectingInput) {
    //     $input | & "node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
    //   } else {
    //     & "node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
    //   }
    //   $ret=$LASTEXITCODE
    // }
    // exit $ret
    let pwsh = '#!/usr/bin/env pwsh\n' +
        '$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n' +
        '\n' +
        '$exe=""\n' +
        (opts.nodePath ? '$env_node_path=$env:NODE_PATH\n' +
            `$env:NODE_PATH="${nodePath}"\n` : '') +
        'if ($PSVersionTable.PSVersion -lt "6.0" -or $IsWindows) {\n' +
        '  # Fix case when both the Windows and Linux builds of Node\n' +
        '  # are installed in the same directory\n' +
        '  $exe=".exe"\n' +
        '}';
    if (opts.nodePath) {
        pwsh = pwsh +
            ' else {\n' +
            `  $env:NODE_PATH="${shNodePath}"\n` +
            '}';
    }
    pwsh += '\n';
    if (pwshLongProg) {
        pwsh = pwsh +
            '$ret=0\n' +
            `if (Test-Path ${pwshLongProg}) {\n` +
            '  # Support pipeline input\n' +
            '  if ($MyInvocation.ExpectingInput) {\n' +
            `    $input | & ${pwshLongProg} ${args} ${shTarget} ${progArgs}$args\n` +
            '  } else {\n' +
            `    & ${pwshLongProg} ${args} ${shTarget} ${progArgs}$args\n` +
            '  }\n' +
            '  $ret=$LASTEXITCODE\n' +
            '} else {\n' +
            '  # Support pipeline input\n' +
            '  if ($MyInvocation.ExpectingInput) {\n' +
            `    $input | & ${pwshProg} ${args} ${shTarget} ${progArgs}$args\n` +
            '  } else {\n' +
            `    & ${pwshProg} ${args} ${shTarget} ${progArgs}$args\n` +
            '  }\n' +
            '  $ret=$LASTEXITCODE\n' +
            '}\n' +
            (opts.nodePath ? '$env:NODE_PATH=$env_node_path\n' : '') +
            'exit $ret\n';
    }
    else {
        pwsh = pwsh +
            '# Support pipeline input\n' +
            'if ($MyInvocation.ExpectingInput) {\n' +
            `  $input | & ${pwshProg} ${args} ${shTarget} ${progArgs}$args\n` +
            '} else {\n' +
            `  & ${pwshProg} ${args} ${shTarget} ${progArgs}$args\n` +
            '}\n' +
            (opts.nodePath ? '$env:NODE_PATH=$env_node_path\n' : '') +
            'exit $LASTEXITCODE\n';
    }
    return pwsh;
}
/**
 * Chmod just created shim and make it executable
 *
 * @param to Path to shim.
 */
function chmodShim(to, opts) {
    return opts.fs_.chmod(to, 0o755);
}
function normalizePathEnvVar(nodePath) {
    if (!nodePath) {
        return {
            win32: '',
            posix: ''
        };
    }
    let split = (typeof nodePath === 'string' ? nodePath.split(path.delimiter) : Array.from(nodePath));
    let result = {};
    for (let i = 0; i < split.length; i++) {
        const win32 = split[i].split('/').join('\\');
        const posix = isWindows() ? split[i].split('\\').join('/').replace(/^([^:\\/]*):/, (_, $1) => `/mnt/${$1.toLowerCase()}`) : split[i];
        result.win32 = result.win32 ? `${result.win32};${win32}` : win32;
        result.posix = result.posix ? `${result.posix}:${posix}` : posix;
        result[i] = { win32, posix };
    }
    return result;
}
module.exports = cmdShim;
//# sourceMappingURL=index.js.map

/***/ }),
/* 701 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(8);
const path = __webpack_require__(84);
const {promisify} = __webpack_require__(90);
const semver = __webpack_require__(702);

const useNativeRecursiveOption = semver.satisfies(process.version, '>=10.12.0');

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
const checkPath = pth => {
	if (process.platform === 'win32') {
		const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''));

		if (pathHasInvalidWinCharacters) {
			const error = new Error(`Path contains invalid characters: ${pth}`);
			error.code = 'EINVAL';
			throw error;
		}
	}
};

const processOptions = options => {
	// https://github.com/sindresorhus/make-dir/issues/18
	const defaults = {
		mode: 0o777,
		fs
	};

	return {
		...defaults,
		...options
	};
};

const permissionError = pth => {
	// This replicates the exception of `fs.mkdir` with native the
	// `recusive` option when run on an invalid drive under Windows.
	const error = new Error(`operation not permitted, mkdir '${pth}'`);
	error.code = 'EPERM';
	error.errno = -4048;
	error.path = pth;
	error.syscall = 'mkdir';
	return error;
};

const makeDir = async (input, options) => {
	checkPath(input);
	options = processOptions(options);

	const mkdir = promisify(options.fs.mkdir);
	const stat = promisify(options.fs.stat);

	if (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) {
		const pth = path.resolve(input);

		await mkdir(pth, {
			mode: options.mode,
			recursive: true
		});

		return pth;
	}

	const make = async pth => {
		try {
			await mkdir(pth, options.mode);

			return pth;
		} catch (error) {
			if (error.code === 'EPERM') {
				throw error;
			}

			if (error.code === 'ENOENT') {
				if (path.dirname(pth) === pth) {
					throw permissionError(pth);
				}

				if (error.message.includes('null bytes')) {
					throw error;
				}

				await make(path.dirname(pth));

				return make(pth);
			}

			try {
				const stats = await stat(pth);
				if (!stats.isDirectory()) {
					throw new Error('The path is not a directory');
				}
			} catch (_) {
				throw error;
			}

			return pth;
		}
	};

	return make(path.resolve(input));
};

module.exports = makeDir;

module.exports.sync = (input, options) => {
	checkPath(input);
	options = processOptions(options);

	if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {
		const pth = path.resolve(input);

		fs.mkdirSync(pth, {
			mode: options.mode,
			recursive: true
		});

		return pth;
	}

	const make = pth => {
		try {
			options.fs.mkdirSync(pth, options.mode);
		} catch (error) {
			if (error.code === 'EPERM') {
				throw error;
			}

			if (error.code === 'ENOENT') {
				if (path.dirname(pth) === pth) {
					throw permissionError(pth);
				}

				if (error.message.includes('null bytes')) {
					throw error;
				}

				make(path.dirname(pth));
				return make(pth);
			}

			try {
				if (!options.fs.statSync(pth).isDirectory()) {
					throw new Error('The path is not a directory');
				}
			} catch (_) {
				throw error;
			}
		}

		return pth;
	};

	return make(path.resolve(input));
};


/***/ }),
/* 702 */
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var t = exports.tokens = {}
var R = 0

function tok (n) {
  t[n] = R++
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

tok('NUMERICIDENTIFIER')
src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*'
tok('NUMERICIDENTIFIERLOOSE')
src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

tok('NONNUMERICIDENTIFIER')
src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

tok('MAINVERSION')
src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')'

tok('MAINVERSIONLOOSE')
src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

tok('PRERELEASEIDENTIFIER')
src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] +
                            '|' + src[t.NONNUMERICIDENTIFIER] + ')'

tok('PRERELEASEIDENTIFIERLOOSE')
src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[t.NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

tok('PRERELEASE')
src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))'

tok('PRERELEASELOOSE')
src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

tok('BUILDIDENTIFIER')
src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

tok('BUILD')
src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] +
             '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

tok('FULL')
tok('FULLPLAIN')
src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] +
                  src[t.PRERELEASE] + '?' +
                  src[t.BUILD] + '?'

src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
tok('LOOSEPLAIN')
src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] +
                  src[t.PRERELEASELOOSE] + '?' +
                  src[t.BUILD] + '?'

tok('LOOSE')
src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$'

tok('GTLT')
src[t.GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
tok('XRANGEIDENTIFIERLOOSE')
src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
tok('XRANGEIDENTIFIER')
src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*'

tok('XRANGEPLAIN')
src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[t.PRERELEASE] + ')?' +
                   src[t.BUILD] + '?' +
                   ')?)?'

tok('XRANGEPLAINLOOSE')
src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[t.PRERELEASELOOSE] + ')?' +
                        src[t.BUILD] + '?' +
                        ')?)?'

tok('XRANGE')
src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$'
tok('XRANGELOOSE')
src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
tok('COERCE')
src[t.COERCE] = '(^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'
tok('COERCERTL')
re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g')

// Tilde ranges.
// Meaning is "reasonably at or greater than"
tok('LONETILDE')
src[t.LONETILDE] = '(?:~>?)'

tok('TILDETRIM')
src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+'
re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

tok('TILDE')
src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$'
tok('TILDELOOSE')
src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
tok('LONECARET')
src[t.LONECARET] = '(?:\\^)'

tok('CARETTRIM')
src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+'
re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g')
var caretTrimReplace = '$1^'

tok('CARET')
src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$'
tok('CARETLOOSE')
src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
tok('COMPARATORLOOSE')
src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$'
tok('COMPARATOR')
src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
tok('COMPARATORTRIM')
src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] +
                      '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
tok('HYPHENRANGE')
src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s*$'

tok('HYPHENRANGELOOSE')
src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
tok('STAR')
src[t.STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

SemVer.prototype.compareBuild = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  var i = 0
  do {
    var a = this.build[i]
    var b = other.build[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.compareBuild = compareBuild
function compareBuild (a, b, loose) {
  var versionA = new SemVer(a, loose)
  var versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(b, a, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1] !== undefined ? m[1] : ''
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY || version === ANY) {
    return true
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    if (this.value === '') {
      return true
    }
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    if (comp.value === '') {
      return true
    }
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[t.COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[t.CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return (
      isSatisfiable(thisComparators, options) &&
      range.set.some(function (rangeComparators) {
        return (
          isSatisfiable(rangeComparators, options) &&
          thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options)
            })
          })
        )
      })
    )
  })
}

// take a set of comparators and determine whether there
// exists a version which can satisfy it
function isSatisfiable (comparators, options) {
  var result = true
  var remainingComparators = comparators.slice()
  var testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p + pr
    } else if (xm) {
      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0' + pr +
        ' <' + M + '.' + (+m + 1) + '.0' + pr
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version, options) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  var match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next
    while ((next = re[t.COERCERTL].exec(version)) &&
      (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
          next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(match[2] +
    '.' + (match[3] || '0') +
    '.' + (match[4] || '0'), options)
}


/***/ }),
/* 703 */
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * is-windows <https://github.com/jonschlinkert/is-windows>
 *
 * Copyright  2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

(function(factory) {
  if (exports && typeof exports === 'object' && "object" !== 'undefined') {
    module.exports = factory();
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function() {
  'use strict';
  return function isWindows() {
    return process && (process.platform === 'win32' || /^(msys|cygwin)$/.test(process.env.OSTYPE));
  };
});


/***/ }),
/* 704 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkType": () => /* binding */ LinkType,
/* harmony export */   "NodeModulesHoistingLimits": () => /* binding */ NodeModulesHoistingLimits,
/* harmony export */   "getArchivePath": () => /* binding */ getArchivePath,
/* harmony export */   "buildNodeModulesTree": () => /* binding */ buildNodeModulesTree,
/* harmony export */   "buildLocatorMap": () => /* binding */ buildLocatorMap
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(162);
/* harmony import */ var _hoist__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(705);



 // Babel doesn't support const enums, thats why we use non-const enum for LinkType in @yarnpkg/pnp
// But because of this TypeScript requires @yarnpkg/pnp during runtime
// To prevent this we redeclare LinkType enum here, to not depend on @yarnpkg/pnp during runtime

var LinkType;

(function (LinkType) {
  LinkType["HARD"] = "HARD";
  LinkType["SOFT"] = "SOFT";
})(LinkType || (LinkType = {}));

var NodeModulesHoistingLimits;

(function (NodeModulesHoistingLimits) {
  NodeModulesHoistingLimits["WORKSPACES"] = "workspaces";
  NodeModulesHoistingLimits["DEPENDENCIES"] = "dependencies";
  NodeModulesHoistingLimits["NONE"] = "none";
})(NodeModulesHoistingLimits || (NodeModulesHoistingLimits = {}));
/** node_modules path segment */


const NODE_MODULES = `node_modules`;
/**
 * The workspace name suffix used internally by this implementation and appeneded to the name of workspace package.
 * It is needed to create and distinguuish special nodes for workspaces
 */

const WORKSPACE_NAME_SUFFIX = `$wsroot$`;
/**
 * Returns path to archive, if package location is inside the archive.
 *
 * @param packagePath package location
 *
 * @returns path to archive is location is insde the archive or null otherwise
 */

const getArchivePath = packagePath => packagePath.indexOf(`.zip/${NODE_MODULES}/`) >= 0 ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.toPortablePath(packagePath.split(`/${NODE_MODULES}/`)[0]) : null;
/**
 * Retrieve full package list and build hoisted `node_modules` directories
 * representation in-memory.
 *
 * @param pnp PnP API
 *
 * @returns hoisted `node_modules` directories representation in-memory
 */

const buildNodeModulesTree = (pnp, options) => {
  const {
    packageTree,
    hoistingLimits
  } = buildPackageTree(pnp, options);
  const hoistedTree = (0,_hoist__WEBPACK_IMPORTED_MODULE_1__.hoist)(packageTree, {
    hoistingLimits
  });
  return populateNodeModulesTree(pnp, hoistedTree, options);
};

const stringifyLocator = locator => `${locator.name}@${locator.reference}`;

const buildLocatorMap = nodeModulesTree => {
  const map = new Map();

  for (const [location, val] of nodeModulesTree.entries()) {
    if (!val.dirList) {
      let entry = map.get(val.locator);

      if (!entry) {
        entry = {
          target: val.target,
          linkType: val.linkType,
          locations: [],
          aliases: val.aliases
        };
        map.set(val.locator, entry);
      }

      entry.locations.push(location);
    }
  }

  for (const val of map.values()) {
    // Sort locations by depth first and then alphabetically for determinism
    val.locations = val.locations.sort((loc1, loc2) => {
      const len1 = loc1.split(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.delimiter).length;
      const len2 = loc2.split(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.delimiter).length;
      return len1 !== len2 ? len2 - len1 : loc2.localeCompare(loc1);
    });
  }

  return map;
};

function isPortalLocator(locatorKey) {
  let descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.parseDescriptor(locatorKey);
  if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.isVirtualDescriptor(descriptor)) descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.devirtualizeDescriptor(descriptor);
  return descriptor.range.startsWith(`portal:`);
}
/**
 * Traverses PnP tree and produces input for the `RawHoister`
 *
 * @param pnp PnP API
 *
 * @returns package tree, packages info and locators
 */


const buildPackageTree = (pnp, options) => {
  const pnpRoots = pnp.getDependencyTreeRoots();
  const hoistingLimits = new Map();
  const workspaceDependenciesMap = new Map();
  const topPkg = pnp.getPackageInformation(pnp.topLevel);
  if (topPkg === null) throw new Error(`Assertion failed: Expected the top-level package to have been registered`);
  const topLocator = pnp.findPackageLocator(topPkg.packageLocation);
  if (topLocator === null) throw new Error(`Assertion failed: Expected the top-level package to have a physical locator`);
  const topPkgPortableLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.toPortablePath(topPkg.packageLocation);
  const topLocatorKey = stringifyLocator(topLocator);

  if (options.project) {
    const workspaceTree = {
      children: new Map()
    };
    const cwdSegments = options.project.cwd.split(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.sep);

    for (const [cwd, workspace] of options.project.workspacesByCwd) {
      const segments = cwd.split(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.sep).slice(cwdSegments.length);
      let node = workspaceTree;

      for (const segment of segments) {
        let nextNode = node.children.get(segment);

        if (!nextNode) {
          nextNode = {
            children: new Map()
          };
          node.children.set(segment, nextNode);
        }

        node = nextNode;
      }

      node.workspaceLocator = {
        name: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyIdent(workspace.anchoredLocator),
        reference: workspace.anchoredLocator.reference
      };
    }

    const addWorkspace = (node, parentWorkspaceLocator) => {
      if (node.workspaceLocator) {
        const parentLocatorKey = stringifyLocator(parentWorkspaceLocator);
        let dependencies = workspaceDependenciesMap.get(parentLocatorKey);

        if (!dependencies) {
          dependencies = new Set();
          workspaceDependenciesMap.set(parentLocatorKey, dependencies);
        }

        dependencies.add(node.workspaceLocator);
      }

      for (const child of node.children.values()) {
        addWorkspace(child, node.workspaceLocator || parentWorkspaceLocator);
      }
    };

    for (const child of workspaceTree.children.values()) {
      addWorkspace(child, workspaceTree.workspaceLocator);
    }
  } else {
    for (const locator of pnpRoots) {
      if (locator.name !== topLocator.name || locator.reference !== topLocator.reference) {
        let dependencies = workspaceDependenciesMap.get(topLocatorKey);

        if (!dependencies) {
          dependencies = new Set();
          workspaceDependenciesMap.set(topLocatorKey, dependencies);
        }

        dependencies.add(locator);
      }
    }
  }

  const packageTree = {
    name: topLocator.name,
    identName: topLocator.name,
    reference: topLocator.reference,
    peerNames: topPkg.packagePeers,
    dependencies: new Set()
  };
  const nodes = new Map();

  const getNodeKey = (name, locator) => `${stringifyLocator(locator)}:${name}`;

  const addPackageToTree = (name, pkg, locator, parent, parentDependencies, parentRelativeCwd, isHoistBorder) => {
    var _a, _b;

    const nodeKey = getNodeKey(name, locator);
    let node = nodes.get(nodeKey);
    const isSeen = !!node;

    if (!isSeen && locator.name === topLocator.name && locator.reference === topLocator.reference) {
      node = packageTree;
      nodes.set(nodeKey, packageTree);
    }

    if (!node) {
      node = {
        name,
        identName: locator.name,
        reference: locator.reference,
        dependencies: new Set(),
        peerNames: pkg.packagePeers
      };
      nodes.set(nodeKey, node);
    }

    if (isHoistBorder) {
      const parentLocatorKey = stringifyLocator({
        name: parent.identName,
        reference: parent.reference
      });
      const dependencyBorders = hoistingLimits.get(parentLocatorKey) || new Set();
      hoistingLimits.set(parentLocatorKey, dependencyBorders);
      dependencyBorders.add(node.name);
    }

    const allDependencies = new Map(pkg.packageDependencies);

    if (options.project) {
      const workspace = options.project.workspacesByCwd.get(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.toPortablePath(pkg.packageLocation.slice(0, -1)));

      if (workspace) {
        const peerCandidates = new Set([...Array.from(workspace.manifest.peerDependencies.values(), x => _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyIdent(x)), ...Array.from(workspace.manifest.peerDependenciesMeta.keys())]);

        for (const peerName of peerCandidates) {
          if (!allDependencies.has(peerName)) {
            allDependencies.set(peerName, parentDependencies.get(peerName) || null);
            node.peerNames.add(peerName);
          }
        }
      }
    }

    const locatorKey = stringifyLocator(locator);
    const workspaceDependencies = workspaceDependenciesMap.get(locatorKey);

    if (workspaceDependencies) {
      for (const workspaceLocator of workspaceDependencies) {
        allDependencies.set(`${workspaceLocator.name}${WORKSPACE_NAME_SUFFIX}`, workspaceLocator.reference);
      }
    }

    parent.dependencies.add(node); // If we link dependencies to file system we must not try to install children dependencies inside portal folders

    const shouldAddChildrenDependencies = options.pnpifyFs || !isPortalLocator(nodeKey);

    if (!isSeen && shouldAddChildrenDependencies) {
      for (const [depName, referencish] of allDependencies) {
        if (referencish !== null) {
          const depLocator = pnp.getLocator(depName, referencish);
          const pkgLocator = pnp.getLocator(depName.replace(WORKSPACE_NAME_SUFFIX, ``), referencish);
          const depPkg = pnp.getPackageInformation(pkgLocator);
          if (depPkg === null) throw new Error(`Assertion failed: Expected the package to have been registered`);
          const parentHoistingLimits = (_a = options.hoistingLimitsByCwd) === null || _a === void 0 ? void 0 : _a.get(parentRelativeCwd);
          const relativeDepCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.relative(topPkgPortableLocation, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.toPortablePath(depPkg.packageLocation)) || _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.PortablePath.dot;
          const depHoistingLimits = (_b = options.hoistingLimitsByCwd) === null || _b === void 0 ? void 0 : _b.get(relativeDepCwd);
          const isHoistBorder = parentHoistingLimits === NodeModulesHoistingLimits.DEPENDENCIES || depHoistingLimits === NodeModulesHoistingLimits.DEPENDENCIES || depHoistingLimits === NodeModulesHoistingLimits.WORKSPACES;
          addPackageToTree(depName, depPkg, depLocator, node, allDependencies, relativeDepCwd, isHoistBorder);
        }
      }
    }
  };

  addPackageToTree(topLocator.name, topPkg, topLocator, packageTree, topPkg.packageDependencies, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.PortablePath.dot, false);
  return {
    packageTree,
    hoistingLimits
  };
};

function getTargetLocatorPath(locator, pnp, options) {
  const pkgLocator = pnp.getLocator(locator.name.replace(WORKSPACE_NAME_SUFFIX, ``), locator.reference);
  const info = pnp.getPackageInformation(pkgLocator);
  if (info === null) throw new Error(`Assertion failed: Expected the package to be registered`);
  let linkType;
  let target;

  if (options.pnpifyFs) {
    // In case of pnpifyFs we represent modules as symlinks to archives in NodeModulesFS
    // `/home/user/project/foo` is a symlink to `/home/user/project/.yarn/.cache/foo.zip/node_modules/foo`
    // To make this fs layout work with legacy tools we make
    // `/home/user/project/.yarn/.cache/foo.zip/node_modules/foo/node_modules` (which normally does not exist inside archive) a symlink to:
    // `/home/user/project/node_modules/foo/node_modules`, so that the tools were able to access it
    target = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.toPortablePath(info.packageLocation);
    linkType = LinkType.SOFT;
  } else {
    const truePath = pnp.resolveVirtual && locator.reference && locator.reference.startsWith(`virtual:`) ? pnp.resolveVirtual(info.packageLocation) : info.packageLocation;
    target = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.toPortablePath(truePath || info.packageLocation);
    linkType = info.linkType;
  }

  return {
    linkType,
    target
  };
}
/**
 * Converts hoisted tree to node modules map
 *
 * @param pnp PnP API
 * @param hoistedTree hoisted package tree from `RawHoister`
 * @param locators locators
 * @param packages package weights
 *
 * @returns node modules map
 */


const populateNodeModulesTree = (pnp, hoistedTree, options) => {
  const tree = new Map();

  const makeLeafNode = (locator, aliases) => {
    const {
      linkType,
      target
    } = getTargetLocatorPath(locator, pnp, options);
    return {
      locator: stringifyLocator(locator),
      target,
      linkType,
      aliases
    };
  };

  const getPackageName = identName => {
    const [nameOrScope, name] = identName.split(`/`);
    return name ? {
      scope: (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.toFilename)(nameOrScope),
      name: (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.toFilename)(name)
    } : {
      scope: null,
      name: (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.toFilename)(nameOrScope)
    };
  };

  const seenNodes = new Set();

  const buildTree = (pkg, locationPrefix) => {
    if (seenNodes.has(pkg)) return;
    seenNodes.add(pkg);

    for (const dep of pkg.dependencies) {
      // We do not want self-references in node_modules, since they confuse existing tools
      if (dep === pkg || pkg.identName.endsWith(WORKSPACE_NAME_SUFFIX) && dep.identName === pkg.identName.replace(WORKSPACE_NAME_SUFFIX, ``)) continue;
      const references = Array.from(dep.references).sort();
      const locator = {
        name: dep.identName,
        reference: references[0]
      };
      const {
        name,
        scope
      } = getPackageName(dep.name);
      const packageNameParts = scope ? [scope, name] : [name];
      const nodeModulesDirPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.join(locationPrefix, NODE_MODULES);
      const nodeModulesLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.join(nodeModulesDirPath, ...packageNameParts);
      const leafNode = makeLeafNode(locator, references.slice(1));

      if (!dep.name.endsWith(WORKSPACE_NAME_SUFFIX)) {
        const prevNode = tree.get(nodeModulesLocation);

        if (prevNode) {
          if (prevNode.dirList) {
            throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge dir node with leaf node`);
          } else {
            const locator1 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.parseLocator(prevNode.locator);
            const locator2 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.parseLocator(leafNode.locator);
            if (prevNode.linkType !== leafNode.linkType) throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge nodes with different link types`);else if (locator1.identHash !== locator2.identHash) throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge nodes with different idents ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyLocator(locator1)} and ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyLocator(locator2)}`);
            leafNode.aliases = [...leafNode.aliases, ...prevNode.aliases, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.parseLocator(prevNode.locator).reference];
          }
        }

        tree.set(nodeModulesLocation, leafNode);
        const segments = nodeModulesLocation.split(`/`);
        const nodeModulesIdx = segments.indexOf(NODE_MODULES);
        let segCount = segments.length - 1;

        while (nodeModulesIdx >= 0 && segCount > nodeModulesIdx) {
          const dirPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.toPortablePath(segments.slice(0, segCount).join(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.sep));
          const targetDir = (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.toFilename)(segments[segCount]);
          const subdirs = tree.get(dirPath);

          if (!subdirs) {
            tree.set(dirPath, {
              dirList: new Set([targetDir])
            });
          } else if (subdirs.dirList) {
            if (subdirs.dirList.has(targetDir)) {
              break;
            } else {
              subdirs.dirList.add(targetDir);
            }
          }

          segCount--;
        }
      }

      buildTree(dep, leafNode.linkType === LinkType.SOFT ? leafNode.target : nodeModulesLocation);
    }
  };

  const rootNode = makeLeafNode({
    name: hoistedTree.name,
    reference: Array.from(hoistedTree.references)[0]
  }, []);
  const rootPath = rootNode.target;
  tree.set(rootPath, rootNode);
  buildTree(hoistedTree, rootPath);
  return tree;
};
/**
 * Benchmarks raw hoisting performance.
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param packageTree package tree
 * @param packages package info
 *
 * @returns average raw hoisting time
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars


const benchmarkRawHoisting = packageTree => {
  const iterCount = 10;
  const startTime = Date.now();

  for (let iter = 0; iter < iterCount; iter++) (0,_hoist__WEBPACK_IMPORTED_MODULE_1__.hoist)(packageTree);

  const endTime = Date.now();
  return (endTime - startTime) / iterCount;
};
/**
 * Benchmarks node_modules tree building.
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param packageTree package tree
 * @param packages package info
 *
 * @returns average raw hoisting time
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars


const benchmarkBuildTree = (pnp, options) => {
  const iterCount = 100;
  const startTime = Date.now();

  for (let iter = 0; iter < iterCount; iter++) {
    const {
      packageTree,
      hoistingLimits
    } = buildPackageTree(pnp, options);
    const hoistedTree = (0,_hoist__WEBPACK_IMPORTED_MODULE_1__.hoist)(packageTree, {
      hoistingLimits
    });
    populateNodeModulesTree(pnp, hoistedTree, options);
  }

  const endTime = Date.now();
  return (endTime - startTime) / iterCount;
};
/**
 * Pretty-prints node_modules tree.
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param tree node_modules tree
 * @param rootPath top-level project root folder
 *
 * @returns sorted node_modules tree
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars


const dumpNodeModulesTree = (tree, rootPath) => {
  const sortedTree = new Map();
  const keys = Array.from(tree.keys()).sort();

  for (const key of keys) {
    const val = tree.get(key);
    sortedTree.set(key, val.dirList ? {
      dirList: new Set(Array.from(val.dirList).sort())
    } : val);
  }

  const seenPaths = new Set();

  const dumpTree = (nodePath, prefix = ``, dirPrefix = ``) => {
    const node = sortedTree.get(nodePath);
    if (!node) return ``;
    seenPaths.add(nodePath);
    let str = ``;

    if (node.dirList) {
      const dirs = Array.from(node.dirList);

      for (let idx = 0; idx < dirs.length; idx++) {
        const dir = dirs[idx];
        str += `${prefix}${idx < dirs.length - 1 ? `` : ``}${dirPrefix}${dir}\n`;
        str += dumpTree(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.join(nodePath, dir), `${prefix}${idx < dirs.length - 1 ? ` ` : `  `}`);
      }
    } else {
      const {
        target,
        linkType
      } = node;
      str += dumpTree(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.join(nodePath, NODE_MODULES), `${prefix} `, `${NODE_MODULES}/`);
      str += `${prefix}${linkType === LinkType.SOFT ? `s>` : `>`}${target}\n`;
    }

    return str;
  };

  let str = dumpTree(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.join(rootPath, NODE_MODULES));

  for (const key of sortedTree.keys()) {
    if (!seenPaths.has(key)) {
      str += `${key.replace(rootPath, ``)}\n${dumpTree(key)}`;
    }
  }

  return str;
};
/**
 * Pretty-prints dependency tree in the `yarn why`-like format
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param pkg node_modules tree
 *
 * @returns sorted node_modules tree
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars


const dumpDepTree = tree => {
  const dumpLocator = locator => {
    if (locator.reference === `workspace:.`) {
      return `.`;
    } else if (!locator.reference) {
      return `${locator.name}@${locator.reference}`;
    } else {
      const version = (locator.reference.indexOf(`#`) > 0 ? locator.reference.split(`#`)[1] : locator.reference).replace(`npm:`, ``);

      if (locator.reference.startsWith(`virtual`)) {
        return `v:${locator.name}@${version}`;
      } else {
        return `${locator.name}@${version}`;
      }
    }
  };

  const dumpPackage = (pkg, parents, prefix = ``) => {
    if (parents.includes(pkg)) return ``;
    const dependencies = Array.from(pkg.dependencies);
    let str = ``;

    for (let idx = 0; idx < dependencies.length; idx++) {
      const dep = dependencies[idx];
      str += `${prefix}${idx < dependencies.length - 1 ? `` : ``}${(parents.includes(dep) ? `>` : ``) + dumpLocator({
        name: dep.name,
        reference: Array.from(dep.references)[0]
      })}\n`;
      str += dumpPackage(dep, [...parents, dep], `${prefix}${idx < dependencies.length - 1 ? ` ` : `  `}`);
    }

    return str;
  };

  return dumpPackage(tree, []);
};

/***/ }),
/* 705 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hoist": () => /* binding */ hoist
/* harmony export */ });
var Hoistable;

(function (Hoistable) {
  Hoistable[Hoistable["YES"] = 0] = "YES";
  Hoistable[Hoistable["NO"] = 1] = "NO";
  Hoistable[Hoistable["DEPENDS"] = 2] = "DEPENDS";
})(Hoistable || (Hoistable = {}));

const makeLocator = (name, reference) => `${name}@${reference}`;

const makeIdent = (name, reference) => {
  const hashIdx = reference.indexOf(`#`); // Strip virtual reference part, we don't need it for hoisting purposes

  const realReference = hashIdx >= 0 ? reference.substring(hashIdx + 1) : reference;
  return makeLocator(name, realReference);
};

var DebugLevel;

(function (DebugLevel) {
  DebugLevel[DebugLevel["NONE"] = -1] = "NONE";
  DebugLevel[DebugLevel["PERF"] = 0] = "PERF";
  DebugLevel[DebugLevel["CHECK"] = 1] = "CHECK";
  DebugLevel[DebugLevel["REASONS"] = 2] = "REASONS";
  DebugLevel[DebugLevel["INTENSIVE_CHECK"] = 9] = "INTENSIVE_CHECK";
})(DebugLevel || (DebugLevel = {}));
/**
 * Hoists package tree.
 *
 * The root node of a tree must has id: '.'.
 * This function does not mutate its arguments, it hoists and returns tree copy.
 *
 * @param tree package tree (cycles in the tree are allowed)
 *
 * @returns hoisted tree copy
 */


const hoist = (tree, opts = {}) => {
  const debugLevel = opts.debugLevel || Number(process.env.NM_DEBUG_LEVEL || DebugLevel.NONE);
  const check = opts.check || debugLevel >= DebugLevel.INTENSIVE_CHECK;
  const hoistingLimits = opts.hoistingLimits || new Map();
  const options = {
    check,
    debugLevel,
    hoistingLimits
  };
  if (options.debugLevel >= DebugLevel.PERF) console.time(`hoist`);
  const treeCopy = cloneTree(tree, options);
  hoistTo(treeCopy, [treeCopy], new Set([treeCopy.locator]), options);
  if (options.debugLevel >= DebugLevel.PERF) console.timeEnd(`hoist`);

  if (options.debugLevel >= DebugLevel.CHECK) {
    const checkLog = selfCheck(treeCopy);

    if (checkLog) {
      throw new Error(`${checkLog}, after hoisting finished:\n${dumpDepTree(treeCopy)}`);
    }
  }

  if (options.debugLevel >= DebugLevel.REASONS) console.log(dumpDepTree(treeCopy));
  return shrinkTree(treeCopy);
};

const getHoistedDependencies = rootNode => {
  const hoistedDependencies = new Map();
  const seenNodes = new Set();

  const addHoistedDependencies = node => {
    if (seenNodes.has(node)) return;
    seenNodes.add(node);

    for (const dep of node.hoistedDependencies.values()) if (!rootNode.dependencies.has(dep.name)) hoistedDependencies.set(dep.name, dep);

    for (const dep of node.dependencies.values()) {
      if (!node.peerNames.has(dep.name)) {
        addHoistedDependencies(dep);
      }
    }
  };

  addHoistedDependencies(rootNode);
  return hoistedDependencies;
};
/**
 * This method clones the node and returns cloned node copy, if the node was not previously decoupled.
 *
 * The node is considered decoupled if there is no multiple parents to any node
 * on the path from the dependency graph root up to this node. This means that there are no other
 * nodes in dependency graph that somehow transitively use this node and hence node can be hoisted without
 * side effects.
 *
 * The process of node decoupling is done by going from root node of the graph up to the node in concern
 * and decoupling each node on this graph path.
 *
 * @param node original node
 *
 * @returns decoupled node
 */


const decoupleGraphNode = (parent, node) => {
  if (node.decoupled) return node;
  const {
    name,
    references,
    ident,
    locator,
    dependencies,
    originalDependencies,
    hoistedDependencies,
    peerNames,
    reasons,
    isHoistBorder
  } = node; // To perform node hoisting from parent node we must clone parent nodes up to the root node,
  // because some other package in the tree might depend on the parent package where hoisting
  // cannot be performed

  const clone = {
    name,
    references: new Set(references),
    ident,
    locator,
    dependencies: new Map(dependencies),
    originalDependencies: new Map(originalDependencies),
    hoistedDependencies: new Map(hoistedDependencies),
    peerNames: new Set(peerNames),
    reasons: new Map(reasons),
    decoupled: true,
    isHoistBorder
  };
  const selfDep = clone.dependencies.get(name);
  if (selfDep && selfDep.ident == clone.ident) // Update self-reference
    clone.dependencies.set(name, clone);
  parent.dependencies.set(clone.name, clone);
  return clone;
};
/**
 * Builds a map of most preferred packages that might be hoisted to the root node.
 *
 * The values in the map are idents sorted by preference from most preferred to less preferred.
 * If the root node has already some version of a package, the value array will contain only
 * one element, since it is not possible for other versions of a package to be hoisted.
 *
 * @param rootNode root node
 * @param preferenceMap preference map
 */


const getHoistIdentMap = (rootNode, preferenceMap) => {
  const identMap = new Map([[rootNode.name, [rootNode.ident]]]);

  for (const dep of rootNode.dependencies.values()) {
    if (!rootNode.peerNames.has(dep.name)) {
      identMap.set(dep.name, [dep.ident]);
    }
  }

  const keyList = Array.from(preferenceMap.keys());
  keyList.sort((key1, key2) => {
    const entry1 = preferenceMap.get(key1);
    const entry2 = preferenceMap.get(key2);

    if (entry2.peerDependents.size !== entry1.peerDependents.size) {
      return entry2.peerDependents.size - entry1.peerDependents.size;
    } else {
      return entry2.dependents.size - entry1.dependents.size;
    }
  });

  for (const key of keyList) {
    const name = key.substring(0, key.indexOf(`@`, 1));
    const ident = key.substring(name.length + 1);

    if (!rootNode.peerNames.has(name)) {
      let idents = identMap.get(name);

      if (!idents) {
        idents = [];
        identMap.set(name, idents);
      }

      if (idents.indexOf(ident) < 0) {
        idents.push(ident);
      }
    }
  }

  return identMap;
};
/**
 * Gets regular node dependencies only and sorts them in the order so that
 * peer dependencies come before the dependency that rely on them.
 *
 * @param node graph node
 * @returns sorted regular dependencies
 */


const getSortedRegularDependencies = node => {
  const dependencies = new Set();

  const addDep = (dep, seenDeps = new Set()) => {
    if (seenDeps.has(dep)) return;
    seenDeps.add(dep);

    for (const peerName of dep.peerNames) {
      if (!node.peerNames.has(peerName)) {
        const peerDep = node.dependencies.get(peerName);

        if (peerDep && !dependencies.has(peerDep)) {
          addDep(peerDep, seenDeps);
        }
      }
    }

    dependencies.add(dep);
  };

  for (const dep of node.dependencies.values()) {
    if (!node.peerNames.has(dep.name)) {
      addDep(dep);
    }
  }

  return dependencies;
};
/**
 * Performs hoisting all the dependencies down the tree to the root node.
 *
 * The algorithm used here reduces dependency graph by deduplicating
 * instances of the packages while keeping:
 * 1. Regular dependency promise: the package should require the exact version of the dependency
 * that was declared in its `package.json`
 * 2. Peer dependency promise: the package and its direct parent package
 * must use the same instance of the peer dependency
 *
 * The regular and peer dependency promises are kept while performing transform
 * on tree branches of packages at a time:
 * `root package` -> `parent package 1` ... `parent package n` -> `dependency`
 * We check wether we can hoist `dependency` to `root package`, this boils down basically
 * to checking:
 * 1. Wether `root package` does not depend on other version of `dependency`
 * 2. Wether all the peer dependencies of a `dependency` had already been hoisted from all `parent packages`
 *
 * If many versions of the `dependency` can be hoisted to the `root package` we choose the most used
 * `dependency` version in the project among them.
 *
 * This function mutates the tree.
 *
 * @param tree package dependencies graph
 * @param rootNode root node to hoist to
 * @param rootNodePath root node path in the tree
 * @param rootNodePathLocators a set of locators for nodes that lead from the top of the tree up to root node
 * @param options hoisting options
 */


const hoistTo = (tree, rootNodePath, rootNodePathLocators, options, seenNodes = new Set()) => {
  const rootNode = rootNodePath[rootNodePath.length - 1];
  if (seenNodes.has(rootNode)) return;
  seenNodes.add(rootNode);
  const preferenceMap = buildPreferenceMap(rootNode);
  const hoistIdentMap = getHoistIdentMap(rootNode, preferenceMap);
  const hoistIdents = new Map(Array.from(hoistIdentMap.entries()).map(([k, v]) => [k, v[0]]));
  const hoistedDependencies = rootNode === tree ? new Map() : getHoistedDependencies(rootNode);
  let wasStateChanged;

  do {
    hoistGraph(tree, rootNodePath, rootNodePathLocators, hoistedDependencies, hoistIdents, hoistIdentMap, options);
    wasStateChanged = false;

    for (const [name, idents] of hoistIdentMap) {
      if (idents.length > 1 && !rootNode.dependencies.has(name)) {
        hoistIdents.delete(name);
        idents.shift();
        hoistIdents.set(name, idents[0]);
        wasStateChanged = true;
      }
    }
  } while (wasStateChanged);

  for (const dependency of rootNode.dependencies.values()) {
    if (!rootNode.peerNames.has(dependency.name) && !rootNodePathLocators.has(dependency.locator)) {
      rootNodePathLocators.add(dependency.locator);
      hoistTo(tree, [...rootNodePath, dependency], rootNodePathLocators, options);
      rootNodePathLocators.delete(dependency.locator);
    }
  }
};

const getNodeHoistInfo = (rootNodePathLocators, nodePath, node, hoistedDependencies, hoistIdents, hoistIdentMap, {
  outputReason
}) => {
  let reasonRoot;
  let reason = null;
  let dependsOn = new Set();
  if (outputReason) reasonRoot = `${Array.from(rootNodePathLocators).map(x => prettyPrintLocator(x)).join(``)}`;
  const parentNode = nodePath[nodePath.length - 1]; // We cannot hoist self-references

  const isSelfReference = node.ident === parentNode.ident;
  const hoistedIdent = hoistIdents.get(node.name);
  let isHoistable = hoistedIdent === node.ident && !isSelfReference;
  if (outputReason && !isHoistable && hoistedIdent && !isSelfReference) reason = `- filled by: ${prettyPrintLocator(hoistIdentMap.get(node.name)[0])} at ${reasonRoot}`;

  if (isHoistable) {
    let isNameAvailable = false;
    const hoistedDep = hoistedDependencies.get(node.name);
    isNameAvailable = !hoistedDep || hoistedDep.ident === node.ident;
    if (outputReason && !isNameAvailable) reason = `- filled by: ${prettyPrintLocator(hoistedDep.locator)} at ${reasonRoot}`;

    if (isNameAvailable) {
      for (let idx = 1; idx < nodePath.length - 1; idx++) {
        const parent = nodePath[idx];
        const parentDep = parent.dependencies.get(node.name);

        if (parentDep && parentDep.ident !== node.ident) {
          isNameAvailable = false;
          if (outputReason) reason = `- filled by: ${prettyPrintLocator(parentDep.locator)} at ${prettyPrintLocator(parent.locator)}`;
          break;
        }
      }
    }

    isHoistable = isNameAvailable;
  }

  if (isHoistable) {
    let arePeerDepsSatisfied = true;
    const checkList = new Set(node.peerNames);

    for (let idx = nodePath.length - 1; idx >= 1; idx--) {
      const parent = nodePath[idx];

      for (const name of checkList) {
        if (parent.peerNames.has(name) && parent.originalDependencies.has(name)) continue;
        const parentDepNode = parent.dependencies.get(name);

        if (parentDepNode) {
          if (idx === nodePath.length - 1) {
            dependsOn.add(parentDepNode);
          } else {
            dependsOn = null;
            arePeerDepsSatisfied = false;

            if (outputReason) {
              reason = `- peer dependency ${prettyPrintLocator(parentDepNode.locator)} from parent ${prettyPrintLocator(parent.locator)} was not hoisted to ${reasonRoot}`;
            }
          }
        }

        checkList.delete(name);
      }

      if (!arePeerDepsSatisfied) {
        break;
      }
    }

    isHoistable = arePeerDepsSatisfied;
  }

  if (dependsOn !== null && dependsOn.size > 0) {
    return {
      isHoistable: Hoistable.DEPENDS,
      dependsOn,
      reason
    };
  } else {
    return {
      isHoistable: isHoistable ? Hoistable.YES : Hoistable.NO,
      reason
    };
  }
};
/**
 * Performs actual graph transformation, by hoisting packages to the root node.
 *
 * @param tree dependency tree
 * @param rootNodePath root node path in the tree
 * @param rootNodePathLocators a set of locators for nodes that lead from the top of the tree up to root node
 * @param hoistedDependencies map of dependencies that were hoisted to parent nodes
 * @param hoistIdents idents that should be attempted to be hoisted to the root node
 */


const hoistGraph = (tree, rootNodePath, rootNodePathLocators, hoistedDependencies, hoistIdents, hoistIdentMap, options) => {
  const rootNode = rootNodePath[rootNodePath.length - 1];
  const seenNodes = new Set();

  const hoistNodeDependencies = (nodePath, locatorPath, parentNode, newNodes) => {
    if (seenNodes.has(parentNode)) return;
    const nextLocatorPath = [...locatorPath, parentNode.locator];
    const dependantTree = new Map();
    const hoistInfos = new Map();

    for (const subDependency of getSortedRegularDependencies(parentNode)) {
      let hoistInfo = null;
      if (!hoistInfo) hoistInfo = getNodeHoistInfo(rootNodePathLocators, [rootNode, ...nodePath, parentNode], subDependency, hoistedDependencies, hoistIdents, hoistIdentMap, {
        outputReason: options.debugLevel >= DebugLevel.REASONS
      });
      hoistInfos.set(subDependency, hoistInfo);

      if (hoistInfo.isHoistable === Hoistable.DEPENDS) {
        for (const node of hoistInfo.dependsOn) {
          const nodeDependants = dependantTree.get(node.name) || new Set();
          nodeDependants.add(subDependency.name);
          dependantTree.set(node.name, nodeDependants);
        }
      }
    }

    const unhoistableNodes = new Set();

    const addUnhoistableNode = (node, hoistInfo, reason) => {
      if (!unhoistableNodes.has(node)) {
        unhoistableNodes.add(node);
        if (node.ident !== parentNode.ident) hoistInfos.set(node, {
          isHoistable: Hoistable.NO,
          reason
        });

        for (const dependantName of dependantTree.get(node.name) || []) {
          addUnhoistableNode(parentNode.dependencies.get(dependantName), hoistInfo, reason);
        }
      }
    };

    let reasonRoot;
    if (options.debugLevel >= DebugLevel.REASONS) reasonRoot = `${Array.from(rootNodePathLocators).map(x => prettyPrintLocator(x)).join(``)}`;

    for (const [node, hoistInfo] of hoistInfos) if (hoistInfo.isHoistable === Hoistable.NO) addUnhoistableNode(node, hoistInfo, `- peer dependency ${prettyPrintLocator(node.locator)} from parent ${prettyPrintLocator(parentNode.locator)} was not hoisted to ${reasonRoot}`);

    for (const node of hoistInfos.keys()) {
      if (!unhoistableNodes.has(node)) {
        parentNode.dependencies.delete(node.name);
        parentNode.hoistedDependencies.set(node.name, node);
        parentNode.reasons.delete(node.name);
        const hoistedNode = rootNode.dependencies.get(node.name); // Add hoisted node to root node, in case it is not already there

        if (!hoistedNode) {
          // Avoid adding other version of root node to itself
          if (rootNode.ident !== node.ident) {
            rootNode.dependencies.set(node.name, node);
            newNodes.add(node);
          }
        } else {
          for (const reference of node.references) {
            hoistedNode.references.add(reference);
          }
        }
      }
    }

    if (options.check) {
      const checkLog = selfCheck(tree);

      if (checkLog) {
        throw new Error(`${checkLog}, after hoisting dependencies of ${[rootNode, ...nodePath, parentNode].map(x => prettyPrintLocator(x.locator)).join(``)}:\n${dumpDepTree(tree)}`);
      }
    }

    const children = getSortedRegularDependencies(parentNode);

    for (const node of children) {
      if (unhoistableNodes.has(node) && nextLocatorPath.indexOf(node.locator) < 0) {
        const hoistInfo = hoistInfos.get(node);
        if (hoistInfo.isHoistable !== Hoistable.YES) parentNode.reasons.set(node.name, hoistInfo.reason);

        if (!node.isHoistBorder) {
          seenNodes.add(parentNode);
          const decoupledNode = decoupleGraphNode(parentNode, node);
          hoistNodeDependencies([...nodePath, parentNode], [...locatorPath, parentNode.locator], decoupledNode, nextNewNodes);
          seenNodes.delete(parentNode);
        }
      }
    }
  };

  let newNodes;
  let nextNewNodes = new Set(getSortedRegularDependencies(rootNode));

  do {
    newNodes = nextNewNodes;
    nextNewNodes = new Set();

    for (const dep of newNodes) {
      if (dep.locator === rootNode.locator || dep.isHoistBorder) continue;
      const decoupledDependency = decoupleGraphNode(rootNode, dep);
      hoistNodeDependencies([], Array.from(rootNodePathLocators), decoupledDependency, nextNewNodes);
    }
  } while (nextNewNodes.size > 0);
};

const selfCheck = tree => {
  const log = [];
  const seenNodes = new Set();
  const parents = new Set();

  const checkNode = (node, parentDeps) => {
    if (seenNodes.has(node)) return;
    seenNodes.add(node);
    if (parents.has(node)) return;
    const dependencies = new Map(parentDeps);

    for (const dep of node.dependencies.values()) if (!node.peerNames.has(dep.name)) dependencies.set(dep.name, dep);

    for (const origDep of node.originalDependencies.values()) {
      const dep = dependencies.get(origDep.name);

      const prettyPrintTreePath = () => `${Array.from(parents).concat([node]).map(x => prettyPrintLocator(x.locator)).join(``)}`;

      if (node.peerNames.has(origDep.name)) {
        const parentDep = parentDeps.get(origDep.name);

        if (parentDep !== dep || !parentDep || parentDep.ident !== origDep.ident) {
          log.push(`${prettyPrintTreePath()} - broken peer promise: expected ${origDep.ident} but found ${parentDep ? parentDep.ident : parentDep}`);
        }
      } else {
        if (!dep) {
          log.push(`${prettyPrintTreePath()} - broken require promise: no required dependency ${origDep.locator} found`);
        } else if (dep.ident !== origDep.ident) {
          log.push(`${prettyPrintTreePath()} - broken require promise for ${origDep.name}: expected ${origDep.ident}, but found: ${dep.ident}`);
        }
      }
    }

    parents.add(node);

    for (const dep of node.dependencies.values()) {
      if (!node.peerNames.has(dep.name)) {
        checkNode(dep, dependencies);
      }
    }

    parents.delete(node);
  };

  checkNode(tree, tree.dependencies);
  return log.join(`\n`);
};
/**
 * Creates a clone of package tree with extra fields used for hoisting purposes.
 *
 * @param tree package tree clone
 */


const cloneTree = (tree, options) => {
  const {
    identName,
    name,
    reference,
    peerNames
  } = tree;
  const treeCopy = {
    name,
    references: new Set([reference]),
    locator: makeLocator(identName, reference),
    ident: makeIdent(identName, reference),
    dependencies: new Map(),
    originalDependencies: new Map(),
    hoistedDependencies: new Map(),
    peerNames: new Set(peerNames),
    reasons: new Map(),
    decoupled: true,
    isHoistBorder: true
  };
  const seenNodes = new Map([[tree, treeCopy]]);

  const addNode = (node, parentNode) => {
    let workNode = seenNodes.get(node);
    const isSeen = !!workNode;

    if (!workNode) {
      const {
        name,
        identName,
        reference,
        peerNames
      } = node;
      const dependenciesNmHoistingLimits = options.hoistingLimits.get(parentNode.locator);
      workNode = {
        name,
        references: new Set([reference]),
        locator: makeLocator(identName, reference),
        ident: makeIdent(identName, reference),
        dependencies: new Map(),
        originalDependencies: new Map(),
        hoistedDependencies: new Map(),
        peerNames: new Set(peerNames),
        reasons: new Map(),
        decoupled: true,
        isHoistBorder: dependenciesNmHoistingLimits ? dependenciesNmHoistingLimits.has(name) : false
      };
      seenNodes.set(node, workNode);
    }

    parentNode.dependencies.set(node.name, workNode);
    parentNode.originalDependencies.set(node.name, workNode);

    if (!isSeen) {
      for (const dep of node.dependencies) {
        addNode(dep, workNode);
      }
    } else {
      const seenCoupledNodes = new Set();

      const markNodeCoupled = node => {
        if (seenCoupledNodes.has(node)) return;
        seenCoupledNodes.add(node);
        node.decoupled = false;

        for (const dep of node.dependencies.values()) {
          if (!node.peerNames.has(dep.name)) {
            markNodeCoupled(dep);
          }
        }
      };

      markNodeCoupled(workNode);
    }
  };

  for (const dep of tree.dependencies) addNode(dep, treeCopy);

  return treeCopy;
};

const getIdentName = locator => locator.substring(0, locator.indexOf(`@`, 1));
/**
 * Creates a clone of hoisted package tree with extra fields removed
 *
 * @param tree stripped down hoisted package tree clone
 */


const shrinkTree = tree => {
  const treeCopy = {
    name: tree.name,
    identName: getIdentName(tree.locator),
    references: new Set(tree.references),
    dependencies: new Set()
  };
  const seenNodes = new Set([tree]);

  const addNode = (node, parentWorkNode, parentNode) => {
    const isSeen = seenNodes.has(node);
    let resultNode;

    if (parentWorkNode === node) {
      resultNode = parentNode;
    } else {
      const {
        name,
        references,
        locator
      } = node;
      resultNode = {
        name,
        identName: getIdentName(locator),
        references,
        dependencies: new Set()
      };
    }

    parentNode.dependencies.add(resultNode);

    if (!isSeen) {
      seenNodes.add(node);

      for (const dep of node.dependencies.values()) {
        if (!node.peerNames.has(dep.name)) {
          addNode(dep, node, resultNode);
        }
      }

      seenNodes.delete(node);
    }
  };

  for (const dep of tree.dependencies.values()) addNode(dep, tree, treeCopy);

  return treeCopy;
};
/**
 * Builds mapping, where key is an alias + dependent package ident and the value is the list of
 * parent package idents who depend on this package.
 *
 * @param rootNode package tree root node
 *
 * @returns preference map
 */


const buildPreferenceMap = rootNode => {
  const preferenceMap = new Map();
  const seenNodes = new Set([rootNode]);

  const getPreferenceKey = node => `${node.name}@${node.ident}`;

  const getOrCreatePreferenceEntry = node => {
    const key = getPreferenceKey(node);
    let entry = preferenceMap.get(key);

    if (!entry) {
      entry = {
        dependents: new Set(),
        peerDependents: new Set()
      };
      preferenceMap.set(key, entry);
    }

    return entry;
  };

  const addDependent = (dependent, node) => {
    const isSeen = !!seenNodes.has(node);
    const entry = getOrCreatePreferenceEntry(node);
    entry.dependents.add(dependent.ident);

    if (!isSeen) {
      seenNodes.add(node);

      for (const dep of node.dependencies.values()) {
        if (node.peerNames.has(dep.name)) {
          const entry = getOrCreatePreferenceEntry(dep);
          entry.peerDependents.add(node.ident);
        } else {
          addDependent(node, dep);
        }
      }
    }
  };

  for (const dep of rootNode.dependencies.values()) if (!rootNode.peerNames.has(dep.name)) addDependent(rootNode, dep);

  return preferenceMap;
};

const prettyPrintLocator = locator => {
  const idx = locator.indexOf(`@`, 1);
  const name = locator.substring(0, idx);
  const reference = locator.substring(idx + 1);

  if (reference === `workspace:.`) {
    return `.`;
  } else if (!reference) {
    return `${name}`;
  } else {
    const version = (reference.indexOf(`#`) > 0 ? reference.split(`#`)[1] : reference).replace(`npm:`, ``);

    if (reference.startsWith(`virtual`)) {
      return `v:${name}@${version}`;
    } else {
      return `${name}@${version}`;
    }
  }
};

const MAX_NODES_TO_DUMP = 50000;
/**
 * Pretty-prints dependency tree in the `yarn why`-like format
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param pkg node_modules tree
 *
 * @returns sorted node_modules tree
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars

const dumpDepTree = tree => {
  let nodeCount = 0;

  const dumpPackage = (pkg, parents, prefix = ``) => {
    if (nodeCount > MAX_NODES_TO_DUMP || parents.has(pkg)) return ``;
    nodeCount++;
    const dependencies = Array.from(pkg.dependencies.values());
    let str = ``;
    parents.add(pkg);

    for (let idx = 0; idx < dependencies.length; idx++) {
      const dep = dependencies[idx];

      if (!pkg.peerNames.has(dep.name)) {
        const reason = pkg.reasons.get(dep.name);
        const identName = getIdentName(dep.locator);
        str += `${prefix}${idx < dependencies.length - 1 ? `` : ``}${(parents.has(dep) ? `>` : ``) + (identName !== dep.name ? `a:${dep.name}:` : ``) + prettyPrintLocator(dep.locator) + (reason ? ` ${reason}` : ``)}\n`;
        str += dumpPackage(dep, parents, `${prefix}${idx < dependencies.length - 1 ? ` ` : `  `}`);
      }
    }

    parents.delete(pkg);
    return str;
  };

  const treeDump = dumpPackage(tree, new Set());
  return treeDump + (nodeCount > MAX_NODES_TO_DUMP ? `\nTree is too large, part of the tree has been dunped\n` : ``);
};

/***/ }),
/* 706 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PnpLooseLinker": () => /* binding */ PnpLooseLinker
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(175);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(176);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(341);
/* harmony import */ var _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(684);
/* harmony import */ var _yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(704);
/* harmony import */ var _yarnpkg_pnp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(686);






class PnpLooseLinker extends _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_1__.PnpLinker {
  constructor() {
    super(...arguments);
    this.mode = `loose`;
  }

  makeInstaller(opts) {
    return new PnpLooseInstaller(opts);
  }

}

class PnpLooseInstaller extends _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_1__.PnpInstaller {
  constructor() {
    super(...arguments);
    this.mode = `loose`;
  }

  async finalizeInstallWithPnp(pnpSettings) {
    if (this.opts.project.configuration.get(`pnpMode`) !== this.mode) return undefined;
    const defaultFsLayer = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.VirtualFS({
      baseFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ZipOpenFS({
        libzip: await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)(),
        maxOpenFiles: 80,
        readOnlyArchives: true
      })
    });
    const pnp = (0,_yarnpkg_pnp__WEBPACK_IMPORTED_MODULE_2__.makeRuntimeApi)(pnpSettings, this.opts.project.cwd, defaultFsLayer);
    const nmTree = (0,_yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_5__.buildNodeModulesTree)(pnp, {
      pnpifyFs: false,
      project: this.opts.project
    });
    const fallbackPool = new Map();
    pnpSettings.fallbackPool = fallbackPool;

    const registerFallback = (name, entry) => {
      const locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.parseLocator(entry.locator);
      const identStr = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.stringifyIdent(locator);

      if (identStr === name) {
        fallbackPool.set(name, locator.reference);
      } else {
        fallbackPool.set(name, [identStr, locator.reference]);
      }
    };

    const root = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(this.opts.project.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.Filename.nodeModules);
    const entry = nmTree.get(root);
    if (typeof entry === `undefined`) throw new Error(`Assertion failed: Expected a root junction point`);
    if (`target` in entry) throw new Error(`Assertion failed: Expected the root junction point to be a directory`);

    for (const childName of entry.dirList) {
      const childP = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(root, childName);
      const child = nmTree.get(childP);
      if (typeof child === `undefined`) throw new Error(`Assertion failed: Expected the child to have been registered`);

      if (`target` in child) {
        registerFallback(childName, child);
      } else {
        for (const subChildName of child.dirList) {
          const subChildP = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(childP, subChildName);
          const subChild = nmTree.get(subChildP);
          if (typeof subChild === `undefined`) throw new Error(`Assertion failed: Expected the subchild to have been registered`);

          if (`target` in subChild) {
            registerFallback(`${childName}/${subChildName}`, subChild);
          } else {
            throw new Error(`Assertion failed: Expected the leaf junction to be a package`);
          }
        }
      }
    }

    return super.finalizeInstallWithPnp(pnpSettings);
  }

}

/***/ }),
/* 707 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "npmConfigUtils": () => /* reexport module object */ _npmConfigUtils__WEBPACK_IMPORTED_MODULE_5__,
/* harmony export */   "npmHttpUtils": () => /* reexport module object */ _npmHttpUtils__WEBPACK_IMPORTED_MODULE_6__,
/* harmony export */   "npmPublishUtils": () => /* reexport module object */ _npmPublishUtils__WEBPACK_IMPORTED_MODULE_7__,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(181);
/* harmony import */ var _NpmHttpFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(708);
/* harmony import */ var _NpmRemapResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(712);
/* harmony import */ var _NpmSemverFetcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(713);
/* harmony import */ var _NpmSemverResolver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(714);
/* harmony import */ var _NpmTagResolver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(715);
/* harmony import */ var _npmConfigUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(710);
/* harmony import */ var _npmHttpUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(709);
/* harmony import */ var _npmPublishUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(716);












const authSettings = {
  npmAlwaysAuth: {
    description: `URL of the selected npm registry (note: npm enterprise isn't supported)`,
    type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.SettingsType.BOOLEAN,
    default: false
  },
  npmAuthIdent: {
    description: `Authentication identity for the npm registry (_auth in npm and yarn v1)`,
    type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.SettingsType.SECRET,
    default: null
  },
  npmAuthToken: {
    description: `Authentication token for the npm registry (_authToken in npm and yarn v1)`,
    type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.SettingsType.SECRET,
    default: null
  }
};
const registrySettings = {
  npmPublishRegistry: {
    description: `Registry to push packages to`,
    type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.SettingsType.STRING,
    default: null
  },
  npmRegistryServer: {
    description: `URL of the selected npm registry (note: npm enterprise isn't supported)`,
    type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.SettingsType.STRING,
    default: `https://registry.yarnpkg.com`
  }
};
const plugin = {
  configuration: { ...authSettings,
    ...registrySettings,
    npmScopes: {
      description: `Settings per package scope`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.SettingsType.MAP,
      valueDefinition: {
        description: ``,
        type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.SettingsType.SHAPE,
        properties: { ...authSettings,
          ...registrySettings
        }
      }
    },
    npmRegistries: {
      description: `Settings per registry`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.SettingsType.MAP,
      normalizeKeys: _npmConfigUtils__WEBPACK_IMPORTED_MODULE_5__.normalizeRegistry,
      valueDefinition: {
        description: ``,
        type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.SettingsType.SHAPE,
        properties: { ...authSettings
        }
      }
    }
  },
  fetchers: [_NpmHttpFetcher__WEBPACK_IMPORTED_MODULE_0__.NpmHttpFetcher, _NpmSemverFetcher__WEBPACK_IMPORTED_MODULE_2__.NpmSemverFetcher],
  resolvers: [_NpmRemapResolver__WEBPACK_IMPORTED_MODULE_1__.NpmRemapResolver, _NpmSemverResolver__WEBPACK_IMPORTED_MODULE_3__.NpmSemverResolver, _NpmTagResolver__WEBPACK_IMPORTED_MODULE_4__.NpmTagResolver]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 708 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmHttpFetcher": () => /* binding */ NpmHttpFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(380);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(711);
/* harmony import */ var _npmHttpUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(709);




class NpmHttpFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_2__.PROTOCOL)) return false;
    const {
      selector,
      params
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.parseRange(locator.reference);
    if (!semver__WEBPACK_IMPORTED_MODULE_0___default().valid(selector)) return false;
    if (params === null || typeof params.__archiveUrl !== `string`) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote server`),
      loader: () => this.fetchFromNetwork(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.getIdentVendorPath(locator),
      checksum
    };
  }

  async fetchFromNetwork(locator, opts) {
    const {
      params
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.parseRange(locator.reference);
    if (params === null || typeof params.__archiveUrl !== `string`) throw new Error(`Assertion failed: The archiveUrl querystring parameter should have been available`);
    const sourceBuffer = await _npmHttpUtils__WEBPACK_IMPORTED_MODULE_1__.get(params.__archiveUrl, {
      configuration: opts.project.configuration,
      ident: locator
    });
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.convertToZip(sourceBuffer, {
      compressionLevel: opts.project.configuration.get(`compressionLevel`),
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.getIdentVendorPath(locator),
      stripComponents: 1
    });
  }

}

/***/ }),
/* 709 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AuthType": () => /* binding */ AuthType,
/* harmony export */   "handleInvalidAuthenticationError": () => /* binding */ handleInvalidAuthenticationError,
/* harmony export */   "getIdentUrl": () => /* binding */ getIdentUrl,
/* harmony export */   "get": () => /* binding */ get,
/* harmony export */   "post": () => /* binding */ post,
/* harmony export */   "put": () => /* binding */ put,
/* harmony export */   "del": () => /* binding */ del
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(180);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(556);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(enquirer__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(247);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _npmConfigUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(710);





var AuthType;

(function (AuthType) {
  AuthType[AuthType["NO_AUTH"] = 0] = "NO_AUTH";
  AuthType[AuthType["BEST_EFFORT"] = 1] = "BEST_EFFORT";
  AuthType[AuthType["CONFIGURATION"] = 2] = "CONFIGURATION";
  AuthType[AuthType["ALWAYS_AUTH"] = 3] = "ALWAYS_AUTH";
})(AuthType || (AuthType = {}));
/**
 * Consumes all 401 Unauthorized errors and reports them as `AUTHENTICATION_INVALID`.
 *
 * It doesn't handle 403 Forbidden, as the npm registry uses it when the user attempts
 * a prohibited action, such as publishing a package with a similar name to an existing package.
 */


async function handleInvalidAuthenticationError(error, {
  attemptedAs,
  registry,
  headers,
  configuration
}) {
  if (error.name === `HTTPError` && error.response.statusCode === 401) {
    throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.MessageName.AUTHENTICATION_INVALID, `Invalid authentication (${typeof attemptedAs !== `string` ? `as ${await whoami(registry, headers, {
      configuration
    })}` : `attempted as ${attemptedAs}`})`);
  }
}
function getIdentUrl(ident) {
  if (ident.scope) {
    return `/@${ident.scope}%2f${ident.name}`;
  } else {
    return `/${ident.name}`;
  }
}
async function get(path, {
  configuration,
  headers,
  ident,
  authType,
  registry,
  ...rest
}) {
  if (ident && typeof registry === `undefined`) registry = _npmConfigUtils__WEBPACK_IMPORTED_MODULE_2__.getScopeRegistry(ident.scope, {
    configuration
  });
  if (ident && ident.scope && typeof authType === `undefined`) authType = AuthType.BEST_EFFORT;
  if (typeof registry !== `string`) throw new Error(`Assertion failed: The registry should be a string`);
  const auth = getAuthenticationHeader(registry, {
    authType,
    configuration,
    ident
  });
  if (auth) headers = { ...headers,
    authorization: auth
  };
  let url;

  try {
    url = new url__WEBPACK_IMPORTED_MODULE_1__.URL(path);
  } catch (e) {
    url = new url__WEBPACK_IMPORTED_MODULE_1__.URL(registry + path);
  }

  try {
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.get(url.href, {
      configuration,
      headers,
      ...rest
    });
  } catch (error) {
    await handleInvalidAuthenticationError(error, {
      registry,
      configuration,
      headers
    });
    throw error;
  }
}
async function post(path, body, {
  attemptedAs,
  configuration,
  headers,
  ident,
  authType = AuthType.ALWAYS_AUTH,
  registry,
  ...rest
}) {
  if (ident && typeof registry === `undefined`) registry = _npmConfigUtils__WEBPACK_IMPORTED_MODULE_2__.getScopeRegistry(ident.scope, {
    configuration
  });
  if (typeof registry !== `string`) throw new Error(`Assertion failed: The registry should be a string`);
  const auth = getAuthenticationHeader(registry, {
    authType,
    configuration,
    ident
  });
  if (auth) headers = { ...headers,
    authorization: auth
  };

  try {
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.post(registry + path, body, {
      configuration,
      headers,
      ...rest
    });
  } catch (error) {
    if (!isOtpError(error)) {
      await handleInvalidAuthenticationError(error, {
        attemptedAs,
        registry,
        configuration,
        headers
      });
      throw error;
    }

    const otp = await askForOtp();
    const headersWithOtp = { ...headers,
      ...getOtpHeaders(otp)
    }; // Retrying request with OTP

    try {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.post(`${registry}${path}`, body, {
        configuration,
        headers: headersWithOtp,
        ...rest
      });
    } catch (error) {
      await handleInvalidAuthenticationError(error, {
        attemptedAs,
        registry,
        configuration,
        headers
      });
      throw error;
    }
  }
}
async function put(path, body, {
  attemptedAs,
  configuration,
  headers,
  ident,
  authType = AuthType.ALWAYS_AUTH,
  registry,
  ...rest
}) {
  if (ident && typeof registry === `undefined`) registry = _npmConfigUtils__WEBPACK_IMPORTED_MODULE_2__.getScopeRegistry(ident.scope, {
    configuration
  });
  if (typeof registry !== `string`) throw new Error(`Assertion failed: The registry should be a string`);
  const auth = getAuthenticationHeader(registry, {
    authType,
    configuration,
    ident
  });
  if (auth) headers = { ...headers,
    authorization: auth
  };

  try {
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.put(registry + path, body, {
      configuration,
      headers,
      ...rest
    });
  } catch (error) {
    if (!isOtpError(error)) {
      await handleInvalidAuthenticationError(error, {
        attemptedAs,
        registry,
        configuration,
        headers
      });
      throw error;
    }

    const otp = await askForOtp();
    const headersWithOtp = { ...headers,
      ...getOtpHeaders(otp)
    }; // Retrying request with OTP

    try {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.put(`${registry}${path}`, body, {
        configuration,
        headers: headersWithOtp,
        ...rest
      });
    } catch (error) {
      await handleInvalidAuthenticationError(error, {
        attemptedAs,
        registry,
        configuration,
        headers
      });
      throw error;
    }
  }
}
async function del(path, {
  attemptedAs,
  configuration,
  headers,
  ident,
  authType = AuthType.ALWAYS_AUTH,
  registry,
  ...rest
}) {
  if (ident && typeof registry === `undefined`) registry = _npmConfigUtils__WEBPACK_IMPORTED_MODULE_2__.getScopeRegistry(ident.scope, {
    configuration
  });
  if (typeof registry !== `string`) throw new Error(`Assertion failed: The registry should be a string`);
  const auth = getAuthenticationHeader(registry, {
    authType,
    configuration,
    ident
  });
  if (auth) headers = { ...headers,
    authorization: auth
  };

  try {
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.del(registry + path, {
      configuration,
      headers,
      ...rest
    });
  } catch (error) {
    if (!isOtpError(error)) {
      await handleInvalidAuthenticationError(error, {
        attemptedAs,
        registry,
        configuration,
        headers
      });
      throw error;
    }

    const otp = await askForOtp();
    const headersWithOtp = { ...headers,
      ...getOtpHeaders(otp)
    }; // Retrying request with OTP

    try {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.del(`${registry}${path}`, {
        configuration,
        headers: headersWithOtp,
        ...rest
      });
    } catch (error) {
      await handleInvalidAuthenticationError(error, {
        attemptedAs,
        registry,
        configuration,
        headers
      });
      throw error;
    }
  }
}

function getAuthenticationHeader(registry, {
  authType = AuthType.CONFIGURATION,
  configuration,
  ident
}) {
  const effectiveConfiguration = _npmConfigUtils__WEBPACK_IMPORTED_MODULE_2__.getAuthConfiguration(registry, {
    configuration,
    ident
  });
  const mustAuthenticate = shouldAuthenticate(effectiveConfiguration, authType);
  if (!mustAuthenticate) return null;
  if (effectiveConfiguration.get(`npmAuthToken`)) return `Bearer ${effectiveConfiguration.get(`npmAuthToken`)}`;
  if (effectiveConfiguration.get(`npmAuthIdent`)) return `Basic ${effectiveConfiguration.get(`npmAuthIdent`)}`;

  if (mustAuthenticate && authType !== AuthType.BEST_EFFORT) {
    throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.MessageName.AUTHENTICATION_NOT_FOUND, `No authentication configured for request`);
  } else {
    return null;
  }
}

function shouldAuthenticate(authConfiguration, authType) {
  switch (authType) {
    case AuthType.CONFIGURATION:
      return authConfiguration.get(`npmAlwaysAuth`);

    case AuthType.BEST_EFFORT:
    case AuthType.ALWAYS_AUTH:
      return true;

    case AuthType.NO_AUTH:
      return false;

    default:
      throw new Error(`Unreachable`);
  }
}

async function whoami(registry, headers, {
  configuration
}) {
  var _a;

  if (typeof headers === `undefined` || typeof headers.authorization === `undefined`) return `an anonymous user`;

  try {
    const response = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.get(new url__WEBPACK_IMPORTED_MODULE_1__.URL(`${registry}/-/whoami`).href, {
      configuration,
      headers,
      jsonResponse: true
    });
    return (_a = response.username) !== null && _a !== void 0 ? _a : `an unknown user`;
  } catch (_b) {
    return `an unknown user`;
  }
}

async function askForOtp() {
  if (process.env.TEST_ENV) return process.env.TEST_NPM_2FA_TOKEN || ``;
  const {
    otp
  } = await (0,enquirer__WEBPACK_IMPORTED_MODULE_0__.prompt)({
    type: `password`,
    name: `otp`,
    message: `One-time password:`,
    required: true,
    onCancel: () => process.exit(130)
  });
  return otp;
}

function isOtpError(error) {
  if (error.name !== `HTTPError`) return false;

  try {
    const authMethods = error.response.headers[`www-authenticate`].split(/,\s*/).map(s => s.toLowerCase());
    return authMethods.includes(`otp`);
  } catch (e) {
    return false;
  }
}

function getOtpHeaders(otp) {
  return {
    [`npm-otp`]: otp
  };
}

/***/ }),
/* 710 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RegistryType": () => /* binding */ RegistryType,
/* harmony export */   "normalizeRegistry": () => /* binding */ normalizeRegistry,
/* harmony export */   "getPublishRegistry": () => /* binding */ getPublishRegistry,
/* harmony export */   "getScopeRegistry": () => /* binding */ getScopeRegistry,
/* harmony export */   "getDefaultRegistry": () => /* binding */ getDefaultRegistry,
/* harmony export */   "getRegistryConfiguration": () => /* binding */ getRegistryConfiguration,
/* harmony export */   "getScopeConfiguration": () => /* binding */ getScopeConfiguration,
/* harmony export */   "getAuthConfiguration": () => /* binding */ getAuthConfiguration
/* harmony export */ });
var RegistryType;

(function (RegistryType) {
  RegistryType["FETCH_REGISTRY"] = "npmRegistryServer";
  RegistryType["PUBLISH_REGISTRY"] = "npmPublishRegistry";
})(RegistryType || (RegistryType = {}));

function normalizeRegistry(registry) {
  return registry.replace(/\/$/, ``);
}
function getPublishRegistry(manifest, {
  configuration
}) {
  if (manifest.publishConfig && manifest.publishConfig.registry) return normalizeRegistry(manifest.publishConfig.registry);
  if (manifest.name) return getScopeRegistry(manifest.name.scope, {
    configuration,
    type: RegistryType.PUBLISH_REGISTRY
  });
  return getDefaultRegistry({
    configuration,
    type: RegistryType.PUBLISH_REGISTRY
  });
}
function getScopeRegistry(scope, {
  configuration,
  type = RegistryType.FETCH_REGISTRY
}) {
  const scopeConfiguration = getScopeConfiguration(scope, {
    configuration
  });
  if (scopeConfiguration === null) return getDefaultRegistry({
    configuration,
    type
  });
  const scopeRegistry = scopeConfiguration.get(type);
  if (scopeRegistry === null) return getDefaultRegistry({
    configuration,
    type
  });
  return normalizeRegistry(scopeRegistry);
}
function getDefaultRegistry({
  configuration,
  type = RegistryType.FETCH_REGISTRY
}) {
  const defaultRegistry = configuration.get(type);
  if (defaultRegistry !== null) return normalizeRegistry(defaultRegistry);
  return normalizeRegistry(configuration.get(RegistryType.FETCH_REGISTRY));
}
function getRegistryConfiguration(registry, {
  configuration
}) {
  const registryConfigurations = configuration.get(`npmRegistries`);
  const exactEntry = registryConfigurations.get(registry);
  if (typeof exactEntry !== `undefined`) return exactEntry;
  const noProtocolEntry = registryConfigurations.get(registry.replace(/^[a-z]+:/, ``));
  if (typeof noProtocolEntry !== `undefined`) return noProtocolEntry;
  return null;
}
function getScopeConfiguration(scope, {
  configuration
}) {
  if (scope === null) return null;
  const scopeConfigurations = configuration.get(`npmScopes`);
  const scopeConfiguration = scopeConfigurations.get(scope);
  if (!scopeConfiguration) return null;
  return scopeConfiguration;
}
function getAuthConfiguration(registry, {
  configuration,
  ident
}) {
  const scopeConfiguration = ident && getScopeConfiguration(ident.scope, {
    configuration
  });
  if ((scopeConfiguration === null || scopeConfiguration === void 0 ? void 0 : scopeConfiguration.get(`npmAuthIdent`)) || (scopeConfiguration === null || scopeConfiguration === void 0 ? void 0 : scopeConfiguration.get(`npmAuthToken`))) return scopeConfiguration;
  const registryConfiguration = getRegistryConfiguration(registry, {
    configuration
  });
  return registryConfiguration || configuration;
}

/***/ }),
/* 711 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PROTOCOL": () => /* binding */ PROTOCOL
/* harmony export */ });
const PROTOCOL = `npm:`;

/***/ }),
/* 712 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmRemapResolver": () => /* binding */ NpmRemapResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(711);


class NpmRemapResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) return false;
    if (!_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.tryParseDescriptor(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL.length), true)) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    // Once transformed into locators, the descriptors are resolved by the NpmSemverResolver
    return false;
  }

  shouldPersistResolution(locator, opts) {
    // Once transformed into locators, the descriptors are resolved by the NpmSemverResolver
    throw new Error(`Unreachable`);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    const nextDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.parseDescriptor(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL.length), true);
    return opts.resolver.getResolutionDependencies(nextDescriptor, opts);
  }

  async getCandidates(descriptor, dependencies, opts) {
    const nextDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.parseDescriptor(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL.length), true);
    return await opts.resolver.getCandidates(nextDescriptor, dependencies, opts);
  }

  async getSatisfying(descriptor, references, opts) {
    const nextDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.parseDescriptor(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL.length), true);
    return opts.resolver.getSatisfying(nextDescriptor, references, opts);
  }

  resolve(locator, opts) {
    // Once transformed into locators, the descriptors are resolved by the NpmSemverResolver
    throw new Error(`Unreachable`);
  }

}

/***/ }),
/* 713 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmSemverFetcher": () => /* binding */ NpmSemverFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(380);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(180);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(247);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(711);
/* harmony import */ var _npmConfigUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(710);
/* harmony import */ var _npmHttpUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(709);







class NpmSemverFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_4__.PROTOCOL)) return false;
    const url = new url__WEBPACK_IMPORTED_MODULE_1__.URL(locator.reference);
    if (!semver__WEBPACK_IMPORTED_MODULE_0___default().valid(url.pathname)) return false;
    if (url.searchParams.has(`__archiveUrl`)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote registry`),
      loader: () => this.fetchFromNetwork(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.getIdentVendorPath(locator),
      checksum
    };
  }

  async fetchFromNetwork(locator, opts) {
    let sourceBuffer;

    try {
      sourceBuffer = await _npmHttpUtils__WEBPACK_IMPORTED_MODULE_3__.get(NpmSemverFetcher.getLocatorUrl(locator), {
        configuration: opts.project.configuration,
        ident: locator
      });
    } catch (error) {
      // The npm registry doesn't always support %2f when fetching the package tarballs 
      // OK: https://registry.yarnpkg.com/@emotion%2fbabel-preset-css-prop/-/babel-preset-css-prop-10.0.7.tgz
      // KO: https://registry.yarnpkg.com/@xtuc%2fieee754/-/ieee754-1.2.0.tgz
      sourceBuffer = await _npmHttpUtils__WEBPACK_IMPORTED_MODULE_3__.get(NpmSemverFetcher.getLocatorUrl(locator).replace(/%2f/g, `/`), {
        configuration: opts.project.configuration,
        ident: locator
      });
    }

    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.convertToZip(sourceBuffer, {
      compressionLevel: opts.project.configuration.get(`compressionLevel`),
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.getIdentVendorPath(locator),
      stripComponents: 1
    });
  }

  static isConventionalTarballUrl(locator, url, {
    configuration
  }) {
    let registry = _npmConfigUtils__WEBPACK_IMPORTED_MODULE_2__.getScopeRegistry(locator.scope, {
      configuration
    });
    const path = NpmSemverFetcher.getLocatorUrl(locator); // From time to time the npm registry returns http urls instead of https 

    url = url.replace(/^https?:(\/\/(?:[^/]+\.)?npmjs.org(?:$|\/))/, `https:$1`); // The yarnpkg and npmjs registries are interchangeable for that matter, so we uniformize them

    registry = registry.replace(/^https:\/\/registry\.npmjs\.org($|\/)/, `https://registry.yarnpkg.com$1`);
    url = url.replace(/^https:\/\/registry\.npmjs\.org($|\/)/, `https://registry.yarnpkg.com$1`);
    if (url === registry + path) return true;
    if (url === registry + path.replace(/%2f/g, `/`)) return true;
    return false;
  }

  static getLocatorUrl(locator) {
    const version = semver__WEBPACK_IMPORTED_MODULE_0___default().clean(locator.reference.slice(_constants__WEBPACK_IMPORTED_MODULE_4__.PROTOCOL.length));
    if (version === null) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
    return `${_npmHttpUtils__WEBPACK_IMPORTED_MODULE_3__.getIdentUrl(locator)}/-/${locator.name}-${version}.tgz`;
  }

}

/***/ }),
/* 714 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmSemverResolver": () => /* binding */ NpmSemverResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(231);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(179);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _NpmSemverFetcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(713);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(711);
/* harmony import */ var _npmHttpUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(709);








const NODE_GYP_IDENT = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.makeIdent(null, `node-gyp`);
const NODE_GYP_MATCH = /\b(node-gyp|prebuild-install)\b/;
class NpmSemverResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_4__.PROTOCOL)) return false;
    return !!_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.validRange(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_4__.PROTOCOL.length));
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_4__.PROTOCOL)) return false;
    const {
      selector
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.parseRange(locator.reference);
    if (!semver__WEBPACK_IMPORTED_MODULE_0___default().valid(selector)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return true;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const range = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.validRange(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_4__.PROTOCOL.length));
    if (range === null) throw new Error(`Expected a valid range, got ${descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_4__.PROTOCOL.length)}`);
    const registryData = await _npmHttpUtils__WEBPACK_IMPORTED_MODULE_2__.get(_npmHttpUtils__WEBPACK_IMPORTED_MODULE_2__.getIdentUrl(descriptor), {
      configuration: opts.project.configuration,
      ident: descriptor,
      jsonResponse: true
    });
    const candidates = Object.keys(registryData.versions).map(version => new (semver__WEBPACK_IMPORTED_MODULE_0___default().SemVer)(version)).filter(version => range.test(version));
    const noDeprecatedCandidates = candidates.filter(version => {
      return !registryData.versions[version.raw].deprecated;
    }); // If there are versions that aren't deprecated, use them

    const finalCandidates = noDeprecatedCandidates.length > 0 ? noDeprecatedCandidates : candidates;
    finalCandidates.sort((a, b) => {
      return -a.compare(b);
    });
    return finalCandidates.map(version => {
      const versionLocator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.makeLocator(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_4__.PROTOCOL}${version.raw}`);
      const archiveUrl = registryData.versions[version.raw].dist.tarball;

      if (_NpmSemverFetcher__WEBPACK_IMPORTED_MODULE_1__.NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, {
        configuration: opts.project.configuration
      })) {
        return versionLocator;
      } else {
        return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.bindLocator(versionLocator, {
          __archiveUrl: archiveUrl
        });
      }
    });
  }

  async getSatisfying(descriptor, references, opts) {
    const range = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.validRange(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_4__.PROTOCOL.length));
    if (range === null) throw new Error(`Expected a valid range, got ${descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_4__.PROTOCOL.length)}`);
    return references.map(reference => {
      try {
        return new (semver__WEBPACK_IMPORTED_MODULE_0___default().SemVer)(reference.slice(_constants__WEBPACK_IMPORTED_MODULE_4__.PROTOCOL.length));
      } catch (_a) {
        return null;
      }
    }).filter(version => version !== null).filter(version => range.test(version)).sort((a, b) => -a.compare(b)).map(version => _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.makeLocator(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_4__.PROTOCOL}${version.raw}`));
  }

  async resolve(locator, opts) {
    const {
      selector
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.parseRange(locator.reference);
    const version = semver__WEBPACK_IMPORTED_MODULE_0___default().clean(selector);
    if (version === null) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
    const registryData = await _npmHttpUtils__WEBPACK_IMPORTED_MODULE_2__.get(_npmHttpUtils__WEBPACK_IMPORTED_MODULE_2__.getIdentUrl(locator), {
      configuration: opts.project.configuration,
      ident: locator,
      jsonResponse: true
    });
    if (!Object.prototype.hasOwnProperty.call(registryData, `versions`)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);
    if (!Object.prototype.hasOwnProperty.call(registryData.versions, version)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.MessageName.REMOTE_NOT_FOUND, `Registry failed to return reference "${version}"`);
    const manifest = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Manifest();
    manifest.load(registryData.versions[version]); // Manually add node-gyp dependency if there is a script using it and not already set
    // This is because the npm registry will automatically add a `node-gyp rebuild` install script
    // in the metadata if there is not already an install script and a binding.gyp file exists.
    // Also, node-gyp is not always set as a dependency in packages, so it will also be added if used in scripts.

    if (!manifest.dependencies.has(NODE_GYP_IDENT.identHash) && !manifest.peerDependencies.has(NODE_GYP_IDENT.identHash)) {
      for (const value of manifest.scripts.values()) {
        if (value.match(NODE_GYP_MATCH)) {
          manifest.dependencies.set(NODE_GYP_IDENT.identHash, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.makeDescriptor(NODE_GYP_IDENT, `latest`));
          opts.report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.MessageName.NODE_GYP_INJECTED, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.prettyLocator(opts.project.configuration, locator)}: Implicit dependencies on node-gyp are discouraged`);
          break;
        }
      }
    } // Show deprecation warnings


    if (typeof manifest.raw.deprecated === `string`) opts.report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.MessageName.DEPRECATED_PACKAGE, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.prettyLocator(opts.project.configuration, locator)} is deprecated: ${manifest.raw.deprecated}`);
    return { ...locator,
      version,
      languageName: `node`,
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.LinkType.HARD,
      dependencies: manifest.dependencies,
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

/***/ }),
/* 715 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmTagResolver": () => /* binding */ NpmTagResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(230);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/* harmony import */ var _NpmSemverFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(713);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(711);
/* harmony import */ var _npmHttpUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(709);





class NpmTagResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_2__.PROTOCOL)) return false;
    if (!_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.TAG_REGEXP.test(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_2__.PROTOCOL.length))) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    // Once transformed into locators, the tags are resolved by the NpmSemverResolver
    return false;
  }

  shouldPersistResolution(locator, opts) {
    // Once transformed into locators, the tags are resolved by the NpmSemverResolver
    throw new Error(`Unreachable`);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const tag = descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_2__.PROTOCOL.length);
    const registryData = await _npmHttpUtils__WEBPACK_IMPORTED_MODULE_1__.get(_npmHttpUtils__WEBPACK_IMPORTED_MODULE_1__.getIdentUrl(descriptor), {
      configuration: opts.project.configuration,
      ident: descriptor,
      jsonResponse: true
    });
    if (!Object.prototype.hasOwnProperty.call(registryData, `dist-tags`)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.REMOTE_INVALID, `Registry returned invalid data - missing "dist-tags" field`);
    const distTags = registryData[`dist-tags`];
    if (!Object.prototype.hasOwnProperty.call(distTags, tag)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.REMOTE_NOT_FOUND, `Registry failed to return tag "${tag}"`);
    const version = distTags[tag];
    const versionLocator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.makeLocator(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_2__.PROTOCOL}${version}`);
    const archiveUrl = registryData.versions[version].dist.tarball;

    if (_NpmSemverFetcher__WEBPACK_IMPORTED_MODULE_0__.NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, {
      configuration: opts.project.configuration
    })) {
      return [versionLocator];
    } else {
      return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.bindLocator(versionLocator, {
        __archiveUrl: archiveUrl
      })];
    }
  }

  async getSatisfying(descriptor, references, opts) {
    // We can't statically know if a tag resolves to a specific version without using the network
    return null;
  }

  async resolve(locator, opts) {
    // Once transformed into locators (through getCandidates), the tags are resolved by the NpmSemverResolver
    throw new Error(`Unreachable`);
  }

}

/***/ }),
/* 716 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makePublishBody": () => /* binding */ makePublishBody
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_plugin_pack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(717);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ssri__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(731);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(247);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_3__);





async function makePublishBody(workspace, buffer, {
  access,
  tag,
  registry
}) {
  const configuration = workspace.project.configuration;
  const ident = workspace.manifest.name;
  const version = workspace.manifest.version;
  const name = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(ident);
  const shasum = (0,crypto__WEBPACK_IMPORTED_MODULE_1__.createHash)(`sha1`).update(buffer).digest(`hex`);
  const integrity = ssri__WEBPACK_IMPORTED_MODULE_2__.fromData(buffer).toString();

  if (typeof access === `undefined`) {
    if (workspace.manifest.publishConfig && typeof workspace.manifest.publishConfig.access === `string`) {
      access = workspace.manifest.publishConfig.access;
    } else if (configuration.get(`npmPublishAccess`) !== null) {
      access = configuration.get(`npmPublishAccess`);
    } else if (ident.scope) {
      access = `restricted`;
    } else {
      access = `public`;
    }
  }

  const raw = await _yarnpkg_plugin_pack__WEBPACK_IMPORTED_MODULE_0__.packUtils.genPackageManifest(workspace); // This matches Lerna's logic:
  // https://github.com/evocateur/libnpmpublish/blob/latest/publish.js#L142
  // While the npm registry ignores the provided tarball URL, it's used by
  // other registries such as verdaccio.

  const tarballName = `${name}-${version}.tgz`;
  const tarballURL = new url__WEBPACK_IMPORTED_MODULE_3__.URL(`${name}/-/${tarballName}`, registry);
  return {
    _id: name,
    _attachments: {
      [tarballName]: {
        [`content_type`]: `application/octet-stream`,
        data: buffer.toString(`base64`),
        length: buffer.length
      }
    },
    name,
    access,
    [`dist-tags`]: {
      [tag]: version
    },
    versions: {
      [version]: { ...raw,
        _id: `${name}@${version}`,
        name,
        version,
        dist: {
          shasum,
          integrity,
          // the npm registry requires a tarball path, but it seems useless 
          tarball: tarballURL.toString()
        }
      }
    }
  };
}

/***/ }),
/* 717 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "packUtils": () => /* reexport module object */ _packUtils__WEBPACK_IMPORTED_MODULE_1__,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(180);
/* harmony import */ var _commands_pack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(718);
/* harmony import */ var _packUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(730);





const DEPENDENCY_TYPES = [`dependencies`, `devDependencies`, `peerDependencies`];
const WORKSPACE_PROTOCOL = `workspace:`;

const beforeWorkspacePacking = (workspace, rawManifest) => {
  if (rawManifest.publishConfig) {
    if (rawManifest.publishConfig.main) rawManifest.main = rawManifest.publishConfig.main;
    if (rawManifest.publishConfig.browser) rawManifest.browser = rawManifest.publishConfig.browser;
    if (rawManifest.publishConfig.module) rawManifest.module = rawManifest.publishConfig.module;
    if (rawManifest.publishConfig.browser) rawManifest.browser = rawManifest.publishConfig.browser;

    if (rawManifest.publishConfig.bin) {
      rawManifest.bin = rawManifest.publishConfig.bin;
    }
  }

  const project = workspace.project;

  for (const dependencyType of DEPENDENCY_TYPES) {
    for (const descriptor of workspace.manifest.getForScope(dependencyType).values()) {
      const matchingWorkspace = project.tryWorkspaceByDescriptor(descriptor);
      const range = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.parseRange(descriptor.range);
      if (range.protocol !== WORKSPACE_PROTOCOL) continue;

      if (matchingWorkspace === null) {
        if (project.tryWorkspaceByIdent(descriptor) === null) {
          throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.MessageName.WORKSPACE_NOT_FOUND, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.prettyDescriptor(project.configuration, descriptor)}: No local workspace found for this range`);
        }
      } else {
        let versionToWrite; // For workspace:path/to/workspace and workspace:* we look up the workspace version

        if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.areDescriptorsEqual(descriptor, matchingWorkspace.anchoredDescriptor) || range.selector === `*`) versionToWrite = matchingWorkspace.manifest.version;else // for workspace:version we simply strip the protocol
          versionToWrite = range.selector;
        rawManifest[dependencyType][_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyIdent(descriptor)] = versionToWrite;
      }
    }
  }
};

const plugin = {
  hooks: {
    beforeWorkspacePacking
  },
  commands: [_commands_pack__WEBPACK_IMPORTED_MODULE_0__.default]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 718 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PackCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(719);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(335);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(155);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _packUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(730);






const outDescription = `Create the archive at the specified path`; // eslint-disable-next-line arca/no-default-export

class PackCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.installIfNeeded = false;
    this.dryRun = false;
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);

    if (await _packUtils__WEBPACK_IMPORTED_MODULE_2__.hasPackScripts(workspace)) {
      if (this.installIfNeeded) {
        await project.install({
          cache: await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Cache.find(configuration),
          report: new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.ThrowReport()
        });
      } else {
        await project.restoreInstallState();
      }
    }

    const target = typeof this.out !== `undefined` ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(this.context.cwd, interpolateOutputName(this.out, {
      workspace
    })) : _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(workspace.cwd, `package.tgz`);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.StreamReport.start({
      configuration,
      stdout: this.context.stdout,
      json: this.json
    }, async report => {
      await _packUtils__WEBPACK_IMPORTED_MODULE_2__.prepareForPack(workspace, {
        report
      }, async () => {
        report.reportJson({
          base: workspace.cwd
        });
        const files = await _packUtils__WEBPACK_IMPORTED_MODULE_2__.genPackList(workspace);

        for (const file of files) {
          report.reportInfo(null, file);
          report.reportJson({
            location: file
          });
        }

        if (!this.dryRun) {
          const pack = await _packUtils__WEBPACK_IMPORTED_MODULE_2__.genPackStream(workspace, files);
          const write = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.xfs.createWriteStream(target);
          pack.pipe(write);
          await new Promise(resolve => {
            write.on(`finish`, resolve);
          });
        }
      });

      if (!this.dryRun) {
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.UNNAMED, `Package archive generated in ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.pretty(configuration, target, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.Type.PATH)}`);
        report.reportJson({
          output: target
        });
      }
    });
    return report.exitCode();
  }

}
PackCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `generate a tarball from the active workspace`,
  details: `
      This command will turn the active workspace into a compressed archive suitable for publishing. The archive will by default be stored at the root of the workspace (\`package.tgz\`).

      If the \`-o,---out\` is set the archive will be created at the specified path. The \`%s\` and \`%v\` variables can be used within the path and will be respectively replaced by the package name and version.
    `,
  examples: [[`Create an archive from the active workspace`, `yarn pack`], [`List the files that would be made part of the workspace's archive`, `yarn pack --dry-run`], [`Name and output the archive in a dedicated folder`, `yarn pack --out /artifacts/%s-%v.tgz`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--install-if-needed`, {
  description: `Run a preliminary \`yarn install\` if the package contains build scripts`
})], PackCommand.prototype, "installIfNeeded", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-n,--dry-run`, {
  description: `Print the file paths without actually generating the package archive`
})], PackCommand.prototype, "dryRun", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], PackCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--filename`, {
  hidden: false,
  description: outDescription
}), clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`-o,--out`, {
  description: outDescription
})], PackCommand.prototype, "out", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`pack`)], PackCommand.prototype, "execute", null);

function interpolateOutputName(name, {
  workspace
}) {
  const interpolated = name.replace(`%s`, prettyWorkspaceIdent(workspace)).replace(`%v`, prettyWorkspaceVersion(workspace));
  return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath(interpolated);
}

function prettyWorkspaceIdent(workspace) {
  if (workspace.manifest.name !== null) {
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.slugifyIdent(workspace.manifest.name);
  } else {
    return `package`;
  }
}

function prettyWorkspaceVersion(workspace) {
  if (workspace.manifest.version !== null) {
    return workspace.manifest.version;
  } else {
    return `unknown`;
  }
}

/***/ }),
/* 719 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseCommand": () => /* reexport safe */ _tools_BaseCommand__WEBPACK_IMPORTED_MODULE_0__.BaseCommand,
/* harmony export */   "WorkspaceRequiredError": () => /* reexport safe */ _tools_WorkspaceRequiredError__WEBPACK_IMPORTED_MODULE_1__.WorkspaceRequiredError,
/* harmony export */   "getDynamicLibs": () => /* reexport safe */ _tools_getDynamicLibs__WEBPACK_IMPORTED_MODULE_2__.getDynamicLibs,
/* harmony export */   "getPluginConfiguration": () => /* reexport safe */ _tools_getPluginConfiguration__WEBPACK_IMPORTED_MODULE_3__.getPluginConfiguration,
/* harmony export */   "openWorkspace": () => /* reexport safe */ _tools_openWorkspace__WEBPACK_IMPORTED_MODULE_4__.openWorkspace,
/* harmony export */   "main": () => /* reexport safe */ _main__WEBPACK_IMPORTED_MODULE_5__.main,
/* harmony export */   "pluginCommands": () => /* reexport safe */ _pluginCommands__WEBPACK_IMPORTED_MODULE_6__.pluginCommands
/* harmony export */ });
/* harmony import */ var _tools_BaseCommand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(720);
/* harmony import */ var _tools_WorkspaceRequiredError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(721);
/* harmony import */ var _tools_getDynamicLibs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(722);
/* harmony import */ var _tools_getPluginConfiguration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(724);
/* harmony import */ var _tools_openWorkspace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(726);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(727);
/* harmony import */ var _pluginCommands__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(728);








/***/ }),
/* 720 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseCommand": () => /* binding */ BaseCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);


class BaseCommand extends clipanion__WEBPACK_IMPORTED_MODULE_0__.Command {}

(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.String(`--cwd`, {
  hidden: true
})], BaseCommand.prototype, "cwd", void 0);

/***/ }),
/* 721 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WorkspaceRequiredError": () => /* binding */ WorkspaceRequiredError
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(162);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);



class WorkspaceRequiredError extends clipanion__WEBPACK_IMPORTED_MODULE_0__.UsageError {
  constructor(projectCwd, cwd) {
    const relativePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.relative(projectCwd, cwd);
    const manifestPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.join(projectCwd, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Manifest.fileName);
    super(`This command can only be run from within a workspace of your project (${relativePath} isn't a workspace of ${manifestPath}).`);
  }

}

/***/ }),
/* 722 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDynamicLibs": () => /* binding */ getDynamicLibs
/* harmony export */ });
const DYNAMIC_LIBS = [`@yarnpkg/cli`, `@yarnpkg/core`, `@yarnpkg/fslib`, `@yarnpkg/libzip`, `@yarnpkg/parsers`, `@yarnpkg/shell`, // Those ones are always useful
`clipanion`, `semver`, `yup`];
const getDynamicLibs = () => {
  return new Map(DYNAMIC_LIBS.map(name => {
    return [name, __webpack_require__(723)(name)];
  }));
};

/***/ }),
/* 723 */
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => [];
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 723;
module.exports = webpackEmptyContext;

/***/ }),
/* 724 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPluginConfiguration": () => /* binding */ getPluginConfiguration
/* harmony export */ });
/* harmony import */ var _yarnpkg_cli_package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(725);
/* harmony import */ var _getDynamicLibs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(722);
// @ts-expect-error


function getPluginConfiguration() {
  const plugins = new Set();

  for (const dependencyName of _yarnpkg_cli_package_json__WEBPACK_IMPORTED_MODULE_0__[`@yarnpkg/builder`].bundles.standard) plugins.add(dependencyName);

  const modules = (0,_getDynamicLibs__WEBPACK_IMPORTED_MODULE_1__.getDynamicLibs)();

  for (const plugin of plugins) modules.set(plugin, __webpack_require__(723)(plugin).default);

  return {
    plugins,
    modules
  };
}

/***/ }),
/* 725 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"name\":\"@yarnpkg/cli\",\"version\":\"2.3.3\",\"license\":\"BSD-2-Clause\",\"main\":\"./sources/index.ts\",\"dependencies\":{\"@yarnpkg/core\":\"workspace:^2.3.1\",\"@yarnpkg/fslib\":\"workspace:^2.3.0\",\"@yarnpkg/libzip\":\"workspace:^2.2.1\",\"@yarnpkg/parsers\":\"workspace:^2.3.0\",\"@yarnpkg/plugin-compat\":\"workspace:^2.1.2\",\"@yarnpkg/plugin-dlx\":\"workspace:^2.1.3\",\"@yarnpkg/plugin-essentials\":\"workspace:^2.3.2\",\"@yarnpkg/plugin-file\":\"workspace:^2.2.0\",\"@yarnpkg/plugin-git\":\"workspace:^2.2.0\",\"@yarnpkg/plugin-github\":\"workspace:^2.1.1\",\"@yarnpkg/plugin-http\":\"workspace:^2.1.1\",\"@yarnpkg/plugin-init\":\"workspace:^2.2.1\",\"@yarnpkg/plugin-link\":\"workspace:^2.1.1\",\"@yarnpkg/plugin-node-modules\":\"workspace:^2.2.2\",\"@yarnpkg/plugin-npm\":\"workspace:^2.3.0\",\"@yarnpkg/plugin-npm-cli\":\"workspace:^2.2.0\",\"@yarnpkg/plugin-pack\":\"workspace:^2.2.2\",\"@yarnpkg/plugin-patch\":\"workspace:^2.1.2\",\"@yarnpkg/plugin-pnp\":\"workspace:^2.3.1\",\"@yarnpkg/shell\":\"workspace:^2.4.0\",\"chalk\":\"^3.0.0\",\"ci-info\":\"^2.0.0\",\"clipanion\":\"^2.6.2\",\"fromentries\":\"^1.2.0\",\"semver\":\"^7.1.2\",\"tslib\":\"^1.13.0\",\"yup\":\"^0.27.0\"},\"devDependencies\":{\"@types/ci-info\":\"^2\",\"@types/yup\":\"0.26.12\",\"@yarnpkg/builder\":\"workspace:^2.1.2\",\"@yarnpkg/monorepo\":\"workspace:0.0.0\",\"@yarnpkg/pnpify\":\"workspace:^2.3.3\",\"micromatch\":\"^4.0.2\",\"typescript\":\"4.1.0-beta\"},\"peerDependencies\":{\"@yarnpkg/core\":\"^2.3.1\"},\"scripts\":{\"postpack\":\"rm -rf lib\",\"prepack\":\"run build:compile \\\"$(pwd)\\\"\",\"build:cli+hook\":\"run build:pnp:hook && builder build bundle\",\"build:cli\":\"builder build bundle\",\"run:cli\":\"builder run\",\"update-local\":\"run build:cli --no-git-hash && rsync -a --delete bundles/ bin/\"},\"publishConfig\":{\"main\":\"./lib/index.js\",\"types\":\"./lib/index.d.ts\",\"bin\":null},\"files\":[\"/lib/**/*\",\"!/lib/pluginConfiguration.*\",\"!/lib/cli.*\"],\"@yarnpkg/builder\":{\"bundles\":{\"standard\":[\"@yarnpkg/plugin-essentials\",\"@yarnpkg/plugin-compat\",\"@yarnpkg/plugin-dlx\",\"@yarnpkg/plugin-file\",\"@yarnpkg/plugin-git\",\"@yarnpkg/plugin-github\",\"@yarnpkg/plugin-http\",\"@yarnpkg/plugin-init\",\"@yarnpkg/plugin-link\",\"@yarnpkg/plugin-node-modules\",\"@yarnpkg/plugin-npm\",\"@yarnpkg/plugin-npm-cli\",\"@yarnpkg/plugin-pack\",\"@yarnpkg/plugin-patch\",\"@yarnpkg/plugin-pnp\"]}},\"repository\":{\"type\":\"git\",\"url\":\"ssh://git@github.com/yarnpkg/berry.git\"},\"engines\":{\"node\":\">=10.19.0\"}}");

/***/ }),
/* 726 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "openWorkspace": () => /* binding */ openWorkspace
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(254);
/* harmony import */ var _WorkspaceRequiredError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(721);


async function openWorkspace(configuration, cwd) {
  const {
    project,
    workspace
  } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.Project.find(configuration, cwd);
  if (!workspace) throw new _WorkspaceRequiredError__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, cwd);
  return workspace;
}

/***/ }),
/* 727 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "main": () => /* binding */ main
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(231);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(238);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(155);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ci_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var ci_info__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ci_info__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _pluginCommands__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(728);
/* harmony import */ var _tools_WelcomeCommand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(729);









function runBinary(path) {
  const physicalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.fromPortablePath(path);
  process.on(`SIGINT`, () => {// We don't want SIGINT to kill our process; we want it to kill the
    // innermost process, whose end will cause our own to exit.
  });

  if (physicalPath) {
    (0,child_process__WEBPACK_IMPORTED_MODULE_0__.execFileSync)(process.execPath, [physicalPath, ...process.argv.slice(2)], {
      stdio: `inherit`,
      env: { ...process.env,
        YARN_IGNORE_PATH: `1`,
        YARN_IGNORE_CWD: `1`
      }
    });
  } else {
    (0,child_process__WEBPACK_IMPORTED_MODULE_0__.execFileSync)(physicalPath, process.argv.slice(2), {
      stdio: `inherit`,
      env: { ...process.env,
        YARN_IGNORE_PATH: `1`,
        YARN_IGNORE_CWD: `1`
      }
    });
  }
}

async function main({
  binaryVersion,
  pluginConfiguration
}) {
  async function run() {
    const cli = new clipanion__WEBPACK_IMPORTED_MODULE_2__.Cli({
      binaryLabel: `Yarn Package Manager`,
      binaryName: `yarn`,
      binaryVersion
    });
    cli.register(_tools_WelcomeCommand__WEBPACK_IMPORTED_MODULE_5__.WelcomeCommand);

    try {
      await exec(cli);
    } catch (error) {
      process.stdout.write(cli.error(error));
      process.exitCode = 1;
    }
  }

  async function exec(cli) {
    // Non-exhaustive known requirements:
    // - 10.16+ for Brotli support on `plugin-compat`
    // - 10.17+ to silence `got` warning on `dns.promises`
    // - 14.0 and 14.1 empty http responses - https://github.com/sindresorhus/got/issues/1496
    var _a, _b, _c, _d, _e;

    const version = process.versions.node;
    const range = `>=10.17 <14 || >14.1`;
    if (process.env.YARN_IGNORE_NODE !== `1` && !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.satisfiesWithPrereleases(version, range)) throw new clipanion__WEBPACK_IMPORTED_MODULE_2__.UsageError(`This tool requires a Node version compatible with ${range} (got ${version}). Upgrade Node, or set \`YARN_IGNORE_NODE=1\` in your environment.`); // Since we only care about a few very specific settings (yarn-path and ignore-path) we tolerate extra configuration key.
    // If we didn't, we wouldn't even be able to run `yarn config` (which is recommended in the invalid config error message)

    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Configuration.find(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(process.cwd()), pluginConfiguration, {
      usePath: true,
      strict: false
    });
    const yarnPath = configuration.get(`yarnPath`);
    const ignorePath = configuration.get(`ignorePath`);
    const ignoreCwd = configuration.get(`ignoreCwd`); // Avoid unnecessary spawn when run directly

    if (!ignorePath && !ignoreCwd && yarnPath === _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.resolve(process.argv[1]))) {
      process.env.YARN_IGNORE_PATH = `1`;
      process.env.YARN_IGNORE_CWD = `1`;
      await exec(cli);
      return;
    } else if (yarnPath !== null && !ignorePath) {
      if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.xfs.existsSync(yarnPath)) {
        process.stdout.write(cli.error(new Error(`The "yarn-path" option has been set (in ${configuration.sources.get(`yarnPath`)}), but the specified location doesn't exist (${yarnPath}).`)));
        process.exitCode = 1;
      } else {
        try {
          runBinary(yarnPath);
        } catch (error) {
          process.exitCode = error.code || 1;
        }
      }
    } else {
      if (ignorePath) delete process.env.YARN_IGNORE_PATH;
      const isTelemetryEnabled = configuration.get(`enableTelemetry`);
      if (isTelemetryEnabled && !ci_info__WEBPACK_IMPORTED_MODULE_1__.isCI && process.stdout.isTTY) _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Configuration.telemetry = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.TelemetryManager(configuration, `puba9cdc10ec5790a2cf4969dd413a47270`);
      (_a = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Configuration.telemetry) === null || _a === void 0 ? void 0 : _a.reportVersion(binaryVersion);

      for (const [name, plugin] of configuration.plugins.entries()) {
        if (_pluginCommands__WEBPACK_IMPORTED_MODULE_4__.pluginCommands.has((_c = (_b = name.match(/^@yarnpkg\/plugin-(.*)$/)) === null || _b === void 0 ? void 0 : _b[1]) !== null && _c !== void 0 ? _c : ``)) (_d = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Configuration.telemetry) === null || _d === void 0 ? void 0 : _d.reportPluginName(name);

        for (const command of plugin.commands || []) {
          cli.register(command);
        }
      }

      const command = cli.process(process.argv.slice(2));
      if (!command.help) (_e = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Configuration.telemetry) === null || _e === void 0 ? void 0 : _e.reportCommandName(command.path.join(` `)); // @ts-expect-error: The cwd is a global option defined by BaseCommand

      const cwd = command.cwd;

      if (typeof cwd !== `undefined` && !ignoreCwd) {
        const iAmHere = (0,fs__WEBPACK_IMPORTED_MODULE_3__.realpathSync)(process.cwd());
        const iShouldBeHere = (0,fs__WEBPACK_IMPORTED_MODULE_3__.realpathSync)(cwd);

        if (iAmHere !== iShouldBeHere) {
          process.chdir(cwd);
          await run();
          return;
        }
      }

      await cli.runExit(command, {
        cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(process.cwd()),
        plugins: pluginConfiguration,
        quiet: false,
        stdin: process.stdin,
        stdout: process.stdout,
        stderr: process.stderr
      });
    }
  }

  return run().catch(error => {
    process.stdout.write(error.stack || error.message);
    process.exitCode = 1;
  }).finally(() => _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.xfs.rmtempPromise());
}

/***/ }),
/* 728 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pluginCommands": () => /* binding */ pluginCommands
/* harmony export */ });
// Don't modify this script directly! Instead, run:
// yarn build:plugin-commands
const pluginCommands = new Map([[`constraints`, [[`constraints`, `query`], [`constraints`, `source`], [`constraints`]]], [`exec`, []], [`interactive-tools`, [[`search`], [`upgrade-interactive`]]], [`stage`, [[`stage`]]], [`typescript`, []], [`version`, [[`version`, `apply`], [`version`, `check`], [`version`]]], [`workspace-tools`, [[`workspaces`, `focus`], [`workspaces`, `foreach`]]]]);

/***/ }),
/* 729 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WelcomeCommand": () => /* binding */ WelcomeCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _BaseCommand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(720);





const getMessage = configuration => `
${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `Welcome on Yarn 2!`, `bold`)}  Thanks for helping us shape our vision of how projects
should be managed going forward.

Being still in RC, Yarn 2 isn't completely stable yet. Some features might be
missing, and some behaviors may have received major overhaul. In case of doubt,
use the following URLs to get some insight:

  - The changelog:
    ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `https://github.com/yarnpkg/berry/tree/CHANGELOG.md`, `cyan`)}

  - Our issue tracker:
    ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `https://github.com/yarnpkg/berry`, `cyan`)}

  - Our Discord server:
    ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `https://discord.gg/yarnpkg`, `cyan`)}

We're hoping you will enjoy the experience. For now, a good start is to run
the two following commands:

  ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `find . -name node_modules -prune -exec rm -r {} \\;`, `magenta`)}
  ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `yarn install`, `magenta`)}

One last trick! If you need at some point to upgrade Yarn to a nightly build,
the following command will install the CLI straight from master:

  ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.pretty(configuration, `yarn set version from sources`, `magenta`)}

See you later 
`;

class WelcomeCommand extends _BaseCommand__WEBPACK_IMPORTED_MODULE_1__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    this.context.stdout.write(`${getMessage(configuration).trim()}\n`);
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`--welcome`)], WelcomeCommand.prototype, "execute", null);

/***/ }),
/* 730 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasPackScripts": () => /* binding */ hasPackScripts,
/* harmony export */   "prepareForPack": () => /* binding */ prepareForPack,
/* harmony export */   "genPackStream": () => /* binding */ genPackStream,
/* harmony export */   "genPackageManifest": () => /* binding */ genPackageManifest,
/* harmony export */   "genPackList": () => /* binding */ genPackList
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(340);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(171);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var tar_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(381);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(164);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_2__);





const NEVER_IGNORE = [`/package.json`, `/readme`, `/readme.*`, `/license`, `/license.*`, `/licence`, `/licence.*`, `/changelog`, `/changelog.*`];
const ALWAYS_IGNORE = [`/package.tgz`, `.github`, `.git`, `.hg`, `node_modules`, `.npmignore`, `.gitignore`, `.#*`, `.DS_Store`];
async function hasPackScripts(workspace) {
  if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.hasWorkspaceScript(workspace, `prepack`)) return true;
  if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.hasWorkspaceScript(workspace, `postpack`)) return true;
  return false;
}
async function prepareForPack(workspace, {
  report
}, cb) {
  await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.maybeExecuteWorkspaceLifecycleScript(workspace, `prepack`, {
    report
  });

  try {
    await cb();
  } finally {
    await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.maybeExecuteWorkspaceLifecycleScript(workspace, `postpack`, {
      report
    });
  }
}
async function genPackStream(workspace, files) {
  var _a, _b;

  if (typeof files === `undefined`) files = await genPackList(workspace);
  const executableFiles = new Set();

  for (const value of (_b = (_a = workspace.manifest.publishConfig) === null || _a === void 0 ? void 0 : _a.executableFiles) !== null && _b !== void 0 ? _b : new Set()) executableFiles.add(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.normalize(value));

  for (const value of workspace.manifest.bin.values()) executableFiles.add(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.normalize(value));

  const pack = tar_stream__WEBPACK_IMPORTED_MODULE_1__.pack();
  process.nextTick(async () => {
    for (const fileRequest of files) {
      const file = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.normalize(fileRequest);
      const source = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(workspace.cwd, file);
      const dest = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(`package`, file);
      const stat = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.lstatPromise(source);
      const opts = {
        name: dest,
        mtime: new Date(315532800000)
      };
      const mode = executableFiles.has(file) ? 0o755 : 0o644;
      let resolveFn;
      let rejectFn;
      const awaitTarget = new Promise((resolve, reject) => {
        resolveFn = resolve;
        rejectFn = reject;
      });

      const cb = error => {
        if (error) {
          rejectFn(error);
        } else {
          resolveFn();
        }
      };

      if (stat.isFile()) {
        let content; // The root package.json supports replacement fields in publishConfig

        if (file === `package.json`) content = Buffer.from(JSON.stringify(await genPackageManifest(workspace), null, 2));else content = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.readFilePromise(source);
        pack.entry({ ...opts,
          mode,
          type: `file`
        }, content, cb);
      } else if (stat.isSymbolicLink()) {
        pack.entry({ ...opts,
          mode,
          type: `symlink`,
          linkname: await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.readlinkPromise(source)
        }, cb);
      } else {
        cb(new Error(`Unsupported file type ${stat.mode} for ${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.fromPortablePath(file)}`));
      }

      await awaitTarget;
    }

    pack.finalize();
  });
  const tgz = (0,zlib__WEBPACK_IMPORTED_MODULE_2__.createGzip)();
  pack.pipe(tgz);
  return tgz;
}
async function genPackageManifest(workspace) {
  const data = JSON.parse(JSON.stringify(workspace.manifest.raw));
  await workspace.project.configuration.triggerHook(hooks => hooks.beforeWorkspacePacking, workspace, data);
  return data;
}
async function genPackList(workspace) {
  var _a, _b, _c, _d, _e, _f, _g, _h;

  const project = workspace.project;
  const configuration = project.configuration;
  const globalList = {
    accept: [],
    reject: []
  };

  for (const pattern of ALWAYS_IGNORE) globalList.reject.push(pattern);

  for (const pattern of NEVER_IGNORE) globalList.accept.push(pattern);

  globalList.reject.push(configuration.get(`rcFilename`));

  const maybeRejectPath = path => {
    if (path === null || !path.startsWith(`${workspace.cwd}/`)) return;
    const workspaceRelativePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.relative(workspace.cwd, path);
    const workspaceAbsolutePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, workspaceRelativePath);
    globalList.reject.push(workspaceAbsolutePath);
  };

  maybeRejectPath(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(project.cwd, configuration.get(`lockfileFilename`)));
  maybeRejectPath(configuration.get(`bstatePath`));
  maybeRejectPath(configuration.get(`cacheFolder`));
  maybeRejectPath(configuration.get(`globalFolder`));
  maybeRejectPath(configuration.get(`installStatePath`));
  maybeRejectPath(configuration.get(`virtualFolder`));
  maybeRejectPath(configuration.get(`yarnPath`));
  await configuration.triggerHook(hooks => {
    return hooks.populateYarnPaths;
  }, project, path => {
    maybeRejectPath(path);
  }); // All child workspaces are ignored

  for (const otherWorkspace of project.workspaces) {
    const rel = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.relative(workspace.cwd, otherWorkspace.cwd);

    if (rel !== `` && !rel.match(/^(\.\.)?\//)) {
      globalList.reject.push(`/${rel}`);
    }
  }

  const ignoreList = {
    accept: [],
    reject: []
  };
  const main = (_b = (_a = workspace.manifest.publishConfig) === null || _a === void 0 ? void 0 : _a.main) !== null && _b !== void 0 ? _b : workspace.manifest.main;
  const module = (_d = (_c = workspace.manifest.publishConfig) === null || _c === void 0 ? void 0 : _c.module) !== null && _d !== void 0 ? _d : workspace.manifest.module;
  const browser = (_f = (_e = workspace.manifest.publishConfig) === null || _e === void 0 ? void 0 : _e.browser) !== null && _f !== void 0 ? _f : workspace.manifest.browser;
  const bins = (_h = (_g = workspace.manifest.publishConfig) === null || _g === void 0 ? void 0 : _g.bin) !== null && _h !== void 0 ? _h : workspace.manifest.bin;
  if (main != null) ignoreList.accept.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, main));
  if (module != null) ignoreList.accept.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, module));
  if (typeof browser === `string`) ignoreList.accept.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, browser));

  for (const path of bins.values()) ignoreList.accept.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, path));

  if (browser instanceof Map) {
    for (const [original, replacement] of browser.entries()) {
      ignoreList.accept.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, original));

      if (typeof replacement === `string`) {
        ignoreList.accept.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, replacement));
      }
    }
  }

  const hasExplicitFileList = workspace.manifest.files !== null;

  if (hasExplicitFileList) {
    ignoreList.reject.push(`/*`);

    for (const pattern of workspace.manifest.files) {
      addIgnorePattern(ignoreList.accept, pattern, {
        cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root
      });
    }
  }

  return await walk(workspace.cwd, {
    hasExplicitFileList,
    globalList,
    ignoreList
  });
}

async function walk(initialCwd, {
  hasExplicitFileList,
  globalList,
  ignoreList
}) {
  const list = [];
  const cwdFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.JailFS(initialCwd);
  const cwdList = [[_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, [ignoreList]]];

  while (cwdList.length > 0) {
    const [cwd, ignoreLists] = cwdList.pop();
    const stat = await cwdFs.lstatPromise(cwd);
    if (isIgnored(cwd, {
      globalList,
      ignoreLists: stat.isDirectory() ? null : ignoreLists
    })) continue;

    if (stat.isDirectory()) {
      const entries = await cwdFs.readdirPromise(cwd);
      let hasGitIgnore = false;
      let hasNpmIgnore = false;

      if (!hasExplicitFileList || cwd !== _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root) {
        for (const entry of entries) {
          hasGitIgnore = hasGitIgnore || entry === `.gitignore`;
          hasNpmIgnore = hasNpmIgnore || entry === `.npmignore`;
        }
      }

      const localIgnoreList = hasNpmIgnore ? await loadIgnoreList(cwdFs, cwd, `.npmignore`) : hasGitIgnore ? await loadIgnoreList(cwdFs, cwd, `.gitignore`) : null;
      let nextIgnoreLists = localIgnoreList !== null ? [localIgnoreList].concat(ignoreLists) : ignoreLists;
      if (isIgnored(cwd, {
        globalList,
        ignoreLists
      })) nextIgnoreLists = [...ignoreLists, {
        accept: [],
        reject: [`**/*`]
      }];

      for (const entry of entries) {
        cwdList.push([_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(cwd, entry), nextIgnoreLists]);
      }
    } else if (stat.isFile() || stat.isSymbolicLink()) {
      list.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, cwd));
    }
  }

  return list.sort();
}

async function loadIgnoreList(fs, cwd, filename) {
  const ignoreList = {
    accept: [],
    reject: []
  };
  const data = await fs.readFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(cwd, filename), `utf8`);

  for (const pattern of data.split(/\n/g)) addIgnorePattern(ignoreList.reject, pattern, {
    cwd
  });

  return ignoreList;
}

function normalizePattern(pattern, {
  cwd
}) {
  const negated = pattern[0] === `!`;
  if (negated) pattern = pattern.slice(1);
  if (pattern.match(/\.{0,1}\//)) pattern = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(cwd, pattern);
  if (negated) pattern = `!${pattern}`;
  return pattern;
}

function addIgnorePattern(target, pattern, {
  cwd
}) {
  const trimed = pattern.trim();
  if (trimed === `` || trimed[0] === `#`) return;
  target.push(normalizePattern(trimed, {
    cwd
  }));
}

function isIgnored(cwd, {
  globalList,
  ignoreLists
}) {
  if (isMatch(cwd, globalList.accept)) return false;
  if (isMatch(cwd, globalList.reject)) return true;

  if (ignoreLists !== null) {
    for (const ignoreList of ignoreLists) {
      if (isMatch(cwd, ignoreList.accept)) return false;

      if (isMatch(cwd, ignoreList.reject)) {
        return true;
      }
    }
  }

  return false;
}

function isMatch(path, patterns) {
  let inclusives = patterns;
  const exclusives = [];

  for (let t = 0; t < patterns.length; ++t) {
    if (patterns[t][0] !== `!`) {
      if (inclusives !== patterns) {
        inclusives.push(patterns[t]);
      }
    } else {
      if (inclusives === patterns) inclusives = patterns.slice(0, t);
      exclusives.push(patterns[t].slice(1));
    }
  }

  if (isMatchBasename(path, exclusives)) return false;
  if (isMatchBasename(path, inclusives)) return true;
  return false;
}

function isMatchBasename(path, patterns) {
  let paths = patterns;
  const basenames = [];

  for (let t = 0; t < patterns.length; ++t) {
    if (patterns[t].includes(`/`)) {
      if (paths !== patterns) {
        paths.push(patterns[t]);
      }
    } else {
      if (paths === patterns) paths = patterns.slice(0, t);
      basenames.push(patterns[t]);
    }
  }

  if (micromatch__WEBPACK_IMPORTED_MODULE_0___default().isMatch(path, paths, {
    dot: true,
    nocase: true
  })) return true;
  if (micromatch__WEBPACK_IMPORTED_MODULE_0___default().isMatch(path, basenames, {
    dot: true,
    basename: true,
    nocase: true
  })) return true;
  return false;
}

/***/ }),
/* 731 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const crypto = __webpack_require__(72)
const figgyPudding = __webpack_require__(732)
const Transform = __webpack_require__(76).Transform

const SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']

const BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i
const SRI_REGEX = /^([^-]+)-([^?]+)([?\S*]*)$/
const STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)*$/
const VCHAR_REGEX = /^[\x21-\x7E]+$/

const SsriOpts = figgyPudding({
  algorithms: {default: ['sha512']},
  error: {default: false},
  integrity: {},
  options: {default: []},
  pickAlgorithm: {default: () => getPrioritizedHash},
  Promise: {default: () => Promise},
  sep: {default: ' '},
  single: {default: false},
  size: {},
  strict: {default: false}
})

class Hash {
  get isHash () { return true }
  constructor (hash, opts) {
    opts = SsriOpts(opts)
    const strict = !!opts.strict
    this.source = hash.trim()
    // 3.1. Integrity metadata (called "Hash" by ssri)
    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description
    const match = this.source.match(
      strict
      ? STRICT_SRI_REGEX
      : SRI_REGEX
    )
    if (!match) { return }
    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }
    this.algorithm = match[1]
    this.digest = match[2]

    const rawOpts = match[3]
    this.options = rawOpts ? rawOpts.slice(1).split('?') : []
  }
  hexDigest () {
    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')
  }
  toJSON () {
    return this.toString()
  }
  toString (opts) {
    opts = SsriOpts(opts)
    if (opts.strict) {
      // Strict mode enforces the standard as close to the foot of the
      // letter as it can.
      if (!(
        // The spec has very restricted productions for algorithms.
        // https://www.w3.org/TR/CSP2/#source-list-syntax
        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&
        // Usually, if someone insists on using a "different" base64, we
        // leave it as-is, since there's multiple standards, and the
        // specified is not a URL-safe variant.
        // https://www.w3.org/TR/CSP2/#base64_value
        this.digest.match(BASE64_REGEX) &&
        // Option syntax is strictly visual chars.
        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression
        // https://tools.ietf.org/html/rfc5234#appendix-B.1
        (this.options || []).every(opt => opt.match(VCHAR_REGEX))
      )) {
        return ''
      }
    }
    const options = this.options && this.options.length
    ? `?${this.options.join('?')}`
    : ''
    return `${this.algorithm}-${this.digest}${options}`
  }
}

class Integrity {
  get isIntegrity () { return true }
  toJSON () {
    return this.toString()
  }
  toString (opts) {
    opts = SsriOpts(opts)
    let sep = opts.sep || ' '
    if (opts.strict) {
      // Entries must be separated by whitespace, according to spec.
      sep = sep.replace(/\S+/g, ' ')
    }
    return Object.keys(this).map(k => {
      return this[k].map(hash => {
        return Hash.prototype.toString.call(hash, opts)
      }).filter(x => x.length).join(sep)
    }).filter(x => x.length).join(sep)
  }
  concat (integrity, opts) {
    opts = SsriOpts(opts)
    const other = typeof integrity === 'string'
    ? integrity
    : stringify(integrity, opts)
    return parse(`${this.toString(opts)} ${other}`, opts)
  }
  hexDigest () {
    return parse(this, {single: true}).hexDigest()
  }
  match (integrity, opts) {
    opts = SsriOpts(opts)
    const other = parse(integrity, opts)
    const algo = other.pickAlgorithm(opts)
    return (
      this[algo] &&
      other[algo] &&
      this[algo].find(hash =>
        other[algo].find(otherhash =>
          hash.digest === otherhash.digest
        )
      )
    ) || false
  }
  pickAlgorithm (opts) {
    opts = SsriOpts(opts)
    const pickAlgorithm = opts.pickAlgorithm
    const keys = Object.keys(this)
    if (!keys.length) {
      throw new Error(`No algorithms available for ${
        JSON.stringify(this.toString())
      }`)
    }
    return keys.reduce((acc, algo) => {
      return pickAlgorithm(acc, algo) || acc
    })
  }
}

module.exports.parse = parse
function parse (sri, opts) {
  opts = SsriOpts(opts)
  if (typeof sri === 'string') {
    return _parse(sri, opts)
  } else if (sri.algorithm && sri.digest) {
    const fullSri = new Integrity()
    fullSri[sri.algorithm] = [sri]
    return _parse(stringify(fullSri, opts), opts)
  } else {
    return _parse(stringify(sri, opts), opts)
  }
}

function _parse (integrity, opts) {
  // 3.4.3. Parse metadata
  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
  if (opts.single) {
    return new Hash(integrity, opts)
  }
  return integrity.trim().split(/\s+/).reduce((acc, string) => {
    const hash = new Hash(string, opts)
    if (hash.algorithm && hash.digest) {
      const algo = hash.algorithm
      if (!acc[algo]) { acc[algo] = [] }
      acc[algo].push(hash)
    }
    return acc
  }, new Integrity())
}

module.exports.stringify = stringify
function stringify (obj, opts) {
  opts = SsriOpts(opts)
  if (obj.algorithm && obj.digest) {
    return Hash.prototype.toString.call(obj, opts)
  } else if (typeof obj === 'string') {
    return stringify(parse(obj, opts), opts)
  } else {
    return Integrity.prototype.toString.call(obj, opts)
  }
}

module.exports.fromHex = fromHex
function fromHex (hexDigest, algorithm, opts) {
  opts = SsriOpts(opts)
  const optString = opts.options && opts.options.length
  ? `?${opts.options.join('?')}`
  : ''
  return parse(
    `${algorithm}-${
      Buffer.from(hexDigest, 'hex').toString('base64')
    }${optString}`, opts
  )
}

module.exports.fromData = fromData
function fromData (data, opts) {
  opts = SsriOpts(opts)
  const algorithms = opts.algorithms
  const optString = opts.options && opts.options.length
  ? `?${opts.options.join('?')}`
  : ''
  return algorithms.reduce((acc, algo) => {
    const digest = crypto.createHash(algo).update(data).digest('base64')
    const hash = new Hash(
      `${algo}-${digest}${optString}`,
       opts
    )
    if (hash.algorithm && hash.digest) {
      const algo = hash.algorithm
      if (!acc[algo]) { acc[algo] = [] }
      acc[algo].push(hash)
    }
    return acc
  }, new Integrity())
}

module.exports.fromStream = fromStream
function fromStream (stream, opts) {
  opts = SsriOpts(opts)
  const P = opts.Promise || Promise
  const istream = integrityStream(opts)
  return new P((resolve, reject) => {
    stream.pipe(istream)
    stream.on('error', reject)
    istream.on('error', reject)
    let sri
    istream.on('integrity', s => { sri = s })
    istream.on('end', () => resolve(sri))
    istream.on('data', () => {})
  })
}

module.exports.checkData = checkData
function checkData (data, sri, opts) {
  opts = SsriOpts(opts)
  sri = parse(sri, opts)
  if (!Object.keys(sri).length) {
    if (opts.error) {
      throw Object.assign(
        new Error('No valid integrity hashes to check against'), {
          code: 'EINTEGRITY'
        }
      )
    } else {
      return false
    }
  }
  const algorithm = sri.pickAlgorithm(opts)
  const digest = crypto.createHash(algorithm).update(data).digest('base64')
  const newSri = parse({algorithm, digest})
  const match = newSri.match(sri, opts)
  if (match || !opts.error) {
    return match
  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {
    const err = new Error(`data size mismatch when checking ${sri}.\n  Wanted: ${opts.size}\n  Found: ${data.length}`)
    err.code = 'EBADSIZE'
    err.found = data.length
    err.expected = opts.size
    err.sri = sri
    throw err
  } else {
    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)
    err.code = 'EINTEGRITY'
    err.found = newSri
    err.expected = sri
    err.algorithm = algorithm
    err.sri = sri
    throw err
  }
}

module.exports.checkStream = checkStream
function checkStream (stream, sri, opts) {
  opts = SsriOpts(opts)
  const P = opts.Promise || Promise
  const checker = integrityStream(opts.concat({
    integrity: sri
  }))
  return new P((resolve, reject) => {
    stream.pipe(checker)
    stream.on('error', reject)
    checker.on('error', reject)
    let sri
    checker.on('verified', s => { sri = s })
    checker.on('end', () => resolve(sri))
    checker.on('data', () => {})
  })
}

module.exports.integrityStream = integrityStream
function integrityStream (opts) {
  opts = SsriOpts(opts)
  // For verification
  const sri = opts.integrity && parse(opts.integrity, opts)
  const goodSri = sri && Object.keys(sri).length
  const algorithm = goodSri && sri.pickAlgorithm(opts)
  const digests = goodSri && sri[algorithm]
  // Calculating stream
  const algorithms = Array.from(
    new Set(opts.algorithms.concat(algorithm ? [algorithm] : []))
  )
  const hashes = algorithms.map(crypto.createHash)
  let streamSize = 0
  const stream = new Transform({
    transform (chunk, enc, cb) {
      streamSize += chunk.length
      hashes.forEach(h => h.update(chunk, enc))
      cb(null, chunk, enc)
    }
  }).on('end', () => {
    const optString = (opts.options && opts.options.length)
    ? `?${opts.options.join('?')}`
    : ''
    const newSri = parse(hashes.map((h, i) => {
      return `${algorithms[i]}-${h.digest('base64')}${optString}`
    }).join(' '), opts)
    // Integrity verification mode
    const match = goodSri && newSri.match(sri, opts)
    if (typeof opts.size === 'number' && streamSize !== opts.size) {
      const err = new Error(`stream size mismatch when checking ${sri}.\n  Wanted: ${opts.size}\n  Found: ${streamSize}`)
      err.code = 'EBADSIZE'
      err.found = streamSize
      err.expected = opts.size
      err.sri = sri
      stream.emit('error', err)
    } else if (opts.integrity && !match) {
      const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`)
      err.code = 'EINTEGRITY'
      err.found = newSri
      err.expected = digests
      err.algorithm = algorithm
      err.sri = sri
      stream.emit('error', err)
    } else {
      stream.emit('size', streamSize)
      stream.emit('integrity', newSri)
      match && stream.emit('verified', match)
    }
  })
  return stream
}

module.exports.create = createIntegrity
function createIntegrity (opts) {
  opts = SsriOpts(opts)
  const algorithms = opts.algorithms
  const optString = opts.options.length
  ? `?${opts.options.join('?')}`
  : ''

  const hashes = algorithms.map(crypto.createHash)

  return {
    update: function (chunk, enc) {
      hashes.forEach(h => h.update(chunk, enc))
      return this
    },
    digest: function (enc) {
      const integrity = algorithms.reduce((acc, algo) => {
        const digest = hashes.shift().digest('base64')
        const hash = new Hash(
          `${algo}-${digest}${optString}`,
          opts
        )
        if (hash.algorithm && hash.digest) {
          const algo = hash.algorithm
          if (!acc[algo]) { acc[algo] = [] }
          acc[algo].push(hash)
        }
        return acc
      }, new Integrity())

      return integrity
    }
  }
}

const NODE_HASHES = new Set(crypto.getHashes())

// This is a Best Effort at a reasonable priority for hash algos
const DEFAULT_PRIORITY = [
  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',
  // TODO - it's unclear _which_ of these Node will actually use as its name
  //        for the algorithm, so we guesswork it based on the OpenSSL names.
  'sha3',
  'sha3-256', 'sha3-384', 'sha3-512',
  'sha3_256', 'sha3_384', 'sha3_512'
].filter(algo => NODE_HASHES.has(algo))

function getPrioritizedHash (algo1, algo2) {
  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())
  ? algo1
  : algo2
}


/***/ }),
/* 732 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


class FiggyPudding {
  constructor (specs, opts, providers) {
    this.__specs = specs || {}
    Object.keys(this.__specs).forEach(alias => {
      if (typeof this.__specs[alias] === 'string') {
        const key = this.__specs[alias]
        const realSpec = this.__specs[key]
        if (realSpec) {
          const aliasArr = realSpec.aliases || []
          aliasArr.push(alias, key)
          realSpec.aliases = [...(new Set(aliasArr))]
          this.__specs[alias] = realSpec
        } else {
          throw new Error(`Alias refers to invalid key: ${key} -> ${alias}`)
        }
      }
    })
    this.__opts = opts || {}
    this.__providers = reverse((providers).filter(
      x => x != null && typeof x === 'object'
    ))
    this.__isFiggyPudding = true
  }
  get (key) {
    return pudGet(this, key, true)
  }
  get [Symbol.toStringTag] () { return 'FiggyPudding' }
  forEach (fn, thisArg = this) {
    for (let [key, value] of this.entries()) {
      fn.call(thisArg, value, key, this)
    }
  }
  toJSON () {
    const obj = {}
    this.forEach((val, key) => {
      obj[key] = val
    })
    return obj
  }
  * entries (_matcher) {
    for (let key of Object.keys(this.__specs)) {
      yield [key, this.get(key)]
    }
    const matcher = _matcher || this.__opts.other
    if (matcher) {
      const seen = new Set()
      for (let p of this.__providers) {
        const iter = p.entries ? p.entries(matcher) : entries(p)
        for (let [key, val] of iter) {
          if (matcher(key) && !seen.has(key)) {
            seen.add(key)
            yield [key, val]
          }
        }
      }
    }
  }
  * [Symbol.iterator] () {
    for (let [key, value] of this.entries()) {
      yield [key, value]
    }
  }
  * keys () {
    for (let [key] of this.entries()) {
      yield key
    }
  }
  * values () {
    for (let [, value] of this.entries()) {
      yield value
    }
  }
  concat (...moreConfig) {
    return new Proxy(new FiggyPudding(
      this.__specs,
      this.__opts,
      reverse(this.__providers).concat(moreConfig)
    ), proxyHandler)
  }
}
try {
  const util = __webpack_require__(90)
  FiggyPudding.prototype[util.inspect.custom] = function (depth, opts) {
    return (
      this[Symbol.toStringTag] + ' '
    ) + util.inspect(this.toJSON(), opts)
  }
} catch (e) {}

function BadKeyError (key) {
  throw Object.assign(new Error(
    `invalid config key requested: ${key}`
  ), {code: 'EBADKEY'})
}

function pudGet (pud, key, validate) {
  let spec = pud.__specs[key]
  if (validate && !spec && (!pud.__opts.other || !pud.__opts.other(key))) {
    BadKeyError(key)
  } else {
    if (!spec) { spec = {} }
    let ret
    for (let p of pud.__providers) {
      ret = tryGet(key, p)
      if (ret === undefined && spec.aliases && spec.aliases.length) {
        for (let alias of spec.aliases) {
          if (alias === key) { continue }
          ret = tryGet(alias, p)
          if (ret !== undefined) {
            break
          }
        }
      }
      if (ret !== undefined) {
        break
      }
    }
    if (ret === undefined && spec.default !== undefined) {
      if (typeof spec.default === 'function') {
        return spec.default(pud)
      } else {
        return spec.default
      }
    } else {
      return ret
    }
  }
}

function tryGet (key, p) {
  let ret
  if (p.__isFiggyPudding) {
    ret = pudGet(p, key, false)
  } else if (typeof p.get === 'function') {
    ret = p.get(key)
  } else {
    ret = p[key]
  }
  return ret
}

const proxyHandler = {
  has (obj, prop) {
    return prop in obj.__specs && pudGet(obj, prop, false) !== undefined
  },
  ownKeys (obj) {
    return Object.keys(obj.__specs)
  },
  get (obj, prop) {
    if (
      typeof prop === 'symbol' ||
      prop.slice(0, 2) === '__' ||
      prop in FiggyPudding.prototype
    ) {
      return obj[prop]
    }
    return obj.get(prop)
  },
  set (obj, prop, value) {
    if (
      typeof prop === 'symbol' ||
      prop.slice(0, 2) === '__'
    ) {
      obj[prop] = value
      return true
    } else {
      throw new Error('figgyPudding options cannot be modified. Use .concat() instead.')
    }
  },
  deleteProperty () {
    throw new Error('figgyPudding options cannot be deleted. Use .concat() and shadow them instead.')
  }
}

module.exports = figgyPudding
function figgyPudding (specs, opts) {
  function factory (...providers) {
    return new Proxy(new FiggyPudding(
      specs,
      opts,
      providers
    ), proxyHandler)
  }
  return factory
}

function reverse (arr) {
  const ret = []
  arr.forEach(x => ret.unshift(x))
  return ret
}

function entries (obj) {
  return Object.keys(obj).map(k => [k, obj[k]])
}


/***/ }),
/* 733 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(181);
/* harmony import */ var _commands_npm_audit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(734);
/* harmony import */ var _commands_npm_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(737);
/* harmony import */ var _commands_npm_login__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(738);
/* harmony import */ var _commands_npm_logout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(739);
/* harmony import */ var _commands_npm_publish__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(740);
/* harmony import */ var _commands_npm_tag_add__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(741);
/* harmony import */ var _commands_npm_tag_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(742);
/* harmony import */ var _commands_npm_tag_remove__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(743);
/* harmony import */ var _commands_npm_whoami__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(744);










const plugin = {
  configuration: {
    npmPublishAccess: {
      description: `Default access of the published packages`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.SettingsType.STRING,
      default: null
    }
  },
  commands: [_commands_npm_audit__WEBPACK_IMPORTED_MODULE_0__.default, _commands_npm_info__WEBPACK_IMPORTED_MODULE_1__.default, _commands_npm_login__WEBPACK_IMPORTED_MODULE_2__.default, _commands_npm_logout__WEBPACK_IMPORTED_MODULE_3__.default, _commands_npm_publish__WEBPACK_IMPORTED_MODULE_4__.default, _commands_npm_tag_add__WEBPACK_IMPORTED_MODULE_5__.default, _commands_npm_tag_list__WEBPACK_IMPORTED_MODULE_6__.default, _commands_npm_tag_remove__WEBPACK_IMPORTED_MODULE_7__.default, _commands_npm_whoami__WEBPACK_IMPORTED_MODULE_8__.default]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 734 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ AuditCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(379);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(411);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(707);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _npmAuditTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(735);
/* harmony import */ var _npmAuditUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(736);






 // eslint-disable-next-line arca/no-default-export

class AuditCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.all = false;
    this.recursive = false;
    this.environment = _npmAuditTypes__WEBPACK_IMPORTED_MODULE_3__.Environment.All;
    this.json = false;
    this.severity = _npmAuditTypes__WEBPACK_IMPORTED_MODULE_3__.Severity.Info;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Project.find(configuration, this.context.cwd);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    await project.restoreInstallState();
    const requires = _npmAuditUtils__WEBPACK_IMPORTED_MODULE_4__.getRequires(project, workspace, {
      all: this.all,
      environment: this.environment
    });
    const dependencies = _npmAuditUtils__WEBPACK_IMPORTED_MODULE_4__.getDependencies(project, workspace, {
      all: this.all
    });

    if (!this.recursive) {
      for (const key of Object.keys(dependencies)) {
        if (!Object.prototype.hasOwnProperty.call(requires, key)) {
          delete dependencies[key];
        } else {
          dependencies[key].requires = {};
        }
      }
    }

    const body = {
      requires,
      dependencies
    };
    const registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getPublishRegistry(workspace.manifest, {
      configuration
    });
    let result;
    const httpReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.LightReport.start({
      configuration,
      stdout: this.context.stdout
    }, async () => {
      try {
        result = await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.post(`/-/npm/v1/security/audits/quick`, body, {
          authType: _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.AuthType.NO_AUTH,
          configuration,
          jsonResponse: true,
          registry
        });
      } catch (err) {
        if (err.name !== `HTTPError`) {
          throw err;
        } else {
          throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.EXCEPTION, err.toString());
        }
      }
    });
    if (httpReport.hasErrors()) return httpReport.exitCode();
    const hasError = _npmAuditUtils__WEBPACK_IMPORTED_MODULE_4__.isError(result.metadata.vulnerabilities, this.severity);

    if (!this.json && hasError) {
      _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.emitTree(_npmAuditUtils__WEBPACK_IMPORTED_MODULE_4__.getReportTree(result, this.severity), {
        configuration,
        json: this.json,
        stdout: this.context.stdout,
        separators: 2
      });
      return 1;
    }

    const outReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.StreamReport.start({
      configuration,
      includeFooter: false,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      report.reportJson(result);

      if (!hasError) {
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.EXCEPTION, `No audit suggestions`);
      }
    });
    return outReport.exitCode();
  }

}
AuditCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  description: `perform a vulnerability audit against the installed packages`,
  details: `
      This command checks for known security reports on the packages you use. The reports are by default extracted from the npm registry, and may or may not be relevant to your actual program (not all vulnerabilities affect all code paths).

      For consistency with our other commands the default is to only check the direct dependencies for the active workspace. To extend this search to all workspaces, use \`-A,--all\`. To extend this search to both direct and transitive dependencies, use \`-R,--recursive\`.

      Applying the \`--severity\` flag will limit the audit table to vulnerabilities of the corresponding severity and above. Valid values are ${_npmAuditUtils__WEBPACK_IMPORTED_MODULE_4__.allSeverities.map(value => `\`${value}\``).join(`, `)}.

      If the \`--json\` flag is set, Yarn will print the output exactly as received from the registry. Regardless of this flag, the process will exit with a non-zero exit code if a report is found for the selected packages.

      To understand the dependency tree requiring vulnerable packages, check the raw report with the \`--json\` flag or use \`yarn why <package>\` to get more information as to who depends on them.
    `,
  examples: [[`Checks for known security issues with the installed packages. The output is a list of known issues.`, `yarn npm audit`], [`Audit dependencies in all workspaces`, `yarn npm audit --all`], [`Limit auditing to \`dependencies\` (excludes \`devDependencies\`)`, `yarn npm audit --environment production`], [`Show audit report as valid JSON`, `yarn npm audit --json`], [`Audit all direct and transitive dependencies`, `yarn npm audit --recursive`], [`Output moderate (or more severe) vulnerabilities`, `yarn npm audit --severity moderate`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`-A,--all`)], AuditCommand.prototype, "all", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`-R,--recursive`)], AuditCommand.prototype, "recursive", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String(`--environment`)], AuditCommand.prototype, "environment", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--json`)], AuditCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String(`--severity`)], AuditCommand.prototype, "severity", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`npm`, `audit`)], AuditCommand.prototype, "execute", null);

/***/ }),
/* 735 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Environment": () => /* binding */ Environment,
/* harmony export */   "Severity": () => /* binding */ Severity
/* harmony export */ });
/* eslint-disable @typescript-eslint/naming-convention */
var Environment;

(function (Environment) {
  Environment["All"] = "all";
  Environment["Production"] = "production";
  Environment["Development"] = "development";
})(Environment || (Environment = {}));

var Severity;

(function (Severity) {
  Severity["Info"] = "info";
  Severity["Low"] = "low";
  Severity["Moderate"] = "moderate";
  Severity["High"] = "high";
  Severity["Critical"] = "critical";
})(Severity || (Severity = {}));

/***/ }),
/* 736 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "allSeverities": () => /* binding */ allSeverities,
/* harmony export */   "getTransitiveDevDependencies": () => /* binding */ getTransitiveDevDependencies,
/* harmony export */   "transformDescriptorIterableToRequiresObject": () => /* binding */ transformDescriptorIterableToRequiresObject,
/* harmony export */   "getSeverityInclusions": () => /* binding */ getSeverityInclusions,
/* harmony export */   "filterVulnerabilities": () => /* binding */ filterVulnerabilities,
/* harmony export */   "isError": () => /* binding */ isError,
/* harmony export */   "getReportTree": () => /* binding */ getReportTree,
/* harmony export */   "getRequires": () => /* binding */ getRequires,
/* harmony export */   "getDependencies": () => /* binding */ getDependencies
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
/* harmony import */ var _npmAuditTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(735);


const allSeverities = [_npmAuditTypes__WEBPACK_IMPORTED_MODULE_0__.Severity.Info, _npmAuditTypes__WEBPACK_IMPORTED_MODULE_0__.Severity.Low, _npmAuditTypes__WEBPACK_IMPORTED_MODULE_0__.Severity.Moderate, _npmAuditTypes__WEBPACK_IMPORTED_MODULE_0__.Severity.High, _npmAuditTypes__WEBPACK_IMPORTED_MODULE_0__.Severity.Critical]; // Enumerate all the transitive dependencies of a set of top-level packages

function getTransitiveDependencies(project, roots) {
  // Queue of dependency descriptorHashes to visit; set of already-visited patterns
  const queue = [];
  const descriptorHashes = new Set();

  const enqueue = descriptorHash => {
    if (descriptorHashes.has(descriptorHash)) return;
    descriptorHashes.add(descriptorHash);
    queue.push(descriptorHash);
  };

  for (const root of roots) enqueue(root); // Final result set


  const transitiveDependencies = new Set();

  while (queue.length > 0) {
    const descriptorHash = queue.shift();
    const locatorHash = project.storedResolutions.get(descriptorHash);
    if (typeof locatorHash === `undefined`) throw new Error(`Assertion failed: Expected the resolution to have been registered`);
    const pkg = project.storedPackages.get(locatorHash);
    if (!pkg) continue; // Add the dependency to the result set

    transitiveDependencies.add(descriptorHash); // Enqueue any dependencies of the dependency for processing

    for (const dependency of pkg.dependencies.values()) {
      enqueue(dependency.descriptorHash);
    }
  }

  return transitiveDependencies;
}

function setDifference(x, y) {
  return new Set([...x].filter(value => !y.has(value)));
} // Given a manifest, an optional workspace layout, and a lockfile, enumerate
// all package versions that:
// - are present in the lockfile
// - are a transitive dependency of some top-level devDependency
// - are not a transitive dependency of some top-level production dependency


function getTransitiveDevDependencies(project, workspace, {
  all
}) {
  // Determine workspaces in scope
  const workspaces = all ? project.workspaces : [workspace]; // Enumerate the top-level package manifest as well as any workspace manifests

  const manifests = workspaces.map(workspace => {
    return workspace.manifest;
  }); // Collect all the top-level production and development dependencies across all manifests

  const productionDependencyIdentSet = new Set(manifests.map(manifest => [...manifest.dependencies].map(([identHash, descriptor]) => identHash)).flat());
  const developmentDependencyIdentSet = new Set(manifests.map(manifest => [...manifest.devDependencies].map(([identHash, descriptor]) => identHash)).flat()); // Map workspace dependencies to descriptor hashes, filtered by the top-level production and development dependencies

  const workspaceDependencies = workspaces.map(workspace => [...workspace.dependencies.values()]).flat();
  const productionRoots = workspaceDependencies.filter(dependency => productionDependencyIdentSet.has(dependency.identHash)).map(dependency => dependency.descriptorHash);
  const developmentRoots = workspaceDependencies.filter(dependency => developmentDependencyIdentSet.has(dependency.identHash)).map(dependency => dependency.descriptorHash); // Enumerate all the transitive production and development dependencies

  const productionDependencies = getTransitiveDependencies(project, productionRoots);
  const developmentDependencies = getTransitiveDependencies(project, developmentRoots); // Exclude any development dependencies that are also production dependencies

  return setDifference(developmentDependencies, productionDependencies);
}
function transformDescriptorIterableToRequiresObject(descriptors) {
  const data = {};

  for (const descriptor of descriptors) data[_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.stringifyIdent(descriptor)] = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.parseRange(descriptor.range).selector;

  return data;
}
function getSeverityInclusions(severity) {
  if (typeof severity === `undefined`) return new Set();
  const severityIndex = allSeverities.indexOf(severity);
  const severities = allSeverities.slice(severityIndex);
  return new Set(severities);
}
function filterVulnerabilities(vulnerabilities, severity) {
  const inclusions = getSeverityInclusions(severity);
  const filteredVulnerabilities = {};

  for (const key of inclusions) filteredVulnerabilities[key] = vulnerabilities[key];

  return filteredVulnerabilities;
}
function isError(vulnerabilities, severity) {
  var _a;

  const filteredVulnerabilities = filterVulnerabilities(vulnerabilities, severity);

  for (const key of Object.keys(filteredVulnerabilities)) if ((_a = filteredVulnerabilities[key]) !== null && _a !== void 0 ? _a : 0 > 0) return true;

  return false;
}
function getReportTree(result, severity) {
  const auditTreeChildren = {};
  const auditTree = {
    children: auditTreeChildren
  };
  let advisories = Object.values(result.advisories);

  if (severity != null) {
    const inclusions = getSeverityInclusions(severity);
    advisories = advisories.filter(advisory => inclusions.has(advisory.severity));
  }

  for (const advisory of _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.sortMap(advisories, advisory => advisory.module_name)) {
    auditTreeChildren[advisory.module_name] = {
      label: advisory.module_name,
      value: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Type.RANGE, advisory.findings.map(finding => finding.version).join(`, `)),
      children: {
        Issue: {
          label: `Issue`,
          value: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Type.NO_HINT, advisory.title)
        },
        URL: {
          label: `URL`,
          value: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Type.URL, advisory.url)
        },
        Severity: {
          label: `Severity`,
          value: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Type.NO_HINT, advisory.severity)
        },
        [`Vulnerable Versions`]: {
          label: `Vulnerable Versions`,
          value: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Type.RANGE, advisory.vulnerable_versions)
        },
        [`Patched Versions`]: {
          label: `Patched Versions`,
          value: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Type.RANGE, advisory.patched_versions)
        },
        Via: {
          label: `Via`,
          value: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Type.NO_HINT, Array.from(new Set(advisory.findings.map(finding => finding.paths).flat().map(path => path.split(`>`)[0]))).join(`, `))
        },
        Recommendation: {
          label: `Recommendation`,
          value: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Type.NO_HINT, advisory.recommendation.replace(/\n/g, ` `))
        }
      }
    };
  }

  return auditTree;
}
function getRequires(project, workspace, {
  all,
  environment
}) {
  const workspaces = all ? project.workspaces : [workspace];
  const includeDependencies = [_npmAuditTypes__WEBPACK_IMPORTED_MODULE_0__.Environment.All, _npmAuditTypes__WEBPACK_IMPORTED_MODULE_0__.Environment.Production].includes(environment);
  const requiredDependencies = [];
  if (includeDependencies) for (const workspace of workspaces) for (const dependency of workspace.manifest.dependencies.values()) requiredDependencies.push(dependency);
  const includeDevDependencies = [_npmAuditTypes__WEBPACK_IMPORTED_MODULE_0__.Environment.All, _npmAuditTypes__WEBPACK_IMPORTED_MODULE_0__.Environment.Development].includes(environment);
  const requiredDevDependencies = [];
  if (includeDevDependencies) for (const workspace of workspaces) for (const dependency of workspace.manifest.devDependencies.values()) requiredDevDependencies.push(dependency);
  return transformDescriptorIterableToRequiresObject([...requiredDependencies, ...requiredDevDependencies].filter(dependency => {
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.parseRange(dependency.range).protocol === null;
  }));
}
function getDependencies(project, workspace, {
  all
}) {
  var _a;

  const transitiveDevDependencies = getTransitiveDevDependencies(project, workspace, {
    all
  });
  const data = {};

  for (const pkg of project.storedPackages.values()) {
    data[_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.stringifyIdent(pkg)] = {
      version: (_a = pkg.version) !== null && _a !== void 0 ? _a : `0.0.0`,
      integrity: pkg.identHash,
      requires: transformDescriptorIterableToRequiresObject(pkg.dependencies.values()),
      dev: transitiveDevDependencies.has(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.convertLocatorToDescriptor(pkg).descriptorHash)
    };
  }

  return data;
}

/***/ }),
/* 737 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ InfoCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(707);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(84);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(90);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_5__);








 // eslint-disable-next-line arca/no-default-export

class InfoCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Project.find(configuration, this.context.cwd);
    const fields = typeof this.fields !== `undefined` ? new Set([`name`, ...this.fields.split(/\s*,\s*/)]) : null;
    const infos = [];
    let leadWithSeparator = false;
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.StreamReport.start({
      configuration,
      includeFooter: false,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      for (const identStr of this.packages) {
        let descriptor;

        if (identStr === `.`) {
          const workspace = project.topLevelWorkspace;
          if (!workspace.manifest.name) throw new clipanion__WEBPACK_IMPORTED_MODULE_2__.UsageError(`Missing 'name' field in ${path__WEBPACK_IMPORTED_MODULE_3___default().join(workspace.cwd, `package.json`)}`);
          descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.makeDescriptor(workspace.manifest.name, `unknown`);
        } else {
          descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.parseDescriptor(identStr);
        }

        const identUrl = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.getIdentUrl(descriptor);
        let result;

        try {
          // The information from `registry.npmjs.org/<package>`
          result = clean(await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.get(identUrl, {
            configuration,
            ident: descriptor,
            jsonResponse: true
          }));
        } catch (err) {
          if (err.name !== `HTTPError`) {
            throw err;
          } else if (err.response.statusCode === 404) {
            throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.EXCEPTION, `Package not found`);
          } else {
            throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.EXCEPTION, err.toString());
          }
        }

        const versions = Object.keys(result.versions).sort((semver__WEBPACK_IMPORTED_MODULE_4___default().compareLoose));
        const fallbackVersion = result[`dist-tags`].latest || versions[versions.length - 1]; // The latest version that satisfies `descriptor.range` (if it is a valid range), else `fallbackVersion`

        let version = fallbackVersion;

        if (semver__WEBPACK_IMPORTED_MODULE_4___default().validRange(descriptor.range)) {
          const maxSatisfyingVersion = semver__WEBPACK_IMPORTED_MODULE_4___default().maxSatisfying(versions, descriptor.range);

          if (maxSatisfyingVersion !== null) {
            version = maxSatisfyingVersion;
          } else {
            report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.UNNAMED, `Unmet range ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.prettyRange(configuration, descriptor.range)}; falling back to the latest version`);
            leadWithSeparator = true;
          }
        } else if (descriptor.range !== `unknown`) {
          report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.UNNAMED, `Invalid range ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.prettyRange(configuration, descriptor.range)}; falling back to the latest version`);
          leadWithSeparator = true;
        }

        const release = result.versions[version];
        /**
         * The merging of
         * @see `result` - The information from `registry.npmjs.org/<package>`
         * @see `release` - The release corresponding to `version`
         * @see `version` - The latest version that satisfies `descriptor.range` (if it is a valid range), else `fallbackVersion`
         * @see `versions` - All version tags of a package, sorted in ascending order
         */

        const packageInformation = { ...result,
          ...release,
          version,
          versions
        };
        let serialized;

        if (fields !== null) {
          serialized = {};

          for (const field of fields) {
            // @ts-expect-error
            const value = packageInformation[field];

            if (typeof value !== `undefined`) {
              serialized[field] = value;
            } else {
              report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.EXCEPTION, `The '${field}' field doesn't exist inside ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.prettyIdent(configuration, descriptor)}'s informations`);
              leadWithSeparator = true;
              continue;
            }
          }
        } else {
          // Remove long fields
          if (!this.json) {
            delete packageInformation.dist;
            delete packageInformation.readme;
            delete packageInformation.users;
          }

          serialized = packageInformation;
        }

        report.reportJson(serialized);

        if (!this.json) {
          infos.push(serialized);
        }
      }
    }); // @ts-expect-error: The Node typings forgot one field

    util__WEBPACK_IMPORTED_MODULE_5__.inspect.styles.name = `cyan`;

    for (const serialized of infos) {
      if (serialized !== infos[0] || leadWithSeparator) this.context.stdout.write(`\n`);
      this.context.stdout.write(`${(0,util__WEBPACK_IMPORTED_MODULE_5__.inspect)(serialized, {
        depth: Infinity,
        colors: true,
        compact: false
      })}\n`);
    }

    return report.exitCode();
  }

}
InfoCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  category: `Npm-related commands`,
  description: `show information about a package`,
  details: `
      This command will fetch information about a package from the npm registry, and prints it in a tree format.

      The package does not have to be installed locally, but needs to have been published (in particular, local changes will be ignored even for workspaces).

      Append \`@<range>\` to the package argument to provide information specific to the latest version that satisfies the range. If the range is invalid or if there is no version satisfying the range, the command will print a warning and fall back to the latest version.

      If the \`-f,--fields\` option is set, it's a comma-separated list of fields which will be used to only display part of the package informations.

      By default, this command won't return the \`dist\`, \`readme\`, and \`users\` fields, since they are often very long. To explicitly request those fields, explicitly list them with the \`--fields\` flag or request the output in JSON mode.
    `,
  examples: [[`Show all available information about react (except the \`dist\`, \`readme\`, and \`users\` fields)`, `yarn npm info react`], [`Show all available information about react as valid JSON (including the \`dist\`, \`readme\`, and \`users\` fields)`, `yarn npm info react --json`], [`Show all available information about react 16.12.0`, `yarn npm info react@16.12.0`], [`Show the description of react`, `yarn npm info react --fields description`], [`Show all available versions of react`, `yarn npm info react --fields versions`], [`Show the readme of react`, `yarn npm info react --fields readme`], [`Show a few fields of react`, `yarn npm info react --fields homepage,repository`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Rest()], InfoCommand.prototype, "packages", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String(`-f,--fields`, {
  description: `A comma-separated list of manifest fields that should be displayed`
})], InfoCommand.prototype, "fields", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], InfoCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`npm`, `info`)], InfoCommand.prototype, "execute", null); // Remove hidden properties recursively


function clean(value) {
  if (Array.isArray(value)) {
    const result = [];

    for (let item of value) {
      item = clean(item);

      if (item) {
        result.push(item);
      }
    }

    return result;
  } else if (typeof value === `object` && value !== null) {
    const result = {};

    for (const key of Object.keys(value)) {
      if (key.startsWith(`_`)) continue;
      const item = clean(value[key]);

      if (item) {
        result[key] = item;
      }
    }

    return result;
  } else if (value) {
    return value;
  } else {
    return null;
  }
}

/***/ }),
/* 738 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NpmLoginCommand,
/* harmony export */   "getRegistry": () => /* binding */ getRegistry
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(707);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(556);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(enquirer__WEBPACK_IMPORTED_MODULE_3__);






 // eslint-disable-next-line arca/no-default-export

class NpmLoginCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.publish = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const registry = await getRegistry({
      configuration,
      cwd: this.context.cwd,
      publish: this.publish,
      scope: this.scope
    });
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const credentials = await getCredentials({
        registry,
        report,
        stdin: this.context.stdin,
        stdout: this.context.stdout
      });
      const url = `/-/user/org.couchdb.user:${encodeURIComponent(credentials.name)}`;
      const response = await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.put(url, credentials, {
        attemptedAs: credentials.name,
        configuration,
        registry,
        jsonResponse: true,
        authType: _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.AuthType.NO_AUTH
      });
      await setAuthToken(registry, response.token, {
        configuration,
        scope: this.scope
      });
      return report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.UNNAMED, `Successfully logged in`);
    });
    return report.exitCode();
  }

}
NpmLoginCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  category: `Npm-related commands`,
  description: `store new login info to access the npm registry`,
  details: `
      This command will ask you for your username, password, and 2FA One-Time-Password (when it applies). It will then modify your local configuration (in your home folder, never in the project itself) to reference the new tokens thus generated.

      Adding the \`-s,--scope\` flag will cause the authentication to be done against whatever registry is configured for the associated scope (see also \`npmScopes\`).

      Adding the \`--publish\` flag will cause the authentication to be done against the registry used when publishing the package (see also \`publishConfig.registry\` and \`npmPublishRegistry\`).
    `,
  examples: [[`Login to the default registry`, `yarn npm login`], [`Login to the registry linked to the @my-scope registry`, `yarn npm login --scope my-scope`], [`Login to the publish registry for the current package`, `yarn npm login --publish`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String(`-s,--scope`, {
  description: `Login to the registry configured for a given scope`
})], NpmLoginCommand.prototype, "scope", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--publish`, {
  description: `Login to the publish registry`
})], NpmLoginCommand.prototype, "publish", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`npm`, `login`)], NpmLoginCommand.prototype, "execute", null);

async function getRegistry({
  scope,
  publish,
  configuration,
  cwd
}) {
  if (scope && publish) return _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getScopeRegistry(scope, {
    configuration,
    type: _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.RegistryType.PUBLISH_REGISTRY
  });
  if (scope) return _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getScopeRegistry(scope, {
    configuration
  });
  if (publish) return _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getPublishRegistry((await (0,_yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.openWorkspace)(configuration, cwd)).manifest, {
    configuration
  });
  return _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getDefaultRegistry({
    configuration
  });
}

async function setAuthToken(registry, npmAuthToken, {
  configuration,
  scope
}) {
  const makeUpdater = entryName => unknownStore => {
    const store = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.isIndexableObject(unknownStore) ? unknownStore : {};
    const entryUnknown = store[entryName];
    const entry = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.isIndexableObject(entryUnknown) ? entryUnknown : {};
    return { ...store,
      [entryName]: { ...entry,
        npmAuthToken
      }
    };
  };

  const update = scope ? {
    npmScopes: makeUpdater(scope)
  } : {
    npmRegistries: makeUpdater(registry)
  };
  return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.updateHomeConfiguration(update);
}

async function getCredentials({
  registry,
  report,
  stdin,
  stdout
}) {
  if (process.env.TEST_ENV) {
    return {
      name: process.env.TEST_NPM_USER || ``,
      password: process.env.TEST_NPM_PASSWORD || ``
    };
  }

  report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.UNNAMED, `Logging in to ${registry}`);
  let isToken = false;

  if (registry.match(/^https:\/\/npm\.pkg\.github\.com(\/|$)/)) {
    report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.UNNAMED, `You seem to be using the GitHub Package Registry. Tokens must be generated with the 'repo', 'write:packages', and 'read:packages' permissions.`);
    isToken = true;
  }

  report.reportSeparator();
  const {
    username,
    password
  } = await (0,enquirer__WEBPACK_IMPORTED_MODULE_3__.prompt)([{
    type: `input`,
    name: `username`,
    message: `Username:`,
    required: true,
    onCancel: () => process.exit(130),
    stdin,
    stdout
  }, {
    type: `password`,
    name: `password`,
    message: isToken ? `Token:` : `Password:`,
    required: true,
    onCancel: () => process.exit(130),
    stdin,
    stdout
  }]);
  report.reportSeparator();
  return {
    name: username,
    password
  };
}

/***/ }),
/* 739 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NpmLogoutCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(707);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _login__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(738);







const LOGOUT_KEYS = new Set([`npmAuthIdent`, `npmAuthToken`]); // eslint-disable-next-line arca/no-default-export

class NpmLogoutCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.publish = false;
    this.all = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);

    const checkLogout = async () => {
      var _a;

      const registry = await (0,_login__WEBPACK_IMPORTED_MODULE_3__.getRegistry)({
        configuration,
        cwd: this.context.cwd,
        publish: this.publish,
        scope: this.scope
      });
      const refreshedConfiguration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
      const fakeIdent = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.makeIdent((_a = this.scope) !== null && _a !== void 0 ? _a : null, `pkg`);
      const authConfiguration = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getAuthConfiguration(registry, {
        configuration: refreshedConfiguration,
        ident: fakeIdent
      });
      return !authConfiguration.get(`npmAuthToken`);
    };

    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      if (this.all) {
        await logoutFromEverything();
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.MessageName.UNNAMED, `Successfully logged out from everything`);
      }

      if (this.scope) {
        await logoutFrom(`npmScopes`, this.scope);
        if (await checkLogout()) report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.MessageName.UNNAMED, `Successfully logged out from ${this.scope}`);else report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.MessageName.UNNAMED, `Scope authentication settings removed, but some other ones settings still apply to it`);
        return;
      }

      const registry = await (0,_login__WEBPACK_IMPORTED_MODULE_3__.getRegistry)({
        configuration,
        cwd: this.context.cwd,
        publish: this.publish
      });
      await logoutFrom(`npmRegistries`, registry);

      if (await checkLogout()) {
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.MessageName.UNNAMED, `Successfully logged out from ${registry}`);
      } else {
        report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.MessageName.UNNAMED, `Registry authentication settings removed, but some other ones settings still apply to it`);
      }
    });
    return report.exitCode();
  }

}
NpmLogoutCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  category: `Npm-related commands`,
  description: `logout of the npm registry`,
  details: `
      This command will log you out by modifying your local configuration (in your home folder, never in the project itself) to delete all credentials linked to a registry.

      Adding the \`-s,--scope\` flag will cause the deletion to be done against whatever registry is configured for the associated scope (see also \`npmScopes\`).

      Adding the \`--publish\` flag will cause the deletion to be done against the registry used when publishing the package (see also \`publishConfig.registry\` and \`npmPublishRegistry\`).

      Adding the \`-A,--all\` flag will cause the deletion to be done against all registries and scopes.
    `,
  examples: [[`Logout of the default registry`, `yarn npm logout`], [`Logout of the @my-scope scope`, `yarn npm logout --scope my-scope`], [`Logout of the publish registry for the current package`, `yarn npm logout --publish`], [`Logout of all registries`, `yarn npm logout --all`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String(`-s,--scope`, {
  description: `Logout of the registry configured for a given scope`
})], NpmLogoutCommand.prototype, "scope", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--publish`, {
  description: `Logout of the publish registry`
})], NpmLogoutCommand.prototype, "publish", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`-A,--all`, {
  description: `Logout of all registries`
})], NpmLogoutCommand.prototype, "all", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`npm`, `logout`)], NpmLogoutCommand.prototype, "execute", null);

function removeTokenFromStore(nextStore, entryName) {
  const entry = nextStore[entryName];
  if (!_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.isIndexableObject(entry)) return false;
  const keys = new Set(Object.keys(entry));
  if ([...LOGOUT_KEYS].every(key => !keys.has(key))) return false;

  for (const key of LOGOUT_KEYS) keys.delete(key);

  if (keys.size === 0) {
    nextStore[entryName] = undefined;
    return true;
  }

  const nextEntry = { ...entry
  };

  for (const key of LOGOUT_KEYS) delete nextEntry[key];

  nextStore[entryName] = nextEntry;
  return true;
}

async function logoutFromEverything() {
  const updater = unknownStore => {
    let updated = false;
    const nextStore = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.isIndexableObject(unknownStore) ? { ...unknownStore
    } : {};

    if (nextStore.npmAuthToken) {
      delete nextStore.npmAuthToken;
      updated = true;
    }

    for (const entryName of Object.keys(nextStore)) if (removeTokenFromStore(nextStore, entryName)) updated = true;

    if (Object.keys(nextStore).length === 0) return undefined;

    if (updated) {
      return nextStore;
    } else {
      return unknownStore;
    }
  };

  return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.updateHomeConfiguration({
    npmRegistries: updater,
    npmScopes: updater
  });
}

async function logoutFrom(entryType, entryName) {
  return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.updateHomeConfiguration({
    [entryType]: unknownStore => {
      const nextStore = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.isIndexableObject(unknownStore) ? unknownStore : {};
      if (!Object.prototype.hasOwnProperty.call(nextStore, entryName)) return unknownStore;
      const unknownEntry = nextStore[entryName];
      const nextEntry = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.isIndexableObject(unknownEntry) ? unknownEntry : {};
      const keys = new Set(Object.keys(nextEntry));
      if ([...LOGOUT_KEYS].every(key => !keys.has(key))) return unknownStore;

      for (const key of LOGOUT_KEYS) keys.delete(key);

      if (keys.size === 0) {
        if (Object.keys(nextStore).length === 1) return undefined;
        return { ...nextStore,
          [entryName]: undefined
        };
      }

      const eraser = {};

      for (const key of LOGOUT_KEYS) eraser[key] = undefined;

      return { ...nextStore,
        [entryName]: { ...nextEntry,
          ...eraser
        }
      };
    }
  });
}

/***/ }),
/* 740 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NpmPublishCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(340);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(707);
/* harmony import */ var _yarnpkg_plugin_pack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(717);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);





 // eslint-disable-next-line arca/no-default-export

class NpmPublishCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.tag = `latest`;
    this.tolerateRepublish = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Project.find(configuration, this.context.cwd);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    if (workspace.manifest.private) throw new clipanion__WEBPACK_IMPORTED_MODULE_3__.UsageError(`Private workspaces cannot be published`);
    if (workspace.manifest.name === null || workspace.manifest.version === null) throw new clipanion__WEBPACK_IMPORTED_MODULE_3__.UsageError(`Workspaces must have valid names and versions to be published on an external registry`);
    await project.restoreInstallState(); // We store it so that TS knows that it's non-null

    const ident = workspace.manifest.name;
    const version = workspace.manifest.version;
    const registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getPublishRegistry(workspace.manifest, {
      configuration
    });
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      // Not an error if --tolerate-republish is set
      if (this.tolerateRepublish) {
        try {
          const registryData = await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.get(_yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.getIdentUrl(ident), {
            configuration,
            registry,
            ident,
            jsonResponse: true
          });
          if (!Object.prototype.hasOwnProperty.call(registryData, `versions`)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);

          if (Object.prototype.hasOwnProperty.call(registryData.versions, version)) {
            report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.UNNAMED, `Registry already knows about version ${version}; skipping.`);
            return;
          }
        } catch (error) {
          if (error.name !== `HTTPError`) {
            throw error;
          } else if (error.response.statusCode !== 404) {
            throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.NETWORK_ERROR, `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`);
          }
        }
      }

      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.maybeExecuteWorkspaceLifecycleScript(workspace, `prepublish`, {
        report
      });
      await _yarnpkg_plugin_pack__WEBPACK_IMPORTED_MODULE_2__.packUtils.prepareForPack(workspace, {
        report
      }, async () => {
        const files = await _yarnpkg_plugin_pack__WEBPACK_IMPORTED_MODULE_2__.packUtils.genPackList(workspace);

        for (const file of files) report.reportInfo(null, file);

        const pack = await _yarnpkg_plugin_pack__WEBPACK_IMPORTED_MODULE_2__.packUtils.genPackStream(workspace, files);
        const buffer = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.bufferStream(pack);
        const body = await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmPublishUtils.makePublishBody(workspace, buffer, {
          access: this.access,
          tag: this.tag,
          registry
        });

        try {
          await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.put(_yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.getIdentUrl(ident), body, {
            configuration,
            registry,
            ident,
            jsonResponse: true
          });
        } catch (error) {
          if (error.name !== `HTTPError`) {
            throw error;
          } else {
            const message = error.response.body && error.response.body.error ? error.response.body.error : `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`;
            report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.NETWORK_ERROR, message);
          }
        }
      });

      if (!report.hasErrors()) {
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.UNNAMED, `Package archive published`);
      }
    });
    return report.exitCode();
  }

}
NpmPublishCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Usage({
  category: `Npm-related commands`,
  description: `publish the active workspace to the npm registry`,
  details: `
      This command will pack the active workspace into a fresh archive and upload it to the npm registry.

      The package will by default be attached to the \`latest\` tag on the registry, but this behavior can be overriden by using the \`--tag\` option.

      Note that for legacy reasons scoped packages are by default published with an access set to \`restricted\` (aka "private packages"). This requires you to register for a paid npm plan. In case you simply wish to publish a public scoped package to the registry (for free), just add the \`--access public\` flag. This behavior can be enabled by default through the \`npmPublishAccess\` settings.
    `,
  examples: [[`Publish the active workspace`, `yarn npm publish`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.String(`--access`, {
  description: `The access for the published package (public or restricted)`
})], NpmPublishCommand.prototype, "access", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.String(`--tag`, {
  description: `The tag on the registry that the package should be attached to`
})], NpmPublishCommand.prototype, "tag", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--tolerate-republish`, {
  description: `Warn and exit when republishing an already existing version of a package`
})], NpmPublishCommand.prototype, "tolerateRepublish", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Path(`npm`, `publish`)], NpmPublishCommand.prototype, "execute", null);

/***/ }),
/* 741 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NpmTagAddCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(707);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(742);






 // eslint-disable-next-line arca/no-default-export

class NpmTagAddCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Project.find(configuration, this.context.cwd);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.parseDescriptor(this.package, true);
    const version = descriptor.range;
    if (!semver__WEBPACK_IMPORTED_MODULE_3___default().valid(version)) throw new clipanion__WEBPACK_IMPORTED_MODULE_2__.UsageError(`The range ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.pretty(configuration, descriptor.range, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Type.RANGE)} must be a valid semver version`);
    const registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getPublishRegistry(workspace.manifest, {
      configuration
    });
    const prettyIdent = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.pretty(configuration, descriptor, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Type.IDENT);
    const prettyVersion = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.pretty(configuration, version, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Type.RANGE);
    const prettyTag = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.pretty(configuration, this.tag, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Type.CODE);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const distTags = await (0,_list__WEBPACK_IMPORTED_MODULE_4__.getDistTags)(descriptor, configuration);
      if (Object.prototype.hasOwnProperty.call(distTags, this.tag) && distTags[this.tag] === version) report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.UNNAMED, `Tag ${prettyTag} is already set to version ${prettyVersion}`);

      try {
        const url = `/-/package${_yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.getIdentUrl(descriptor)}/dist-tags/${encodeURIComponent(this.tag)}`;
        await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.put(url, version, {
          configuration,
          registry,
          ident: descriptor,
          jsonRequest: true,
          jsonResponse: true
        });
      } catch (error) {
        if (error.name !== `HTTPError`) {
          throw error;
        } else {
          const message = error.response.body && error.response.body.error ? error.response.body.error : `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`;
          report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.NETWORK_ERROR, message);
        }
      }

      if (!report.hasErrors()) {
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.UNNAMED, `Tag ${prettyTag} added to version ${prettyVersion} of package ${prettyIdent}`);
      }
    });
    return report.exitCode();
  }

}
NpmTagAddCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  category: `Npm-related commands`,
  description: `add a tag for a specific version of a package`,
  details: `
      This command will add a tag to the npm registry for a specific version of a package. If the tag already exists, it will be overwritten.
    `,
  examples: [[`Add a \`beta\` tag for version \`2.3.4-beta.4\` of package \`my-pkg\``, `yarn npm tag add my-pkg@2.3.4-beta.4 beta`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String()], NpmTagAddCommand.prototype, "package", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String()], NpmTagAddCommand.prototype, "tag", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`npm`, `tag`, `add`)], NpmTagAddCommand.prototype, "execute", null);

/***/ }),
/* 742 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NpmTagListCommand,
/* harmony export */   "getDistTags": () => /* binding */ getDistTags
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(411);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(707);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);





 // eslint-disable-next-line arca/no-default-export

class NpmTagListCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    let ident;

    if (typeof this.package !== `undefined`) {
      ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.parseIdent(this.package);
    } else {
      if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
      if (!workspace.manifest.name) throw new clipanion__WEBPACK_IMPORTED_MODULE_2__.UsageError(`Missing 'name' field in ${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.join(workspace.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.Filename.manifest)}`);
      ident = workspace.manifest.name;
    }

    const distTags = await getDistTags(ident, configuration);
    const distTagEntries = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.sortMap(Object.entries(distTags), ([tag]) => tag);
    const tree = {
      children: distTagEntries.map(([tag, version]) => ({
        value: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.tuple(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Type.RESOLUTION, {
          descriptor: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.makeDescriptor(ident, tag),
          locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.makeLocator(ident, version)
        })
      }))
    };
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.emitTree(tree, {
      configuration,
      json: this.json,
      stdout: this.context.stdout
    });
  }

}
NpmTagListCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  category: `Npm-related commands`,
  description: `list all dist-tags of a package`,
  details: `
      This command will list all tags of a package from the npm registry.

      If the package is not specified, Yarn will default to the current workspace.
    `,
  examples: [[`List all tags of package \`my-pkg\``, `yarn npm tag list my-pkg`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String({
  required: false
})], NpmTagListCommand.prototype, "package", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--json`, {
  description: `Format the output as an NDJSON stream`
})], NpmTagListCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`npm`, `tag`, `list`)], NpmTagListCommand.prototype, "execute", null);

async function getDistTags(ident, configuration) {
  const url = `/-/package${_yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.getIdentUrl(ident)}/dist-tags`;
  return _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.get(url, {
    configuration,
    ident,
    jsonResponse: true
  }).catch(err => {
    if (err.name !== `HTTPError`) {
      throw err;
    } else if (err.response.statusCode === 404) {
      throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.MessageName.EXCEPTION, `Package not found`);
    } else {
      throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.MessageName.EXCEPTION, err.toString());
    }
  });
}

/***/ }),
/* 743 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NpmTagRemoveCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(707);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var yup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(413);
/* harmony import */ var _list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(742);






 // eslint-disable-next-line arca/no-default-export

class NpmTagRemoveCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Project.find(configuration, this.context.cwd);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.parseIdent(this.package);
    const registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getPublishRegistry(workspace.manifest, {
      configuration
    });
    const prettyTag = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.pretty(configuration, this.tag, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Type.CODE);
    const prettyIdent = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.pretty(configuration, ident, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.Type.IDENT);
    const distTags = await (0,_list__WEBPACK_IMPORTED_MODULE_4__.getDistTags)(ident, configuration);
    if (!Object.prototype.hasOwnProperty.call(distTags, this.tag)) throw new clipanion__WEBPACK_IMPORTED_MODULE_2__.UsageError(`${prettyTag} is not a tag of package ${prettyIdent}`);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      try {
        const url = `/-/package${_yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.getIdentUrl(ident)}/dist-tags/${encodeURIComponent(this.tag)}`;
        await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.del(url, {
          configuration,
          registry,
          ident,
          jsonResponse: true
        });
      } catch (error) {
        if (error.name !== `HTTPError`) {
          throw error;
        } else {
          const message = error.response.body && error.response.body.error ? error.response.body.error : `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`;
          report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.NETWORK_ERROR, message);
        }
      }

      if (!report.hasErrors()) {
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.UNNAMED, `Tag ${prettyTag} removed from package ${prettyIdent}`);
      }
    });
    return report.exitCode();
  }

}
NpmTagRemoveCommand.schema = yup__WEBPACK_IMPORTED_MODULE_3__.object().shape({
  // Better show a more detailed error, rather than the npm registry's "Bad request"
  tag: yup__WEBPACK_IMPORTED_MODULE_3__.string().notOneOf([`latest`])
});
NpmTagRemoveCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  category: `Npm-related commands`,
  description: `remove a tag from a package`,
  details: `
      This command will remove a tag from a package from the npm registry.
    `,
  examples: [[`Remove the \`beta\` tag from package \`my-pkg\``, `yarn npm tag remove my-pkg beta`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String()], NpmTagRemoveCommand.prototype, "package", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String()], NpmTagRemoveCommand.prototype, "tag", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`npm`, `tag`, `remove`)], NpmTagRemoveCommand.prototype, "execute", null);

/***/ }),
/* 744 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NpmWhoamiCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(707);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);





 // eslint-disable-next-line arca/no-default-export

class NpmWhoamiCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.publish = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    let registry;
    if (this.scope && this.publish) registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getScopeRegistry(this.scope, {
      configuration,
      type: _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.RegistryType.PUBLISH_REGISTRY
    });else if (this.scope) registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getScopeRegistry(this.scope, {
      configuration
    });else if (this.publish) registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getPublishRegistry((await (0,_yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.openWorkspace)(configuration, this.context.cwd)).manifest, {
      configuration
    });else registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getDefaultRegistry({
      configuration
    });
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      try {
        const response = await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.get(`/-/whoami`, {
          configuration,
          registry,
          authType: _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.AuthType.ALWAYS_AUTH,
          jsonResponse: true,
          ident: this.scope ? _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.makeIdent(this.scope, ``) : undefined
        });
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.UNNAMED, response.username);
      } catch (err) {
        if (err.name !== `HTTPError`) {
          throw err;
        } else if (err.response.statusCode === 401 || err.response.statusCode === 403) {
          report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.AUTHENTICATION_INVALID, `Authentication failed - your credentials may have expired`);
        } else {
          report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.AUTHENTICATION_INVALID, err.toString());
        }
      }
    });
    return report.exitCode();
  }

}
NpmWhoamiCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  category: `Npm-related commands`,
  description: `display the name of the authenticated user`,
  details: `
      Print the username associated with the current authentication settings to the standard output.

      When using \`-s,--scope\`, the username printed will be the one that matches the authentication settings of the registry associated with the given scope (those settings can be overriden using the \`npmRegistries\` map, and the registry associated with the scope is configured via the \`npmScopes\` map).

      When using \`--publish\`, the registry we'll select will by default be the one used when publishing packages (\`publishConfig.registry\` or \`npmPublishRegistry\` if available, otherwise we'll fallback to the regular \`npmRegistryServer\`).
    `,
  examples: [[`Print username for the default registry`, `yarn npm whoami`], [`Print username for the registry on a given scope`, `yarn npm whoami --scope company`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String(`-s,--scope`, {
  description: `Print username for the registry configured for a given scope`
})], NpmWhoamiCommand.prototype, "scope", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--publish`, {
  description: `Print username for the publish registry`
})], NpmWhoamiCommand.prototype, "publish", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`npm`, `whoami`)], NpmWhoamiCommand.prototype, "execute", null);

/***/ }),
/* 745 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "patchUtils": () => /* reexport module object */ _patchUtils__WEBPACK_IMPORTED_MODULE_4__,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(181);
/* harmony import */ var _PatchFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(746);
/* harmony import */ var _PatchResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(752);
/* harmony import */ var _commands_patchCommit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(753);
/* harmony import */ var _commands_patch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(754);
/* harmony import */ var _patchUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(747);







const plugin = {
  configuration: {
    enableInlineHunks: {
      description: `If true, the installs will print unmatched patch hunks`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.SettingsType.BOOLEAN,
      default: false
    }
  },
  commands: [_commands_patchCommit__WEBPACK_IMPORTED_MODULE_2__.default, _commands_patch__WEBPACK_IMPORTED_MODULE_3__.default],
  fetchers: [_PatchFetcher__WEBPACK_IMPORTED_MODULE_0__.PatchFetcher],
  resolvers: [_PatchResolver__WEBPACK_IMPORTED_MODULE_1__.PatchResolver]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 746 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PatchFetcher": () => /* binding */ PatchFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(155);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(163);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(170);
/* harmony import */ var _yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(341);
/* harmony import */ var _patchUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(747);
/* harmony import */ var _tools_UnmatchedHunkError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(749);
/* harmony import */ var _tools_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(751);







class PatchFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith(`patch:`)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
      loader: () => this.patchPackage(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.getIdentVendorPath(locator),
      localPath: this.getLocalPath(locator, opts),
      checksum
    };
  }

  async patchPackage(locator, opts) {
    const {
      parentLocator,
      sourceLocator,
      sourceVersion,
      patchPaths
    } = _patchUtils__WEBPACK_IMPORTED_MODULE_1__.parseLocator(locator);
    const patchFiles = await _patchUtils__WEBPACK_IMPORTED_MODULE_1__.loadPatchFiles(parentLocator, patchPaths, opts);
    const tmpDir = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.mktempPromise();
    const tmpFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.join(tmpDir, `patched.zip`);
    const sourceFetch = await opts.fetcher.fetch(sourceLocator, opts);
    const prefixPath = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.getIdentVendorPath(locator);
    const libzip = await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)();
    const patchedPackage = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ZipFS(tmpFile, {
      libzip,
      create: true,
      level: opts.project.configuration.get(`compressionLevel`)
    });
    await patchedPackage.mkdirpPromise(prefixPath);
    await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.releaseAfterUseAsync(async () => {
      await patchedPackage.copyPromise(prefixPath, sourceFetch.prefixPath, {
        baseFs: sourceFetch.packageFs,
        stableSort: true
      });
    }, sourceFetch.releaseFs);
    const patchFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.PortablePath.root, prefixPath), {
      baseFs: patchedPackage
    });

    for (const patchFile of patchFiles) {
      if (patchFile !== null) {
        try {
          await _patchUtils__WEBPACK_IMPORTED_MODULE_1__.applyPatchFile(_patchUtils__WEBPACK_IMPORTED_MODULE_1__.parsePatchFile(patchFile), {
            baseFs: patchFs,
            version: sourceVersion
          });
        } catch (err) {
          if (!(err instanceof _tools_UnmatchedHunkError__WEBPACK_IMPORTED_MODULE_2__.UnmatchedHunkError)) throw err;
          const enableInlineHunks = opts.project.configuration.get(`enableInlineHunks`);
          const suggestion = !enableInlineHunks ? ` (set enableInlineHunks for details)` : ``;
          throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.PATCH_HUNK_FAILED, err.message + suggestion, report => {
            if (!enableInlineHunks) return;
            (0,_tools_format__WEBPACK_IMPORTED_MODULE_3__.reportHunk)(err.hunk, {
              configuration: opts.project.configuration,
              report
            });
          });
        }
      }
    }

    return patchedPackage;
  }

}

/***/ }),
/* 747 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyPatchFile": () => /* reexport safe */ _tools_apply__WEBPACK_IMPORTED_MODULE_0__.applyPatchFile,
/* harmony export */   "parsePatchFile": () => /* reexport safe */ _tools_parse__WEBPACK_IMPORTED_MODULE_1__.parsePatchFile,
/* harmony export */   "parseDescriptor": () => /* binding */ parseDescriptor,
/* harmony export */   "parseLocator": () => /* binding */ parseLocator,
/* harmony export */   "makeDescriptor": () => /* binding */ makeDescriptor,
/* harmony export */   "makeLocator": () => /* binding */ makeLocator,
/* harmony export */   "isParentRequired": () => /* binding */ isParentRequired,
/* harmony export */   "loadPatchFiles": () => /* binding */ loadPatchFiles,
/* harmony export */   "extractPackageToDisk": () => /* binding */ extractPackageToDisk,
/* harmony export */   "diffFolders": () => /* binding */ diffFolders
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(335);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(373);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(170);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(155);
/* harmony import */ var _tools_apply__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(748);
/* harmony import */ var _tools_parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(750);




const BUILTIN_REGEXP = /^builtin<([^>]+)>$/;

function parseSpec(spec, sourceParser) {
  const {
    source,
    selector,
    params
  } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.parseRange(spec);
  if (source === null) throw new Error(`Patch locators must explicitly define their source`);
  const patchPaths = selector ? selector.split(/&/).map(path => _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.toPortablePath(path)) : [];
  const parentLocator = params && typeof params.locator === `string` ? _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.parseLocator(params.locator) : null;
  const sourceVersion = params && typeof params.version === `string` ? params.version : null;
  const sourceItem = sourceParser(source);
  return {
    parentLocator,
    sourceItem,
    patchPaths,
    sourceVersion
  };
}

function parseDescriptor(descriptor) {
  const {
    sourceItem,
    ...rest
  } = parseSpec(descriptor.range, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.parseDescriptor);
  return { ...rest,
    sourceDescriptor: sourceItem
  };
}
function parseLocator(locator) {
  const {
    sourceItem,
    ...rest
  } = parseSpec(locator.reference, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.parseLocator);
  return { ...rest,
    sourceLocator: sourceItem
  };
}

function makeSpec({
  parentLocator,
  sourceItem,
  patchPaths,
  sourceVersion,
  patchHash
}, sourceStringifier) {
  const parentLocatorSpread = parentLocator !== null ? {
    locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyLocator(parentLocator)
  } : {};
  const sourceVersionSpread = typeof sourceVersion !== `undefined` ? {
    version: sourceVersion
  } : {};
  const patchHashSpread = typeof patchHash !== `undefined` ? {
    hash: patchHash
  } : {};
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.makeRange({
    protocol: `patch:`,
    source: sourceStringifier(sourceItem),
    selector: patchPaths.join(`&`),
    params: { ...sourceVersionSpread,
      ...patchHashSpread,
      ...parentLocatorSpread
    }
  });
}

function makeDescriptor(ident, {
  parentLocator,
  sourceDescriptor,
  patchPaths
}) {
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.makeLocator(ident, makeSpec({
    parentLocator,
    sourceItem: sourceDescriptor,
    patchPaths
  }, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyDescriptor));
}
function makeLocator(ident, {
  parentLocator,
  sourcePackage,
  patchPaths,
  patchHash
}) {
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.makeLocator(ident, makeSpec({
    parentLocator,
    sourceItem: sourcePackage,
    sourceVersion: sourcePackage.version,
    patchPaths,
    patchHash
  }, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyLocator));
}

function visitPatchPath({
  onAbsolute,
  onRelative,
  onBuiltin
}, patchPath) {
  const builtinMatch = patchPath.match(BUILTIN_REGEXP);
  if (builtinMatch !== null) return onBuiltin(builtinMatch[1]);

  if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.isAbsolute(patchPath)) {
    return onAbsolute(patchPath);
  } else {
    return onRelative(patchPath);
  }
}

function isParentRequired(patchPath) {
  return visitPatchPath({
    onAbsolute: () => false,
    onRelative: () => true,
    onBuiltin: () => false
  }, patchPath);
}
async function loadPatchFiles(parentLocator, patchPaths, opts) {
  // When the patch files use absolute paths we can directly access them via
  // their location on the disk. Otherwise we must go through the package fs.
  const parentFetch = parentLocator !== null ? await opts.fetcher.fetch(parentLocator, opts) : null; // If the package fs publicized its "original location" (for example like
  // in the case of "file:" packages), we use it to derive the real location.

  const effectiveParentFetch = parentFetch && parentFetch.localPath ? {
    packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.PortablePath.root),
    prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.PortablePath.root, parentFetch.localPath)
  } : parentFetch; // Discard the parent fs unless we really need it to access the files

  if (parentFetch && parentFetch !== effectiveParentFetch && parentFetch.releaseFs) parentFetch.releaseFs(); // First we obtain the specification for all the patches that we'll have to
  // apply to the original package.

  const patchFiles = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.releaseAfterUseAsync(async () => {
    return await Promise.all(patchPaths.map(async patchPath => visitPatchPath({
      onAbsolute: async () => {
        return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.readFilePromise(patchPath, `utf8`);
      },
      onRelative: async () => {
        if (parentFetch === null) throw new Error(`Assertion failed: The parent locator should have been fetched`);
        return await parentFetch.packageFs.readFilePromise(patchPath, `utf8`);
      },
      onBuiltin: async name => {
        return await opts.project.configuration.firstHook(hooks => {
          return hooks.getBuiltinPatch;
        }, opts.project, name);
      }
    }, patchPath)));
  }); // Normalizes the line endings to prevent mismatches when cloning a
  // repository on Windows systems (the default settings for Git are to
  // convert newlines back and forth, which would mess with the checksum)

  return patchFiles.map(definition => {
    if (typeof definition === `string`) {
      return definition.replace(/\r\n?/g, `\n`);
    } else {
      return definition;
    }
  });
}
async function extractPackageToDisk(locator, {
  cache,
  project
}) {
  const checksums = project.storedChecksums;
  const report = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.ThrowReport();
  const fetcher = project.configuration.makeFetcher();
  const fetchResult = await fetcher.fetch(locator, {
    cache,
    project,
    fetcher,
    checksums,
    report
  });
  const temp = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mktempPromise();
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.copyPromise(temp, fetchResult.prefixPath, {
    baseFs: fetchResult.packageFs
  });
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.writeJsonPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.join(temp, `.yarn-patch.json`), {
    locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.stringifyLocator(locator)
  });
  _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.detachTemp(temp);
  return temp;
}
async function diffFolders(folderA, folderB) {
  const folderAN = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(folderA).replace(/\\/g, `/`);
  const folderBN = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(folderB).replace(/\\/g, `/`);
  const {
    stdout
  } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.execvp(`git`, [`diff`, `--src-prefix=a/`, `--dst-prefix=b/`, `--ignore-cr-at-eol`, `--full-index`, `--no-index`, folderAN, folderBN], {
    cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.toPortablePath(process.cwd())
  });
  const normalizePath = folderAN.startsWith(`/`) ? p => p.slice(1) : p => p;
  return stdout.replace(new RegExp(`(a|b)(${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.escapeRegExp(`/${normalizePath(folderAN)}/`)})`, `g`), `$1/`).replace(new RegExp(`(a|b)${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.escapeRegExp(`/${normalizePath(folderBN)}/`)}`, `g`), `$1/`).replace(new RegExp(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.escapeRegExp(`${folderAN}/`), `g`), ``).replace(new RegExp(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.escapeRegExp(`${folderBN}/`), `g`), ``);
}

/***/ }),
/* 748 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyPatchFile": () => /* binding */ applyPatchFile,
/* harmony export */   "applyPatch": () => /* binding */ applyPatch
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(231);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(165);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(162);
/* harmony import */ var _UnmatchedHunkError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(749);
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(750);




const DEFAULT_TIME = 315532800;

async function preserveTime(baseFs, p, cb) {
  const stat = await baseFs.lstatPromise(p);
  const result = await cb();
  if (typeof result !== `undefined`) p = result;

  if (baseFs.lutimesPromise) {
    await baseFs.lutimesPromise(p, stat.atime, stat.mtime);
  } else if (!stat.isSymbolicLink()) {
    await baseFs.utimesPromise(p, stat.atime, stat.mtime);
  } else {
    throw new Error(`Cannot preserve the time values of a symlink`);
  }
}

async function applyPatchFile(effects, {
  baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.NodeFS(),
  dryRun = false,
  version = null
} = {}) {
  for (const eff of effects) {
    if (eff.semverExclusivity !== null && version !== null) if (!_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.satisfiesWithPrereleases(version, eff.semverExclusivity)) continue;

    switch (eff.type) {
      case `file deletion`:
        {
          if (dryRun) {
            if (!baseFs.existsSync(eff.path)) {
              throw new Error(`Trying to delete a file that doesn't exist: ${eff.path}`);
            }
          } else {
            await preserveTime(baseFs, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.dirname(eff.path), async () => {
              await baseFs.unlinkPromise(eff.path);
            });
          }
        }
        break;

      case `rename`:
        {
          if (dryRun) {
            if (!baseFs.existsSync(eff.fromPath)) {
              throw new Error(`Trying to move a file that doesn't exist: ${eff.fromPath}`);
            }
          } else {
            await preserveTime(baseFs, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.dirname(eff.fromPath), async () => {
              await preserveTime(baseFs, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.dirname(eff.toPath), async () => {
                await preserveTime(baseFs, eff.fromPath, async () => {
                  await baseFs.movePromise(eff.fromPath, eff.toPath);
                  return eff.toPath;
                });
              });
            });
          }
        }
        break;

      case `file creation`:
        {
          if (dryRun) {
            if (baseFs.existsSync(eff.path)) {
              throw new Error(`Trying to create a file that already exists: ${eff.path}`);
            }
          } else {
            const fileContents = eff.hunk ? eff.hunk.parts[0].lines.join(`\n`) + (eff.hunk.parts[0].noNewlineAtEndOfFile ? `` : `\n`) : ``; // Todo: the parent of the first directory thus created will still see its mtime changed

            await baseFs.mkdirpPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.dirname(eff.path), {
              chmod: 0o755,
              utimes: [DEFAULT_TIME, DEFAULT_TIME]
            });
            await baseFs.writeFilePromise(eff.path, fileContents, {
              mode: eff.mode
            });
            await baseFs.utimesPromise(eff.path, DEFAULT_TIME, DEFAULT_TIME);
          }
        }
        break;

      case `patch`:
        {
          await preserveTime(baseFs, eff.path, async () => {
            await applyPatch(eff, {
              baseFs,
              dryRun
            });
          });
        }
        break;

      case `mode change`:
        {
          const currentStat = await baseFs.statPromise(eff.path);
          const currentMode = currentStat.mode;
          if (isExecutable(eff.newMode) !== isExecutable(currentMode)) continue;
          await preserveTime(baseFs, eff.path, async () => {
            await baseFs.chmodPromise(eff.path, eff.newMode);
          });
        }
        break;

      default:
        {
          _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.assertNever(eff);
        }
        break;
    }
  }
}

function isExecutable(fileMode) {
  return (fileMode & 0o100) > 0;
}

function trimRight(s) {
  return s.replace(/\s+$/, ``);
}

function linesAreEqual(a, b) {
  return trimRight(a) === trimRight(b);
}
/**
 * How does noNewLineAtEndOfFile work?
 *
 * if you remove the newline from a file that had one without editing other bits:
 *
 *    it creates an insertion/removal pair where the insertion has \ No new line at end of file
 *
 * if you edit a file that didn't have a new line and don't add one:
 *
 *    both insertion and deletion have \ No new line at end of file
 *
 * if you edit a file that didn't have a new line and add one:
 *
 *    deletion has \ No new line at end of file
 *    but not insertion
 *
 * if you edit a file that had a new line and leave it in:
 *
 *    neither insetion nor deletion have the annoation
 *
 */


async function applyPatch({
  hunks,
  path
}, {
  baseFs,
  dryRun = false
}) {
  const mode = await baseFs.statSync(path).mode;
  const fileContents = await baseFs.readFileSync(path, `utf8`);
  const fileLines = fileContents.split(/\n/);
  const result = [];
  let fixupOffset = 0;
  let maxFrozenLine = 0;

  for (const hunk of hunks) {
    const firstGuess = Math.max(maxFrozenLine, hunk.header.patched.start + fixupOffset);
    const maxPrefixFuzz = Math.max(0, firstGuess - maxFrozenLine);
    const maxSuffixFuzz = Math.max(0, fileLines.length - firstGuess - hunk.header.original.length);
    const maxFuzz = Math.max(maxPrefixFuzz, maxSuffixFuzz);
    let offset = 0;
    let location = 0;
    let modifications = null;

    while (offset <= maxFuzz) {
      if (offset <= maxPrefixFuzz) {
        location = firstGuess - offset;
        modifications = evaluateHunk(hunk, fileLines, location);

        if (modifications !== null) {
          offset = -offset;
          break;
        }
      }

      if (offset <= maxSuffixFuzz) {
        location = firstGuess + offset;
        modifications = evaluateHunk(hunk, fileLines, location);

        if (modifications !== null) {
          break;
        }
      }

      offset += 1;
    }

    if (modifications === null) throw new _UnmatchedHunkError__WEBPACK_IMPORTED_MODULE_0__.UnmatchedHunkError(hunks.indexOf(hunk), hunk);
    result.push(modifications);
    fixupOffset += offset;
    maxFrozenLine = location + hunk.header.original.length;
  }

  if (dryRun) return;
  let diffOffset = 0;

  for (const modifications of result) {
    for (const modification of modifications) {
      switch (modification.type) {
        case `splice`:
          {
            const firstLine = modification.index + diffOffset;
            fileLines.splice(firstLine, modification.numToDelete, ...modification.linesToInsert);
            diffOffset += modification.linesToInsert.length - modification.numToDelete;
          }
          break;

        case `pop`:
          {
            fileLines.pop();
          }
          break;

        case `push`:
          {
            fileLines.push(modification.line);
          }
          break;

        default:
          {
            _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.assertNever(modification);
          }
          break;
      }
    }
  }

  await baseFs.writeFilePromise(path, fileLines.join(`\n`), {
    mode
  });
}

function evaluateHunk(hunk, fileLines, offset) {
  const result = [];

  for (const part of hunk.parts) {
    switch (part.type) {
      case _parse__WEBPACK_IMPORTED_MODULE_1__.PatchMutationType.Context:
      case _parse__WEBPACK_IMPORTED_MODULE_1__.PatchMutationType.Deletion:
        {
          for (const line of part.lines) {
            const originalLine = fileLines[offset];
            if (originalLine == null || !linesAreEqual(originalLine, line)) return null;
            offset += 1;
          }

          if (part.type === _parse__WEBPACK_IMPORTED_MODULE_1__.PatchMutationType.Deletion) {
            result.push({
              type: `splice`,
              index: offset - part.lines.length,
              numToDelete: part.lines.length,
              linesToInsert: []
            });

            if (part.noNewlineAtEndOfFile) {
              result.push({
                type: `push`,
                line: ``
              });
            }
          }
        }
        break;

      case _parse__WEBPACK_IMPORTED_MODULE_1__.PatchMutationType.Insertion:
        {
          result.push({
            type: `splice`,
            index: offset,
            numToDelete: 0,
            linesToInsert: part.lines
          });

          if (part.noNewlineAtEndOfFile) {
            result.push({
              type: `pop`
            });
          }
        }
        break;

      default:
        {
          _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.assertNever(part.type);
        }
        break;
    }
  }

  return result;
}

/***/ }),
/* 749 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnmatchedHunkError": () => /* binding */ UnmatchedHunkError
/* harmony export */ });
class UnmatchedHunkError extends Error {
  constructor(index, hunk) {
    super(`Cannot apply hunk #${index + 1}`);
    this.hunk = hunk;
  }

}

/***/ }),
/* 750 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPath": () => /* binding */ getPath,
/* harmony export */   "parseHunkHeaderLine": () => /* binding */ parseHunkHeaderLine,
/* harmony export */   "NON_EXECUTABLE_FILE_MODE": () => /* binding */ NON_EXECUTABLE_FILE_MODE,
/* harmony export */   "EXECUTABLE_FILE_MODE": () => /* binding */ EXECUTABLE_FILE_MODE,
/* harmony export */   "PatchMutationType": () => /* binding */ PatchMutationType,
/* harmony export */   "interpretParsedPatchFile": () => /* binding */ interpretParsedPatchFile,
/* harmony export */   "parsePatchFile": () => /* binding */ parsePatchFile,
/* harmony export */   "verifyHunkIntegrity": () => /* binding */ verifyHunkIntegrity
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(162);


const HEADER_REGEXP = /^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))? @@.*/;
function getPath(p) {
  return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.PortablePath.root, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.PortablePath.root, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.toPortablePath(p)));
}
function parseHunkHeaderLine(headerLine) {
  const match = headerLine.trim().match(HEADER_REGEXP);
  if (!match) throw new Error(`Bad header line: '${headerLine}'`);
  return {
    original: {
      start: Math.max(Number(match[1]), 1),
      length: Number(match[3] || 1)
    },
    patched: {
      start: Math.max(Number(match[4]), 1),
      length: Number(match[6] || 1)
    }
  };
}
const NON_EXECUTABLE_FILE_MODE = 0o644;
const EXECUTABLE_FILE_MODE = 0o755;
var PatchMutationType;

(function (PatchMutationType) {
  PatchMutationType["Context"] = "context";
  PatchMutationType["Insertion"] = "insertion";
  PatchMutationType["Deletion"] = "deletion";
})(PatchMutationType || (PatchMutationType = {}));

const emptyFilePatch = () => ({
  semverExclusivity: null,
  diffLineFromPath: null,
  diffLineToPath: null,
  oldMode: null,
  newMode: null,
  deletedFileMode: null,
  newFileMode: null,
  renameFrom: null,
  renameTo: null,
  beforeHash: null,
  afterHash: null,
  fromPath: null,
  toPath: null,
  hunks: null
});

const emptyHunk = headerLine => ({
  header: parseHunkHeaderLine(headerLine),
  parts: []
});

const hunkLinetypes = {
  [`@`]: `header`,
  [`-`]: PatchMutationType.Deletion,
  [`+`]: PatchMutationType.Insertion,
  [` `]: PatchMutationType.Context,
  [`\\`]: `pragma`,
  // Treat blank lines as context
  undefined: PatchMutationType.Context
};

function parsePatchLines(lines) {
  const result = [];
  let currentFilePatch = emptyFilePatch();
  let state = `parsing header`;
  let currentHunk = null;
  let currentHunkMutationPart = null;

  function commitHunk() {
    if (currentHunk) {
      if (currentHunkMutationPart) {
        currentHunk.parts.push(currentHunkMutationPart);
        currentHunkMutationPart = null;
      }

      currentFilePatch.hunks.push(currentHunk);
      currentHunk = null;
    }
  }

  function commitFilePatch() {
    commitHunk();
    result.push(currentFilePatch);
    currentFilePatch = emptyFilePatch();
  }

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (state === `parsing header`) {
      if (line.startsWith(`@@`)) {
        state = `parsing hunks`;
        currentFilePatch.hunks = [];
        i -= 1;
      } else if (line.startsWith(`diff --git `)) {
        if (currentFilePatch && currentFilePatch.diffLineFromPath) commitFilePatch();
        const match = line.match(/^diff --git a\/(.*?) b\/(.*?)\s*$/);
        if (!match) throw new Error(`Bad diff line: ${line}`);
        currentFilePatch.diffLineFromPath = match[1];
        currentFilePatch.diffLineToPath = match[2];
      } else if (line.startsWith(`old mode `)) {
        currentFilePatch.oldMode = line.slice(`old mode `.length).trim();
      } else if (line.startsWith(`new mode `)) {
        currentFilePatch.newMode = line.slice(`new mode `.length).trim();
      } else if (line.startsWith(`deleted file mode `)) {
        currentFilePatch.deletedFileMode = line.slice(`deleted file mode `.length).trim();
      } else if (line.startsWith(`new file mode `)) {
        currentFilePatch.newFileMode = line.slice(`new file mode `.length).trim();
      } else if (line.startsWith(`rename from `)) {
        currentFilePatch.renameFrom = line.slice(`rename from `.length).trim();
      } else if (line.startsWith(`rename to `)) {
        currentFilePatch.renameTo = line.slice(`rename to `.length).trim();
      } else if (line.startsWith(`index `)) {
        const match = line.match(/(\w+)\.\.(\w+)/);
        if (!match) continue;
        currentFilePatch.beforeHash = match[1];
        currentFilePatch.afterHash = match[2];
      } else if (line.startsWith(`semver exclusivity `)) {
        currentFilePatch.semverExclusivity = line.slice(`semver exclusivity `.length).trim();
      } else if (line.startsWith(`--- `)) {
        currentFilePatch.fromPath = line.slice(`--- a/`.length).trim();
      } else if (line.startsWith(`+++ `)) {
        currentFilePatch.toPath = line.slice(`+++ b/`.length).trim();
      }
    } else {
      // parsing hunks
      const lineType = hunkLinetypes[line[0]] || null;

      switch (lineType) {
        case `header`:
          {
            commitHunk();
            currentHunk = emptyHunk(line);
          }
          break;

        case null:
          {
            // unrecognized, bail out
            state = `parsing header`;
            commitFilePatch();
            i -= 1;
          }
          break;

        case `pragma`:
          {
            if (!line.startsWith(`\\ No newline at end of file`)) throw new Error(`Unrecognized pragma in patch file: ${line}`);
            if (!currentHunkMutationPart) throw new Error(`Bad parser state: No newline at EOF pragma encountered without context`);
            currentHunkMutationPart.noNewlineAtEndOfFile = true;
          }
          break;

        case PatchMutationType.Context:
        case PatchMutationType.Deletion:
        case PatchMutationType.Insertion:
          {
            if (!currentHunk) throw new Error(`Bad parser state: Hunk lines encountered before hunk header`);

            if (currentHunkMutationPart && currentHunkMutationPart.type !== lineType) {
              currentHunk.parts.push(currentHunkMutationPart);
              currentHunkMutationPart = null;
            }

            if (!currentHunkMutationPart) {
              currentHunkMutationPart = {
                type: lineType,
                lines: [],
                noNewlineAtEndOfFile: false
              };
            }

            currentHunkMutationPart.lines.push(line.slice(1));
          }
          break;

        default:
          {
            _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.assertNever(lineType);
          }
          break;
      }
    }
  }

  commitFilePatch();

  for (const {
    hunks
  } of result) if (hunks) for (const hunk of hunks) verifyHunkIntegrity(hunk);

  return result;
}

function interpretParsedPatchFile(files) {
  const result = [];

  for (const file of files) {
    const {
      semverExclusivity,
      diffLineFromPath,
      diffLineToPath,
      oldMode,
      newMode,
      deletedFileMode,
      newFileMode,
      renameFrom,
      renameTo,
      beforeHash,
      afterHash,
      fromPath,
      toPath,
      hunks
    } = file;
    const type = renameFrom ? `rename` : deletedFileMode ? `file deletion` : newFileMode ? `file creation` : hunks && hunks.length > 0 ? `patch` : `mode change`;
    let destinationFilePath = null;

    switch (type) {
      case `rename`:
        {
          if (!renameFrom || !renameTo) throw new Error(`Bad parser state: rename from & to not given`);
          result.push({
            type: `rename`,
            semverExclusivity,
            fromPath: getPath(renameFrom),
            toPath: getPath(renameTo)
          });
          destinationFilePath = renameTo;
        }
        break;

      case `file deletion`:
        {
          const path = diffLineFromPath || fromPath;
          if (!path) throw new Error(`Bad parse state: no path given for file deletion`);
          result.push({
            type: `file deletion`,
            semverExclusivity,
            hunk: hunks && hunks[0] || null,
            path: getPath(path),
            mode: parseFileMode(deletedFileMode),
            hash: beforeHash
          });
        }
        break;

      case `file creation`:
        {
          const path = diffLineToPath || toPath;
          if (!path) throw new Error(`Bad parse state: no path given for file creation`);
          result.push({
            type: `file creation`,
            semverExclusivity,
            hunk: hunks && hunks[0] || null,
            path: getPath(path),
            mode: parseFileMode(newFileMode),
            hash: afterHash
          });
        }
        break;

      case `patch`:
      case `mode change`:
        {
          destinationFilePath = toPath || diffLineToPath;
        }
        break;

      default:
        {
          _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.assertNever(type);
        }
        break;
    }

    if (destinationFilePath && oldMode && newMode && oldMode !== newMode) {
      result.push({
        type: `mode change`,
        semverExclusivity,
        path: getPath(destinationFilePath),
        oldMode: parseFileMode(oldMode),
        newMode: parseFileMode(newMode)
      });
    }

    if (destinationFilePath && hunks && hunks.length) {
      result.push({
        type: `patch`,
        semverExclusivity,
        path: getPath(destinationFilePath),
        hunks,
        beforeHash,
        afterHash
      });
    }
  }

  return result;
}

function parseFileMode(mode) {
  const parsedMode = parseInt(mode, 8) & 0o777;
  if (parsedMode !== NON_EXECUTABLE_FILE_MODE && parsedMode !== EXECUTABLE_FILE_MODE) throw new Error(`Unexpected file mode string: ${mode}`);
  return parsedMode;
}

function parsePatchFile(file) {
  const lines = file.split(/\n/g);
  if (lines[lines.length - 1] === ``) lines.pop();
  return interpretParsedPatchFile(parsePatchLines(lines));
}
function verifyHunkIntegrity(hunk) {
  // verify hunk integrity
  let originalLength = 0;
  let patchedLength = 0;

  for (const {
    type,
    lines
  } of hunk.parts) {
    switch (type) {
      case PatchMutationType.Context:
        {
          patchedLength += lines.length;
          originalLength += lines.length;
        }
        break;

      case PatchMutationType.Deletion:
        {
          originalLength += lines.length;
        }
        break;

      case PatchMutationType.Insertion:
        {
          patchedLength += lines.length;
        }
        break;

      default:
        {
          _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.assertNever(type);
        }
        break;
    }
  }

  if (originalLength !== hunk.header.original.length || patchedLength !== hunk.header.patched.length) {
    const format = n => n < 0 ? n : `+${n}`;

    throw new Error(`hunk header integrity check failed (expected @@ ${format(hunk.header.original.length)} ${format(hunk.header.patched.length)} @@, got @@ ${format(originalLength)} ${format(patchedLength)} @@)`);
  }
}

/***/ }),
/* 751 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "reportHunk": () => /* binding */ reportHunk
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(177);
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(750);


function reportHunk(hunk, {
  configuration,
  report
}) {
  for (const part of hunk.parts) {
    for (const line of part.lines) {
      switch (part.type) {
        case _parse__WEBPACK_IMPORTED_MODULE_0__.PatchMutationType.Context:
          {
            report.reportInfo(null, `  ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.pretty(configuration, line, `grey`)}`);
          }
          break;

        case _parse__WEBPACK_IMPORTED_MODULE_0__.PatchMutationType.Deletion:
          {
            report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.MessageName.FROZEN_LOCKFILE_EXCEPTION, `- ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.pretty(configuration, line, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.Type.REMOVED)}`);
          }
          break;

        case _parse__WEBPACK_IMPORTED_MODULE_0__.PatchMutationType.Insertion:
          {
            report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.MessageName.FROZEN_LOCKFILE_EXCEPTION, `+ ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.pretty(configuration, line, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.Type.ADDED)}`);
          }
          break;

        default:
          {
            _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.assertNever(part.type);
          }
      }
    }
  }
}

/***/ }),
/* 752 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PatchResolver": () => /* binding */ PatchResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _patchUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(747);


 // We use this to for the patches to be regenerated without bumping the whole
// cache, like when the libzip had incorrect mtime in some cases

const CACHE_VERSION = 2;
class PatchResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith(`patch:`)) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith(`patch:`)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    // If the patch is statically defined (ie absolute or a builtin), then we
    // don't need to bind the descriptor to its parent
    const {
      patchPaths
    } = _patchUtils__WEBPACK_IMPORTED_MODULE_0__.parseDescriptor(descriptor);
    if (patchPaths.every(patchPath => !_patchUtils__WEBPACK_IMPORTED_MODULE_0__.isParentRequired(patchPath))) return descriptor;
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.bindDescriptor(descriptor, {
      locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.stringifyLocator(fromLocator)
    });
  }

  getResolutionDependencies(descriptor, opts) {
    const {
      sourceDescriptor
    } = _patchUtils__WEBPACK_IMPORTED_MODULE_0__.parseDescriptor(descriptor);
    return [sourceDescriptor];
  }

  async getCandidates(descriptor, dependencies, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const {
      parentLocator,
      sourceDescriptor,
      patchPaths
    } = _patchUtils__WEBPACK_IMPORTED_MODULE_0__.parseDescriptor(descriptor);
    const patchFiles = await _patchUtils__WEBPACK_IMPORTED_MODULE_0__.loadPatchFiles(parentLocator, patchPaths, opts.fetchOptions);
    const sourcePackage = dependencies.get(sourceDescriptor.descriptorHash);
    if (typeof sourcePackage === `undefined`) throw new Error(`Assertion failed: The dependency should have been resolved`);
    const patchHash = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.makeHash(`${CACHE_VERSION}`, ...patchFiles).slice(0, 6);
    return [_patchUtils__WEBPACK_IMPORTED_MODULE_0__.makeLocator(descriptor, {
      parentLocator,
      sourcePackage,
      patchPaths,
      patchHash
    })];
  }

  async getSatisfying(descriptor, references, opts) {
    return null;
  }

  async resolve(locator, opts) {
    const {
      sourceLocator
    } = _patchUtils__WEBPACK_IMPORTED_MODULE_0__.parseLocator(locator);
    const sourcePkg = await opts.resolver.resolve(sourceLocator, opts);
    return { ...sourcePkg,
      ...locator
    };
  }

}

/***/ }),
/* 753 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PatchCommitCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(162);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(155);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _patchUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(747);





 // eslint-disable-next-line arca/no-default-export

class PatchCommitCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    await project.restoreInstallState();
    const folderPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(this.patchFolder));
    const metaPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.join(folderPath, `.yarn-patch.json`);
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.xfs.existsSync(metaPath)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The argument folder didn't get created by 'yarn patch'`);
    const meta = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.xfs.readJsonPromise(metaPath);
    const locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.parseLocator(meta.locator, true);
    if (!project.storedPackages.has(locator.locatorHash)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`No package found in the project for the given locator`);
    const originalPath = await _patchUtils__WEBPACK_IMPORTED_MODULE_2__.extractPackageToDisk(locator, {
      cache,
      project
    });
    this.context.stdout.write(await _patchUtils__WEBPACK_IMPORTED_MODULE_2__.diffFolders(originalPath, folderPath));
  }

}
PatchCommitCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `
      This will turn the folder passed in parameter into a patchfile suitable for consumption with the \`patch:\` protocol.

      Only folders generated through \`yarn patch\` are accepted as valid input for \`yarn patch-commit\`.
    `
});

(0,tslib__WEBPACK_IMPORTED_MODULE_9__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], PatchCommitCommand.prototype, "patchFolder", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_9__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`patch-commit`)], PatchCommitCommand.prototype, "execute", null);

/***/ }),
/* 754 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PatchCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(254);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(378);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(177);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(374);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(180);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(13);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(162);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _patchUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(747);





 // eslint-disable-next-line arca/no-default-export

class PatchCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    await project.restoreInstallState();
    let locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.parseLocator(this.package);

    if (locator.reference === `unknown`) {
      const candidateLocators = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.mapAndFilter([...project.storedPackages.values()], pkg => {
        if (pkg.identHash !== locator.identHash) return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.mapAndFilter.skip;
        if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.isVirtualLocator(pkg)) return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.mapAndFilter.skip;
        return pkg;
      });
      if (candidateLocators.length === 0) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`No package found in the project for the given locator`);
      if (candidateLocators.length > 1) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Multiple candidate packages found; explicitly choose one of them (use \`yarn why <package>\` to get more information as to who depends on them):\n${candidateLocators.map(locator => `\n- ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.prettyLocator(configuration, locator)}`).join(``)}`);
      locator = candidateLocators[0];
    }

    if (!project.storedPackages.has(locator.locatorHash)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`No package found in the project for the given locator`);
    await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const temp = await _patchUtils__WEBPACK_IMPORTED_MODULE_2__.extractPackageToDisk(locator, {
        cache,
        project
      });
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Package ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.prettyLocator(configuration, locator)} got extracted with success!`);
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `You can now edit the following folder: ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.pretty(configuration, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.fromPortablePath(temp), `magenta`)}`);
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Once you are done run ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.pretty(configuration, `yarn patch-commit ${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.fromPortablePath(temp)}`, `cyan`)} and Yarn will store a patchfile based on your changes.`);
    });
  }

}
PatchCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `
      This command will cause a package to be extracted in a temporary directory (under a folder named "patch-workdir"). This folder will be editable at will; running \`yarn patch\` inside it will then cause Yarn to generate a patchfile and register it into your top-level manifest (cf the \`patch:\` protocol).
    `
});

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], PatchCommand.prototype, "package", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`patch`)], PatchCommand.prototype, "execute", null);

/***/ }),
/* 755 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const url_1 = __webpack_require__(247);
const create_1 = __webpack_require__(756);
const defaults = {
    options: {
        method: 'GET',
        retry: {
            limit: 2,
            methods: [
                'GET',
                'PUT',
                'HEAD',
                'DELETE',
                'OPTIONS',
                'TRACE'
            ],
            statusCodes: [
                408,
                413,
                429,
                500,
                502,
                503,
                504,
                521,
                522,
                524
            ],
            errorCodes: [
                'ETIMEDOUT',
                'ECONNRESET',
                'EADDRINUSE',
                'ECONNREFUSED',
                'EPIPE',
                'ENOTFOUND',
                'ENETUNREACH',
                'EAI_AGAIN'
            ],
            maxRetryAfter: undefined,
            calculateDelay: ({ computedValue }) => computedValue
        },
        timeout: {},
        headers: {
            'user-agent': 'got (https://github.com/sindresorhus/got)'
        },
        hooks: {
            init: [],
            beforeRequest: [],
            beforeRedirect: [],
            beforeRetry: [],
            beforeError: [],
            afterResponse: []
        },
        cache: undefined,
        dnsCache: undefined,
        decompress: true,
        throwHttpErrors: true,
        followRedirect: true,
        isStream: false,
        responseType: 'text',
        resolveBodyOnly: false,
        maxRedirects: 10,
        prefixUrl: '',
        methodRewriting: true,
        ignoreInvalidCookies: false,
        context: {},
        // TODO: Set this to `true` when Got 12 gets released
        http2: false,
        allowGetBody: false,
        https: undefined,
        pagination: {
            transform: (response) => {
                if (response.request.options.responseType === 'json') {
                    return response.body;
                }
                return JSON.parse(response.body);
            },
            paginate: response => {
                if (!Reflect.has(response.headers, 'link')) {
                    return false;
                }
                const items = response.headers.link.split(',');
                let next;
                for (const item of items) {
                    const parsed = item.split(';');
                    if (parsed[1].includes('next')) {
                        next = parsed[0].trimStart().trim();
                        next = next.slice(1, -1);
                        break;
                    }
                }
                if (next) {
                    const options = {
                        url: new url_1.URL(next)
                    };
                    return options;
                }
                return false;
            },
            filter: () => true,
            shouldContinue: () => true,
            countLimit: Infinity,
            backoff: 0,
            requestLimit: 10000,
            stackAllItems: true
        },
        parseJson: (text) => JSON.parse(text),
        stringifyJson: (object) => JSON.stringify(object),
        cacheOptions: {}
    },
    handlers: [create_1.defaultHandler],
    mutableDefaults: false
};
const got = create_1.default(defaults);
exports.default = got;
// For CommonJS default export support
module.exports = got;
module.exports.default = got;
module.exports.__esModule = true; // Workaround for TS issue: https://github.com/sindresorhus/got/pull/1267
__exportStar(__webpack_require__(756), exports);
__exportStar(__webpack_require__(758), exports);


/***/ }),
/* 756 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultHandler = void 0;
const is_1 = __webpack_require__(757);
const as_promise_1 = __webpack_require__(758);
const create_rejection_1 = __webpack_require__(811);
const core_1 = __webpack_require__(761);
const deep_freeze_1 = __webpack_require__(812);
const errors = {
    RequestError: as_promise_1.RequestError,
    CacheError: as_promise_1.CacheError,
    ReadError: as_promise_1.ReadError,
    HTTPError: as_promise_1.HTTPError,
    MaxRedirectsError: as_promise_1.MaxRedirectsError,
    TimeoutError: as_promise_1.TimeoutError,
    ParseError: as_promise_1.ParseError,
    CancelError: as_promise_1.CancelError,
    UnsupportedProtocolError: as_promise_1.UnsupportedProtocolError,
    UploadError: as_promise_1.UploadError
};
// The `delay` package weighs 10KB (!)
const delay = async (ms) => new Promise(resolve => {
    setTimeout(resolve, ms);
});
const { normalizeArguments } = core_1.default;
const mergeOptions = (...sources) => {
    let mergedOptions;
    for (const source of sources) {
        mergedOptions = normalizeArguments(undefined, source, mergedOptions);
    }
    return mergedOptions;
};
const getPromiseOrStream = (options) => options.isStream ? new core_1.default(undefined, options) : as_promise_1.default(options);
const isGotInstance = (value) => ('defaults' in value && 'options' in value.defaults);
const aliases = [
    'get',
    'post',
    'put',
    'patch',
    'head',
    'delete'
];
exports.defaultHandler = (options, next) => next(options);
const callInitHooks = (hooks, options) => {
    if (hooks) {
        for (const hook of hooks) {
            hook(options);
        }
    }
};
const create = (defaults) => {
    // Proxy properties from next handlers
    defaults._rawHandlers = defaults.handlers;
    defaults.handlers = defaults.handlers.map(fn => ((options, next) => {
        // This will be assigned by assigning result
        let root;
        const result = fn(options, newOptions => {
            root = next(newOptions);
            return root;
        });
        if (result !== root && !options.isStream && root) {
            const typedResult = result;
            const { then: promiseThen, catch: promiseCatch, finally: promiseFianlly } = typedResult;
            Object.setPrototypeOf(typedResult, Object.getPrototypeOf(root));
            Object.defineProperties(typedResult, Object.getOwnPropertyDescriptors(root));
            // These should point to the new promise
            // eslint-disable-next-line promise/prefer-await-to-then
            typedResult.then = promiseThen;
            typedResult.catch = promiseCatch;
            typedResult.finally = promiseFianlly;
        }
        return result;
    }));
    // Got interface
    const got = ((url, options, _defaults) => {
        var _a, _b;
        let iteration = 0;
        const iterateHandlers = (newOptions) => {
            return defaults.handlers[iteration++](newOptions, iteration === defaults.handlers.length ? getPromiseOrStream : iterateHandlers);
        };
        // TODO: Remove this in Got 12.
        if (is_1.default.plainObject(url)) {
            const mergedOptions = {
                ...url,
                ...options
            };
            core_1.setNonEnumerableProperties([url, options], mergedOptions);
            options = mergedOptions;
            url = undefined;
        }
        try {
            // Call `init` hooks
            let initHookError;
            try {
                callInitHooks(defaults.options.hooks.init, options);
                callInitHooks((_a = options === null || options === void 0 ? void 0 : options.hooks) === null || _a === void 0 ? void 0 : _a.init, options);
            }
            catch (error) {
                initHookError = error;
            }
            // Normalize options & call handlers
            const normalizedOptions = normalizeArguments(url, options, _defaults !== null && _defaults !== void 0 ? _defaults : defaults.options);
            normalizedOptions[core_1.kIsNormalizedAlready] = true;
            if (initHookError) {
                throw new as_promise_1.RequestError(initHookError.message, initHookError, normalizedOptions);
            }
            return iterateHandlers(normalizedOptions);
        }
        catch (error) {
            if (options === null || options === void 0 ? void 0 : options.isStream) {
                throw error;
            }
            else {
                return create_rejection_1.default(error, defaults.options.hooks.beforeError, (_b = options === null || options === void 0 ? void 0 : options.hooks) === null || _b === void 0 ? void 0 : _b.beforeError);
            }
        }
    });
    got.extend = (...instancesOrOptions) => {
        const optionsArray = [defaults.options];
        let handlers = [...defaults._rawHandlers];
        let isMutableDefaults;
        for (const value of instancesOrOptions) {
            if (isGotInstance(value)) {
                optionsArray.push(value.defaults.options);
                handlers.push(...value.defaults._rawHandlers);
                isMutableDefaults = value.defaults.mutableDefaults;
            }
            else {
                optionsArray.push(value);
                if ('handlers' in value) {
                    handlers.push(...value.handlers);
                }
                isMutableDefaults = value.mutableDefaults;
            }
        }
        handlers = handlers.filter(handler => handler !== exports.defaultHandler);
        if (handlers.length === 0) {
            handlers.push(exports.defaultHandler);
        }
        return create({
            options: mergeOptions(...optionsArray),
            handlers,
            mutableDefaults: Boolean(isMutableDefaults)
        });
    };
    // Pagination
    const paginateEach = (async function* (url, options) {
        // TODO: Remove this `@ts-expect-error` when upgrading to TypeScript 4.
        // Error: Argument of type 'Merge<Options, PaginationOptions<T, R>> | undefined' is not assignable to parameter of type 'Options | undefined'.
        // @ts-expect-error
        let normalizedOptions = normalizeArguments(url, options, defaults.options);
        normalizedOptions.resolveBodyOnly = false;
        const pagination = normalizedOptions.pagination;
        if (!is_1.default.object(pagination)) {
            throw new TypeError('`options.pagination` must be implemented');
        }
        const all = [];
        let { countLimit } = pagination;
        let numberOfRequests = 0;
        while (numberOfRequests < pagination.requestLimit) {
            if (numberOfRequests !== 0) {
                // eslint-disable-next-line no-await-in-loop
                await delay(pagination.backoff);
            }
            // @ts-expect-error FIXME!
            // TODO: Throw when result is not an instance of Response
            // eslint-disable-next-line no-await-in-loop
            const result = (await got(undefined, undefined, normalizedOptions));
            // eslint-disable-next-line no-await-in-loop
            const parsed = await pagination.transform(result);
            const current = [];
            for (const item of parsed) {
                if (pagination.filter(item, all, current)) {
                    if (!pagination.shouldContinue(item, all, current)) {
                        return;
                    }
                    yield item;
                    if (pagination.stackAllItems) {
                        all.push(item);
                    }
                    current.push(item);
                    if (--countLimit <= 0) {
                        return;
                    }
                }
            }
            const optionsToMerge = pagination.paginate(result, all, current);
            if (optionsToMerge === false) {
                return;
            }
            if (optionsToMerge === result.request.options) {
                normalizedOptions = result.request.options;
            }
            else if (optionsToMerge !== undefined) {
                normalizedOptions = normalizeArguments(undefined, optionsToMerge, normalizedOptions);
            }
            numberOfRequests++;
        }
    });
    got.paginate = paginateEach;
    got.paginate.all = (async (url, options) => {
        const results = [];
        for await (const item of paginateEach(url, options)) {
            results.push(item);
        }
        return results;
    });
    // For those who like very descriptive names
    got.paginate.each = paginateEach;
    // Stream API
    got.stream = ((url, options) => got(url, { ...options, isStream: true }));
    // Shortcuts
    for (const method of aliases) {
        got[method] = ((url, options) => got(url, { ...options, method }));
        got.stream[method] = ((url, options) => {
            return got(url, { ...options, method, isStream: true });
        });
    }
    Object.assign(got, errors);
    Object.defineProperty(got, 'defaults', {
        value: defaults.mutableDefaults ? defaults : deep_freeze_1.default(defaults),
        writable: defaults.mutableDefaults,
        configurable: defaults.mutableDefaults,
        enumerable: true
    });
    got.mergeOptions = mergeOptions;
    return got;
};
exports.default = create;
__exportStar(__webpack_require__(813), exports);


/***/ }),
/* 757 */
/***/ ((module, exports) => {

"use strict";

/// <reference lib="es2018"/>
/// <reference lib="dom"/>
/// <reference types="node"/>
Object.defineProperty(exports, "__esModule", ({ value: true }));
const typedArrayTypeNames = [
    'Int8Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Int16Array',
    'Uint16Array',
    'Int32Array',
    'Uint32Array',
    'Float32Array',
    'Float64Array',
    'BigInt64Array',
    'BigUint64Array'
];
function isTypedArrayName(name) {
    return typedArrayTypeNames.includes(name);
}
const objectTypeNames = [
    'Function',
    'Generator',
    'AsyncGenerator',
    'GeneratorFunction',
    'AsyncGeneratorFunction',
    'AsyncFunction',
    'Observable',
    'Array',
    'Buffer',
    'Object',
    'RegExp',
    'Date',
    'Error',
    'Map',
    'Set',
    'WeakMap',
    'WeakSet',
    'ArrayBuffer',
    'SharedArrayBuffer',
    'DataView',
    'Promise',
    'URL',
    'HTMLElement',
    ...typedArrayTypeNames
];
function isObjectTypeName(name) {
    return objectTypeNames.includes(name);
}
const primitiveTypeNames = [
    'null',
    'undefined',
    'string',
    'number',
    'bigint',
    'boolean',
    'symbol'
];
function isPrimitiveTypeName(name) {
    return primitiveTypeNames.includes(name);
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isOfType(type) {
    return (value) => typeof value === type;
}
const { toString } = Object.prototype;
const getObjectType = (value) => {
    const objectTypeName = toString.call(value).slice(8, -1);
    if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
        return 'HTMLElement';
    }
    if (isObjectTypeName(objectTypeName)) {
        return objectTypeName;
    }
    return undefined;
};
const isObjectOfType = (type) => (value) => getObjectType(value) === type;
function is(value) {
    if (value === null) {
        return 'null';
    }
    switch (typeof value) {
        case 'undefined':
            return 'undefined';
        case 'string':
            return 'string';
        case 'number':
            return 'number';
        case 'boolean':
            return 'boolean';
        case 'function':
            return 'Function';
        case 'bigint':
            return 'bigint';
        case 'symbol':
            return 'symbol';
        default:
    }
    if (is.observable(value)) {
        return 'Observable';
    }
    if (is.array(value)) {
        return 'Array';
    }
    if (is.buffer(value)) {
        return 'Buffer';
    }
    const tagType = getObjectType(value);
    if (tagType) {
        return tagType;
    }
    if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError('Please don\'t use object wrappers for primitive types');
    }
    return 'Object';
}
is.undefined = isOfType('undefined');
is.string = isOfType('string');
const isNumberType = isOfType('number');
is.number = (value) => isNumberType(value) && !is.nan(value);
is.bigint = isOfType('bigint');
// eslint-disable-next-line @typescript-eslint/ban-types
is.function_ = isOfType('function');
is.null_ = (value) => value === null;
is.class_ = (value) => is.function_(value) && value.toString().startsWith('class ');
is.boolean = (value) => value === true || value === false;
is.symbol = isOfType('symbol');
is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
is.array = (value, assertion) => {
    if (!Array.isArray(value)) {
        return false;
    }
    if (!is.function_(assertion)) {
        return true;
    }
    return value.every(assertion);
};
is.buffer = (value) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = value) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value)) !== null && _d !== void 0 ? _d : false; };
is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
is.object = (value) => !is.null_(value) && (typeof value === 'object' || is.function_(value));
is.iterable = (value) => { var _a; return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]); };
is.asyncIterable = (value) => { var _a; return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.asyncIterator]); };
is.generator = (value) => is.iterable(value) && is.function_(value.next) && is.function_(value.throw);
is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
is.nativePromise = (value) => isObjectOfType('Promise')(value);
const hasPromiseAPI = (value) => {
    var _a, _b;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.then) &&
        is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.catch);
};
is.promise = (value) => is.nativePromise(value) || hasPromiseAPI(value);
is.generatorFunction = isObjectOfType('GeneratorFunction');
is.asyncGeneratorFunction = (value) => getObjectType(value) === 'AsyncGeneratorFunction';
is.asyncFunction = (value) => getObjectType(value) === 'AsyncFunction';
// eslint-disable-next-line no-prototype-builtins, @typescript-eslint/ban-types
is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty('prototype');
is.regExp = isObjectOfType('RegExp');
is.date = isObjectOfType('Date');
is.error = isObjectOfType('Error');
is.map = (value) => isObjectOfType('Map')(value);
is.set = (value) => isObjectOfType('Set')(value);
is.weakMap = (value) => isObjectOfType('WeakMap')(value);
is.weakSet = (value) => isObjectOfType('WeakSet')(value);
is.int8Array = isObjectOfType('Int8Array');
is.uint8Array = isObjectOfType('Uint8Array');
is.uint8ClampedArray = isObjectOfType('Uint8ClampedArray');
is.int16Array = isObjectOfType('Int16Array');
is.uint16Array = isObjectOfType('Uint16Array');
is.int32Array = isObjectOfType('Int32Array');
is.uint32Array = isObjectOfType('Uint32Array');
is.float32Array = isObjectOfType('Float32Array');
is.float64Array = isObjectOfType('Float64Array');
is.bigInt64Array = isObjectOfType('BigInt64Array');
is.bigUint64Array = isObjectOfType('BigUint64Array');
is.arrayBuffer = isObjectOfType('ArrayBuffer');
is.sharedArrayBuffer = isObjectOfType('SharedArrayBuffer');
is.dataView = isObjectOfType('DataView');
is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
is.urlInstance = (value) => isObjectOfType('URL')(value);
is.urlString = (value) => {
    if (!is.string(value)) {
        return false;
    }
    try {
        new URL(value); // eslint-disable-line no-new
        return true;
    }
    catch (_a) {
        return false;
    }
};
// TODO: Use the `not` operator with a type guard here when it's available.
// Example: `is.truthy = (value: unknown): value is (not false | not 0 | not '' | not undefined | not null) => Boolean(value);`
is.truthy = (value) => Boolean(value);
// Example: `is.falsy = (value: unknown): value is (not true | 0 | '' | undefined | null) => Boolean(value);`
is.falsy = (value) => !value;
is.nan = (value) => Number.isNaN(value);
is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
is.integer = (value) => Number.isInteger(value);
is.safeInteger = (value) => Number.isSafeInteger(value);
is.plainObject = (value) => {
    // From: https://github.com/sindresorhus/is-plain-obj/blob/master/index.js
    if (toString.call(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.getPrototypeOf({});
};
is.typedArray = (value) => isTypedArrayName(getObjectType(value));
const isValidLength = (value) => is.safeInteger(value) && value >= 0;
is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
is.inRange = (value, range) => {
    if (is.number(range)) {
        return value >= Math.min(0, range) && value <= Math.max(range, 0);
    }
    if (is.array(range) && range.length === 2) {
        return value >= Math.min(...range) && value <= Math.max(...range);
    }
    throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
};
const NODE_TYPE_ELEMENT = 1;
const DOM_PROPERTIES_TO_CHECK = [
    'innerHTML',
    'ownerDocument',
    'style',
    'attributes',
    'nodeValue'
];
is.domElement = (value) => {
    return is.object(value) &&
        value.nodeType === NODE_TYPE_ELEMENT &&
        is.string(value.nodeName) &&
        !is.plainObject(value) &&
        DOM_PROPERTIES_TO_CHECK.every(property => property in value);
};
is.observable = (value) => {
    var _a, _b, _c, _d;
    if (!value) {
        return false;
    }
    // eslint-disable-next-line no-use-extend-native/no-use-extend-native
    if (value === ((_b = (_a = value)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a))) {
        return true;
    }
    if (value === ((_d = (_c = value)['@@observable']) === null || _d === void 0 ? void 0 : _d.call(_c))) {
        return true;
    }
    return false;
};
is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
is.infinite = (value) => value === Infinity || value === -Infinity;
const isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
is.evenInteger = isAbsoluteMod2(0);
is.oddInteger = isAbsoluteMod2(1);
is.emptyArray = (value) => is.array(value) && value.length === 0;
is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
is.emptyString = (value) => is.string(value) && value.length === 0;
// TODO: Use `not ''` when the `not` operator is available.
is.nonEmptyString = (value) => is.string(value) && value.length > 0;
const isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
// TODO: Use `not` operator here to remove `Map` and `Set` from type guard:
// - https://github.com/Microsoft/TypeScript/pull/29317
is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
is.emptySet = (value) => is.set(value) && value.size === 0;
is.nonEmptySet = (value) => is.set(value) && value.size > 0;
is.emptyMap = (value) => is.map(value) && value.size === 0;
is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
const predicateOnArray = (method, predicate, values) => {
    if (!is.function_(predicate)) {
        throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
    }
    if (values.length === 0) {
        throw new TypeError('Invalid number of values');
    }
    return method.call(values, predicate);
};
is.any = (predicate, ...values) => {
    const predicates = is.array(predicate) ? predicate : [predicate];
    return predicates.some(singlePredicate => predicateOnArray(Array.prototype.some, singlePredicate, values));
};
is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
const assertType = (condition, description, value) => {
    if (!condition) {
        throw new TypeError(`Expected value which is \`${description}\`, received value of type \`${is(value)}\`.`);
    }
};
exports.assert = {
    // Unknowns.
    undefined: (value) => assertType(is.undefined(value), 'undefined', value),
    string: (value) => assertType(is.string(value), 'string', value),
    number: (value) => assertType(is.number(value), 'number', value),
    bigint: (value) => assertType(is.bigint(value), 'bigint', value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    function_: (value) => assertType(is.function_(value), 'Function', value),
    null_: (value) => assertType(is.null_(value), 'null', value),
    class_: (value) => assertType(is.class_(value), "Class" /* class_ */, value),
    boolean: (value) => assertType(is.boolean(value), 'boolean', value),
    symbol: (value) => assertType(is.symbol(value), 'symbol', value),
    numericString: (value) => assertType(is.numericString(value), "string with a number" /* numericString */, value),
    array: (value, assertion) => {
        const assert = assertType;
        assert(is.array(value), 'Array', value);
        if (assertion) {
            value.forEach(assertion);
        }
    },
    buffer: (value) => assertType(is.buffer(value), 'Buffer', value),
    nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined" /* nullOrUndefined */, value),
    object: (value) => assertType(is.object(value), 'Object', value),
    iterable: (value) => assertType(is.iterable(value), "Iterable" /* iterable */, value),
    asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable" /* asyncIterable */, value),
    generator: (value) => assertType(is.generator(value), 'Generator', value),
    asyncGenerator: (value) => assertType(is.asyncGenerator(value), 'AsyncGenerator', value),
    nativePromise: (value) => assertType(is.nativePromise(value), "native Promise" /* nativePromise */, value),
    promise: (value) => assertType(is.promise(value), 'Promise', value),
    generatorFunction: (value) => assertType(is.generatorFunction(value), 'GeneratorFunction', value),
    asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), 'AsyncGeneratorFunction', value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    asyncFunction: (value) => assertType(is.asyncFunction(value), 'AsyncFunction', value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    boundFunction: (value) => assertType(is.boundFunction(value), 'Function', value),
    regExp: (value) => assertType(is.regExp(value), 'RegExp', value),
    date: (value) => assertType(is.date(value), 'Date', value),
    error: (value) => assertType(is.error(value), 'Error', value),
    map: (value) => assertType(is.map(value), 'Map', value),
    set: (value) => assertType(is.set(value), 'Set', value),
    weakMap: (value) => assertType(is.weakMap(value), 'WeakMap', value),
    weakSet: (value) => assertType(is.weakSet(value), 'WeakSet', value),
    int8Array: (value) => assertType(is.int8Array(value), 'Int8Array', value),
    uint8Array: (value) => assertType(is.uint8Array(value), 'Uint8Array', value),
    uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), 'Uint8ClampedArray', value),
    int16Array: (value) => assertType(is.int16Array(value), 'Int16Array', value),
    uint16Array: (value) => assertType(is.uint16Array(value), 'Uint16Array', value),
    int32Array: (value) => assertType(is.int32Array(value), 'Int32Array', value),
    uint32Array: (value) => assertType(is.uint32Array(value), 'Uint32Array', value),
    float32Array: (value) => assertType(is.float32Array(value), 'Float32Array', value),
    float64Array: (value) => assertType(is.float64Array(value), 'Float64Array', value),
    bigInt64Array: (value) => assertType(is.bigInt64Array(value), 'BigInt64Array', value),
    bigUint64Array: (value) => assertType(is.bigUint64Array(value), 'BigUint64Array', value),
    arrayBuffer: (value) => assertType(is.arrayBuffer(value), 'ArrayBuffer', value),
    sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), 'SharedArrayBuffer', value),
    dataView: (value) => assertType(is.dataView(value), 'DataView', value),
    urlInstance: (value) => assertType(is.urlInstance(value), 'URL', value),
    urlString: (value) => assertType(is.urlString(value), "string with a URL" /* urlString */, value),
    truthy: (value) => assertType(is.truthy(value), "truthy" /* truthy */, value),
    falsy: (value) => assertType(is.falsy(value), "falsy" /* falsy */, value),
    nan: (value) => assertType(is.nan(value), "NaN" /* nan */, value),
    primitive: (value) => assertType(is.primitive(value), "primitive" /* primitive */, value),
    integer: (value) => assertType(is.integer(value), "integer" /* integer */, value),
    safeInteger: (value) => assertType(is.safeInteger(value), "integer" /* safeInteger */, value),
    plainObject: (value) => assertType(is.plainObject(value), "plain object" /* plainObject */, value),
    typedArray: (value) => assertType(is.typedArray(value), "TypedArray" /* typedArray */, value),
    arrayLike: (value) => assertType(is.arrayLike(value), "array-like" /* arrayLike */, value),
    domElement: (value) => assertType(is.domElement(value), "HTMLElement" /* domElement */, value),
    observable: (value) => assertType(is.observable(value), 'Observable', value),
    nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream" /* nodeStream */, value),
    infinite: (value) => assertType(is.infinite(value), "infinite number" /* infinite */, value),
    emptyArray: (value) => assertType(is.emptyArray(value), "empty array" /* emptyArray */, value),
    nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array" /* nonEmptyArray */, value),
    emptyString: (value) => assertType(is.emptyString(value), "empty string" /* emptyString */, value),
    nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string" /* nonEmptyString */, value),
    emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace" /* emptyStringOrWhitespace */, value),
    emptyObject: (value) => assertType(is.emptyObject(value), "empty object" /* emptyObject */, value),
    nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object" /* nonEmptyObject */, value),
    emptySet: (value) => assertType(is.emptySet(value), "empty set" /* emptySet */, value),
    nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set" /* nonEmptySet */, value),
    emptyMap: (value) => assertType(is.emptyMap(value), "empty map" /* emptyMap */, value),
    nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map" /* nonEmptyMap */, value),
    // Numbers.
    evenInteger: (value) => assertType(is.evenInteger(value), "even integer" /* evenInteger */, value),
    oddInteger: (value) => assertType(is.oddInteger(value), "odd integer" /* oddInteger */, value),
    // Two arguments.
    directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T" /* directInstanceOf */, instance),
    inRange: (value, range) => assertType(is.inRange(value, range), "in range" /* inRange */, value),
    // Variadic functions.
    any: (predicate, ...values) => assertType(is.any(predicate, ...values), "predicate returns truthy for any value" /* any */, values),
    all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values" /* all */, values)
};
// Some few keywords are reserved, but we'll populate them for Node.js users
// See https://github.com/Microsoft/TypeScript/issues/2536
Object.defineProperties(is, {
    class: {
        value: is.class_
    },
    function: {
        value: is.function_
    },
    null: {
        value: is.null_
    }
});
Object.defineProperties(exports.assert, {
    class: {
        value: exports.assert.class_
    },
    function: {
        value: exports.assert.function_
    },
    null: {
        value: exports.assert.null_
    }
});
exports.default = is;
// For CommonJS default export support
module.exports = is;
module.exports.default = is;
module.exports.assert = exports.assert;


/***/ }),
/* 758 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(119);
const is_1 = __webpack_require__(757);
const PCancelable = __webpack_require__(759);
const types_1 = __webpack_require__(760);
const parse_body_1 = __webpack_require__(810);
const core_1 = __webpack_require__(761);
const proxy_events_1 = __webpack_require__(798);
const get_buffer_1 = __webpack_require__(804);
const is_response_ok_1 = __webpack_require__(806);
const proxiedRequestEvents = [
    'request',
    'response',
    'redirect',
    'uploadProgress',
    'downloadProgress'
];
function asPromise(normalizedOptions) {
    let globalRequest;
    let globalResponse;
    const emitter = new events_1.EventEmitter();
    const promise = new PCancelable((resolve, reject, onCancel) => {
        const makeRequest = (retryCount) => {
            const request = new core_1.default(undefined, normalizedOptions);
            request.retryCount = retryCount;
            request._noPipe = true;
            onCancel(() => request.destroy());
            onCancel.shouldReject = false;
            onCancel(() => reject(new types_1.CancelError(request)));
            globalRequest = request;
            request.once('response', async (response) => {
                var _a;
                response.retryCount = retryCount;
                if (response.request.aborted) {
                    // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error
                    return;
                }
                // Download body
                let rawBody;
                try {
                    rawBody = await get_buffer_1.default(request);
                    response.rawBody = rawBody;
                }
                catch (_b) {
                    // The same error is caught below.
                    // See request.once('error')
                    return;
                }
                if (request._isAboutToError) {
                    return;
                }
                // Parse body
                const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();
                const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);
                const { options } = request;
                if (isCompressed && !options.decompress) {
                    response.body = rawBody;
                }
                else {
                    try {
                        response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);
                    }
                    catch (error) {
                        // Fallback to `utf8`
                        response.body = rawBody.toString();
                        if (is_response_ok_1.isResponseOk(response)) {
                            request._beforeError(error);
                            return;
                        }
                    }
                }
                try {
                    for (const [index, hook] of options.hooks.afterResponse.entries()) {
                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise
                        // eslint-disable-next-line no-await-in-loop
                        response = await hook(response, async (updatedOptions) => {
                            const typedOptions = core_1.default.normalizeArguments(undefined, {
                                ...updatedOptions,
                                retry: {
                                    calculateDelay: () => 0
                                },
                                throwHttpErrors: false,
                                resolveBodyOnly: false
                            }, options);
                            // Remove any further hooks for that request, because we'll call them anyway.
                            // The loop continues. We don't want duplicates (asPromise recursion).
                            typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);
                            for (const hook of typedOptions.hooks.beforeRetry) {
                                // eslint-disable-next-line no-await-in-loop
                                await hook(typedOptions);
                            }
                            const promise = asPromise(typedOptions);
                            onCancel(() => {
                                promise.catch(() => { });
                                promise.cancel();
                            });
                            return promise;
                        });
                    }
                }
                catch (error) {
                    request._beforeError(new types_1.RequestError(error.message, error, request));
                    return;
                }
                if (!is_response_ok_1.isResponseOk(response)) {
                    request._beforeError(new types_1.HTTPError(response));
                    return;
                }
                globalResponse = response;
                resolve(request.options.resolveBodyOnly ? response.body : response);
            });
            const onError = (error) => {
                if (promise.isCanceled) {
                    return;
                }
                const { options } = request;
                if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {
                    const { response } = error;
                    resolve(request.options.resolveBodyOnly ? response.body : response);
                    return;
                }
                reject(error);
            };
            request.once('error', onError);
            request.once('retry', (newRetryCount, error) => {
                var _a;
                if (is_1.default.nodeStream((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body)) {
                    onError(error);
                    return;
                }
                makeRequest(newRetryCount);
            });
            proxy_events_1.default(request, emitter, proxiedRequestEvents);
        };
        makeRequest(0);
    });
    promise.on = (event, fn) => {
        emitter.on(event, fn);
        return promise;
    };
    const shortcut = (responseType) => {
        const newPromise = (async () => {
            // Wait until downloading has ended
            await promise;
            const { options } = globalResponse.request;
            return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);
        })();
        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
        return newPromise;
    };
    promise.json = () => {
        const { headers } = globalRequest.options;
        if (!globalRequest.writableFinished && headers.accept === undefined) {
            headers.accept = 'application/json';
        }
        return shortcut('json');
    };
    promise.buffer = () => shortcut('buffer');
    promise.text = () => shortcut('text');
    return promise;
}
exports.default = asPromise;
__exportStar(__webpack_require__(760), exports);


/***/ }),
/* 759 */
/***/ ((module) => {

"use strict";


class CancelError extends Error {
	constructor(reason) {
		super(reason || 'Promise was canceled');
		this.name = 'CancelError';
	}

	get isCanceled() {
		return true;
	}
}

class PCancelable {
	static fn(userFn) {
		return (...arguments_) => {
			return new PCancelable((resolve, reject, onCancel) => {
				arguments_.push(onCancel);
				// eslint-disable-next-line promise/prefer-await-to-then
				userFn(...arguments_).then(resolve, reject);
			});
		};
	}

	constructor(executor) {
		this._cancelHandlers = [];
		this._isPending = true;
		this._isCanceled = false;
		this._rejectOnCancel = true;

		this._promise = new Promise((resolve, reject) => {
			this._reject = reject;

			const onResolve = value => {
				this._isPending = false;
				resolve(value);
			};

			const onReject = error => {
				this._isPending = false;
				reject(error);
			};

			const onCancel = handler => {
				if (!this._isPending) {
					throw new Error('The `onCancel` handler was attached after the promise settled.');
				}

				this._cancelHandlers.push(handler);
			};

			Object.defineProperties(onCancel, {
				shouldReject: {
					get: () => this._rejectOnCancel,
					set: boolean => {
						this._rejectOnCancel = boolean;
					}
				}
			});

			return executor(onResolve, onReject, onCancel);
		});
	}

	then(onFulfilled, onRejected) {
		// eslint-disable-next-line promise/prefer-await-to-then
		return this._promise.then(onFulfilled, onRejected);
	}

	catch(onRejected) {
		return this._promise.catch(onRejected);
	}

	finally(onFinally) {
		return this._promise.finally(onFinally);
	}

	cancel(reason) {
		if (!this._isPending || this._isCanceled) {
			return;
		}

		if (this._cancelHandlers.length > 0) {
			try {
				for (const handler of this._cancelHandlers) {
					handler();
				}
			} catch (error) {
				this._reject(error);
			}
		}

		this._isCanceled = true;
		if (this._rejectOnCancel) {
			this._reject(new CancelError(reason));
		}
	}

	get isCanceled() {
		return this._isCanceled;
	}
}

Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

module.exports = PCancelable;
module.exports.CancelError = CancelError;


/***/ }),
/* 760 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancelError = exports.ParseError = void 0;
const core_1 = __webpack_require__(761);
/**
An error to be thrown when server response code is 2xx, and parsing body fails.
Includes a `response` property.
*/
class ParseError extends core_1.RequestError {
    constructor(error, response) {
        const { options } = response.request;
        super(`${error.message} in "${options.url.toString()}"`, error, response.request);
        this.name = 'ParseError';
    }
}
exports.ParseError = ParseError;
/**
An error to be thrown when the request is aborted with `.cancel()`.
*/
class CancelError extends core_1.RequestError {
    constructor(request) {
        super('Promise was canceled', {}, request);
        this.name = 'CancelError';
    }
    get isCanceled() {
        return true;
    }
}
exports.CancelError = CancelError;
__exportStar(__webpack_require__(761), exports);


/***/ }),
/* 761 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnsupportedProtocolError = exports.ReadError = exports.TimeoutError = exports.UploadError = exports.CacheError = exports.HTTPError = exports.MaxRedirectsError = exports.RequestError = exports.setNonEnumerableProperties = exports.knownHookEvents = exports.withoutBody = exports.kIsNormalizedAlready = void 0;
const util_1 = __webpack_require__(90);
const stream_1 = __webpack_require__(76);
const fs_1 = __webpack_require__(8);
const url_1 = __webpack_require__(247);
const http = __webpack_require__(241);
const http_1 = __webpack_require__(241);
const https = __webpack_require__(240);
const http_timer_1 = __webpack_require__(762);
const cacheable_lookup_1 = __webpack_require__(764);
const CacheableRequest = __webpack_require__(766);
const decompressResponse = __webpack_require__(781);
// @ts-expect-error Missing types
const http2wrapper = __webpack_require__(783);
const lowercaseKeys = __webpack_require__(775);
const is_1 = __webpack_require__(757);
const get_body_size_1 = __webpack_require__(796);
const is_form_data_1 = __webpack_require__(797);
const proxy_events_1 = __webpack_require__(798);
const timed_out_1 = __webpack_require__(799);
const url_to_options_1 = __webpack_require__(801);
const options_to_url_1 = __webpack_require__(802);
const weakable_map_1 = __webpack_require__(803);
const get_buffer_1 = __webpack_require__(804);
const dns_ip_version_1 = __webpack_require__(805);
const is_response_ok_1 = __webpack_require__(806);
const deprecation_warning_1 = __webpack_require__(807);
const normalize_arguments_1 = __webpack_require__(808);
const calculate_retry_delay_1 = __webpack_require__(809);
const globalDnsCache = new cacheable_lookup_1.default();
const kRequest = Symbol('request');
const kResponse = Symbol('response');
const kResponseSize = Symbol('responseSize');
const kDownloadedSize = Symbol('downloadedSize');
const kBodySize = Symbol('bodySize');
const kUploadedSize = Symbol('uploadedSize');
const kServerResponsesPiped = Symbol('serverResponsesPiped');
const kUnproxyEvents = Symbol('unproxyEvents');
const kIsFromCache = Symbol('isFromCache');
const kCancelTimeouts = Symbol('cancelTimeouts');
const kStartedReading = Symbol('startedReading');
const kStopReading = Symbol('stopReading');
const kTriggerRead = Symbol('triggerRead');
const kBody = Symbol('body');
const kJobs = Symbol('jobs');
const kOriginalResponse = Symbol('originalResponse');
const kRetryTimeout = Symbol('retryTimeout');
exports.kIsNormalizedAlready = Symbol('isNormalizedAlready');
const supportsBrotli = is_1.default.string(process.versions.brotli);
exports.withoutBody = new Set(['GET', 'HEAD']);
exports.knownHookEvents = [
    'init',
    'beforeRequest',
    'beforeRedirect',
    'beforeError',
    'beforeRetry',
    // Promise-Only
    'afterResponse'
];
function validateSearchParameters(searchParameters) {
    // eslint-disable-next-line guard-for-in
    for (const key in searchParameters) {
        const value = searchParameters[key];
        if (!is_1.default.string(value) && !is_1.default.number(value) && !is_1.default.boolean(value) && !is_1.default.null_(value) && !is_1.default.undefined(value)) {
            throw new TypeError(`The \`searchParams\` value '${String(value)}' must be a string, number, boolean or null`);
        }
    }
}
function isClientRequest(clientRequest) {
    return is_1.default.object(clientRequest) && !('statusCode' in clientRequest);
}
const cacheableStore = new weakable_map_1.default();
const waitForOpenFile = async (file) => new Promise((resolve, reject) => {
    const onError = (error) => {
        reject(error);
    };
    // Node.js 12 has incomplete types
    if (!file.pending) {
        resolve();
    }
    file.once('error', onError);
    file.once('ready', () => {
        file.off('error', onError);
        resolve();
    });
});
const redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);
const nonEnumerableProperties = [
    'context',
    'body',
    'json',
    'form'
];
exports.setNonEnumerableProperties = (sources, to) => {
    // Non enumerable properties shall not be merged
    const properties = {};
    for (const source of sources) {
        if (!source) {
            continue;
        }
        for (const name of nonEnumerableProperties) {
            if (!(name in source)) {
                continue;
            }
            properties[name] = {
                writable: true,
                configurable: true,
                enumerable: false,
                // @ts-expect-error TS doesn't see the check above
                value: source[name]
            };
        }
    }
    Object.defineProperties(to, properties);
};
/**
An error to be thrown when a request fails.
Contains a `code` property with error class code, like `ECONNREFUSED`.
*/
class RequestError extends Error {
    constructor(message, error, self) {
        var _a;
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = 'RequestError';
        this.code = error.code;
        if (self instanceof Request) {
            Object.defineProperty(this, 'request', {
                enumerable: false,
                value: self
            });
            Object.defineProperty(this, 'response', {
                enumerable: false,
                value: self[kResponse]
            });
            Object.defineProperty(this, 'options', {
                // This fails because of TS 3.7.2 useDefineForClassFields
                // Ref: https://github.com/microsoft/TypeScript/issues/34972
                enumerable: false,
                value: self.options
            });
        }
        else {
            Object.defineProperty(this, 'options', {
                // This fails because of TS 3.7.2 useDefineForClassFields
                // Ref: https://github.com/microsoft/TypeScript/issues/34972
                enumerable: false,
                value: self
            });
        }
        this.timings = (_a = this.request) === null || _a === void 0 ? void 0 : _a.timings;
        // Recover the original stacktrace
        if (!is_1.default.undefined(error.stack)) {
            const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
            const thisStackTrace = this.stack.slice(indexOfMessage).split('\n').reverse();
            const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split('\n').reverse();
            // Remove duplicated traces
            while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {
                thisStackTrace.shift();
            }
            this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join('\n')}${errorStackTrace.reverse().join('\n')}`;
        }
    }
}
exports.RequestError = RequestError;
/**
An error to be thrown when the server redirects you more than ten times.
Includes a `response` property.
*/
class MaxRedirectsError extends RequestError {
    constructor(request) {
        super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);
        this.name = 'MaxRedirectsError';
    }
}
exports.MaxRedirectsError = MaxRedirectsError;
/**
An error to be thrown when the server response code is not 2xx nor 3xx if `options.followRedirect` is `true`, but always except for 304.
Includes a `response` property.
*/
class HTTPError extends RequestError {
    constructor(response) {
        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
        this.name = 'HTTPError';
    }
}
exports.HTTPError = HTTPError;
/**
An error to be thrown when a cache method fails.
For example, if the database goes down or there's a filesystem error.
*/
class CacheError extends RequestError {
    constructor(error, request) {
        super(error.message, error, request);
        this.name = 'CacheError';
    }
}
exports.CacheError = CacheError;
/**
An error to be thrown when the request body is a stream and an error occurs while reading from that stream.
*/
class UploadError extends RequestError {
    constructor(error, request) {
        super(error.message, error, request);
        this.name = 'UploadError';
    }
}
exports.UploadError = UploadError;
/**
An error to be thrown when the request is aborted due to a timeout.
Includes an `event` and `timings` property.
*/
class TimeoutError extends RequestError {
    constructor(error, timings, request) {
        super(error.message, error, request);
        this.name = 'TimeoutError';
        this.event = error.event;
        this.timings = timings;
    }
}
exports.TimeoutError = TimeoutError;
/**
An error to be thrown when reading from response stream fails.
*/
class ReadError extends RequestError {
    constructor(error, request) {
        super(error.message, error, request);
        this.name = 'ReadError';
    }
}
exports.ReadError = ReadError;
/**
An error to be thrown when given an unsupported protocol.
*/
class UnsupportedProtocolError extends RequestError {
    constructor(options) {
        super(`Unsupported protocol "${options.url.protocol}"`, {}, options);
        this.name = 'UnsupportedProtocolError';
    }
}
exports.UnsupportedProtocolError = UnsupportedProtocolError;
const proxiedRequestEvents = [
    'socket',
    'connect',
    'continue',
    'information',
    'upgrade',
    'timeout'
];
class Request extends stream_1.Duplex {
    constructor(url, options = {}, defaults) {
        super({
            // This must be false, to enable throwing after destroy
            // It is used for retry logic in Promise API
            autoDestroy: false,
            // It needs to be zero because we're just proxying the data to another stream
            highWaterMark: 0
        });
        this[kDownloadedSize] = 0;
        this[kUploadedSize] = 0;
        this.requestInitialized = false;
        this[kServerResponsesPiped] = new Set();
        this.redirects = [];
        this[kStopReading] = false;
        this[kTriggerRead] = false;
        this[kJobs] = [];
        this.retryCount = 0;
        // TODO: Remove this when targeting Node.js >= 12
        this._progressCallbacks = [];
        const unlockWrite = () => this._unlockWrite();
        const lockWrite = () => this._lockWrite();
        this.on('pipe', (source) => {
            source.prependListener('data', unlockWrite);
            source.on('data', lockWrite);
            source.prependListener('end', unlockWrite);
            source.on('end', lockWrite);
        });
        this.on('unpipe', (source) => {
            source.off('data', unlockWrite);
            source.off('data', lockWrite);
            source.off('end', unlockWrite);
            source.off('end', lockWrite);
        });
        this.on('pipe', source => {
            if (source instanceof http_1.IncomingMessage) {
                this.options.headers = {
                    ...source.headers,
                    ...this.options.headers
                };
            }
        });
        const { json, body, form } = options;
        if (json || body || form) {
            this._lockWrite();
        }
        if (exports.kIsNormalizedAlready in options) {
            this.options = options;
        }
        else {
            try {
                // @ts-expect-error Common TypeScript bug saying that `this.constructor` is not accessible
                this.options = this.constructor.normalizeArguments(url, options, defaults);
            }
            catch (error) {
                // TODO: Move this to `_destroy()`
                if (is_1.default.nodeStream(options.body)) {
                    options.body.destroy();
                }
                this.destroy(error);
                return;
            }
        }
        (async () => {
            var _a;
            try {
                if (this.options.body instanceof fs_1.ReadStream) {
                    await waitForOpenFile(this.options.body);
                }
                const { url: normalizedURL } = this.options;
                if (!normalizedURL) {
                    throw new TypeError('Missing `url` property');
                }
                this.requestUrl = normalizedURL.toString();
                decodeURI(this.requestUrl);
                await this._finalizeBody();
                await this._makeRequest();
                if (this.destroyed) {
                    (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroy();
                    return;
                }
                // Queued writes etc.
                for (const job of this[kJobs]) {
                    job();
                }
                // Prevent memory leak
                this[kJobs].length = 0;
                this.requestInitialized = true;
            }
            catch (error) {
                if (error instanceof RequestError) {
                    this._beforeError(error);
                    return;
                }
                // This is a workaround for https://github.com/nodejs/node/issues/33335
                if (!this.destroyed) {
                    this.destroy(error);
                }
            }
        })();
    }
    static normalizeArguments(url, options, defaults) {
        var _a, _b, _c, _d, _e;
        const rawOptions = options;
        if (is_1.default.object(url) && !is_1.default.urlInstance(url)) {
            options = { ...defaults, ...url, ...options };
        }
        else {
            if (url && options && options.url !== undefined) {
                throw new TypeError('The `url` option is mutually exclusive with the `input` argument');
            }
            options = { ...defaults, ...options };
            if (url !== undefined) {
                options.url = url;
            }
            if (is_1.default.urlInstance(options.url)) {
                options.url = new url_1.URL(options.url.toString());
            }
        }
        // TODO: Deprecate URL options in Got 12.
        // Support extend-specific options
        if (options.cache === false) {
            options.cache = undefined;
        }
        if (options.dnsCache === false) {
            options.dnsCache = undefined;
        }
        // Nice type assertions
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.method);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.headers);
        is_1.assert.any([is_1.default.string, is_1.default.urlInstance, is_1.default.undefined], options.prefixUrl);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cookieJar);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.searchParams);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.cache);
        is_1.assert.any([is_1.default.object, is_1.default.number, is_1.default.undefined], options.timeout);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.context);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.hooks);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.decompress);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.ignoreInvalidCookies);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.followRedirect);
        is_1.assert.any([is_1.default.number, is_1.default.undefined], options.maxRedirects);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.throwHttpErrors);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.http2);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.allowGetBody);
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.localAddress);
        is_1.assert.any([dns_ip_version_1.isDnsLookupIpVersion, is_1.default.undefined], options.dnsLookupIpVersion);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.https);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.rejectUnauthorized);
        if (options.https) {
            is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.https.rejectUnauthorized);
            is_1.assert.any([is_1.default.function_, is_1.default.undefined], options.https.checkServerIdentity);
            is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificateAuthority);
            is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.key);
            is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificate);
            is_1.assert.any([is_1.default.string, is_1.default.undefined], options.https.passphrase);
            is_1.assert.any([is_1.default.string, is_1.default.buffer, is_1.default.array, is_1.default.undefined], options.https.pfx);
        }
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cacheOptions);
        // `options.method`
        if (is_1.default.string(options.method)) {
            options.method = options.method.toUpperCase();
        }
        else {
            options.method = 'GET';
        }
        // `options.headers`
        if (options.headers === (defaults === null || defaults === void 0 ? void 0 : defaults.headers)) {
            options.headers = { ...options.headers };
        }
        else {
            options.headers = lowercaseKeys({ ...(defaults === null || defaults === void 0 ? void 0 : defaults.headers), ...options.headers });
        }
        // Disallow legacy `url.Url`
        if ('slashes' in options) {
            throw new TypeError('The legacy `url.Url` has been deprecated. Use `URL` instead.');
        }
        // `options.auth`
        if ('auth' in options) {
            throw new TypeError('Parameter `auth` is deprecated. Use `username` / `password` instead.');
        }
        // `options.searchParams`
        if ('searchParams' in options) {
            if (options.searchParams && options.searchParams !== (defaults === null || defaults === void 0 ? void 0 : defaults.searchParams)) {
                let searchParameters;
                if (is_1.default.string(options.searchParams) || (options.searchParams instanceof url_1.URLSearchParams)) {
                    searchParameters = new url_1.URLSearchParams(options.searchParams);
                }
                else {
                    validateSearchParameters(options.searchParams);
                    searchParameters = new url_1.URLSearchParams();
                    // eslint-disable-next-line guard-for-in
                    for (const key in options.searchParams) {
                        const value = options.searchParams[key];
                        if (value === null) {
                            searchParameters.append(key, '');
                        }
                        else if (value !== undefined) {
                            searchParameters.append(key, value);
                        }
                    }
                }
                // `normalizeArguments()` is also used to merge options
                (_a = defaults === null || defaults === void 0 ? void 0 : defaults.searchParams) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => {
                    // Only use default if one isn't already defined
                    if (!searchParameters.has(key)) {
                        searchParameters.append(key, value);
                    }
                });
                options.searchParams = searchParameters;
            }
        }
        // `options.username` & `options.password`
        options.username = (_b = options.username) !== null && _b !== void 0 ? _b : '';
        options.password = (_c = options.password) !== null && _c !== void 0 ? _c : '';
        // `options.prefixUrl` & `options.url`
        if (is_1.default.undefined(options.prefixUrl)) {
            options.prefixUrl = (_d = defaults === null || defaults === void 0 ? void 0 : defaults.prefixUrl) !== null && _d !== void 0 ? _d : '';
        }
        else {
            options.prefixUrl = options.prefixUrl.toString();
            if (options.prefixUrl !== '' && !options.prefixUrl.endsWith('/')) {
                options.prefixUrl += '/';
            }
        }
        if (is_1.default.string(options.url)) {
            if (options.url.startsWith('/')) {
                throw new Error('`input` must not start with a slash when using `prefixUrl`');
            }
            options.url = options_to_url_1.default(options.prefixUrl + options.url, options);
        }
        else if ((is_1.default.undefined(options.url) && options.prefixUrl !== '') || options.protocol) {
            options.url = options_to_url_1.default(options.prefixUrl, options);
        }
        if (options.url) {
            if ('port' in options) {
                delete options.port;
            }
            // Make it possible to change `options.prefixUrl`
            let { prefixUrl } = options;
            Object.defineProperty(options, 'prefixUrl', {
                set: (value) => {
                    const url = options.url;
                    if (!url.href.startsWith(value)) {
                        throw new Error(`Cannot change \`prefixUrl\` from ${prefixUrl} to ${value}: ${url.href}`);
                    }
                    options.url = new url_1.URL(value + url.href.slice(prefixUrl.length));
                    prefixUrl = value;
                },
                get: () => prefixUrl
            });
            // Support UNIX sockets
            let { protocol } = options.url;
            if (protocol === 'unix:') {
                protocol = 'http:';
                options.url = new url_1.URL(`http://unix${options.url.pathname}${options.url.search}`);
            }
            // Set search params
            if (options.searchParams) {
                // eslint-disable-next-line @typescript-eslint/no-base-to-string
                options.url.search = options.searchParams.toString();
            }
            // Protocol check
            if (protocol !== 'http:' && protocol !== 'https:') {
                throw new UnsupportedProtocolError(options);
            }
            // Update `username`
            if (options.username === '') {
                options.username = options.url.username;
            }
            else {
                options.url.username = options.username;
            }
            // Update `password`
            if (options.password === '') {
                options.password = options.url.password;
            }
            else {
                options.url.password = options.password;
            }
        }
        // `options.cookieJar`
        const { cookieJar } = options;
        if (cookieJar) {
            let { setCookie, getCookieString } = cookieJar;
            is_1.assert.function_(setCookie);
            is_1.assert.function_(getCookieString);
            /* istanbul ignore next: Horrible `tough-cookie` v3 check */
            if (setCookie.length === 4 && getCookieString.length === 0) {
                setCookie = util_1.promisify(setCookie.bind(options.cookieJar));
                getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));
                options.cookieJar = {
                    setCookie,
                    getCookieString: getCookieString
                };
            }
        }
        // `options.cache`
        const { cache } = options;
        if (cache) {
            if (!cacheableStore.has(cache)) {
                cacheableStore.set(cache, new CacheableRequest(((requestOptions, handler) => {
                    const result = requestOptions[kRequest](requestOptions, handler);
                    // TODO: remove this when `cacheable-request` supports async request functions.
                    if (is_1.default.promise(result)) {
                        // @ts-expect-error
                        // We only need to implement the error handler in order to support HTTP2 caching.
                        // The result will be a promise anyway.
                        result.once = (event, handler) => {
                            if (event === 'error') {
                                result.catch(handler);
                            }
                            else if (event === 'abort') {
                                // The empty catch is needed here in case when
                                // it rejects before it's `await`ed in `_makeRequest`.
                                (async () => {
                                    try {
                                        const request = (await result);
                                        request.once('abort', handler);
                                    }
                                    catch (_a) { }
                                })();
                            }
                            else {
                                /* istanbul ignore next: safety check */
                                throw new Error(`Unknown HTTP2 promise event: ${event}`);
                            }
                            return result;
                        };
                    }
                    return result;
                }), cache));
            }
        }
        // `options.cacheOptions`
        options.cacheOptions = { ...options.cacheOptions };
        // `options.dnsCache`
        if (options.dnsCache === true) {
            options.dnsCache = globalDnsCache;
        }
        else if (!is_1.default.undefined(options.dnsCache) && !options.dnsCache.lookup) {
            throw new TypeError(`Parameter \`dnsCache\` must be a CacheableLookup instance or a boolean, got ${is_1.default(options.dnsCache)}`);
        }
        // `options.timeout`
        if (is_1.default.number(options.timeout)) {
            options.timeout = { request: options.timeout };
        }
        else if (defaults && options.timeout !== defaults.timeout) {
            options.timeout = {
                ...defaults.timeout,
                ...options.timeout
            };
        }
        else {
            options.timeout = { ...options.timeout };
        }
        // `options.context`
        if (!options.context) {
            options.context = {};
        }
        // `options.hooks`
        const areHooksDefault = options.hooks === (defaults === null || defaults === void 0 ? void 0 : defaults.hooks);
        options.hooks = { ...options.hooks };
        for (const event of exports.knownHookEvents) {
            if (event in options.hooks) {
                if (is_1.default.array(options.hooks[event])) {
                    // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044
                    options.hooks[event] = [...options.hooks[event]];
                }
                else {
                    throw new TypeError(`Parameter \`${event}\` must be an Array, got ${is_1.default(options.hooks[event])}`);
                }
            }
            else {
                options.hooks[event] = [];
            }
        }
        if (defaults && !areHooksDefault) {
            for (const event of exports.knownHookEvents) {
                const defaultHooks = defaults.hooks[event];
                if (defaultHooks.length !== 0) {
                    // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044
                    options.hooks[event] = [
                        ...defaults.hooks[event],
                        ...options.hooks[event]
                    ];
                }
            }
        }
        // DNS options
        if ('family' in options) {
            deprecation_warning_1.default('"options.family" was never documented, please use "options.dnsLookupIpVersion"');
        }
        // HTTPS options
        if (defaults === null || defaults === void 0 ? void 0 : defaults.https) {
            options.https = { ...defaults.https, ...options.https };
        }
        if ('rejectUnauthorized' in options) {
            deprecation_warning_1.default('"options.rejectUnauthorized" is now deprecated, please use "options.https.rejectUnauthorized"');
        }
        if ('checkServerIdentity' in options) {
            deprecation_warning_1.default('"options.checkServerIdentity" was never documented, please use "options.https.checkServerIdentity"');
        }
        if ('ca' in options) {
            deprecation_warning_1.default('"options.ca" was never documented, please use "options.https.certificateAuthority"');
        }
        if ('key' in options) {
            deprecation_warning_1.default('"options.key" was never documented, please use "options.https.key"');
        }
        if ('cert' in options) {
            deprecation_warning_1.default('"options.cert" was never documented, please use "options.https.certificate"');
        }
        if ('passphrase' in options) {
            deprecation_warning_1.default('"options.passphrase" was never documented, please use "options.https.passphrase"');
        }
        if ('pfx' in options) {
            deprecation_warning_1.default('"options.pfx" was never documented, please use "options.https.pfx"');
        }
        // Other options
        if ('followRedirects' in options) {
            throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');
        }
        if (options.agent) {
            for (const key in options.agent) {
                if (key !== 'http' && key !== 'https' && key !== 'http2') {
                    throw new TypeError(`Expected the \`options.agent\` properties to be \`http\`, \`https\` or \`http2\`, got \`${key}\``);
                }
            }
        }
        options.maxRedirects = (_e = options.maxRedirects) !== null && _e !== void 0 ? _e : 0;
        // Set non-enumerable properties
        exports.setNonEnumerableProperties([defaults, rawOptions], options);
        return normalize_arguments_1.default(options, defaults);
    }
    _lockWrite() {
        const onLockedWrite = () => {
            throw new TypeError('The payload has been already provided');
        };
        this.write = onLockedWrite;
        this.end = onLockedWrite;
    }
    _unlockWrite() {
        this.write = super.write;
        this.end = super.end;
    }
    async _finalizeBody() {
        const { options } = this;
        const { headers } = options;
        const isForm = !is_1.default.undefined(options.form);
        const isJSON = !is_1.default.undefined(options.json);
        const isBody = !is_1.default.undefined(options.body);
        const hasPayload = isForm || isJSON || isBody;
        const cannotHaveBody = exports.withoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);
        this._cannotHaveBody = cannotHaveBody;
        if (hasPayload) {
            if (cannotHaveBody) {
                throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
            }
            if ([isBody, isForm, isJSON].filter(isTrue => isTrue).length > 1) {
                throw new TypeError('The `body`, `json` and `form` options are mutually exclusive');
            }
            if (isBody &&
                !(options.body instanceof stream_1.Readable) &&
                !is_1.default.string(options.body) &&
                !is_1.default.buffer(options.body) &&
                !is_form_data_1.default(options.body)) {
                throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');
            }
            if (isForm && !is_1.default.object(options.form)) {
                throw new TypeError('The `form` option must be an Object');
            }
            {
                // Serialize body
                const noContentType = !is_1.default.string(headers['content-type']);
                if (isBody) {
                    // Special case for https://github.com/form-data/form-data
                    if (is_form_data_1.default(options.body) && noContentType) {
                        headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
                    }
                    this[kBody] = options.body;
                }
                else if (isForm) {
                    if (noContentType) {
                        headers['content-type'] = 'application/x-www-form-urlencoded';
                    }
                    this[kBody] = (new url_1.URLSearchParams(options.form)).toString();
                }
                else {
                    if (noContentType) {
                        headers['content-type'] = 'application/json';
                    }
                    this[kBody] = options.stringifyJson(options.json);
                }
                const uploadBodySize = await get_body_size_1.default(this[kBody], options.headers);
                // See https://tools.ietf.org/html/rfc7230#section-3.3.2
                // A user agent SHOULD send a Content-Length in a request message when
                // no Transfer-Encoding is sent and the request method defines a meaning
                // for an enclosed payload body.  For example, a Content-Length header
                // field is normally sent in a POST request even when the value is 0
                // (indicating an empty payload body).  A user agent SHOULD NOT send a
                // Content-Length header field when the request message does not contain
                // a payload body and the method semantics do not anticipate such a
                // body.
                if (is_1.default.undefined(headers['content-length']) && is_1.default.undefined(headers['transfer-encoding'])) {
                    if (!cannotHaveBody && !is_1.default.undefined(uploadBodySize)) {
                        headers['content-length'] = String(uploadBodySize);
                    }
                }
            }
        }
        else if (cannotHaveBody) {
            this._lockWrite();
        }
        else {
            this._unlockWrite();
        }
        this[kBodySize] = Number(headers['content-length']) || undefined;
    }
    async _onResponseBase(response) {
        const { options } = this;
        const { url } = options;
        this[kOriginalResponse] = response;
        if (options.decompress) {
            response = decompressResponse(response);
        }
        const statusCode = response.statusCode;
        const typedResponse = response;
        typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];
        typedResponse.url = options.url.toString();
        typedResponse.requestUrl = this.requestUrl;
        typedResponse.redirectUrls = this.redirects;
        typedResponse.request = this;
        typedResponse.isFromCache = response.fromCache || false;
        typedResponse.ip = this.ip;
        typedResponse.retryCount = this.retryCount;
        this[kIsFromCache] = typedResponse.isFromCache;
        this[kResponseSize] = Number(response.headers['content-length']) || undefined;
        this[kResponse] = response;
        response.once('end', () => {
            this[kResponseSize] = this[kDownloadedSize];
            this.emit('downloadProgress', this.downloadProgress);
        });
        response.once('error', (error) => {
            // Force clean-up, because some packages don't do this.
            // TODO: Fix decompress-response
            response.destroy();
            this._beforeError(new ReadError(error, this));
        });
        response.once('aborted', () => {
            this._beforeError(new ReadError({
                name: 'Error',
                message: 'The server aborted pending request',
                code: 'ECONNRESET'
            }, this));
        });
        this.emit('downloadProgress', this.downloadProgress);
        const rawCookies = response.headers['set-cookie'];
        if (is_1.default.object(options.cookieJar) && rawCookies) {
            let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
            if (options.ignoreInvalidCookies) {
                promises = promises.map(async (p) => p.catch(() => { }));
            }
            try {
                await Promise.all(promises);
            }
            catch (error) {
                this._beforeError(error);
                return;
            }
        }
        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {
            // We're being redirected, we don't care about the response.
            // It'd be best to abort the request, but we can't because
            // we would have to sacrifice the TCP connection. We don't want that.
            response.resume();
            if (this[kRequest]) {
                this[kCancelTimeouts]();
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete this[kRequest];
                this[kUnproxyEvents]();
            }
            const shouldBeGet = statusCode === 303 && options.method !== 'GET' && options.method !== 'HEAD';
            if (shouldBeGet || !options.methodRewriting) {
                // Server responded with "see other", indicating that the resource exists at another location,
                // and the client should request it from that location via GET or HEAD.
                options.method = 'GET';
                if ('body' in options) {
                    delete options.body;
                }
                if ('json' in options) {
                    delete options.json;
                }
                if ('form' in options) {
                    delete options.form;
                }
                this[kBody] = undefined;
                delete options.headers['content-length'];
            }
            if (this.redirects.length >= options.maxRedirects) {
                this._beforeError(new MaxRedirectsError(this));
                return;
            }
            try {
                // Do not remove. See https://github.com/sindresorhus/got/pull/214
                const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();
                // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604
                const redirectUrl = new url_1.URL(redirectBuffer, url);
                const redirectString = redirectUrl.toString();
                decodeURI(redirectString);
                // Redirecting to a different site, clear sensitive data.
                if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
                    if ('host' in options.headers) {
                        delete options.headers.host;
                    }
                    if ('cookie' in options.headers) {
                        delete options.headers.cookie;
                    }
                    if ('authorization' in options.headers) {
                        delete options.headers.authorization;
                    }
                    if (options.username || options.password) {
                        options.username = '';
                        options.password = '';
                    }
                }
                else {
                    redirectUrl.username = options.username;
                    redirectUrl.password = options.password;
                }
                this.redirects.push(redirectString);
                options.url = redirectUrl;
                for (const hook of options.hooks.beforeRedirect) {
                    // eslint-disable-next-line no-await-in-loop
                    await hook(options, typedResponse);
                }
                this.emit('redirect', typedResponse, options);
                await this._makeRequest();
            }
            catch (error) {
                this._beforeError(error);
                return;
            }
            return;
        }
        if (options.isStream && options.throwHttpErrors && !is_response_ok_1.isResponseOk(typedResponse)) {
            this._beforeError(new HTTPError(typedResponse));
            return;
        }
        response.on('readable', () => {
            if (this[kTriggerRead]) {
                this._read();
            }
        });
        this.on('resume', () => {
            response.resume();
        });
        this.on('pause', () => {
            response.pause();
        });
        response.once('end', () => {
            this.push(null);
        });
        this.emit('response', response);
        for (const destination of this[kServerResponsesPiped]) {
            if (destination.headersSent) {
                continue;
            }
            // eslint-disable-next-line guard-for-in
            for (const key in response.headers) {
                const isAllowed = options.decompress ? key !== 'content-encoding' : true;
                const value = response.headers[key];
                if (isAllowed) {
                    destination.setHeader(key, value);
                }
            }
            destination.statusCode = statusCode;
        }
    }
    async _onResponse(response) {
        try {
            await this._onResponseBase(response);
        }
        catch (error) {
            /* istanbul ignore next: better safe than sorry */
            this._beforeError(error);
        }
    }
    _onRequest(request) {
        const { options } = this;
        const { timeout, url } = options;
        http_timer_1.default(request);
        this[kCancelTimeouts] = timed_out_1.default(request, timeout, url);
        const responseEventName = options.cache ? 'cacheableResponse' : 'response';
        request.once(responseEventName, (response) => {
            void this._onResponse(response);
        });
        request.once('error', (error) => {
            var _a;
            // Force clean-up, because some packages (e.g. nock) don't do this.
            request.destroy();
            // Node.js <= 12.18.2 mistakenly emits the response `end` first.
            (_a = request.res) === null || _a === void 0 ? void 0 : _a.removeAllListeners('end');
            if (error instanceof timed_out_1.TimeoutError) {
                error = new TimeoutError(error, this.timings, this);
            }
            else {
                error = new RequestError(error.message, error, this);
            }
            this._beforeError(error);
        });
        this[kUnproxyEvents] = proxy_events_1.default(request, this, proxiedRequestEvents);
        this[kRequest] = request;
        this.emit('uploadProgress', this.uploadProgress);
        // Send body
        const body = this[kBody];
        const currentRequest = this.redirects.length === 0 ? this : request;
        if (is_1.default.nodeStream(body)) {
            body.pipe(currentRequest);
            body.once('error', (error) => {
                this._beforeError(new UploadError(error, this));
            });
        }
        else {
            this._unlockWrite();
            if (!is_1.default.undefined(body)) {
                this._writeRequest(body, undefined, () => { });
                currentRequest.end();
                this._lockWrite();
            }
            else if (this._cannotHaveBody || this._noPipe) {
                currentRequest.end();
                this._lockWrite();
            }
        }
        this.emit('request', request);
    }
    async _createCacheableRequest(url, options) {
        return new Promise((resolve, reject) => {
            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed
            Object.assign(options, url_to_options_1.default(url));
            // `http-cache-semantics` checks this
            // TODO: Fix this ignore.
            // @ts-expect-error
            delete options.url;
            let request;
            // This is ugly
            const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
                // TODO: Fix `cacheable-response`
                response._readableState.autoDestroy = false;
                if (request) {
                    (await request).emit('cacheableResponse', response);
                }
                resolve(response);
            });
            // Restore options
            options.url = url;
            cacheRequest.once('error', reject);
            cacheRequest.once('request', async (requestOrPromise) => {
                request = requestOrPromise;
                resolve(request);
            });
        });
    }
    async _makeRequest() {
        var _a, _b, _c, _d, _e;
        const { options } = this;
        const { headers } = options;
        for (const key in headers) {
            if (is_1.default.undefined(headers[key])) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete headers[key];
            }
            else if (is_1.default.null_(headers[key])) {
                throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
            }
        }
        if (options.decompress && is_1.default.undefined(headers['accept-encoding'])) {
            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';
        }
        // Set cookies
        if (options.cookieJar) {
            const cookieString = await options.cookieJar.getCookieString(options.url.toString());
            if (is_1.default.nonEmptyString(cookieString)) {
                options.headers.cookie = cookieString;
            }
        }
        for (const hook of options.hooks.beforeRequest) {
            // eslint-disable-next-line no-await-in-loop
            const result = await hook(options);
            if (!is_1.default.undefined(result)) {
                // @ts-expect-error Skip the type mismatch to support abstract responses
                options.request = () => result;
                break;
            }
        }
        if (options.body && this[kBody] !== options.body) {
            this[kBody] = options.body;
        }
        const { agent, request, timeout, url } = options;
        if (options.dnsCache && !('lookup' in options)) {
            options.lookup = options.dnsCache.lookup;
        }
        // UNIX sockets
        if (url.hostname === 'unix') {
            const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
            if (matches === null || matches === void 0 ? void 0 : matches.groups) {
                const { socketPath, path } = matches.groups;
                Object.assign(options, {
                    socketPath,
                    path,
                    host: ''
                });
            }
        }
        const isHttps = url.protocol === 'https:';
        // Fallback function
        let fallbackFn;
        if (options.http2) {
            fallbackFn = http2wrapper.auto;
        }
        else {
            fallbackFn = isHttps ? https.request : http.request;
        }
        const realFn = (_a = options.request) !== null && _a !== void 0 ? _a : fallbackFn;
        // Cache support
        const fn = options.cache ? this._createCacheableRequest : realFn;
        // Pass an agent directly when HTTP2 is disabled
        if (agent && !options.http2) {
            options.agent = agent[isHttps ? 'https' : 'http'];
        }
        // Prepare plain HTTP request options
        options[kRequest] = realFn;
        delete options.request;
        // TODO: Fix this ignore.
        // @ts-expect-error
        delete options.timeout;
        const requestOptions = options;
        requestOptions.shared = (_b = options.cacheOptions) === null || _b === void 0 ? void 0 : _b.shared;
        requestOptions.cacheHeuristic = (_c = options.cacheOptions) === null || _c === void 0 ? void 0 : _c.cacheHeuristic;
        requestOptions.immutableMinTimeToLive = (_d = options.cacheOptions) === null || _d === void 0 ? void 0 : _d.immutableMinTimeToLive;
        requestOptions.ignoreCargoCult = (_e = options.cacheOptions) === null || _e === void 0 ? void 0 : _e.ignoreCargoCult;
        // If `dnsLookupIpVersion` is not present do not override `family`
        if (options.dnsLookupIpVersion !== undefined) {
            try {
                requestOptions.family = dns_ip_version_1.dnsLookupIpVersionToFamily(options.dnsLookupIpVersion);
            }
            catch (_f) {
                throw new Error('Invalid `dnsLookupIpVersion` option value');
            }
        }
        // HTTPS options remapping
        if (options.https) {
            if ('rejectUnauthorized' in options.https) {
                requestOptions.rejectUnauthorized = options.https.rejectUnauthorized;
            }
            if (options.https.checkServerIdentity) {
                requestOptions.checkServerIdentity = options.https.checkServerIdentity;
            }
            if (options.https.certificateAuthority) {
                requestOptions.ca = options.https.certificateAuthority;
            }
            if (options.https.certificate) {
                requestOptions.cert = options.https.certificate;
            }
            if (options.https.key) {
                requestOptions.key = options.https.key;
            }
            if (options.https.passphrase) {
                requestOptions.passphrase = options.https.passphrase;
            }
            if (options.https.pfx) {
                requestOptions.pfx = options.https.pfx;
            }
        }
        try {
            let requestOrResponse = await fn(url, requestOptions);
            if (is_1.default.undefined(requestOrResponse)) {
                requestOrResponse = fallbackFn(url, requestOptions);
            }
            // Restore options
            options.request = request;
            options.timeout = timeout;
            options.agent = agent;
            // HTTPS options restore
            if (options.https) {
                if ('rejectUnauthorized' in options.https) {
                    delete requestOptions.rejectUnauthorized;
                }
                if (options.https.checkServerIdentity) {
                    // @ts-expect-error - This one will be removed when we remove the alias.
                    delete requestOptions.checkServerIdentity;
                }
                if (options.https.certificateAuthority) {
                    delete requestOptions.ca;
                }
                if (options.https.certificate) {
                    delete requestOptions.cert;
                }
                if (options.https.key) {
                    delete requestOptions.key;
                }
                if (options.https.passphrase) {
                    delete requestOptions.passphrase;
                }
                if (options.https.pfx) {
                    delete requestOptions.pfx;
                }
            }
            if (isClientRequest(requestOrResponse)) {
                this._onRequest(requestOrResponse);
                // Emit the response after the stream has been ended
            }
            else if (this.writable) {
                this.once('finish', () => {
                    void this._onResponse(requestOrResponse);
                });
                this._unlockWrite();
                this.end();
                this._lockWrite();
            }
            else {
                void this._onResponse(requestOrResponse);
            }
        }
        catch (error) {
            if (error instanceof CacheableRequest.CacheError) {
                throw new CacheError(error, this);
            }
            throw new RequestError(error.message, error, this);
        }
    }
    async _error(error) {
        try {
            for (const hook of this.options.hooks.beforeError) {
                // eslint-disable-next-line no-await-in-loop
                error = await hook(error);
            }
        }
        catch (error_) {
            error = new RequestError(error_.message, error_, this);
        }
        this.destroy(error);
    }
    _beforeError(error) {
        if (this[kStopReading]) {
            return;
        }
        const { options } = this;
        const retryCount = this.retryCount + 1;
        this[kStopReading] = true;
        if (!(error instanceof RequestError)) {
            error = new RequestError(error.message, error, this);
        }
        const typedError = error;
        const { response } = typedError;
        void (async () => {
            if (response && !response.body) {
                response.setEncoding(this._readableState.encoding);
                try {
                    response.rawBody = await get_buffer_1.default(response);
                    response.body = response.rawBody.toString();
                }
                catch (_a) { }
            }
            if (this.listenerCount('retry') !== 0) {
                let backoff;
                try {
                    let retryAfter;
                    if (response && 'retry-after' in response.headers) {
                        retryAfter = Number(response.headers['retry-after']);
                        if (Number.isNaN(retryAfter)) {
                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();
                            if (retryAfter <= 0) {
                                retryAfter = 1;
                            }
                        }
                        else {
                            retryAfter *= 1000;
                        }
                    }
                    backoff = await options.retry.calculateDelay({
                        attemptCount: retryCount,
                        retryOptions: options.retry,
                        error: typedError,
                        retryAfter,
                        computedValue: calculate_retry_delay_1.default({
                            attemptCount: retryCount,
                            retryOptions: options.retry,
                            error: typedError,
                            retryAfter,
                            computedValue: 0
                        })
                    });
                }
                catch (error_) {
                    void this._error(new RequestError(error_.message, error_, this));
                    return;
                }
                if (backoff) {
                    const retry = async () => {
                        try {
                            for (const hook of this.options.hooks.beforeRetry) {
                                // eslint-disable-next-line no-await-in-loop
                                await hook(this.options, typedError, retryCount);
                            }
                        }
                        catch (error_) {
                            void this._error(new RequestError(error_.message, error, this));
                            return;
                        }
                        // Something forced us to abort the retry
                        if (this.destroyed) {
                            return;
                        }
                        this.destroy();
                        this.emit('retry', retryCount, error);
                    };
                    this[kRetryTimeout] = setTimeout(retry, backoff);
                    return;
                }
            }
            void this._error(typedError);
        })();
    }
    _read() {
        this[kTriggerRead] = true;
        const response = this[kResponse];
        if (response && !this[kStopReading]) {
            // We cannot put this in the `if` above
            // because `.read()` also triggers the `end` event
            if (response.readableLength) {
                this[kTriggerRead] = false;
            }
            let data;
            while ((data = response.read()) !== null) {
                this[kDownloadedSize] += data.length;
                this[kStartedReading] = true;
                const progress = this.downloadProgress;
                if (progress.percent < 1) {
                    this.emit('downloadProgress', progress);
                }
                this.push(data);
            }
        }
    }
    // Node.js 12 has incorrect types, so the encoding must be a string
    _write(chunk, encoding, callback) {
        const write = () => {
            this._writeRequest(chunk, encoding, callback);
        };
        if (this.requestInitialized) {
            write();
        }
        else {
            this[kJobs].push(write);
        }
    }
    _writeRequest(chunk, encoding, callback) {
        if (this[kRequest].destroyed) {
            // Probably the `ClientRequest` instance will throw
            return;
        }
        this._progressCallbacks.push(() => {
            this[kUploadedSize] += Buffer.byteLength(chunk, encoding);
            const progress = this.uploadProgress;
            if (progress.percent < 1) {
                this.emit('uploadProgress', progress);
            }
        });
        // TODO: What happens if it's from cache? Then this[kRequest] won't be defined.
        this[kRequest].write(chunk, encoding, (error) => {
            if (!error && this._progressCallbacks.length !== 0) {
                this._progressCallbacks.shift()();
            }
            callback(error);
        });
    }
    _final(callback) {
        const endRequest = () => {
            // FIX: Node.js 10 calls the write callback AFTER the end callback!
            while (this._progressCallbacks.length !== 0) {
                this._progressCallbacks.shift()();
            }
            // We need to check if `this[kRequest]` is present,
            // because it isn't when we use cache.
            if (!(kRequest in this)) {
                callback();
                return;
            }
            if (this[kRequest].destroyed) {
                callback();
                return;
            }
            this[kRequest].end((error) => {
                if (!error) {
                    this[kBodySize] = this[kUploadedSize];
                    this.emit('uploadProgress', this.uploadProgress);
                    this[kRequest].emit('upload-complete');
                }
                callback(error);
            });
        };
        if (this.requestInitialized) {
            endRequest();
        }
        else {
            this[kJobs].push(endRequest);
        }
    }
    _destroy(error, callback) {
        var _a;
        this[kStopReading] = true;
        // Prevent further retries
        clearTimeout(this[kRetryTimeout]);
        if (kRequest in this) {
            this[kCancelTimeouts]();
            // TODO: Remove the next `if` when these get fixed:
            // - https://github.com/nodejs/node/issues/32851
            if (!((_a = this[kResponse]) === null || _a === void 0 ? void 0 : _a.complete)) {
                this[kRequest].destroy();
            }
        }
        if (error !== null && !is_1.default.undefined(error) && !(error instanceof RequestError)) {
            error = new RequestError(error.message, error, this);
        }
        callback(error);
    }
    get _isAboutToError() {
        return this[kStopReading];
    }
    /**
    The remote IP address.
    */
    get ip() {
        var _a;
        return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.socket.remoteAddress;
    }
    /**
    Indicates whether the request has been aborted or not.
    */
    get aborted() {
        var _a, _b, _c;
        return ((_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroyed) !== null && _b !== void 0 ? _b : this.destroyed) && !((_c = this[kOriginalResponse]) === null || _c === void 0 ? void 0 : _c.complete);
    }
    get socket() {
        var _a;
        return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.socket;
    }
    /**
    Progress event for downloading (receiving a response).
    */
    get downloadProgress() {
        let percent;
        if (this[kResponseSize]) {
            percent = this[kDownloadedSize] / this[kResponseSize];
        }
        else if (this[kResponseSize] === this[kDownloadedSize]) {
            percent = 1;
        }
        else {
            percent = 0;
        }
        return {
            percent,
            transferred: this[kDownloadedSize],
            total: this[kResponseSize]
        };
    }
    /**
    Progress event for uploading (sending a request).
    */
    get uploadProgress() {
        let percent;
        if (this[kBodySize]) {
            percent = this[kUploadedSize] / this[kBodySize];
        }
        else if (this[kBodySize] === this[kUploadedSize]) {
            percent = 1;
        }
        else {
            percent = 0;
        }
        return {
            percent,
            transferred: this[kUploadedSize],
            total: this[kBodySize]
        };
    }
    /**
    The object contains the following properties:

    - `start` - Time when the request started.
    - `socket` - Time when a socket was assigned to the request.
    - `lookup` - Time when the DNS lookup finished.
    - `connect` - Time when the socket successfully connected.
    - `secureConnect` - Time when the socket securely connected.
    - `upload` - Time when the request finished uploading.
    - `response` - Time when the request fired `response` event.
    - `end` - Time when the response fired `end` event.
    - `error` - Time when the request fired `error` event.
    - `abort` - Time when the request fired `abort` event.
    - `phases`
        - `wait` - `timings.socket - timings.start`
        - `dns` - `timings.lookup - timings.socket`
        - `tcp` - `timings.connect - timings.lookup`
        - `tls` - `timings.secureConnect - timings.connect`
        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
        - `firstByte` - `timings.response - timings.upload`
        - `download` - `timings.end - timings.response`
        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`

    If something has not been measured yet, it will be `undefined`.

    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
    */
    get timings() {
        var _a;
        return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.timings;
    }
    /**
    Whether the response was retrieved from the cache.
    */
    get isFromCache() {
        return this[kIsFromCache];
    }
    pipe(destination, options) {
        if (this[kStartedReading]) {
            throw new Error('Failed to pipe. The response has been emitted already.');
        }
        if (destination instanceof http_1.ServerResponse) {
            this[kServerResponsesPiped].add(destination);
        }
        return super.pipe(destination, options);
    }
    unpipe(destination) {
        if (destination instanceof http_1.ServerResponse) {
            this[kServerResponsesPiped].delete(destination);
        }
        super.unpipe(destination);
        return this;
    }
}
exports.default = Request;


/***/ }),
/* 762 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const defer_to_connect_1 = __webpack_require__(763);
const nodejsMajorVersion = Number(process.versions.node.split('.')[0]);
const timer = (request) => {
    const timings = {
        start: Date.now(),
        socket: undefined,
        lookup: undefined,
        connect: undefined,
        secureConnect: undefined,
        upload: undefined,
        response: undefined,
        end: undefined,
        error: undefined,
        abort: undefined,
        phases: {
            wait: undefined,
            dns: undefined,
            tcp: undefined,
            tls: undefined,
            request: undefined,
            firstByte: undefined,
            download: undefined,
            total: undefined
        }
    };
    request.timings = timings;
    const handleError = (origin) => {
        const emit = origin.emit.bind(origin);
        origin.emit = (event, ...args) => {
            // Catches the `error` event
            if (event === 'error') {
                timings.error = Date.now();
                timings.phases.total = timings.error - timings.start;
                origin.emit = emit;
            }
            // Saves the original behavior
            return emit(event, ...args);
        };
    };
    handleError(request);
    request.prependOnceListener('abort', () => {
        timings.abort = Date.now();
        // Let the `end` response event be responsible for setting the total phase,
        // unless the Node.js major version is >= 13.
        if (!timings.response || nodejsMajorVersion >= 13) {
            timings.phases.total = Date.now() - timings.start;
        }
    });
    const onSocket = (socket) => {
        timings.socket = Date.now();
        timings.phases.wait = timings.socket - timings.start;
        const lookupListener = () => {
            timings.lookup = Date.now();
            timings.phases.dns = timings.lookup - timings.socket;
        };
        socket.prependOnceListener('lookup', lookupListener);
        defer_to_connect_1.default(socket, {
            connect: () => {
                timings.connect = Date.now();
                if (timings.lookup === undefined) {
                    socket.removeListener('lookup', lookupListener);
                    timings.lookup = timings.connect;
                    timings.phases.dns = timings.lookup - timings.socket;
                }
                timings.phases.tcp = timings.connect - timings.lookup;
                // This callback is called before flushing any data,
                // so we don't need to set `timings.phases.request` here.
            },
            secureConnect: () => {
                timings.secureConnect = Date.now();
                timings.phases.tls = timings.secureConnect - timings.connect;
            }
        });
    };
    if (request.socket) {
        onSocket(request.socket);
    }
    else {
        request.prependOnceListener('socket', onSocket);
    }
    const onUpload = () => {
        var _a;
        timings.upload = Date.now();
        timings.phases.request = timings.upload - (_a = timings.secureConnect, (_a !== null && _a !== void 0 ? _a : timings.connect));
    };
    const writableFinished = () => {
        if (typeof request.writableFinished === 'boolean') {
            return request.writableFinished;
        }
        // Node.js doesn't have `request.writableFinished` property
        return request.finished && request.outputSize === 0 && (!request.socket || request.socket.writableLength === 0);
    };
    if (writableFinished()) {
        onUpload();
    }
    else {
        request.prependOnceListener('finish', onUpload);
    }
    request.prependOnceListener('response', (response) => {
        timings.response = Date.now();
        timings.phases.firstByte = timings.response - timings.upload;
        response.timings = timings;
        handleError(response);
        response.prependOnceListener('end', () => {
            timings.end = Date.now();
            timings.phases.download = timings.end - timings.response;
            timings.phases.total = timings.end - timings.start;
        });
    });
    return timings;
};
exports.default = timer;
// For CommonJS default export support
module.exports = timer;
module.exports.default = timer;


/***/ }),
/* 763 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tls_1 = __webpack_require__(245);
const deferToConnect = (socket, fn) => {
    let listeners;
    if (typeof fn === 'function') {
        const connect = fn;
        listeners = { connect };
    }
    else {
        listeners = fn;
    }
    const hasConnectListener = typeof listeners.connect === 'function';
    const hasSecureConnectListener = typeof listeners.secureConnect === 'function';
    const hasCloseListener = typeof listeners.close === 'function';
    const onConnect = () => {
        if (hasConnectListener) {
            listeners.connect();
        }
        if (socket instanceof tls_1.TLSSocket && hasSecureConnectListener) {
            if (socket.authorized) {
                listeners.secureConnect();
            }
            else if (!socket.authorizationError) {
                socket.once('secureConnect', listeners.secureConnect);
            }
        }
        if (hasCloseListener) {
            socket.once('close', listeners.close);
        }
    };
    if (socket.writable && !socket.connecting) {
        onConnect();
    }
    else if (socket.connecting) {
        socket.once('connect', onConnect);
    }
    else if (socket.destroyed && hasCloseListener) {
        listeners.close(socket._hadError);
    }
};
exports.default = deferToConnect;
// For CommonJS default export support
module.exports = deferToConnect;
module.exports.default = deferToConnect;


/***/ }),
/* 764 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {
	V4MAPPED,
	ADDRCONFIG,
	ALL,
	promises: {
		Resolver: AsyncResolver
	},
	lookup: dnsLookup
} = __webpack_require__(765);
const {promisify} = __webpack_require__(90);
const os = __webpack_require__(21);

const kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');
const kCacheableLookupInstance = Symbol('cacheableLookupInstance');
const kExpires = Symbol('expires');

const supportsALL = typeof ALL === 'number';

const verifyAgent = agent => {
	if (!(agent && typeof agent.createConnection === 'function')) {
		throw new Error('Expected an Agent instance as the first argument');
	}
};

const map4to6 = entries => {
	for (const entry of entries) {
		if (entry.family === 6) {
			continue;
		}

		entry.address = `::ffff:${entry.address}`;
		entry.family = 6;
	}
};

const getIfaceInfo = () => {
	let has4 = false;
	let has6 = false;

	for (const device of Object.values(os.networkInterfaces())) {
		for (const iface of device) {
			if (iface.internal) {
				continue;
			}

			if (iface.family === 'IPv6') {
				has6 = true;
			} else {
				has4 = true;
			}

			if (has4 && has6) {
				return {has4, has6};
			}
		}
	}

	return {has4, has6};
};

const isIterable = map => {
	return Symbol.iterator in map;
};

const ttl = {ttl: true};
const all = {all: true};

class CacheableLookup {
	constructor({
		cache = new Map(),
		maxTtl = Infinity,
		fallbackDuration = 3600,
		errorTtl = 0.15,
		resolver = new AsyncResolver(),
		lookup = dnsLookup
	} = {}) {
		this.maxTtl = maxTtl;
		this.errorTtl = errorTtl;

		this._cache = cache;
		this._resolver = resolver;
		this._dnsLookup = promisify(lookup);

		if (this._resolver instanceof AsyncResolver) {
			this._resolve4 = this._resolver.resolve4.bind(this._resolver);
			this._resolve6 = this._resolver.resolve6.bind(this._resolver);
		} else {
			this._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));
			this._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));
		}

		this._iface = getIfaceInfo();

		this._pending = {};
		this._nextRemovalTime = false;
		this._hostnamesToFallback = new Set();

		if (fallbackDuration < 1) {
			this._fallback = false;
		} else {
			this._fallback = true;

			const interval = setInterval(() => {
				this._hostnamesToFallback.clear();
			}, fallbackDuration * 1000);

			/* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */
			if (interval.unref) {
				interval.unref();
			}
		}

		this.lookup = this.lookup.bind(this);
		this.lookupAsync = this.lookupAsync.bind(this);
	}

	set servers(servers) {
		this.clear();

		this._resolver.setServers(servers);
	}

	get servers() {
		return this._resolver.getServers();
	}

	lookup(hostname, options, callback) {
		if (typeof options === 'function') {
			callback = options;
			options = {};
		} else if (typeof options === 'number') {
			options = {
				family: options
			};
		}

		if (!callback) {
			throw new Error('Callback must be a function.');
		}

		// eslint-disable-next-line promise/prefer-await-to-then
		this.lookupAsync(hostname, options).then(result => {
			if (options.all) {
				callback(null, result);
			} else {
				callback(null, result.address, result.family, result.expires, result.ttl);
			}
		}, callback);
	}

	async lookupAsync(hostname, options = {}) {
		if (typeof options === 'number') {
			options = {
				family: options
			};
		}

		let cached = await this.query(hostname);

		if (options.family === 6) {
			const filtered = cached.filter(entry => entry.family === 6);

			if (options.hints & V4MAPPED) {
				if ((supportsALL && options.hints & ALL) || filtered.length === 0) {
					map4to6(cached);
				} else {
					cached = filtered;
				}
			} else {
				cached = filtered;
			}
		} else if (options.family === 4) {
			cached = cached.filter(entry => entry.family === 4);
		}

		if (options.hints & ADDRCONFIG) {
			const {_iface} = this;
			cached = cached.filter(entry => entry.family === 6 ? _iface.has6 : _iface.has4);
		}

		if (cached.length === 0) {
			const error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
			error.code = 'ENOTFOUND';
			error.hostname = hostname;

			throw error;
		}

		if (options.all) {
			return cached;
		}

		return cached[0];
	}

	async query(hostname) {
		let cached = await this._cache.get(hostname);

		if (!cached) {
			const pending = this._pending[hostname];

			if (pending) {
				cached = await pending;
			} else {
				const newPromise = this.queryAndCache(hostname);
				this._pending[hostname] = newPromise;

				cached = await newPromise;
			}
		}

		cached = cached.map(entry => {
			return {...entry};
		});

		return cached;
	}

	async _resolve(hostname) {
		const wrap = async promise => {
			try {
				return await promise;
			} catch (error) {
				if (error.code === 'ENODATA' || error.code === 'ENOTFOUND') {
					return [];
				}

				throw error;
			}
		};

		// ANY is unsafe as it doesn't trigger new queries in the underlying server.
		const [A, AAAA] = await Promise.all([
			this._resolve4(hostname, ttl),
			this._resolve6(hostname, ttl)
		].map(promise => wrap(promise)));

		let aTtl = 0;
		let aaaaTtl = 0;
		let cacheTtl = 0;

		const now = Date.now();

		for (const entry of A) {
			entry.family = 4;
			entry.expires = now + (entry.ttl * 1000);

			aTtl = Math.max(aTtl, entry.ttl);
		}

		for (const entry of AAAA) {
			entry.family = 6;
			entry.expires = now + (entry.ttl * 1000);

			aaaaTtl = Math.max(aaaaTtl, entry.ttl);
		}

		if (A.length > 0) {
			if (AAAA.length > 0) {
				cacheTtl = Math.min(aTtl, aaaaTtl);
			} else {
				cacheTtl = aTtl;
			}
		} else {
			cacheTtl = aaaaTtl;
		}

		return {
			entries: [
				...A,
				...AAAA
			],
			cacheTtl
		};
	}

	async _lookup(hostname) {
		try {
			const entries = await this._dnsLookup(hostname, {
				all: true
			});

			return {
				entries,
				cacheTtl: 0
			};
		} catch (_) {
			return {
				entries: [],
				cacheTtl: 0
			};
		}
	}

	async _set(hostname, data, cacheTtl) {
		if (this.maxTtl > 0 && cacheTtl > 0) {
			cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;
			data[kExpires] = Date.now() + cacheTtl;

			try {
				await this._cache.set(hostname, data, cacheTtl);
			} catch (error) {
				this.lookupAsync = async () => {
					const cacheError = new Error('Cache Error. Please recreate the CacheableLookup instance.');
					cacheError.cause = error;

					throw cacheError;
				};
			}

			if (isIterable(this._cache)) {
				this._tick(cacheTtl);
			}
		}
	}

	async queryAndCache(hostname) {
		if (this._hostnamesToFallback.has(hostname)) {
			return this._dnsLookup(hostname, all);
		}

		try {
			let query = await this._resolve(hostname);

			if (query.entries.length === 0 && this._fallback) {
				query = await this._lookup(hostname);

				if (query.entries.length !== 0) {
					// Use `dns.lookup(...)` for that particular hostname
					this._hostnamesToFallback.add(hostname);
				}
			}

			const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
			await this._set(hostname, query.entries, cacheTtl);

			delete this._pending[hostname];

			return query.entries;
		} catch (error) {
			delete this._pending[hostname];

			throw error;
		}
	}

	_tick(ms) {
		const nextRemovalTime = this._nextRemovalTime;

		if (!nextRemovalTime || ms < nextRemovalTime) {
			clearTimeout(this._removalTimeout);

			this._nextRemovalTime = ms;

			this._removalTimeout = setTimeout(() => {
				this._nextRemovalTime = false;

				let nextExpiry = Infinity;

				const now = Date.now();

				for (const [hostname, entries] of this._cache) {
					const expires = entries[kExpires];

					if (now >= expires) {
						this._cache.delete(hostname);
					} else if (expires < nextExpiry) {
						nextExpiry = expires;
					}
				}

				if (nextExpiry !== Infinity) {
					this._tick(nextExpiry - now);
				}
			}, ms);

			/* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */
			if (this._removalTimeout.unref) {
				this._removalTimeout.unref();
			}
		}
	}

	install(agent) {
		verifyAgent(agent);

		if (kCacheableLookupCreateConnection in agent) {
			throw new Error('CacheableLookup has been already installed');
		}

		agent[kCacheableLookupCreateConnection] = agent.createConnection;
		agent[kCacheableLookupInstance] = this;

		agent.createConnection = (options, callback) => {
			if (!('lookup' in options)) {
				options.lookup = this.lookup;
			}

			return agent[kCacheableLookupCreateConnection](options, callback);
		};
	}

	uninstall(agent) {
		verifyAgent(agent);

		if (agent[kCacheableLookupCreateConnection]) {
			if (agent[kCacheableLookupInstance] !== this) {
				throw new Error('The agent is not owned by this CacheableLookup instance');
			}

			agent.createConnection = agent[kCacheableLookupCreateConnection];

			delete agent[kCacheableLookupCreateConnection];
			delete agent[kCacheableLookupInstance];
		}
	}

	updateInterfaceInfo() {
		const {_iface} = this;

		this._iface = getIfaceInfo();

		if ((_iface.has4 && !this._iface.has4) || (_iface.has6 && !this._iface.has6)) {
			this._cache.clear();
		}
	}

	clear(hostname) {
		if (hostname) {
			this._cache.delete(hostname);
			return;
		}

		this._cache.clear();
	}
}

module.exports = CacheableLookup;
module.exports.default = CacheableLookup;


/***/ }),
/* 765 */
/***/ ((module) => {

"use strict";
module.exports = require("dns");;

/***/ }),
/* 766 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(119);
const urlLib = __webpack_require__(247);
const normalizeUrl = __webpack_require__(767);
const getStream = __webpack_require__(768);
const CachePolicy = __webpack_require__(773);
const Response = __webpack_require__(774);
const lowercaseKeys = __webpack_require__(775);
const cloneResponse = __webpack_require__(776);
const Keyv = __webpack_require__(778);

class CacheableRequest {
	constructor(request, cacheAdapter) {
		if (typeof request !== 'function') {
			throw new TypeError('Parameter `request` must be a function');
		}

		this.cache = new Keyv({
			uri: typeof cacheAdapter === 'string' && cacheAdapter,
			store: typeof cacheAdapter !== 'string' && cacheAdapter,
			namespace: 'cacheable-request'
		});

		return this.createCacheableRequest(request);
	}

	createCacheableRequest(request) {
		return (opts, cb) => {
			let url;
			if (typeof opts === 'string') {
				url = normalizeUrlObject(urlLib.parse(opts));
				opts = {};
			} else if (opts instanceof urlLib.URL) {
				url = normalizeUrlObject(urlLib.parse(opts.toString()));
				opts = {};
			} else {
				const [pathname, ...searchParts] = (opts.path || '').split('?');
				const search = searchParts.length > 0 ?
					`?${searchParts.join('?')}` :
					'';
				url = normalizeUrlObject({ ...opts, pathname, search });
			}

			opts = {
				headers: {},
				method: 'GET',
				cache: true,
				strictTtl: false,
				automaticFailover: false,
				...opts,
				...urlObjectToRequestOptions(url)
			};
			opts.headers = lowercaseKeys(opts.headers);

			const ee = new EventEmitter();
			const normalizedUrlString = normalizeUrl(
				urlLib.format(url),
				{
					stripWWW: false,
					removeTrailingSlash: false,
					stripAuthentication: false
				}
			);
			const key = `${opts.method}:${normalizedUrlString}`;
			let revalidate = false;
			let madeRequest = false;

			const makeRequest = opts => {
				madeRequest = true;
				let requestErrored = false;
				let requestErrorCallback;

				const requestErrorPromise = new Promise(resolve => {
					requestErrorCallback = () => {
						if (!requestErrored) {
							requestErrored = true;
							resolve();
						}
					};
				});

				const handler = response => {
					if (revalidate && !opts.forceRefresh) {
						response.status = response.statusCode;
						const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);
						if (!revalidatedPolicy.modified) {
							const headers = revalidatedPolicy.policy.responseHeaders();
							response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);
							response.cachePolicy = revalidatedPolicy.policy;
							response.fromCache = true;
						}
					}

					if (!response.fromCache) {
						response.cachePolicy = new CachePolicy(opts, response, opts);
						response.fromCache = false;
					}

					let clonedResponse;
					if (opts.cache && response.cachePolicy.storable()) {
						clonedResponse = cloneResponse(response);

						(async () => {
							try {
								const bodyPromise = getStream.buffer(response);

								await Promise.race([
									requestErrorPromise,
									new Promise(resolve => response.once('end', resolve))
								]);

								if (requestErrored) {
									return;
								}

								const body = await bodyPromise;

								const value = {
									cachePolicy: response.cachePolicy.toObject(),
									url: response.url,
									statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
									body
								};

								let ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;
								if (opts.maxTtl) {
									ttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;
								}

								await this.cache.set(key, value, ttl);
							} catch (error) {
								ee.emit('error', new CacheableRequest.CacheError(error));
							}
						})();
					} else if (opts.cache && revalidate) {
						(async () => {
							try {
								await this.cache.delete(key);
							} catch (error) {
								ee.emit('error', new CacheableRequest.CacheError(error));
							}
						})();
					}

					ee.emit('response', clonedResponse || response);
					if (typeof cb === 'function') {
						cb(clonedResponse || response);
					}
				};

				try {
					const req = request(opts, handler);
					req.once('error', requestErrorCallback);
					req.once('abort', requestErrorCallback);
					ee.emit('request', req);
				} catch (error) {
					ee.emit('error', new CacheableRequest.RequestError(error));
				}
			};

			(async () => {
				const get = async opts => {
					await Promise.resolve();

					const cacheEntry = opts.cache ? await this.cache.get(key) : undefined;
					if (typeof cacheEntry === 'undefined') {
						return makeRequest(opts);
					}

					const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
					if (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) {
						const headers = policy.responseHeaders();
						const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
						response.cachePolicy = policy;
						response.fromCache = true;

						ee.emit('response', response);
						if (typeof cb === 'function') {
							cb(response);
						}
					} else {
						revalidate = cacheEntry;
						opts.headers = policy.revalidationHeaders(opts);
						makeRequest(opts);
					}
				};

				const errorHandler = error => ee.emit('error', new CacheableRequest.CacheError(error));
				this.cache.once('error', errorHandler);
				ee.on('response', () => this.cache.removeListener('error', errorHandler));

				try {
					await get(opts);
				} catch (error) {
					if (opts.automaticFailover && !madeRequest) {
						makeRequest(opts);
					}

					ee.emit('error', new CacheableRequest.CacheError(error));
				}
			})();

			return ee;
		};
	}
}

function urlObjectToRequestOptions(url) {
	const options = { ...url };
	options.path = `${url.pathname || '/'}${url.search || ''}`;
	delete options.pathname;
	delete options.search;
	return options;
}

function normalizeUrlObject(url) {
	// If url was parsed by url.parse or new URL:
	// - hostname will be set
	// - host will be hostname[:port]
	// - port will be set if it was explicit in the parsed string
	// Otherwise, url was from request options:
	// - hostname or host may be set
	// - host shall not have port encoded
	return {
		protocol: url.protocol,
		auth: url.auth,
		hostname: url.hostname || url.host || 'localhost',
		port: url.port,
		pathname: url.pathname,
		search: url.search
	};
}

CacheableRequest.RequestError = class extends Error {
	constructor(error) {
		super(error.message);
		this.name = 'RequestError';
		Object.assign(this, error);
	}
};

CacheableRequest.CacheError = class extends Error {
	constructor(error) {
		super(error.message);
		this.name = 'CacheError';
		Object.assign(this, error);
	}
};

module.exports = CacheableRequest;


/***/ }),
/* 767 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Use the `URL` global when targeting Node.js 10
const URLParser = typeof URL === 'undefined' ? __webpack_require__(247).URL : URL;

// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
const DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';
const DATA_URL_DEFAULT_CHARSET = 'us-ascii';

const testParameter = (name, filters) => {
	return filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name);
};

const normalizeDataURL = (urlString, {stripHash}) => {
	const parts = urlString.match(/^data:(.*?),(.*?)(?:#(.*))?$/);

	if (!parts) {
		throw new Error(`Invalid URL: ${urlString}`);
	}

	const mediaType = parts[1].split(';');
	const body = parts[2];
	const hash = stripHash ? '' : parts[3];

	let base64 = false;

	if (mediaType[mediaType.length - 1] === 'base64') {
		mediaType.pop();
		base64 = true;
	}

	// Lowercase MIME type
	const mimeType = (mediaType.shift() || '').toLowerCase();
	const attributes = mediaType
		.map(attribute => {
			let [key, value = ''] = attribute.split('=').map(string => string.trim());

			// Lowercase `charset`
			if (key === 'charset') {
				value = value.toLowerCase();

				if (value === DATA_URL_DEFAULT_CHARSET) {
					return '';
				}
			}

			return `${key}${value ? `=${value}` : ''}`;
		})
		.filter(Boolean);

	const normalizedMediaType = [
		...attributes
	];

	if (base64) {
		normalizedMediaType.push('base64');
	}

	if (normalizedMediaType.length !== 0 || (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)) {
		normalizedMediaType.unshift(mimeType);
	}

	return `data:${normalizedMediaType.join(';')},${base64 ? body.trim() : body}${hash ? `#${hash}` : ''}`;
};

const normalizeUrl = (urlString, options) => {
	options = {
		defaultProtocol: 'http:',
		normalizeProtocol: true,
		forceHttp: false,
		forceHttps: false,
		stripAuthentication: true,
		stripHash: false,
		stripWWW: true,
		removeQueryParameters: [/^utm_\w+/i],
		removeTrailingSlash: true,
		removeDirectoryIndex: false,
		sortQueryParameters: true,
		...options
	};

	// TODO: Remove this at some point in the future
	if (Reflect.has(options, 'normalizeHttps')) {
		throw new Error('options.normalizeHttps is renamed to options.forceHttp');
	}

	if (Reflect.has(options, 'normalizeHttp')) {
		throw new Error('options.normalizeHttp is renamed to options.forceHttps');
	}

	if (Reflect.has(options, 'stripFragment')) {
		throw new Error('options.stripFragment is renamed to options.stripHash');
	}

	urlString = urlString.trim();

	// Data URL
	if (/^data:/i.test(urlString)) {
		return normalizeDataURL(urlString, options);
	}

	const hasRelativeProtocol = urlString.startsWith('//');
	const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);

	// Prepend protocol
	if (!isRelativeUrl) {
		urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
	}

	const urlObj = new URLParser(urlString);

	if (options.forceHttp && options.forceHttps) {
		throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');
	}

	if (options.forceHttp && urlObj.protocol === 'https:') {
		urlObj.protocol = 'http:';
	}

	if (options.forceHttps && urlObj.protocol === 'http:') {
		urlObj.protocol = 'https:';
	}

	// Remove auth
	if (options.stripAuthentication) {
		urlObj.username = '';
		urlObj.password = '';
	}

	// Remove hash
	if (options.stripHash) {
		urlObj.hash = '';
	}

	// Remove duplicate slashes if not preceded by a protocol
	if (urlObj.pathname) {
		// TODO: Use the following instead when targeting Node.js 10
		// `urlObj.pathname = urlObj.pathname.replace(/(?<!https?:)\/{2,}/g, '/');`
		urlObj.pathname = urlObj.pathname.replace(/((?!:).|^)\/{2,}/g, (_, p1) => {
			if (/^(?!\/)/g.test(p1)) {
				return `${p1}/`;
			}

			return '/';
		});
	}

	// Decode URI octets
	if (urlObj.pathname) {
		urlObj.pathname = decodeURI(urlObj.pathname);
	}

	// Remove directory index
	if (options.removeDirectoryIndex === true) {
		options.removeDirectoryIndex = [/^index\.[a-z]+$/];
	}

	if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
		let pathComponents = urlObj.pathname.split('/');
		const lastComponent = pathComponents[pathComponents.length - 1];

		if (testParameter(lastComponent, options.removeDirectoryIndex)) {
			pathComponents = pathComponents.slice(0, pathComponents.length - 1);
			urlObj.pathname = pathComponents.slice(1).join('/') + '/';
		}
	}

	if (urlObj.hostname) {
		// Remove trailing dot
		urlObj.hostname = urlObj.hostname.replace(/\.$/, '');

		// Remove `www.`
		if (options.stripWWW && /^www\.([a-z\-\d]{2,63})\.([a-z.]{2,5})$/.test(urlObj.hostname)) {
			// Each label should be max 63 at length (min: 2).
			// The extension should be max 5 at length (min: 2).
			// Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
			urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
		}
	}

	// Remove query unwanted parameters
	if (Array.isArray(options.removeQueryParameters)) {
		for (const key of [...urlObj.searchParams.keys()]) {
			if (testParameter(key, options.removeQueryParameters)) {
				urlObj.searchParams.delete(key);
			}
		}
	}

	// Sort query parameters
	if (options.sortQueryParameters) {
		urlObj.searchParams.sort();
	}

	if (options.removeTrailingSlash) {
		urlObj.pathname = urlObj.pathname.replace(/\/$/, '');
	}

	// Take advantage of many of the Node `url` normalizations
	urlString = urlObj.toString();

	// Remove ending `/`
	if ((options.removeTrailingSlash || urlObj.pathname === '/') && urlObj.hash === '') {
		urlString = urlString.replace(/\/$/, '');
	}

	// Restore relative protocol, if applicable
	if (hasRelativeProtocol && !options.normalizeProtocol) {
		urlString = urlString.replace(/^http:\/\//, '//');
	}

	// Remove http/https
	if (options.stripProtocol) {
		urlString = urlString.replace(/^(?:https?:)?\/\//, '');
	}

	return urlString;
};

module.exports = normalizeUrl;
// TODO: Remove this for the next major release
module.exports.default = normalizeUrl;


/***/ }),
/* 768 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const pump = __webpack_require__(769);
const bufferStream = __webpack_require__(772);

class MaxBufferError extends Error {
	constructor() {
		super('maxBuffer exceeded');
		this.name = 'MaxBufferError';
	}
}

async function getStream(inputStream, options) {
	if (!inputStream) {
		return Promise.reject(new Error('Expected a stream'));
	}

	options = {
		maxBuffer: Infinity,
		...options
	};

	const {maxBuffer} = options;

	let stream;
	await new Promise((resolve, reject) => {
		const rejectPromise = error => {
			if (error) { // A null check
				error.bufferedData = stream.getBufferedValue();
			}

			reject(error);
		};

		stream = pump(inputStream, bufferStream(options), error => {
			if (error) {
				rejectPromise(error);
				return;
			}

			resolve();
		});

		stream.on('data', () => {
			if (stream.getBufferedLength() > maxBuffer) {
				rejectPromise(new MaxBufferError());
			}
		});
	});

	return stream.getBufferedValue();
}

module.exports = getStream;
// TODO: Remove this for the next major release
module.exports.default = getStream;
module.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});
module.exports.array = (stream, options) => getStream(stream, {...options, array: true});
module.exports.MaxBufferError = MaxBufferError;


/***/ }),
/* 769 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(770)
var eos = __webpack_require__(771)
var fs = __webpack_require__(8) // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}
var ancient = /^v?\.0/.test(process.version)

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump


/***/ }),
/* 770 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(410)
module.exports = wrappy(once)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}


/***/ }),
/* 771 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(770);

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback();
	};

	var onend = function() {
		readable = false;
		if (!writable) callback();
	};

	var onexit = function(exitCode) {
		callback(exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', callback);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', callback);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;

/***/ }),
/* 772 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {PassThrough: PassThroughStream} = __webpack_require__(76);

module.exports = options => {
	options = {...options};

	const {array} = options;
	let {encoding} = options;
	const isBuffer = encoding === 'buffer';
	let objectMode = false;

	if (array) {
		objectMode = !(encoding || isBuffer);
	} else {
		encoding = encoding || 'utf8';
	}

	if (isBuffer) {
		encoding = null;
	}

	const stream = new PassThroughStream({objectMode});

	if (encoding) {
		stream.setEncoding(encoding);
	}

	let length = 0;
	const chunks = [];

	stream.on('data', chunk => {
		chunks.push(chunk);

		if (objectMode) {
			length = chunks.length;
		} else {
			length += chunk.length;
		}
	});

	stream.getBufferedValue = () => {
		if (array) {
			return chunks;
		}

		return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
	};

	stream.getBufferedLength = () => length;

	return stream;
};


/***/ }),
/* 773 */
/***/ ((module) => {

"use strict";

// rfc7231 6.1
const statusCodeCacheableByDefault = [200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501];

// This implementation does not understand partial responses (206)
const understoodStatuses = [200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501];

const hopByHopHeaders = {
    'date': true, // included, because we add Age update Date
    'connection':true, 'keep-alive':true, 'proxy-authenticate':true, 'proxy-authorization':true, 'te':true, 'trailer':true, 'transfer-encoding':true, 'upgrade':true
};
const excludedFromRevalidationUpdate = {
    // Since the old body is reused, it doesn't make sense to change properties of the body
    'content-length': true, 'content-encoding': true, 'transfer-encoding': true,
    'content-range': true,
};

function parseCacheControl(header) {
    const cc = {};
    if (!header) return cc;

    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),
    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale
    const parts = header.trim().split(/\s*,\s*/); // TODO: lame parsing
    for(const part of parts) {
        const [k,v] = part.split(/\s*=\s*/, 2);
        cc[k] = (v === undefined) ? true : v.replace(/^"|"$/g, ''); // TODO: lame unquoting
    }

    return cc;
}

function formatCacheControl(cc) {
    let parts = [];
    for(const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + '=' + v);
    }
    if (!parts.length) {
        return undefined;
    }
    return parts.join(', ');
}

module.exports = class CachePolicy {
    constructor(req, res, {shared, cacheHeuristic, immutableMinTimeToLive, ignoreCargoCult, trustServerDate, _fromObject} = {}) {
        if (_fromObject) {
            this._fromObject(_fromObject);
            return;
        }

        if (!res || !res.headers) {
            throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);

        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._trustServerDate = undefined !== trustServerDate ? trustServerDate : true;
        this._cacheHeuristic = undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE
        this._immutableMinTtl = undefined !== immutableMinTimeToLive ? immutableMinTimeToLive : 24*3600*1000;

        this._status = 'status' in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers['cache-control']);
        this._method = 'method' in req ? req.method : 'GET';
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used
        this._reqcc = parseCacheControl(req.headers['cache-control']);

        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,
        // so there's no point stricly adhering to the blindly copy&pasted directives.
        if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
            delete this._rescc['pre-check'];
            delete this._rescc['post-check'];
            delete this._rescc['no-cache'];
            delete this._rescc['no-store'];
            delete this._rescc['must-revalidate'];
            this._resHeaders = Object.assign({}, this._resHeaders, {'cache-control': formatCacheControl(this._rescc)});
            delete this._resHeaders.expires;
            delete this._resHeaders.pragma;
        }

        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive
        // as having the same effect as if "Cache-Control: no-cache" were present (see Section 5.2.1).
        if (!res.headers['cache-control'] && /no-cache/.test(res.headers.pragma)) {
            this._rescc['no-cache'] = true;
        }
    }

    now() {
        return Date.now();
    }

    storable() {
        // The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.
        return !!(!this._reqcc['no-store'] &&
            // A cache MUST NOT store a response to any request, unless:
            // The request method is understood by the cache and defined as being cacheable, and
            ('GET' === this._method || 'HEAD' === this._method || ('POST' === this._method && this._hasExplicitExpiration())) &&
            // the response status code is understood by the cache, and
            understoodStatuses.indexOf(this._status) !== -1 &&
            // the "no-store" cache directive does not appear in request or response header fields, and
            !this._rescc['no-store'] &&
            // the "private" response directive does not appear in the response, if the cache is shared, and
            (!this._isShared || !this._rescc.private) &&
            // the Authorization header field does not appear in the request, if the cache is shared,
            (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) &&
            // the response either:
            (
                // contains an Expires header field, or
                this._resHeaders.expires ||
                // contains a max-age response directive, or
                // contains a s-maxage response directive and the cache is shared, or
                // contains a public response directive.
                this._rescc.public || this._rescc['max-age'] || this._rescc['s-maxage'] ||
                // has a status code that is defined as cacheable by default
                statusCodeCacheableByDefault.indexOf(this._status) !== -1
            ));
    }

    _hasExplicitExpiration() {
        // 4.2.1 Calculating Freshness Lifetime
        return (this._isShared && this._rescc['s-maxage']) ||
            this._rescc['max-age'] ||
            this._resHeaders.expires;
    }

    _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
            throw Error("Request headers missing");
        }
    }

    satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);

        // When presented with a request, a cache MUST NOT reuse a stored response, unless:
        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,
        // unless the stored response is successfully validated (Section 4.3), and
        const requestCC = parseCacheControl(req.headers['cache-control']);
        if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {
            return false;
        }

        if (requestCC['max-age'] && this.age() > requestCC['max-age']) {
            return false;
        }

        if (requestCC['min-fresh'] && this.timeToLive() < 1000*requestCC['min-fresh']) {
            return false;
        }

        // the stored response is either:
        // fresh, or allowed to be served stale
        if (this.stale()) {
            const allowsStale = requestCC['max-stale'] && !this._rescc['must-revalidate'] && (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());
            if (!allowsStale) {
                return false;
            }
        }

        return this._requestMatches(req, false);
    }

    _requestMatches(req, allowHeadMethod) {
        // The presented effective request URI and that of the stored response match, and
        return (!this._url || this._url === req.url) &&
            (this._host === req.headers.host) &&
            // the request method associated with the stored response allows it to be used for the presented request, and
            (!req.method || this._method === req.method || (allowHeadMethod && 'HEAD' === req.method)) &&
            // selecting header fields nominated by the stored response (if any) match those presented, and
            this._varyMatches(req);
    }

    _allowsStoringAuthenticated() {
        //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.
        return this._rescc['must-revalidate'] || this._rescc.public || this._rescc['s-maxage'];
    }

    _varyMatches(req) {
        if (!this._resHeaders.vary) {
            return true;
        }

        // A Vary header field-value of "*" always fails to match
        if (this._resHeaders.vary === '*') {
            return false;
        }

        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for(const name of fields) {
            if (req.headers[name] !== this._reqHeaders[name]) return false;
        }
        return true;
    }

    _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for(const name in inHeaders) {
            if (hopByHopHeaders[name]) continue;
            headers[name] = inHeaders[name];
        }
        // 9.1.  Connection
        if (inHeaders.connection) {
            const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
            for(const name of tokens) {
                delete headers[name];
            }
        }
        if (headers.warning) {
            const warnings = headers.warning.split(/,/).filter(warning => {
                return !/^\s*1[0-9][0-9]/.test(warning);
            });
            if (!warnings.length) {
                delete headers.warning;
            } else {
                headers.warning = warnings.join(',').trim();
            }
        }
        return headers;
    }

    responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();

        // A cache SHOULD generate 113 warning if it heuristically chose a freshness
        // lifetime greater than 24 hours and the response's age is greater than 24 hours.
        if (age > 3600*24 && !this._hasExplicitExpiration() && this.maxAge() > 3600*24) {
            headers.warning = (headers.warning ? `${headers.warning}, ` : '') + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
    }

    /**
     * Value of the Date response header or current time if Date was demed invalid
     * @return timestamp
     */
    date() {
        if (this._trustServerDate) {
            return this._serverDate();
        }
        return this._responseTime;
    }

    _serverDate() {
        const dateValue = Date.parse(this._resHeaders.date)
        if (isFinite(dateValue)) {
            const maxClockDrift = 8*3600*1000;
            const clockDrift = Math.abs(this._responseTime - dateValue);
            if (clockDrift < maxClockDrift) {
                return dateValue;
            }
        }
        return this._responseTime;
    }

    /**
     * Value of the Age header, in seconds, updated for the current time.
     * May be fractional.
     *
     * @return Number
     */
    age() {
        let age = Math.max(0, (this._responseTime - this.date())/1000);
        if (this._resHeaders.age) {
            let ageValue = this._ageValue();
            if (ageValue > age) age = ageValue;
        }

        const residentTime = (this.now() - this._responseTime)/1000;
        return age + residentTime;
    }

    _ageValue() {
        const ageValue = parseInt(this._resHeaders.age);
        return isFinite(ageValue) ? ageValue : 0;
    }

    /**
     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
     *
     * For an up-to-date value, see `timeToLive()`.
     *
     * @return Number
     */
    maxAge() {
        if (!this.storable() || this._rescc['no-cache']) {
            return 0;
        }

        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default
        // so this implementation requires explicit opt-in via public header
        if (this._isShared && (this._resHeaders['set-cookie'] && !this._rescc.public && !this._rescc.immutable)) {
            return 0;
        }

        if (this._resHeaders.vary === '*') {
            return 0;
        }

        if (this._isShared) {
            if (this._rescc['proxy-revalidate']) {
                return 0;
            }
            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.
            if (this._rescc['s-maxage']) {
                return parseInt(this._rescc['s-maxage'], 10);
            }
        }

        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.
        if (this._rescc['max-age']) {
            return parseInt(this._rescc['max-age'], 10);
        }

        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;

        const dateValue = this._serverDate();
        if (this._resHeaders.expires) {
            const expires = Date.parse(this._resHeaders.expires);
            // A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
            if (Number.isNaN(expires) || expires < dateValue) {
                return 0;
            }
            return Math.max(defaultMinTtl, (expires - dateValue)/1000);
        }

        if (this._resHeaders['last-modified']) {
            const lastModified = Date.parse(this._resHeaders['last-modified']);
            if (isFinite(lastModified) && dateValue > lastModified) {
                return Math.max(defaultMinTtl, (dateValue - lastModified)/1000 * this._cacheHeuristic);
            }
        }

        return defaultMinTtl;
    }

    timeToLive() {
        return Math.max(0, this.maxAge() - this.age())*1000;
    }

    stale() {
        return this.maxAge() <= this.age();
    }

    static fromObject(obj) {
        return new this(undefined, undefined, {_fromObject:obj});
    }

    _fromObject(obj) {
        if (this._responseTime) throw Error("Reinitialized");
        if (!obj || obj.v !== 1) throw Error("Invalid serialization");

        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24*3600*1000;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
    }

    toObject() {
        return {
            v:1,
            t: this._responseTime,
            sh: this._isShared,
            ch: this._cacheHeuristic,
            imm: this._immutableMinTtl,
            st: this._status,
            resh: this._resHeaders,
            rescc: this._rescc,
            m: this._method,
            u: this._url,
            h: this._host,
            a: this._noAuthorization,
            reqh: this._reqHeaders,
            reqcc: this._reqcc,
        };
    }

    /**
     * Headers for sending to the origin server to revalidate stale response.
     * Allows server to return 304 to allow reuse of the previous response.
     *
     * Hop by hop headers are always stripped.
     * Revalidation headers may be added or removed, depending on request.
     */
    revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);

        // This implementation does not understand range requests
        delete headers['if-range'];

        if (!this._requestMatches(incomingReq, true) || !this.storable()) { // revalidation allowed via HEAD
            // not for the same resource, or wasn't allowed to be cached anyway
            delete headers['if-none-match'];
            delete headers['if-modified-since'];
            return headers;
        }

        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */
        if (this._resHeaders.etag) {
            headers['if-none-match'] = headers['if-none-match'] ? `${headers['if-none-match']}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }

        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.
        const forbidsWeakValidators = headers['accept-ranges'] || headers['if-match'] || headers['if-unmodified-since'] || (this._method && this._method != 'GET');

        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
        Note: This implementation does not understand partial responses (206) */
        if (forbidsWeakValidators) {
            delete headers['if-modified-since'];

            if (headers['if-none-match']) {
                const etags = headers['if-none-match'].split(/,/).filter(etag => {
                    return !/^\s*W\//.test(etag);
                });
                if (!etags.length) {
                    delete headers['if-none-match'];
                } else {
                    headers['if-none-match'] = etags.join(',').trim();
                }
            }
        } else if (this._resHeaders['last-modified'] && !headers['if-modified-since']) {
            headers['if-modified-since'] = this._resHeaders['last-modified'];
        }

        return headers;
    }

    /**
     * Creates new CachePolicy with information combined from the previews response,
     * and the new revalidation response.
     *
     * Returns {policy, modified} where modified is a boolean indicating
     * whether the response body has been modified, and old cached body can't be used.
     *
     * @return {Object} {policy: CachePolicy, modified: Boolean}
     */
    revalidatedPolicy(request, response) {
        this._assertRequestHasHeaders(request);
        if (!response || !response.headers) {
            throw Error("Response headers missing");
        }

        // These aren't going to be supported exactly, since one CachePolicy object
        // doesn't know about all the other cached objects.
        let matches = false;
        if (response.status !== undefined && response.status != 304) {
            matches = false;
        } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
            // "All of the stored responses with the same strong validator are selected.
            // If none of the stored responses contain the same strong validator,
            // then the cache MUST NOT use the new response to update any stored responses."
            matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//,'') === response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
            // "If the new response contains a weak validator and that validator corresponds
            // to one of the cache's stored responses,
            // then the most recent of those matching stored responses is selected for update."
            matches = this._resHeaders.etag.replace(/^\s*W\//,'') === response.headers.etag.replace(/^\s*W\//,'');
        } else if (this._resHeaders['last-modified']) {
            matches = this._resHeaders['last-modified'] === response.headers['last-modified'];
        } else {
            // If the new response does not include any form of validator (such as in the case where
            // a client generates an If-Modified-Since request from a source other than the Last-Modified
            // response header field), and there is only one stored response, and that stored response also
            // lacks a validator, then that stored response is selected for update.
            if (!this._resHeaders.etag && !this._resHeaders['last-modified'] &&
                !response.headers.etag && !response.headers['last-modified']) {
                matches = true;
            }
        }

        if (!matches) {
            return {
                policy: new this.constructor(request, response),
                // Client receiving 304 without body, even if it's invalid/mismatched has no option
                // but to reuse a cached body. We don't have a good way to tell clients to do
                // error recovery in such case.
                modified: response.status != 304,
                matches: false,
            }
        }

        // use other header fields provided in the 304 (Not Modified) response to replace all instances
        // of the corresponding header fields in the stored response.
        const headers = {};
        for(const k in this._resHeaders) {
            headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        }

        const newResponse = Object.assign({}, response, {
            status: this._status,
            method: this._method,
            headers,
        });
        return {
            policy: new this.constructor(request, newResponse, {shared: this._isShared, cacheHeuristic: this._cacheHeuristic, immutableMinTimeToLive: this._immutableMinTtl, trustServerDate: this._trustServerDate}),
            modified: false,
            matches: true,
        };
    }
};


/***/ }),
/* 774 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Readable = __webpack_require__(76).Readable;
const lowercaseKeys = __webpack_require__(775);

class Response extends Readable {
	constructor(statusCode, headers, body, url) {
		if (typeof statusCode !== 'number') {
			throw new TypeError('Argument `statusCode` should be a number');
		}
		if (typeof headers !== 'object') {
			throw new TypeError('Argument `headers` should be an object');
		}
		if (!(body instanceof Buffer)) {
			throw new TypeError('Argument `body` should be a buffer');
		}
		if (typeof url !== 'string') {
			throw new TypeError('Argument `url` should be a string');
		}

		super();
		this.statusCode = statusCode;
		this.headers = lowercaseKeys(headers);
		this.body = body;
		this.url = url;
	}

	_read() {
		this.push(this.body);
		this.push(null);
	}
}

module.exports = Response;


/***/ }),
/* 775 */
/***/ ((module) => {

"use strict";

module.exports = object => {
	const result = {};

	for (const [key, value] of Object.entries(object)) {
		result[key.toLowerCase()] = value;
	}

	return result;
};


/***/ }),
/* 776 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const PassThrough = __webpack_require__(76).PassThrough;
const mimicResponse = __webpack_require__(777);

const cloneResponse = response => {
	if (!(response && response.pipe)) {
		throw new TypeError('Parameter `response` must be a response stream.');
	}

	const clone = new PassThrough();
	mimicResponse(response, clone);

	return response.pipe(clone);
};

module.exports = cloneResponse;


/***/ }),
/* 777 */
/***/ ((module) => {

"use strict";


// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const knownProps = [
	'destroy',
	'setTimeout',
	'socket',
	'headers',
	'trailers',
	'rawHeaders',
	'statusCode',
	'httpVersion',
	'httpVersionMinor',
	'httpVersionMajor',
	'rawTrailers',
	'statusMessage'
];

module.exports = (fromStream, toStream) => {
	const fromProps = new Set(Object.keys(fromStream).concat(knownProps));

	for (const prop of fromProps) {
		// Don't overwrite existing properties
		if (prop in toStream) {
			continue;
		}

		toStream[prop] = typeof fromStream[prop] === 'function' ? fromStream[prop].bind(fromStream) : fromStream[prop];
	}
};


/***/ }),
/* 778 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(119);
const JSONB = __webpack_require__(779);

const loadStore = opts => {
	const adapters = {
		redis: '@keyv/redis',
		mongodb: '@keyv/mongo',
		mongo: '@keyv/mongo',
		sqlite: '@keyv/sqlite',
		postgresql: '@keyv/postgres',
		postgres: '@keyv/postgres',
		mysql: '@keyv/mysql'
	};
	if (opts.adapter || opts.uri) {
		const adapter = opts.adapter || /^[^:]*/.exec(opts.uri)[0];
		return new (__webpack_require__(780)(adapters[adapter]))(opts);
	}

	return new Map();
};

class Keyv extends EventEmitter {
	constructor(uri, opts) {
		super();
		this.opts = Object.assign(
			{
				namespace: 'keyv',
				serialize: JSONB.stringify,
				deserialize: JSONB.parse
			},
			(typeof uri === 'string') ? { uri } : uri,
			opts
		);

		if (!this.opts.store) {
			const adapterOpts = Object.assign({}, this.opts);
			this.opts.store = loadStore(adapterOpts);
		}

		if (typeof this.opts.store.on === 'function') {
			this.opts.store.on('error', err => this.emit('error', err));
		}

		this.opts.store.namespace = this.opts.namespace;
	}

	_getKeyPrefix(key) {
		return `${this.opts.namespace}:${key}`;
	}

	get(key, opts) {
		key = this._getKeyPrefix(key);
		const { store } = this.opts;
		return Promise.resolve()
			.then(() => store.get(key))
			.then(data => {
				return (typeof data === 'string') ? this.opts.deserialize(data) : data;
			})
			.then(data => {
				if (data === undefined) {
					return undefined;
				}

				if (typeof data.expires === 'number' && Date.now() > data.expires) {
					this.delete(key);
					return undefined;
				}

				return (opts && opts.raw) ? data : data.value;
			});
	}

	set(key, value, ttl) {
		key = this._getKeyPrefix(key);
		if (typeof ttl === 'undefined') {
			ttl = this.opts.ttl;
		}

		if (ttl === 0) {
			ttl = undefined;
		}

		const { store } = this.opts;

		return Promise.resolve()
			.then(() => {
				const expires = (typeof ttl === 'number') ? (Date.now() + ttl) : null;
				value = { value, expires };
				return this.opts.serialize(value);
			})
			.then(value => store.set(key, value, ttl))
			.then(() => true);
	}

	delete(key) {
		key = this._getKeyPrefix(key);
		const { store } = this.opts;
		return Promise.resolve()
			.then(() => store.delete(key));
	}

	clear() {
		const { store } = this.opts;
		return Promise.resolve()
			.then(() => store.clear());
	}
}

module.exports = Keyv;


/***/ }),
/* 779 */
/***/ ((__unused_webpack_module, exports) => {

//TODO: handle reviver/dehydrate function like normal
//and handle indentation, like normal.
//if anyone needs this... please send pull request.

exports.stringify = function stringify (o) {
  if('undefined' == typeof o) return o

  if(o && Buffer.isBuffer(o))
    return JSON.stringify(':base64:' + o.toString('base64'))

  if(o && o.toJSON)
    o =  o.toJSON()

  if(o && 'object' === typeof o) {
    var s = ''
    var array = Array.isArray(o)
    s = array ? '[' : '{'
    var first = true

    for(var k in o) {
      var ignore = 'function' == typeof o[k] || (!array && 'undefined' === typeof o[k])
      if(Object.hasOwnProperty.call(o, k) && !ignore) {
        if(!first)
          s += ','
        first = false
        if (array) {
          if(o[k] == undefined)
            s += 'null'
          else
            s += stringify(o[k])
        } else if (o[k] !== void(0)) {
          s += stringify(k) + ':' + stringify(o[k])
        }
      }
    }

    s += array ? ']' : '}'

    return s
  } else if ('string' === typeof o) {
    return JSON.stringify(/^:/.test(o) ? ':' + o : o)
  } else if ('undefined' === typeof o) {
    return 'null';
  } else
    return JSON.stringify(o)
}

exports.parse = function (s) {
  return JSON.parse(s, function (key, value) {
    if('string' === typeof value) {
      if(/^:base64:/.test(value))
        return Buffer.from(value.substring(8), 'base64')
      else
        return /^:/.test(value) ? value.substring(1) : value 
    }
    return value
  })
}


/***/ }),
/* 780 */
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => [];
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 780;
module.exports = webpackEmptyContext;

/***/ }),
/* 781 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {Transform, PassThrough} = __webpack_require__(76);
const zlib = __webpack_require__(164);
const mimicResponse = __webpack_require__(782);

module.exports = response => {
	const contentEncoding = (response.headers['content-encoding'] || '').toLowerCase();

	if (!['gzip', 'deflate', 'br'].includes(contentEncoding)) {
		return response;
	}

	// TODO: Remove this when targeting Node.js 12.
	const isBrotli = contentEncoding === 'br';
	if (isBrotli && typeof zlib.createBrotliDecompress !== 'function') {
		response.destroy(new Error('Brotli is not supported on Node.js < 12'));
		return response;
	}

	let isEmpty = true;

	const checker = new Transform({
		transform(data, _encoding, callback) {
			isEmpty = false;

			callback(null, data);
		},

		flush(callback) {
			callback();
		}
	});

	const finalStream = new PassThrough({
		autoDestroy: false,
		destroy(error, callback) {
			response.destroy();

			callback(error);
		}
	});

	const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();

	decompressStream.once('error', error => {
		if (isEmpty && !response.readable) {
			finalStream.end();
			return;
		}

		finalStream.destroy(error);
	});

	mimicResponse(response, finalStream);
	response.pipe(checker).pipe(decompressStream).pipe(finalStream);

	return finalStream;
};


/***/ }),
/* 782 */
/***/ ((module) => {

"use strict";


// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const knownProperties = [
	'aborted',
	'complete',
	'headers',
	'httpVersion',
	'httpVersionMinor',
	'httpVersionMajor',
	'method',
	'rawHeaders',
	'rawTrailers',
	'setTimeout',
	'socket',
	'statusCode',
	'statusMessage',
	'trailers',
	'url'
];

module.exports = (fromStream, toStream) => {
	if (toStream._readableState.autoDestroy) {
		throw new Error('The second stream must have the `autoDestroy` option set to `false`');
	}

	const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));

	const properties = {};

	for (const property of fromProperties) {
		// Don't overwrite existing properties.
		if (property in toStream) {
			continue;
		}

		properties[property] = {
			get() {
				const value = fromStream[property];
				const isFunction = typeof value === 'function';

				return isFunction ? value.bind(fromStream) : value;
			},
			set(value) {
				fromStream[property] = value;
			},
			enumerable: true,
			configurable: false
		};
	}

	Object.defineProperties(toStream, properties);

	fromStream.once('aborted', () => {
		toStream.destroy();

		toStream.emit('aborted');
	});

	fromStream.once('close', () => {
		if (fromStream.complete) {
			if (toStream.readable) {
				toStream.once('end', () => {
					toStream.emit('close');
				});
			} else {
				toStream.emit('close');
			}
		} else {
			toStream.emit('close');
		}
	});

	return toStream;
};


/***/ }),
/* 783 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const http2 = __webpack_require__(784);
const agent = __webpack_require__(785);
const ClientRequest = __webpack_require__(787);
const IncomingMessage = __webpack_require__(788);
const auto = __webpack_require__(793);

const request = (url, options, callback) => {
	return new ClientRequest(url, options, callback);
};

const get = (url, options, callback) => {
	// eslint-disable-next-line unicorn/prevent-abbreviations
	const req = new ClientRequest(url, options, callback);
	req.end();

	return req;
};

module.exports = {
	...http2,
	ClientRequest,
	IncomingMessage,
	...agent,
	request,
	get,
	auto
};


/***/ }),
/* 784 */
/***/ ((module) => {

"use strict";
module.exports = require("http2");;

/***/ }),
/* 785 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const EventEmitter = __webpack_require__(119);
const tls = __webpack_require__(245);
const http2 = __webpack_require__(784);
const QuickLRU = __webpack_require__(786);

const kCurrentStreamsCount = Symbol('currentStreamsCount');
const kRequest = Symbol('request');
const kOriginSet = Symbol('cachedOriginSet');
const kGracefullyClosing = Symbol('gracefullyClosing');

const nameKeys = [
	// `http2.connect()` options
	'maxDeflateDynamicTableSize',
	'maxSessionMemory',
	'maxHeaderListPairs',
	'maxOutstandingPings',
	'maxReservedRemoteStreams',
	'maxSendHeaderBlockLength',
	'paddingStrategy',

	// `tls.connect()` options
	'localAddress',
	'path',
	'rejectUnauthorized',
	'minDHSize',

	// `tls.createSecureContext()` options
	'ca',
	'cert',
	'clientCertEngine',
	'ciphers',
	'key',
	'pfx',
	'servername',
	'minVersion',
	'maxVersion',
	'secureProtocol',
	'crl',
	'honorCipherOrder',
	'ecdhCurve',
	'dhparam',
	'secureOptions',
	'sessionIdContext'
];

const getSortedIndex = (array, value, compare) => {
	let low = 0;
	let high = array.length;

	while (low < high) {
		const mid = (low + high) >>> 1;

		/* istanbul ignore next */
		if (compare(array[mid], value)) {
			// This never gets called because we use descending sort. Better to have this anyway.
			low = mid + 1;
		} else {
			high = mid;
		}
	}

	return low;
};

const compareSessions = (a, b) => {
	return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
};

// See https://tools.ietf.org/html/rfc8336
const closeCoveredSessions = (where, session) => {
	// Clients SHOULD NOT emit new requests on any connection whose Origin
	// Set is a proper subset of another connection's Origin Set, and they
	// SHOULD close it once all outstanding requests are satisfied.
	for (const coveredSession of where) {
		if (
			// The set is a proper subset when its length is less than the other set.
			coveredSession[kOriginSet].length < session[kOriginSet].length &&

			// And the other set includes all elements of the subset.
			coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&

			// Makes sure that the session can handle all requests from the covered session.
			coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams
		) {
			// This allows pending requests to finish and prevents making new requests.
			gracefullyClose(coveredSession);
		}
	}
};

// This is basically inverted `closeCoveredSessions(...)`.
const closeSessionIfCovered = (where, coveredSession) => {
	for (const session of where) {
		if (
			coveredSession[kOriginSet].length < session[kOriginSet].length &&
			coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&
			coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams
		) {
			gracefullyClose(coveredSession);
		}
	}
};

const getSessions = ({agent, isFree}) => {
	const result = {};

	// eslint-disable-next-line guard-for-in
	for (const normalizedOptions in agent.sessions) {
		const sessions = agent.sessions[normalizedOptions];

		const filtered = sessions.filter(session => {
			const result = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;

			return isFree ? result : !result;
		});

		if (filtered.length !== 0) {
			result[normalizedOptions] = filtered;
		}
	}

	return result;
};

const gracefullyClose = session => {
	session[kGracefullyClosing] = true;

	if (session[kCurrentStreamsCount] === 0) {
		session.close();
	}
};

class Agent extends EventEmitter {
	constructor({timeout = 60000, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100} = {}) {
		super();

		// A session is considered busy when its current streams count
		// is equal to or greater than the `maxConcurrentStreams` value.

		// A session is considered free when its current streams count
		// is less than the `maxConcurrentStreams` value.

		// SESSIONS[NORMALIZED_OPTIONS] = [];
		this.sessions = {};

		// The queue for creating new sessions. It looks like this:
		// QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION
		//
		// The entry function has `listeners`, `completed` and `destroyed` properties.
		// `listeners` is an array of objects containing `resolve` and `reject` functions.
		// `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.
		// `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.
		this.queue = {};

		// Each session will use this timeout value.
		this.timeout = timeout;

		// Max sessions in total
		this.maxSessions = maxSessions;

		// Max free sessions in total
		// TODO: decreasing `maxFreeSessions` should close some sessions
		this.maxFreeSessions = maxFreeSessions;

		this._freeSessionsCount = 0;
		this._sessionsCount = 0;

		// We don't support push streams by default.
		this.settings = {
			enablePush: false
		};

		// Reusing TLS sessions increases performance.
		this.tlsSessionCache = new QuickLRU({maxSize: maxCachedTlsSessions});
	}

	static normalizeOrigin(url, servername) {
		if (typeof url === 'string') {
			url = new URL(url);
		}

		if (servername && url.hostname !== servername) {
			url.hostname = servername;
		}

		return url.origin;
	}

	normalizeOptions(options) {
		let normalized = '';

		if (options) {
			for (const key of nameKeys) {
				if (options[key]) {
					normalized += `:${options[key]}`;
				}
			}
		}

		return normalized;
	}

	_tryToCreateNewSession(normalizedOptions, normalizedOrigin) {
		if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {
			return;
		}

		const item = this.queue[normalizedOptions][normalizedOrigin];

		// The entry function can be run only once.
		// BUG: The session may be never created when:
		// - the first condition is false AND
		// - this function is never called with the same arguments in the future.
		if (this._sessionsCount < this.maxSessions && !item.completed) {
			item.completed = true;

			item();
		}
	}

	getSession(origin, options, listeners) {
		return new Promise((resolve, reject) => {
			if (Array.isArray(listeners)) {
				listeners = [...listeners];

				// Resolve the current promise ASAP, we're just moving the listeners.
				// They will be executed at a different time.
				resolve();
			} else {
				listeners = [{resolve, reject}];
			}

			const normalizedOptions = this.normalizeOptions(options);
			const normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);

			if (normalizedOrigin === undefined) {
				for (const {reject} of listeners) {
					reject(new TypeError('The `origin` argument needs to be a string or an URL object'));
				}

				return;
			}

			if (normalizedOptions in this.sessions) {
				const sessions = this.sessions[normalizedOptions];

				let maxConcurrentStreams = -1;
				let currentStreamsCount = -1;
				let optimalSession;

				// We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.
				// Additionally, we are looking for session which has biggest current pending streams count.
				for (const session of sessions) {
					const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;

					if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
						break;
					}

					if (session[kOriginSet].includes(normalizedOrigin)) {
						const sessionCurrentStreamsCount = session[kCurrentStreamsCount];

						if (
							sessionCurrentStreamsCount >= sessionMaxConcurrentStreams ||
							session[kGracefullyClosing] ||
							// Unfortunately the `close` event isn't called immediately,
							// so `session.destroyed` is `true`, but `session.closed` is `false`.
							session.destroyed
						) {
							continue;
						}

						// We only need set this once.
						if (!optimalSession) {
							maxConcurrentStreams = sessionMaxConcurrentStreams;
						}

						// We're looking for the session which has biggest current pending stream count,
						// in order to minimalize the amount of active sessions.
						if (sessionCurrentStreamsCount > currentStreamsCount) {
							optimalSession = session;
							currentStreamsCount = sessionCurrentStreamsCount;
						}
					}
				}

				if (optimalSession) {
					/* istanbul ignore next: safety check */
					if (listeners.length !== 1) {
						for (const {reject} of listeners) {
							const error = new Error(
								`Expected the length of listeners to be 1, got ${listeners.length}.\n` +
								'Please report this to https://github.com/szmarczak/http2-wrapper/'
							);

							reject(error);
						}

						return;
					}

					listeners[0].resolve(optimalSession);
					return;
				}
			}

			if (normalizedOptions in this.queue) {
				if (normalizedOrigin in this.queue[normalizedOptions]) {
					// There's already an item in the queue, just attach ourselves to it.
					this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);

					// This shouldn't be executed here.
					// See the comment inside _tryToCreateNewSession.
					this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
					return;
				}
			} else {
				this.queue[normalizedOptions] = {};
			}

			// The entry must be removed from the queue IMMEDIATELY when:
			// 1. the session connects successfully,
			// 2. an error occurs.
			const removeFromQueue = () => {
				// Our entry can be replaced. We cannot remove the new one.
				if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
					delete this.queue[normalizedOptions][normalizedOrigin];

					if (Object.keys(this.queue[normalizedOptions]).length === 0) {
						delete this.queue[normalizedOptions];
					}
				}
			};

			// The main logic is here
			const entry = () => {
				const name = `${normalizedOrigin}:${normalizedOptions}`;
				let receivedSettings = false;

				try {
					const session = http2.connect(origin, {
						createConnection: this.createConnection,
						settings: this.settings,
						session: this.tlsSessionCache.get(name),
						...options
					});
					session[kCurrentStreamsCount] = 0;
					session[kGracefullyClosing] = false;

					const isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
					let wasFree = true;

					session.socket.once('session', tlsSession => {
						this.tlsSessionCache.set(name, tlsSession);
					});

					session.once('error', error => {
						// Listeners are empty when the session successfully connected.
						for (const {reject} of listeners) {
							reject(error);
						}

						// The connection got broken, purge the cache.
						this.tlsSessionCache.delete(name);
					});

					session.setTimeout(this.timeout, () => {
						// Terminates all streams owned by this session.
						// TODO: Maybe the streams should have a "Session timed out" error?
						session.destroy();
					});

					session.once('close', () => {
						if (receivedSettings) {
							// 1. If it wasn't free then no need to decrease because
							//    it has been decreased already in session.request().
							// 2. `stream.once('close')` won't increment the count
							//    because the session is already closed.
							if (wasFree) {
								this._freeSessionsCount--;
							}

							this._sessionsCount--;

							// This cannot be moved to the stream logic,
							// because there may be a session that hadn't made a single request.
							const where = this.sessions[normalizedOptions];
							where.splice(where.indexOf(session), 1);

							if (where.length === 0) {
								delete this.sessions[normalizedOptions];
							}
						} else {
							// Broken connection
							const error = new Error('Session closed without receiving a SETTINGS frame');
							error.code = 'HTTP2WRAPPER_NOSETTINGS';

							for (const {reject} of listeners) {
								reject(error);
							}

							removeFromQueue();
						}

						// There may be another session awaiting.
						this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
					});

					// Iterates over the queue and processes listeners.
					const processListeners = () => {
						if (!(normalizedOptions in this.queue) || !isFree()) {
							return;
						}

						for (const origin of session[kOriginSet]) {
							if (origin in this.queue[normalizedOptions]) {
								const {listeners} = this.queue[normalizedOptions][origin];

								// Prevents session overloading.
								while (listeners.length !== 0 && isFree()) {
									// We assume `resolve(...)` calls `request(...)` *directly*,
									// otherwise the session will get overloaded.
									listeners.shift().resolve(session);
								}

								const where = this.queue[normalizedOptions];
								if (where[origin].listeners.length === 0) {
									delete where[origin];

									if (Object.keys(where).length === 0) {
										delete this.queue[normalizedOptions];
										break;
									}
								}

								// We're no longer free, no point in continuing.
								if (!isFree()) {
									break;
								}
							}
						}
					};

					// The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.
					session.on('origin', () => {
						session[kOriginSet] = session.originSet;

						if (!isFree()) {
							// The session is full.
							return;
						}

						processListeners();

						// Close covered sessions (if possible).
						closeCoveredSessions(this.sessions[normalizedOptions], session);
					});

					session.once('remoteSettings', () => {
						// Fix Node.js bug preventing the process from exiting
						session.ref();
						session.unref();

						this._sessionsCount++;

						// The Agent could have been destroyed already.
						if (entry.destroyed) {
							const error = new Error('Agent has been destroyed');

							for (const listener of listeners) {
								listener.reject(error);
							}

							session.destroy();
							return;
						}

						session[kOriginSet] = session.originSet;

						{
							const where = this.sessions;

							if (normalizedOptions in where) {
								const sessions = where[normalizedOptions];
								sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
							} else {
								where[normalizedOptions] = [session];
							}
						}

						this._freeSessionsCount += 1;
						receivedSettings = true;

						this.emit('session', session);

						processListeners();
						removeFromQueue();

						// TODO: Close last recently used (or least used?) session
						if (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {
							session.close();
						}

						// Check if we haven't managed to execute all listeners.
						if (listeners.length !== 0) {
							// Request for a new session with predefined listeners.
							this.getSession(normalizedOrigin, options, listeners);
							listeners.length = 0;
						}

						// `session.remoteSettings.maxConcurrentStreams` might get increased
						session.on('remoteSettings', () => {
							processListeners();

							// In case the Origin Set changes
							closeCoveredSessions(this.sessions[normalizedOptions], session);
						});
					});

					// Shim `session.request()` in order to catch all streams
					session[kRequest] = session.request;
					session.request = (headers, streamOptions) => {
						if (session[kGracefullyClosing]) {
							throw new Error('The session is gracefully closing. No new streams are allowed.');
						}

						const stream = session[kRequest](headers, streamOptions);

						// The process won't exit until the session is closed or all requests are gone.
						session.ref();

						++session[kCurrentStreamsCount];

						if (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {
							this._freeSessionsCount--;
						}

						stream.once('close', () => {
							wasFree = isFree();

							--session[kCurrentStreamsCount];

							if (!session.destroyed && !session.closed) {
								closeSessionIfCovered(this.sessions[normalizedOptions], session);

								if (isFree() && !session.closed) {
									if (!wasFree) {
										this._freeSessionsCount++;

										wasFree = true;
									}

									const isEmpty = session[kCurrentStreamsCount] === 0;

									if (isEmpty) {
										session.unref();
									}

									if (
										isEmpty &&
										(
											this._freeSessionsCount > this.maxFreeSessions ||
											session[kGracefullyClosing]
										)
									) {
										session.close();
									} else {
										closeCoveredSessions(this.sessions[normalizedOptions], session);
										processListeners();
									}
								}
							}
						});

						return stream;
					};
				} catch (error) {
					for (const listener of listeners) {
						listener.reject(error);
					}

					removeFromQueue();
				}
			};

			entry.listeners = listeners;
			entry.completed = false;
			entry.destroyed = false;

			this.queue[normalizedOptions][normalizedOrigin] = entry;
			this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
		});
	}

	request(origin, options, headers, streamOptions) {
		return new Promise((resolve, reject) => {
			this.getSession(origin, options, [{
				reject,
				resolve: session => {
					try {
						resolve(session.request(headers, streamOptions));
					} catch (error) {
						reject(error);
					}
				}
			}]);
		});
	}

	createConnection(origin, options) {
		return Agent.connect(origin, options);
	}

	static connect(origin, options) {
		options.ALPNProtocols = ['h2'];

		const port = origin.port || 443;
		const host = origin.hostname || origin.host;

		if (typeof options.servername === 'undefined') {
			options.servername = host;
		}

		return tls.connect(port, host, options);
	}

	closeFreeSessions() {
		for (const sessions of Object.values(this.sessions)) {
			for (const session of sessions) {
				if (session[kCurrentStreamsCount] === 0) {
					session.close();
				}
			}
		}
	}

	destroy(reason) {
		for (const sessions of Object.values(this.sessions)) {
			for (const session of sessions) {
				session.destroy(reason);
			}
		}

		for (const entriesOfAuthority of Object.values(this.queue)) {
			for (const entry of Object.values(entriesOfAuthority)) {
				entry.destroyed = true;
			}
		}

		// New requests should NOT attach to destroyed sessions
		this.queue = {};
	}

	get freeSessions() {
		return getSessions({agent: this, isFree: true});
	}

	get busySessions() {
		return getSessions({agent: this, isFree: false});
	}
}

Agent.kCurrentStreamsCount = kCurrentStreamsCount;
Agent.kGracefullyClosing = kGracefullyClosing;

module.exports = {
	Agent,
	globalAgent: new Agent()
};


/***/ }),
/* 786 */
/***/ ((module) => {

"use strict";


class QuickLRU {
	constructor(options = {}) {
		if (!(options.maxSize && options.maxSize > 0)) {
			throw new TypeError('`maxSize` must be a number greater than 0');
		}

		this.maxSize = options.maxSize;
		this.onEviction = options.onEviction;
		this.cache = new Map();
		this.oldCache = new Map();
		this._size = 0;
	}

	_set(key, value) {
		this.cache.set(key, value);
		this._size++;

		if (this._size >= this.maxSize) {
			this._size = 0;

			if (typeof this.onEviction === 'function') {
				for (const [key, value] of this.oldCache.entries()) {
					this.onEviction(key, value);
				}
			}

			this.oldCache = this.cache;
			this.cache = new Map();
		}
	}

	get(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			const value = this.oldCache.get(key);
			this.oldCache.delete(key);
			this._set(key, value);
			return value;
		}
	}

	set(key, value) {
		if (this.cache.has(key)) {
			this.cache.set(key, value);
		} else {
			this._set(key, value);
		}

		return this;
	}

	has(key) {
		return this.cache.has(key) || this.oldCache.has(key);
	}

	peek(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			return this.oldCache.get(key);
		}
	}

	delete(key) {
		const deleted = this.cache.delete(key);
		if (deleted) {
			this._size--;
		}

		return this.oldCache.delete(key) || deleted;
	}

	clear() {
		this.cache.clear();
		this.oldCache.clear();
		this._size = 0;
	}

	* keys() {
		for (const [key] of this) {
			yield key;
		}
	}

	* values() {
		for (const [, value] of this) {
			yield value;
		}
	}

	* [Symbol.iterator]() {
		for (const item of this.cache) {
			yield item;
		}

		for (const item of this.oldCache) {
			const [key] = item;
			if (!this.cache.has(key)) {
				yield item;
			}
		}
	}

	get size() {
		let oldCacheSize = 0;
		for (const key of this.oldCache.keys()) {
			if (!this.cache.has(key)) {
				oldCacheSize++;
			}
		}

		return Math.min(this._size + oldCacheSize, this.maxSize);
	}
}

module.exports = QuickLRU;


/***/ }),
/* 787 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const http2 = __webpack_require__(784);
const {Writable} = __webpack_require__(76);
const {Agent, globalAgent} = __webpack_require__(785);
const IncomingMessage = __webpack_require__(788);
const urlToOptions = __webpack_require__(789);
const proxyEvents = __webpack_require__(790);
const isRequestPseudoHeader = __webpack_require__(791);
const {
	ERR_INVALID_ARG_TYPE,
	ERR_INVALID_PROTOCOL,
	ERR_HTTP_HEADERS_SENT,
	ERR_INVALID_HTTP_TOKEN,
	ERR_HTTP_INVALID_HEADER_VALUE,
	ERR_INVALID_CHAR
} = __webpack_require__(792);

const {
	HTTP2_HEADER_STATUS,
	HTTP2_HEADER_METHOD,
	HTTP2_HEADER_PATH,
	HTTP2_METHOD_CONNECT
} = http2.constants;

const kHeaders = Symbol('headers');
const kOrigin = Symbol('origin');
const kSession = Symbol('session');
const kOptions = Symbol('options');
const kFlushedHeaders = Symbol('flushedHeaders');
const kJobs = Symbol('jobs');

const isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
const isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;

class ClientRequest extends Writable {
	constructor(input, options, callback) {
		super({
			autoDestroy: false
		});

		const hasInput = typeof input === 'string' || input instanceof URL;
		if (hasInput) {
			input = urlToOptions(input instanceof URL ? input : new URL(input));
		}

		if (typeof options === 'function' || options === undefined) {
			// (options, callback)
			callback = options;
			options = hasInput ? input : {...input};
		} else {
			// (input, options, callback)
			options = {...input, ...options};
		}

		if (options.h2session) {
			this[kSession] = options.h2session;
		} else if (options.agent === false) {
			this.agent = new Agent({maxFreeSessions: 0});
		} else if (typeof options.agent === 'undefined' || options.agent === null) {
			if (typeof options.createConnection === 'function') {
				// This is a workaround - we don't have to create the session on our own.
				this.agent = new Agent({maxFreeSessions: 0});
				this.agent.createConnection = options.createConnection;
			} else {
				this.agent = globalAgent;
			}
		} else if (typeof options.agent.request === 'function') {
			this.agent = options.agent;
		} else {
			throw new ERR_INVALID_ARG_TYPE('options.agent', ['Agent-like Object', 'undefined', 'false'], options.agent);
		}

		if (options.protocol && options.protocol !== 'https:') {
			throw new ERR_INVALID_PROTOCOL(options.protocol, 'https:');
		}

		const port = options.port || options.defaultPort || (this.agent && this.agent.defaultPort) || 443;
		const host = options.hostname || options.host || 'localhost';

		// Don't enforce the origin via options. It may be changed in an Agent.
		delete options.hostname;
		delete options.host;
		delete options.port;

		const {timeout} = options;
		options.timeout = undefined;

		this[kHeaders] = Object.create(null);
		this[kJobs] = [];

		this.socket = null;
		this.connection = null;

		this.method = options.method || 'GET';
		this.path = options.path;

		this.res = null;
		this.aborted = false;
		this.reusedSocket = false;

		if (options.headers) {
			for (const [header, value] of Object.entries(options.headers)) {
				this.setHeader(header, value);
			}
		}

		if (options.auth && !('authorization' in this[kHeaders])) {
			this[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');
		}

		options.session = options.tlsSession;
		options.path = options.socketPath;

		this[kOptions] = options;

		// Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.
		if (port === 443) {
			this[kOrigin] = `https://${host}`;

			if (!(':authority' in this[kHeaders])) {
				this[kHeaders][':authority'] = host;
			}
		} else {
			this[kOrigin] = `https://${host}:${port}`;

			if (!(':authority' in this[kHeaders])) {
				this[kHeaders][':authority'] = `${host}:${port}`;
			}
		}

		if (timeout) {
			this.setTimeout(timeout);
		}

		if (callback) {
			this.once('response', callback);
		}

		this[kFlushedHeaders] = false;
	}

	get method() {
		return this[kHeaders][HTTP2_HEADER_METHOD];
	}

	set method(value) {
		if (value) {
			this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
		}
	}

	get path() {
		return this[kHeaders][HTTP2_HEADER_PATH];
	}

	set path(value) {
		if (value) {
			this[kHeaders][HTTP2_HEADER_PATH] = value;
		}
	}

	get _mustNotHaveABody() {
		return this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';
	}

	_write(chunk, encoding, callback) {
		// https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156
		if (this._mustNotHaveABody) {
			callback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));
			/* istanbul ignore next: Node.js 12 throws directly */
			return;
		}

		this.flushHeaders();

		const callWrite = () => this._request.write(chunk, encoding, callback);
		if (this._request) {
			callWrite();
		} else {
			this[kJobs].push(callWrite);
		}
	}

	_final(callback) {
		if (this.destroyed) {
			return;
		}

		this.flushHeaders();

		const callEnd = () => {
			// For GET, HEAD and DELETE
			if (this._mustNotHaveABody) {
				callback();
				return;
			}

			this._request.end(callback);
		};

		if (this._request) {
			callEnd();
		} else {
			this[kJobs].push(callEnd);
		}
	}

	abort() {
		if (this.res && this.res.complete) {
			return;
		}

		if (!this.aborted) {
			process.nextTick(() => this.emit('abort'));
		}

		this.aborted = true;

		this.destroy();
	}

	_destroy(error, callback) {
		if (this.res) {
			this.res._dump();
		}

		if (this._request) {
			this._request.destroy();
		}

		callback(error);
	}

	async flushHeaders() {
		if (this[kFlushedHeaders] || this.destroyed) {
			return;
		}

		this[kFlushedHeaders] = true;

		const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;

		// The real magic is here
		const onStream = stream => {
			this._request = stream;

			if (this.destroyed) {
				stream.destroy();
				return;
			}

			// Forwards `timeout`, `continue`, `close` and `error` events to this instance.
			if (!isConnectMethod) {
				proxyEvents(stream, this, ['timeout', 'continue', 'close', 'error']);
			}

			// Wait for the `finish` event. We don't want to emit the `response` event
			// before `request.end()` is called.
			const waitForEnd = fn => {
				return (...args) => {
					if (!this.writable && !this.destroyed) {
						fn(...args);
					} else {
						this.once('finish', () => {
							fn(...args);
						});
					}
				};
			};

			// This event tells we are ready to listen for the data.
			stream.once('response', waitForEnd((headers, flags, rawHeaders) => {
				// If we were to emit raw request stream, it would be as fast as the native approach.
				// Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).
				const response = new IncomingMessage(this.socket, stream.readableHighWaterMark);
				this.res = response;

				response.req = this;
				response.statusCode = headers[HTTP2_HEADER_STATUS];
				response.headers = headers;
				response.rawHeaders = rawHeaders;

				response.once('end', () => {
					if (this.aborted) {
						response.aborted = true;
						response.emit('aborted');
					} else {
						response.complete = true;

						// Has no effect, just be consistent with the Node.js behavior
						response.socket = null;
						response.connection = null;
					}
				});

				if (isConnectMethod) {
					response.upgrade = true;

					// The HTTP1 API says the socket is detached here,
					// but we can't do that so we pass the original HTTP2 request.
					if (this.emit('connect', response, stream, Buffer.alloc(0))) {
						this.emit('close');
					} else {
						// No listeners attached, destroy the original request.
						stream.destroy();
					}
				} else {
					// Forwards data
					stream.on('data', chunk => {
						if (!response._dumped && !response.push(chunk)) {
							stream.pause();
						}
					});

					stream.once('end', () => {
						response.push(null);
					});

					if (!this.emit('response', response)) {
						// No listeners attached, dump the response.
						response._dump();
					}
				}
			}));

			// Emits `information` event
			stream.once('headers', waitForEnd(
				headers => this.emit('information', {statusCode: headers[HTTP2_HEADER_STATUS]})
			));

			stream.once('trailers', waitForEnd((trailers, flags, rawTrailers) => {
				const {res} = this;

				// Assigns trailers to the response object.
				res.trailers = trailers;
				res.rawTrailers = rawTrailers;
			}));

			const {socket} = stream.session;
			this.socket = socket;
			this.connection = socket;

			for (const job of this[kJobs]) {
				job();
			}

			this.emit('socket', this.socket);
		};

		// Makes a HTTP2 request
		if (this[kSession]) {
			try {
				onStream(this[kSession].request(this[kHeaders]));
			} catch (error) {
				this.emit('error', error);
			}
		} else {
			this.reusedSocket = true;

			try {
				onStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));
			} catch (error) {
				this.emit('error', error);
			}
		}
	}

	getHeader(name) {
		if (typeof name !== 'string') {
			throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
		}

		return this[kHeaders][name.toLowerCase()];
	}

	get headersSent() {
		return this[kFlushedHeaders];
	}

	removeHeader(name) {
		if (typeof name !== 'string') {
			throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
		}

		if (this.headersSent) {
			throw new ERR_HTTP_HEADERS_SENT('remove');
		}

		delete this[kHeaders][name.toLowerCase()];
	}

	setHeader(name, value) {
		if (this.headersSent) {
			throw new ERR_HTTP_HEADERS_SENT('set');
		}

		if (typeof name !== 'string' || (!isValidHttpToken.test(name) && !isRequestPseudoHeader(name))) {
			throw new ERR_INVALID_HTTP_TOKEN('Header name', name);
		}

		if (typeof value === 'undefined') {
			throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
		}

		if (isInvalidHeaderValue.test(value)) {
			throw new ERR_INVALID_CHAR('header content', name);
		}

		this[kHeaders][name.toLowerCase()] = value;
	}

	setNoDelay() {
		// HTTP2 sockets cannot be malformed, do nothing.
	}

	setSocketKeepAlive() {
		// HTTP2 sockets cannot be malformed, do nothing.
	}

	setTimeout(ms, callback) {
		const applyTimeout = () => this._request.setTimeout(ms, callback);

		if (this._request) {
			applyTimeout();
		} else {
			this[kJobs].push(applyTimeout);
		}

		return this;
	}

	get maxHeadersCount() {
		if (!this.destroyed && this._request) {
			return this._request.session.localSettings.maxHeaderListSize;
		}

		return undefined;
	}

	set maxHeadersCount(_value) {
		// Updating HTTP2 settings would affect all requests, do nothing.
	}
}

module.exports = ClientRequest;


/***/ }),
/* 788 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {Readable} = __webpack_require__(76);

class IncomingMessage extends Readable {
	constructor(socket, highWaterMark) {
		super({
			highWaterMark,
			autoDestroy: false
		});

		this.statusCode = null;
		this.statusMessage = '';
		this.httpVersion = '2.0';
		this.httpVersionMajor = 2;
		this.httpVersionMinor = 0;
		this.headers = {};
		this.trailers = {};
		this.req = null;

		this.aborted = false;
		this.complete = false;
		this.upgrade = null;

		this.rawHeaders = [];
		this.rawTrailers = [];

		this.socket = socket;
		this.connection = socket;

		this._dumped = false;
	}

	_destroy(error) {
		this.req._request.destroy(error);
	}

	setTimeout(ms, callback) {
		this.req.setTimeout(ms, callback);
		return this;
	}

	_dump() {
		if (!this._dumped) {
			this._dumped = true;

			this.removeAllListeners('data');
			this.resume();
		}
	}

	_read() {
		if (this.req) {
			this.req._request.resume();
		}
	}
}

module.exports = IncomingMessage;


/***/ }),
/* 789 */
/***/ ((module) => {

"use strict";

/* istanbul ignore file: https://github.com/nodejs/node/blob/a91293d4d9ab403046ab5eb022332e4e3d249bd3/lib/internal/url.js#L1257 */

module.exports = url => {
	const options = {
		protocol: url.protocol,
		hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
		host: url.host,
		hash: url.hash,
		search: url.search,
		pathname: url.pathname,
		href: url.href,
		path: `${url.pathname || ''}${url.search || ''}`
	};

	if (typeof url.port === 'string' && url.port.length !== 0) {
		options.port = Number(url.port);
	}

	if (url.username || url.password) {
		options.auth = `${url.username || ''}:${url.password || ''}`;
	}

	return options;
};


/***/ }),
/* 790 */
/***/ ((module) => {

"use strict";


module.exports = (from, to, events) => {
	for (const event of events) {
		from.on(event, (...args) => to.emit(event, ...args));
	}
};


/***/ }),
/* 791 */
/***/ ((module) => {

"use strict";


module.exports = header => {
	switch (header) {
		case ':method':
		case ':scheme':
		case ':authority':
		case ':path':
			return true;
		default:
			return false;
	}
};


/***/ }),
/* 792 */
/***/ ((module) => {

"use strict";

/* istanbul ignore file: https://github.com/nodejs/node/blob/master/lib/internal/errors.js */

const makeError = (Base, key, getMessage) => {
	module.exports[key] = class NodeError extends Base {
		constructor(...args) {
			super(typeof getMessage === 'string' ? getMessage : getMessage(args));
			this.name = `${super.name} [${key}]`;
			this.code = key;
		}
	};
};

makeError(TypeError, 'ERR_INVALID_ARG_TYPE', args => {
	const type = args[0].includes('.') ? 'property' : 'argument';

	let valid = args[1];
	const isManyTypes = Array.isArray(valid);

	if (isManyTypes) {
		valid = `${valid.slice(0, -1).join(', ')} or ${valid.slice(-1)}`;
	}

	return `The "${args[0]}" ${type} must be ${isManyTypes ? 'one of' : 'of'} type ${valid}. Received ${typeof args[2]}`;
});

makeError(TypeError, 'ERR_INVALID_PROTOCOL', args => {
	return `Protocol "${args[0]}" not supported. Expected "${args[1]}"`;
});

makeError(Error, 'ERR_HTTP_HEADERS_SENT', args => {
	return `Cannot ${args[0]} headers after they are sent to the client`;
});

makeError(TypeError, 'ERR_INVALID_HTTP_TOKEN', args => {
	return `${args[0]} must be a valid HTTP token [${args[1]}]`;
});

makeError(TypeError, 'ERR_HTTP_INVALID_HEADER_VALUE', args => {
	return `Invalid value "${args[0]} for header "${args[1]}"`;
});

makeError(TypeError, 'ERR_INVALID_CHAR', args => {
	return `Invalid character in ${args[0]} [${args[1]}]`;
});


/***/ }),
/* 793 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const http = __webpack_require__(241);
const https = __webpack_require__(240);
const resolveALPN = __webpack_require__(794);
const QuickLRU = __webpack_require__(786);
const Http2ClientRequest = __webpack_require__(787);
const calculateServerName = __webpack_require__(795);
const urlToOptions = __webpack_require__(789);

const cache = new QuickLRU({maxSize: 100});
const queue = new Map();

const installSocket = (agent, socket, options) => {
	socket._httpMessage = {shouldKeepAlive: true};

	const onFree = () => {
		agent.emit('free', socket, options);
	};

	socket.on('free', onFree);

	const onClose = () => {
		agent.removeSocket(socket, options);
	};

	socket.on('close', onClose);

	const onRemove = () => {
		agent.removeSocket(socket, options);
		socket.off('close', onClose);
		socket.off('free', onFree);
		socket.off('agentRemove', onRemove);
	};

	socket.on('agentRemove', onRemove);

	agent.emit('free', socket, options);
};

const resolveProtocol = async options => {
	const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;

	if (!cache.has(name)) {
		if (queue.has(name)) {
			const result = await queue.get(name);
			return result.alpnProtocol;
		}

		const {path, agent} = options;
		options.path = options.socketPath;

		const resultPromise = resolveALPN(options);
		queue.set(name, resultPromise);

		try {
			const {socket, alpnProtocol} = await resultPromise;
			cache.set(name, alpnProtocol);

			options.path = path;

			if (alpnProtocol === 'h2') {
				// https://github.com/nodejs/node/issues/33343
				socket.destroy();
			} else {
				const {globalAgent} = https;
				const defaultCreateConnection = https.Agent.prototype.createConnection;

				if (agent) {
					if (agent.createConnection === defaultCreateConnection) {
						installSocket(agent, socket, options);
					} else {
						socket.destroy();
					}
				} else if (globalAgent.createConnection === defaultCreateConnection) {
					installSocket(globalAgent, socket, options);
				} else {
					socket.destroy();
				}
			}

			queue.delete(name);

			return alpnProtocol;
		} catch (error) {
			queue.delete(name);

			throw error;
		}
	}

	return cache.get(name);
};

module.exports = async (input, options, callback) => {
	if (typeof input === 'string' || input instanceof URL) {
		input = urlToOptions(new URL(input));
	}

	if (typeof options === 'function') {
		callback = options;
		options = undefined;
	}

	options = {
		ALPNProtocols: ['h2', 'http/1.1'],
		...input,
		...options,
		resolveSocket: true
	};

	if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
		throw new Error('The `ALPNProtocols` option must be an Array with at least one entry');
	}

	options.protocol = options.protocol || 'https:';
	const isHttps = options.protocol === 'https:';

	options.host = options.hostname || options.host || 'localhost';
	options.session = options.tlsSession;
	options.servername = options.servername || calculateServerName(options);
	options.port = options.port || (isHttps ? 443 : 80);
	options._defaultAgent = isHttps ? https.globalAgent : http.globalAgent;

	const agents = options.agent;

	if (agents) {
		if (agents.addRequest) {
			throw new Error('The `options.agent` object can contain only `http`, `https` or `http2` properties');
		}

		options.agent = agents[isHttps ? 'https' : 'http'];
	}

	if (isHttps) {
		const protocol = await resolveProtocol(options);

		if (protocol === 'h2') {
			if (agents) {
				options.agent = agents.http2;
			}

			return new Http2ClientRequest(options, callback);
		}
	}

	return http.request(options, callback);
};

module.exports.protocolCache = cache;


/***/ }),
/* 794 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const tls = __webpack_require__(245);

module.exports = (options = {}) => new Promise((resolve, reject) => {
	const socket = tls.connect(options, () => {
		if (options.resolveSocket) {
			socket.off('error', reject);
			resolve({alpnProtocol: socket.alpnProtocol, socket});
		} else {
			socket.destroy();
			resolve({alpnProtocol: socket.alpnProtocol});
		}
	});

	socket.on('error', reject);
});


/***/ }),
/* 795 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const net = __webpack_require__(244);
/* istanbul ignore file: https://github.com/nodejs/node/blob/v13.0.1/lib/_http_agent.js */

module.exports = options => {
	let servername = options.host;
	const hostHeader = options.headers && options.headers.host;

	if (hostHeader) {
		if (hostHeader.startsWith('[')) {
			const index = hostHeader.indexOf(']');
			if (index === -1) {
				servername = hostHeader;
			} else {
				servername = hostHeader.slice(1, -1);
			}
		} else {
			servername = hostHeader.split(':', 1)[0];
		}
	}

	if (net.isIP(servername)) {
		return '';
	}

	return servername;
};


/***/ }),
/* 796 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs_1 = __webpack_require__(8);
const util_1 = __webpack_require__(90);
const is_1 = __webpack_require__(757);
const is_form_data_1 = __webpack_require__(797);
const statAsync = util_1.promisify(fs_1.stat);
exports.default = async (body, headers) => {
    if (headers && 'content-length' in headers) {
        return Number(headers['content-length']);
    }
    if (!body) {
        return 0;
    }
    if (is_1.default.string(body)) {
        return Buffer.byteLength(body);
    }
    if (is_1.default.buffer(body)) {
        return body.length;
    }
    if (is_form_data_1.default(body)) {
        return util_1.promisify(body.getLength.bind(body))();
    }
    if (body instanceof fs_1.ReadStream) {
        const { size } = await statAsync(body.path);
        return size;
    }
    return undefined;
};


/***/ }),
/* 797 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_1 = __webpack_require__(757);
exports.default = (body) => is_1.default.nodeStream(body) && is_1.default.function_(body.getBoundary);


/***/ }),
/* 798 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function default_1(from, to, events) {
    const fns = {};
    for (const event of events) {
        fns[event] = (...args) => {
            to.emit(event, ...args);
        };
        from.on(event, fns[event]);
    }
    return () => {
        for (const event of events) {
            from.off(event, fns[event]);
        }
    };
}
exports.default = default_1;


/***/ }),
/* 799 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutError = void 0;
const net = __webpack_require__(244);
const unhandle_1 = __webpack_require__(800);
const reentry = Symbol('reentry');
const noop = () => { };
class TimeoutError extends Error {
    constructor(threshold, event) {
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        this.event = event;
        this.name = 'TimeoutError';
        this.code = 'ETIMEDOUT';
    }
}
exports.TimeoutError = TimeoutError;
exports.default = (request, delays, options) => {
    if (reentry in request) {
        return noop;
    }
    request[reentry] = true;
    const cancelers = [];
    const { once, unhandleAll } = unhandle_1.default();
    const addTimeout = (delay, callback, event) => {
        var _a;
        const timeout = setTimeout(callback, delay, delay, event);
        (_a = timeout.unref) === null || _a === void 0 ? void 0 : _a.call(timeout);
        const cancel = () => {
            clearTimeout(timeout);
        };
        cancelers.push(cancel);
        return cancel;
    };
    const { host, hostname } = options;
    const timeoutHandler = (delay, event) => {
        request.destroy(new TimeoutError(delay, event));
    };
    const cancelTimeouts = () => {
        for (const cancel of cancelers) {
            cancel();
        }
        unhandleAll();
    };
    request.once('error', error => {
        cancelTimeouts();
        // Save original behavior
        /* istanbul ignore next */
        if (request.listenerCount('error') === 0) {
            throw error;
        }
    });
    request.once('close', cancelTimeouts);
    once(request, 'response', (response) => {
        once(response, 'end', cancelTimeouts);
    });
    if (typeof delays.request !== 'undefined') {
        addTimeout(delays.request, timeoutHandler, 'request');
    }
    if (typeof delays.socket !== 'undefined') {
        const socketTimeoutHandler = () => {
            timeoutHandler(delays.socket, 'socket');
        };
        request.setTimeout(delays.socket, socketTimeoutHandler);
        // `request.setTimeout(0)` causes a memory leak.
        // We can just remove the listener and forget about the timer - it's unreffed.
        // See https://github.com/sindresorhus/got/issues/690
        cancelers.push(() => {
            request.removeListener('timeout', socketTimeoutHandler);
        });
    }
    once(request, 'socket', (socket) => {
        var _a;
        const { socketPath } = request;
        /* istanbul ignore next: hard to test */
        if (socket.connecting) {
            const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a !== void 0 ? _a : '') !== 0);
            if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {
                const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');
                once(socket, 'lookup', cancelTimeout);
            }
            if (typeof delays.connect !== 'undefined') {
                const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');
                if (hasPath) {
                    once(socket, 'connect', timeConnect());
                }
                else {
                    once(socket, 'lookup', (error) => {
                        if (error === null) {
                            once(socket, 'connect', timeConnect());
                        }
                    });
                }
            }
            if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {
                once(socket, 'connect', () => {
                    const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');
                    once(socket, 'secureConnect', cancelTimeout);
                });
            }
        }
        if (typeof delays.send !== 'undefined') {
            const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');
            /* istanbul ignore next: hard to test */
            if (socket.connecting) {
                once(socket, 'connect', () => {
                    once(request, 'upload-complete', timeRequest());
                });
            }
            else {
                once(request, 'upload-complete', timeRequest());
            }
        }
    });
    if (typeof delays.response !== 'undefined') {
        once(request, 'upload-complete', () => {
            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');
            once(request, 'response', cancelTimeout);
        });
    }
    return cancelTimeouts;
};


/***/ }),
/* 800 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// When attaching listeners, it's very easy to forget about them.
// Especially if you do error handling and set timeouts.
// So instead of checking if it's proper to throw an error on every timeout ever,
// use this simple tool which will remove all listeners you have attached.
exports.default = () => {
    const handlers = [];
    return {
        once(origin, event, fn) {
            origin.once(event, fn);
            handlers.push({ origin, event, fn });
        },
        unhandleAll() {
            for (const handler of handlers) {
                const { origin, event, fn } = handler;
                origin.removeListener(event, fn);
            }
            handlers.length = 0;
        }
    };
};


/***/ }),
/* 801 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_1 = __webpack_require__(757);
exports.default = (url) => {
    // Cast to URL
    url = url;
    const options = {
        protocol: url.protocol,
        hostname: is_1.default.string(url.hostname) && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ''}${url.search || ''}`
    };
    if (is_1.default.string(url.port) && url.port.length !== 0) {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = `${url.username || ''}:${url.password || ''}`;
    }
    return options;
};


/***/ }),
/* 802 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* istanbul ignore file: deprecated */
const url_1 = __webpack_require__(247);
const keys = [
    'protocol',
    'host',
    'hostname',
    'port',
    'pathname',
    'search'
];
exports.default = (origin, options) => {
    var _a, _b;
    if (options.path) {
        if (options.pathname) {
            throw new TypeError('Parameters `path` and `pathname` are mutually exclusive.');
        }
        if (options.search) {
            throw new TypeError('Parameters `path` and `search` are mutually exclusive.');
        }
        if (options.searchParams) {
            throw new TypeError('Parameters `path` and `searchParams` are mutually exclusive.');
        }
    }
    if (options.search && options.searchParams) {
        throw new TypeError('Parameters `search` and `searchParams` are mutually exclusive.');
    }
    if (!origin) {
        if (!options.protocol) {
            throw new TypeError('No URL protocol specified');
        }
        origin = `${options.protocol}//${(_b = (_a = options.hostname) !== null && _a !== void 0 ? _a : options.host) !== null && _b !== void 0 ? _b : ''}`;
    }
    const url = new url_1.URL(origin);
    if (options.path) {
        const searchIndex = options.path.indexOf('?');
        if (searchIndex === -1) {
            options.pathname = options.path;
        }
        else {
            options.pathname = options.path.slice(0, searchIndex);
            options.search = options.path.slice(searchIndex + 1);
        }
        delete options.path;
    }
    for (const key of keys) {
        if (options[key]) {
            url[key] = options[key].toString();
        }
    }
    return url;
};


/***/ }),
/* 803 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class WeakableMap {
    constructor() {
        this.weakMap = new WeakMap();
        this.map = new Map();
    }
    set(key, value) {
        if (typeof key === 'object') {
            this.weakMap.set(key, value);
        }
        else {
            this.map.set(key, value);
        }
    }
    get(key) {
        if (typeof key === 'object') {
            return this.weakMap.get(key);
        }
        return this.map.get(key);
    }
    has(key) {
        if (typeof key === 'object') {
            return this.weakMap.has(key);
        }
        return this.map.has(key);
    }
}
exports.default = WeakableMap;


/***/ }),
/* 804 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// TODO: Update https://github.com/sindresorhus/get-stream
const getBuffer = async (stream) => {
    const chunks = [];
    let length = 0;
    for await (const chunk of stream) {
        chunks.push(chunk);
        length += Buffer.byteLength(chunk);
    }
    if (Buffer.isBuffer(chunks[0])) {
        return Buffer.concat(chunks, length);
    }
    return Buffer.from(chunks.join(''));
};
exports.default = getBuffer;


/***/ }),
/* 805 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dnsLookupIpVersionToFamily = exports.isDnsLookupIpVersion = void 0;
const conversionTable = {
    auto: 0,
    ipv4: 4,
    ipv6: 6
};
exports.isDnsLookupIpVersion = (value) => {
    return value in conversionTable;
};
exports.dnsLookupIpVersionToFamily = (dnsLookupIpVersion) => {
    if (exports.isDnsLookupIpVersion(dnsLookupIpVersion)) {
        return conversionTable[dnsLookupIpVersion];
    }
    throw new Error('Invalid DNS lookup IP version');
};


/***/ }),
/* 806 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isResponseOk = void 0;
exports.isResponseOk = (response) => {
    const { statusCode } = response;
    const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
    return (statusCode >= 200 && statusCode <= limitStatusCode) || statusCode === 304;
};


/***/ }),
/* 807 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const alreadyWarned = new Set();
exports.default = (message) => {
    if (alreadyWarned.has(message)) {
        return;
    }
    alreadyWarned.add(message);
    // @ts-expect-error Missing types.
    process.emitWarning(`Got: ${message}`, {
        type: 'DeprecationWarning'
    });
};


/***/ }),
/* 808 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_1 = __webpack_require__(757);
const normalizeArguments = (options, defaults) => {
    if (is_1.default.null_(options.encoding)) {
        throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');
    }
    is_1.assert.any([is_1.default.string, is_1.default.undefined], options.encoding);
    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.resolveBodyOnly);
    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.methodRewriting);
    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.isStream);
    is_1.assert.any([is_1.default.string, is_1.default.undefined], options.responseType);
    // `options.responseType`
    if (options.responseType === undefined) {
        options.responseType = 'text';
    }
    // `options.retry`
    const { retry } = options;
    if (defaults) {
        options.retry = { ...defaults.retry };
    }
    else {
        options.retry = {
            calculateDelay: retryObject => retryObject.computedValue,
            limit: 0,
            methods: [],
            statusCodes: [],
            errorCodes: [],
            maxRetryAfter: undefined
        };
    }
    if (is_1.default.object(retry)) {
        options.retry = {
            ...options.retry,
            ...retry
        };
        options.retry.methods = [...new Set(options.retry.methods.map(method => method.toUpperCase()))];
        options.retry.statusCodes = [...new Set(options.retry.statusCodes)];
        options.retry.errorCodes = [...new Set(options.retry.errorCodes)];
    }
    else if (is_1.default.number(retry)) {
        options.retry.limit = retry;
    }
    if (is_1.default.undefined(options.retry.maxRetryAfter)) {
        options.retry.maxRetryAfter = Math.min(
        // TypeScript is not smart enough to handle `.filter(x => is.number(x))`.
        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator
        ...[options.timeout.request, options.timeout.connect].filter(is_1.default.number));
    }
    // `options.pagination`
    if (is_1.default.object(options.pagination)) {
        if (defaults) {
            options.pagination = {
                ...defaults.pagination,
                ...options.pagination
            };
        }
        const { pagination } = options;
        if (!is_1.default.function_(pagination.transform)) {
            throw new Error('`options.pagination.transform` must be implemented');
        }
        if (!is_1.default.function_(pagination.shouldContinue)) {
            throw new Error('`options.pagination.shouldContinue` must be implemented');
        }
        if (!is_1.default.function_(pagination.filter)) {
            throw new TypeError('`options.pagination.filter` must be implemented');
        }
        if (!is_1.default.function_(pagination.paginate)) {
            throw new Error('`options.pagination.paginate` must be implemented');
        }
    }
    // JSON mode
    if (options.responseType === 'json' && options.headers.accept === undefined) {
        options.headers.accept = 'application/json';
    }
    return options;
};
exports.default = normalizeArguments;


/***/ }),
/* 809 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.retryAfterStatusCodes = void 0;
exports.retryAfterStatusCodes = new Set([413, 429, 503]);
const calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter }) => {
    if (attemptCount > retryOptions.limit) {
        return 0;
    }
    const hasMethod = retryOptions.methods.includes(error.options.method);
    const hasErrorCode = retryOptions.errorCodes.includes(error.code);
    const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
    if (!hasMethod || (!hasErrorCode && !hasStatusCode)) {
        return 0;
    }
    if (error.response) {
        if (retryAfter) {
            if (retryOptions.maxRetryAfter === undefined || retryAfter > retryOptions.maxRetryAfter) {
                return 0;
            }
            return retryAfter;
        }
        if (error.response.statusCode === 413) {
            return 0;
        }
    }
    const noise = Math.random() * 100;
    return ((2 ** (attemptCount - 1)) * 1000) + noise;
};
exports.default = calculateRetryDelay;


/***/ }),
/* 810 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const types_1 = __webpack_require__(760);
const parseBody = (response, responseType, parseJson, encoding) => {
    const { rawBody } = response;
    try {
        if (responseType === 'text') {
            return rawBody.toString(encoding);
        }
        if (responseType === 'json') {
            return rawBody.length === 0 ? '' : parseJson(rawBody.toString());
        }
        if (responseType === 'buffer') {
            return rawBody;
        }
        throw new types_1.ParseError({
            message: `Unknown body type '${responseType}'`,
            name: 'Error'
        }, response);
    }
    catch (error) {
        throw new types_1.ParseError(error, response);
    }
};
exports.default = parseBody;


/***/ }),
/* 811 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const types_1 = __webpack_require__(760);
function createRejection(error, ...beforeErrorGroups) {
    const promise = (async () => {
        if (error instanceof types_1.RequestError) {
            try {
                for (const hooks of beforeErrorGroups) {
                    if (hooks) {
                        for (const hook of hooks) {
                            // eslint-disable-next-line no-await-in-loop
                            error = await hook(error);
                        }
                    }
                }
            }
            catch (error_) {
                error = error_;
            }
        }
        throw error;
    })();
    const returnPromise = () => promise;
    promise.json = returnPromise;
    promise.text = returnPromise;
    promise.buffer = returnPromise;
    promise.on = returnPromise;
    return promise;
}
exports.default = createRejection;


/***/ }),
/* 812 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_1 = __webpack_require__(757);
function deepFreeze(object) {
    for (const value of Object.values(object)) {
        if (is_1.default.plainObject(value) || is_1.default.array(value)) {
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
}
exports.default = deepFreeze;


/***/ }),
/* 813 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			if(mode & 2 && typeof value == 'object' && value) {
/******/ 				for(const key in value) def[key] = () => value[key];
/******/ 			}
/******/ 			def['default'] = () => value;
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })()
;